<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 948:655c2444785380713384763e1576b8b08a50c2e6</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 655c2444785380713384763e1576b8b08a50c2e6" />
<meta property="og:url" content="/comm-central/rev/655c2444785380713384763e1576b8b08a50c2e6" />
<meta property="og:description" content="status commit with the following excitement:" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 655c2444785380713384763e1576b8b08a50c2e6 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/655c2444785380713384763e1576b8b08a50c2e6">shortlog</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/655c2444785380713384763e1576b8b08a50c2e6">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6">files</a> |
changeset |
<a href="/comm-central/raw-rev/655c2444785380713384763e1576b8b08a50c2e6">raw</a>  | <a href="/comm-central/archive/655c2444785380713384763e1576b8b08a50c2e6.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
status commit with the following excitement:
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Sun, 28 Sep 2008 23:22:47 -0700</td></tr>

<tr>
 <td>changeset 948</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/655c2444785380713384763e1576b8b08a50c2e6">655c2444785380713384763e1576b8b08a50c2e6</a></td>
</tr>



<tr>
<td>parent 947</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/f00184db17deab700cdd65cc01ba7f6c28d92767">f00184db17deab700cdd65cc01ba7f6c28d92767</a>
</td>
</tr>

<tr>
<td>child 949</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/373953d7da1f66116791b18fe0cc6ede271ed380">373953d7da1f66116791b18fe0cc6ede271ed380</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=655c2444785380713384763e1576b8b08a50c2e6">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">status commit with the following excitement:
 * support for contact tag indexing.
 * generalization to support the above.
 * massive refactoring of the autocomplete implementation.
 * custom XBL for our autocomplete, allowing some very cool things very soon.
 * cleanup/generalization for the rest of the above.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/components/glautocomp.js">components/glautocomp.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/components/glautocomp.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/components/glautocomp.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/components/glautocomp.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/components/glautocomp.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/components/glautocomp.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.css">content/glodacomplete.css</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.css">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.css">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.css">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.css">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.css">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.xml">content/glodacomplete.xml</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.xml">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.xml">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.xml">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.xml">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/content/glodacomplete.xml">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/content/thunderbirdOverlay.xul">content/thunderbirdOverlay.xul</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/content/thunderbirdOverlay.xul">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/content/thunderbirdOverlay.xul">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/content/thunderbirdOverlay.xul">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/content/thunderbirdOverlay.xul">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/content/thunderbirdOverlay.xul">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/jar.mn">jar.mn</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/jar.mn">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/jar.mn">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/jar.mn">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/jar.mn">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/jar.mn">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/collection.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/collection.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/everybody.js">modules/everybody.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/everybody.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/everybody.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/everybody.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/everybody.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/everybody.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/explattr.js">modules/explattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/explattr.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/explattr.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/explattr.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/explattr.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/explattr.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/fundattr.js">modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/index_ab.js">modules/index_ab.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/index_ab.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/index_ab.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/index_ab.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/index_ab.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/index_ab.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/indexer.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/noun_freetag.js">modules/noun_freetag.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/noun_freetag.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/noun_freetag.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/noun_freetag.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/noun_freetag.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/noun_freetag.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/query.js">modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/655c2444785380713384763e1576b8b08a50c2e6/modules/query.js">file</a> |
<a href="/comm-central/annotate/655c2444785380713384763e1576b8b08a50c2e6/modules/query.js">annotate</a> |
<a href="/comm-central/diff/655c2444785380713384763e1576b8b08a50c2e6/modules/query.js">diff</a> |
<a href="/comm-central/comparison/655c2444785380713384763e1576b8b08a50c2e6/modules/query.js">comparison</a> |
<a href="/comm-central/log/655c2444785380713384763e1576b8b08a50c2e6/modules/query.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/components/glautocomp.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/components/glautocomp.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l1.4"></a><span id="l1.4"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l1.5"></a><span id="l1.5">  *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l1.6"></a><span id="l1.6">  *</span>
<a href="#l1.7"></a><span id="l1.7">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l1.8"></a><span id="l1.8">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l1.9"></a><span id="l1.9">  * the License. You may obtain a copy of the License at</span>
<a href="#l1.10"></a><span id="l1.10">  * http://www.mozilla.org/MPL/</span>
<a href="#l1.11"></a><span id="l1.11" class="difflineminus">- * </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+ *</span>
<a href="#l1.13"></a><span id="l1.13">  * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l1.14"></a><span id="l1.14">  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l1.15"></a><span id="l1.15">  * for the specific language governing rights and limitations under the</span>
<a href="#l1.16"></a><span id="l1.16">  * License.</span>
<a href="#l1.17"></a><span id="l1.17">  *</span>
<a href="#l1.18"></a><span id="l1.18">  * The Original Code is Thunderbird Global Database.</span>
<a href="#l1.19"></a><span id="l1.19">  *</span>
<a href="#l1.20"></a><span id="l1.20">  * The Initial Developer of the Original Code is</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineat">@@ -28,54 +28,104 @@</span>
<a href="#l1.22"></a><span id="l1.22">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l1.23"></a><span id="l1.23">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l1.24"></a><span id="l1.24">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l1.25"></a><span id="l1.25">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l1.26"></a><span id="l1.26">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l1.27"></a><span id="l1.27">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l1.28"></a><span id="l1.28">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l1.29"></a><span id="l1.29">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l1.30"></a><span id="l1.30" class="difflineminus">- * </span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+ *</span>
<a href="#l1.32"></a><span id="l1.32">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l1.33"></a><span id="l1.33"> </span>
<a href="#l1.34"></a><span id="l1.34"> const Cc = Components.classes;</span>
<a href="#l1.35"></a><span id="l1.35"> const Ci = Components.interfaces;</span>
<a href="#l1.36"></a><span id="l1.36"> const Cr = Components.results;</span>
<a href="#l1.37"></a><span id="l1.37"> const Cu = Components.utils;</span>
<a href="#l1.38"></a><span id="l1.38"> </span>
<a href="#l1.39"></a><span id="l1.39"> Cu.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l1.40"></a><span id="l1.40"> </span>
<a href="#l1.41"></a><span id="l1.41" class="difflineminus">-Components.utils.import(&quot;resource://gre/modules/XPCOMUtils.jsm&quot;);</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+var LOG = null;</span>
<a href="#l1.43"></a><span id="l1.43"> </span>
<a href="#l1.44"></a><span id="l1.44"> var Gloda = null;</span>
<a href="#l1.45"></a><span id="l1.45"> var GlodaUtils = null;</span>
<a href="#l1.46"></a><span id="l1.46"> var MultiSuffixTree = null;</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+var FreeTagNoun = null;</span>
<a href="#l1.48"></a><span id="l1.48"> </span>
<a href="#l1.49"></a><span id="l1.49" class="difflineminus">-function nsAutoCompleteGlodaResult(aCompleter, aString, aResults, aDone) {</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineplus">+function ResultRowSingle(aItem, aCriteriaType, aCriteria) {</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+  this.nounID = aItem.NOUN_ID;</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineplus">+  this.nounMeta = Gloda._nounIDToMeta[this.nounID];</span>
<a href="#l1.53"></a><span id="l1.53" class="difflineplus">+  this.criteriaType = aCriteriaType;</span>
<a href="#l1.54"></a><span id="l1.54" class="difflineplus">+  this.criteria = aCriteria;</span>
<a href="#l1.55"></a><span id="l1.55" class="difflineplus">+  this.item = aItem;</span>
<a href="#l1.56"></a><span id="l1.56" class="difflineplus">+}</span>
<a href="#l1.57"></a><span id="l1.57" class="difflineplus">+ResultRowSingle.prototype = {</span>
<a href="#l1.58"></a><span id="l1.58" class="difflineplus">+  multi: false</span>
<a href="#l1.59"></a><span id="l1.59" class="difflineplus">+};</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineplus">+</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineplus">+function ResultRowMulti(aNounID, aCriteriaType, aCriteria, aQuery) {</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+  this.nounID = aNounID;</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineplus">+  this.nounMeta = Gloda._nounIDToMeta[aNounID];</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+  this.criteriaType = aCriteriaType;</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+  this.criteria = aCriteria;</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+  this.collection = aQuery.getCollection(this);</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+}</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+ResultRowMulti.prototype = {</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+  multi: true,</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineplus">+  onItemsAdded: function(aItems) {</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineplus">+  },</span>
<a href="#l1.72"></a><span id="l1.72" class="difflineplus">+  onItemsModified: function(aItems) {</span>
<a href="#l1.73"></a><span id="l1.73" class="difflineplus">+  },</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineplus">+  onItemsRemoved: function(aItems) {</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineplus">+  },</span>
<a href="#l1.76"></a><span id="l1.76" class="difflineplus">+  onQueryCompleted: function() {</span>
<a href="#l1.77"></a><span id="l1.77" class="difflineplus">+  }</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineplus">+}</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineplus">+</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+function nsAutoCompleteGlodaResult(aListener, aCompleter, aString) {</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineplus">+  this.listener = aListener;</span>
<a href="#l1.82"></a><span id="l1.82">   this.completer = aCompleter;</span>
<a href="#l1.83"></a><span id="l1.83">   this.searchString = aString;</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineminus">-  this._results = aResults;</span>
<a href="#l1.85"></a><span id="l1.85" class="difflineminus">-  this._done = aDone || false;</span>
<a href="#l1.86"></a><span id="l1.86" class="difflineplus">+  this._results = [];</span>
<a href="#l1.87"></a><span id="l1.87" class="difflineplus">+  this._pendingCount = 0;</span>
<a href="#l1.88"></a><span id="l1.88">   this._problem = false;</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineplus">+  </span>
<a href="#l1.90"></a><span id="l1.90" class="difflineplus">+  this.wrappedJSObject = this;</span>
<a href="#l1.91"></a><span id="l1.91"> }</span>
<a href="#l1.92"></a><span id="l1.92"> nsAutoCompleteGlodaResult.prototype = {</span>
<a href="#l1.93"></a><span id="l1.93" class="difflineminus">-  _results: null,</span>
<a href="#l1.94"></a><span id="l1.94">   getObjectAt: function(aIndex) {</span>
<a href="#l1.95"></a><span id="l1.95">     return this._results[aIndex];</span>
<a href="#l1.96"></a><span id="l1.96">   },</span>
<a href="#l1.97"></a><span id="l1.97" class="difflineplus">+  markPending: function ACGR_markPending(aCompleter) {</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineplus">+    this._pendingCount++;</span>
<a href="#l1.99"></a><span id="l1.99" class="difflineplus">+  },</span>
<a href="#l1.100"></a><span id="l1.100" class="difflineplus">+  markCompleted: function ACGR_markCompleted(aCompleter) {</span>
<a href="#l1.101"></a><span id="l1.101" class="difflineplus">+    if (--this._pendingCount == 0) {</span>
<a href="#l1.102"></a><span id="l1.102" class="difflineplus">+      LOG.debug(&quot;Notifying completion.&quot;);</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+      this.listener.onSearchResult(this.completer, this);</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineplus">+    }</span>
<a href="#l1.105"></a><span id="l1.105" class="difflineplus">+  },</span>
<a href="#l1.106"></a><span id="l1.106" class="difflineplus">+  addRows: function ACGR_addRows(aRows) {</span>
<a href="#l1.107"></a><span id="l1.107" class="difflineplus">+    if (!aRows.length)</span>
<a href="#l1.108"></a><span id="l1.108" class="difflineplus">+      return;</span>
<a href="#l1.109"></a><span id="l1.109" class="difflineplus">+    LOG.debug(&quot;Adding &quot; + aRows.length + &quot; rows (&quot; + this._pendingCount +</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineplus">+              &quot; jobs still pending)&quot;);</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineplus">+    this._results.push.apply(this._results, aRows); </span>
<a href="#l1.112"></a><span id="l1.112" class="difflineplus">+    this.listener.onSearchResult(this.completer, this);</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineplus">+  },</span>
<a href="#l1.114"></a><span id="l1.114">   // ==== nsIAutoCompleteResult</span>
<a href="#l1.115"></a><span id="l1.115">   searchString: null,</span>
<a href="#l1.116"></a><span id="l1.116">   get searchResult() {</span>
<a href="#l1.117"></a><span id="l1.117">     if (this._problem)</span>
<a href="#l1.118"></a><span id="l1.118">       return Ci.nsIAutoCompleteResult.RESULT_FAILURE;</span>
<a href="#l1.119"></a><span id="l1.119">     if (this._results.length)</span>
<a href="#l1.120"></a><span id="l1.120" class="difflineminus">-      return (this._done) ? Ci.nsIAutoCompleteResult.RESULT_SUCCESS</span>
<a href="#l1.121"></a><span id="l1.121" class="difflineplus">+      return (!this._pendingCount) ? Ci.nsIAutoCompleteResult.RESULT_SUCCESS</span>
<a href="#l1.122"></a><span id="l1.122">                           : Ci.nsIAutoCompleteResult.RESULT_SUCCESS_ONGOING;</span>
<a href="#l1.123"></a><span id="l1.123">     else</span>
<a href="#l1.124"></a><span id="l1.124" class="difflineminus">-      return (this._done) ? Ci.nsIAutoCompleteResult.RESULT_NOMATCH</span>
<a href="#l1.125"></a><span id="l1.125" class="difflineplus">+      return (!this._pendingCount) ? Ci.nsIAutoCompleteResult.RESULT_NOMATCH</span>
<a href="#l1.126"></a><span id="l1.126">                           : Ci.nsIAutoCompleteResult.RESULT_NOMATCH_ONGOING;</span>
<a href="#l1.127"></a><span id="l1.127">   },</span>
<a href="#l1.128"></a><span id="l1.128">   defaultIndex: -1,</span>
<a href="#l1.129"></a><span id="l1.129">   errorDescription: null,</span>
<a href="#l1.130"></a><span id="l1.130">   get matchCount() {</span>
<a href="#l1.131"></a><span id="l1.131">     return (this._results === null) ? 0 : this._results.length;</span>
<a href="#l1.132"></a><span id="l1.132">   },</span>
<a href="#l1.133"></a><span id="l1.133">   // this is the lower text, (shows the url in firefox)</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineat">@@ -91,103 +141,79 @@ nsAutoCompleteGlodaResult.prototype = {</span>
<a href="#l1.135"></a><span id="l1.135">     if (thing.value) // identity</span>
<a href="#l1.136"></a><span id="l1.136">       return thing.contact.name;</span>
<a href="#l1.137"></a><span id="l1.137">     else</span>
<a href="#l1.138"></a><span id="l1.138">       return thing.name || thing.subject;</span>
<a href="#l1.139"></a><span id="l1.139">   },</span>
<a href="#l1.140"></a><span id="l1.140">   // rich uses this to be the &quot;type&quot;</span>
<a href="#l1.141"></a><span id="l1.141">   getStyleAt: function(aIndex) {</span>
<a href="#l1.142"></a><span id="l1.142">     let thing = this._results[aIndex];</span>
<a href="#l1.143"></a><span id="l1.143" class="difflineminus">-    if (thing.subject)</span>
<a href="#l1.144"></a><span id="l1.144" class="difflineminus">-      return &quot;gloda-conversation&quot;;</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineminus">-    if (thing.value)</span>
<a href="#l1.146"></a><span id="l1.146" class="difflineminus">-      return &quot;gloda-identity&quot;;</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineminus">-    return &quot;gloda-contact&quot;;</span>
<a href="#l1.148"></a><span id="l1.148" class="difflineplus">+    if (thing.multi)</span>
<a href="#l1.149"></a><span id="l1.149" class="difflineplus">+      return &quot;gloda-multi-&quot; + thing.nounMeta.name;</span>
<a href="#l1.150"></a><span id="l1.150" class="difflineplus">+    else</span>
<a href="#l1.151"></a><span id="l1.151" class="difflineplus">+      return &quot;gloda-single-&quot; + thing.nounMeta.name;</span>
<a href="#l1.152"></a><span id="l1.152">   },</span>
<a href="#l1.153"></a><span id="l1.153">   // rich uses this to be the icon</span>
<a href="#l1.154"></a><span id="l1.154">   getImageAt: function(aIndex) {</span>
<a href="#l1.155"></a><span id="l1.155">     let thing = this._results[aIndex];</span>
<a href="#l1.156"></a><span id="l1.156">     if (!thing.value)</span>
<a href="#l1.157"></a><span id="l1.157">       return null;</span>
<a href="#l1.158"></a><span id="l1.158" class="difflineminus">-  </span>
<a href="#l1.159"></a><span id="l1.159" class="difflineplus">+</span>
<a href="#l1.160"></a><span id="l1.160">     let md5hash = GlodaUtils.md5HashString(thing.value);</span>
<a href="#l1.161"></a><span id="l1.161" class="difflineminus">-    let gravURL = &quot;http://www.gravatar.com/avatar/&quot; + md5hash + </span>
<a href="#l1.162"></a><span id="l1.162" class="difflineplus">+    let gravURL = &quot;http://www.gravatar.com/avatar/&quot; + md5hash +</span>
<a href="#l1.163"></a><span id="l1.163">                                 &quot;?d=identicon&amp;s=32&amp;r=g&quot;;</span>
<a href="#l1.164"></a><span id="l1.164">     return gravURL;</span>
<a href="#l1.165"></a><span id="l1.165">   },</span>
<a href="#l1.166"></a><span id="l1.166">   removeValueAt: function() {},</span>
<a href="#l1.167"></a><span id="l1.167" class="difflineminus">-  </span>
<a href="#l1.168"></a><span id="l1.168" class="difflineplus">+</span>
<a href="#l1.169"></a><span id="l1.169">   _stop: function() {</span>
<a href="#l1.170"></a><span id="l1.170">   },</span>
<a href="#l1.171"></a><span id="l1.171"> };</span>
<a href="#l1.172"></a><span id="l1.172"> </span>
<a href="#l1.173"></a><span id="l1.173" class="difflineminus">-function nsAutoCompleteGloda() {</span>
<a href="#l1.174"></a><span id="l1.174" class="difflineminus">-  this.wrappedJSObject = this;</span>
<a href="#l1.175"></a><span id="l1.175" class="difflineminus">-  </span>
<a href="#l1.176"></a><span id="l1.176" class="difflineminus">-  // set up our awesome globals!</span>
<a href="#l1.177"></a><span id="l1.177" class="difflineminus">-  if (Gloda === null) {</span>
<a href="#l1.178"></a><span id="l1.178" class="difflineminus">-    let loadNS = {};</span>
<a href="#l1.179"></a><span id="l1.179" class="difflineminus">-    Cu.import(&quot;resource://gloda/modules/gloda.js&quot;, loadNS);</span>
<a href="#l1.180"></a><span id="l1.180" class="difflineminus">-    Gloda = loadNS.Gloda;</span>
<a href="#l1.181"></a><span id="l1.181" class="difflineminus">-    // force initialization</span>
<a href="#l1.182"></a><span id="l1.182" class="difflineminus">-    Cu.import(&quot;resource://gloda/modules/everybody.js&quot;, loadNS);</span>
<a href="#l1.183"></a><span id="l1.183" class="difflineminus">-</span>
<a href="#l1.184"></a><span id="l1.184" class="difflineminus">-    Cu.import(&quot;resource://gloda/modules/utils.js&quot;, loadNS);</span>
<a href="#l1.185"></a><span id="l1.185" class="difflineminus">-    GlodaUtils = loadNS.GlodaUtils;</span>
<a href="#l1.186"></a><span id="l1.186" class="difflineminus">-    Cu.import(&quot;resource://gloda/modules/suffixtree.js&quot;, loadNS);</span>
<a href="#l1.187"></a><span id="l1.187" class="difflineminus">-    MultiSuffixTree = loadNS.MultiSuffixTree;</span>
<a href="#l1.188"></a><span id="l1.188" class="difflineminus">-  }</span>
<a href="#l1.189"></a><span id="l1.189" class="difflineminus">-  </span>
<a href="#l1.190"></a><span id="l1.190" class="difflineminus">-  Gloda.lookupNoun(&quot;contact&quot;);</span>
<a href="#l1.191"></a><span id="l1.191" class="difflineminus">-  </span>
<a href="#l1.192"></a><span id="l1.192" class="difflineplus">+/**</span>
<a href="#l1.193"></a><span id="l1.193" class="difflineplus">+ * Complete contacts/identities based on name/email.  Instant phase is based on</span>
<a href="#l1.194"></a><span id="l1.194" class="difflineplus">+ *  a suffix-tree built of popular contacts/identities.  Delayed phase relies</span>
<a href="#l1.195"></a><span id="l1.195" class="difflineplus">+ *  on a LIKE search of all known contacts.</span>
<a href="#l1.196"></a><span id="l1.196" class="difflineplus">+ */</span>
<a href="#l1.197"></a><span id="l1.197" class="difflineplus">+function ContactIdentityCompleter() {</span>
<a href="#l1.198"></a><span id="l1.198">   // get all the contacts</span>
<a href="#l1.199"></a><span id="l1.199">   let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l1.200"></a><span id="l1.200">   this.contactCollection = contactQuery.popularityRange(10, null).getAllSync();</span>
<a href="#l1.201"></a><span id="l1.201" class="difflineminus">-  </span>
<a href="#l1.202"></a><span id="l1.202" class="difflineplus">+</span>
<a href="#l1.203"></a><span id="l1.203">   // cheat and explicitly add our own contact...</span>
<a href="#l1.204"></a><span id="l1.204">   this.contactCollection._onItemsAdded([Gloda.myContact]);</span>
<a href="#l1.205"></a><span id="l1.205"> </span>
<a href="#l1.206"></a><span id="l1.206">   // assuming we found some contacts...</span>
<a href="#l1.207"></a><span id="l1.207">   if (this.contactCollection.items.length) {</span>
<a href="#l1.208"></a><span id="l1.208">     // get all the identities...</span>
<a href="#l1.209"></a><span id="l1.209">     let identityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l1.210"></a><span id="l1.210">     // ...that belong to one of the above contacts.</span>
<a href="#l1.211"></a><span id="l1.211">     identityQuery.contact.apply(identityQuery, this.contactCollection.items);</span>
<a href="#l1.212"></a><span id="l1.212">     this.identityCollection = identityQuery.getAllSync();</span>
<a href="#l1.213"></a><span id="l1.213">   }</span>
<a href="#l1.214"></a><span id="l1.214">   else {</span>
<a href="#l1.215"></a><span id="l1.215">     // create an empty explicit collection</span>
<a href="#l1.216"></a><span id="l1.216">     this.identityCollection = Gloda.explicitCollection(Gloda.NOUN_IDENTITY, []);</span>
<a href="#l1.217"></a><span id="l1.217">   }</span>
<a href="#l1.218"></a><span id="l1.218" class="difflineminus">-  </span>
<a href="#l1.219"></a><span id="l1.219" class="difflineplus">+</span>
<a href="#l1.220"></a><span id="l1.220">   let contactNames = [(c.name.replace(&quot; &quot;, &quot;&quot;).toLowerCase() || &quot;x&quot;) for each</span>
<a href="#l1.221"></a><span id="l1.221">                       (c in this.contactCollection.items)];</span>
<a href="#l1.222"></a><span id="l1.222">   let identityMails = [i.value.toLowerCase() for each</span>
<a href="#l1.223"></a><span id="l1.223">                        (i in this.identityCollection.items)];</span>
<a href="#l1.224"></a><span id="l1.224" class="difflineminus">-  </span>
<a href="#l1.225"></a><span id="l1.225" class="difflineplus">+</span>
<a href="#l1.226"></a><span id="l1.226">   this.suffixTree = new MultiSuffixTree(contactNames.concat(identityMails),</span>
<a href="#l1.227"></a><span id="l1.227">     this.contactCollection.items.concat(this.identityCollection.items));</span>
<a href="#l1.228"></a><span id="l1.228" class="difflineminus">-    </span>
<a href="#l1.229"></a><span id="l1.229" class="difflineminus">-  this.outstandingSearches = {};</span>
<a href="#l1.230"></a><span id="l1.230" class="difflineminus">-  this._magicTime = false;</span>
<a href="#l1.231"></a><span id="l1.231"> }</span>
<a href="#l1.232"></a><span id="l1.232" class="difflineplus">+ContactIdentityCompleter.prototype = {</span>
<a href="#l1.233"></a><span id="l1.233" class="difflineplus">+  _popularitySorter: function(a, b){ return b.popularity - a.popularity; },</span>
<a href="#l1.234"></a><span id="l1.234" class="difflineplus">+  complete: function ContactIdentityCompleter_complete(aResult, aString) {</span>
<a href="#l1.235"></a><span id="l1.235" class="difflineplus">+    if (aString.length &lt; 3)</span>
<a href="#l1.236"></a><span id="l1.236" class="difflineplus">+      return false;</span>
<a href="#l1.237"></a><span id="l1.237"> </span>
<a href="#l1.238"></a><span id="l1.238" class="difflineminus">-nsAutoCompleteGloda.prototype = {</span>
<a href="#l1.239"></a><span id="l1.239" class="difflineminus">-  classDescription: &quot;AutoCompleteGloda&quot;,</span>
<a href="#l1.240"></a><span id="l1.240" class="difflineminus">-  contractID: &quot;@mozilla.org/autocomplete/search;1?name=gloda&quot;,</span>
<a href="#l1.241"></a><span id="l1.241" class="difflineminus">-  classID: Components.ID(&quot;{3bbe4d77-3f70-4252-9500-bc00c26f476c}&quot;),</span>
<a href="#l1.242"></a><span id="l1.242" class="difflineminus">-  QueryInterface: XPCOMUtils.generateQI([</span>
<a href="#l1.243"></a><span id="l1.243" class="difflineminus">-      Components.interfaces.nsIAutoCompleteSearch]),</span>
<a href="#l1.244"></a><span id="l1.244" class="difflineminus">-</span>
<a href="#l1.245"></a><span id="l1.245" class="difflineminus">-  startSearch: function(aString, aParam, aResult, aListener) {</span>
<a href="#l1.246"></a><span id="l1.246" class="difflineminus">-    // only match if they type at least 3 letters...</span>
<a href="#l1.247"></a><span id="l1.247" class="difflineminus">-    let matches = [];</span>
<a href="#l1.248"></a><span id="l1.248" class="difflineminus">-    if (aString.length &gt;= 3) {</span>
<a href="#l1.249"></a><span id="l1.249" class="difflineminus">-      matches = this.suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l1.250"></a><span id="l1.250" class="difflineminus">-    }</span>
<a href="#l1.251"></a><span id="l1.251" class="difflineplus">+    let matches = this.suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l1.252"></a><span id="l1.252"> </span>
<a href="#l1.253"></a><span id="l1.253">     // let's filter out duplicates due to identity/contact double-hits by</span>
<a href="#l1.254"></a><span id="l1.254">     //  establishing a map based on the contact id for these guys.</span>
<a href="#l1.255"></a><span id="l1.255">     // let's also favor identities as we do it, because that gets us the</span>
<a href="#l1.256"></a><span id="l1.256">     //  most accurate gravat, potentially</span>
<a href="#l1.257"></a><span id="l1.257">     let contactToThing = {};</span>
<a href="#l1.258"></a><span id="l1.258">     for (let iMatch = 0; iMatch &lt; matches.length; iMatch++) {</span>
<a href="#l1.259"></a><span id="l1.259">       let thing = matches[iMatch];</span>
<a href="#l1.260"></a><span id="l1.260" class="difflineat">@@ -195,84 +221,203 @@ nsAutoCompleteGloda.prototype = {</span>
<a href="#l1.261"></a><span id="l1.261">         contactToThing[thing.id] = thing;</span>
<a href="#l1.262"></a><span id="l1.262">       else if (thing.NOUN_ID == Gloda.NOUN_IDENTITY)</span>
<a href="#l1.263"></a><span id="l1.263">         contactToThing[thing.contactID] = thing;</span>
<a href="#l1.264"></a><span id="l1.264">     }</span>
<a href="#l1.265"></a><span id="l1.265">     // and since we can now map from contacts down to identities, map contacts</span>
<a href="#l1.266"></a><span id="l1.266">     //  to the first identity for them that we find...</span>
<a href="#l1.267"></a><span id="l1.267">     matches = [val.NOUN_ID == Gloda.NOUN_IDENTITY ? val : val.identities[0]</span>
<a href="#l1.268"></a><span id="l1.268">                for each (val in contactToThing)];</span>
<a href="#l1.269"></a><span id="l1.269" class="difflineminus">-    </span>
<a href="#l1.270"></a><span id="l1.270" class="difflineminus">-    // - match subjects</span>
<a href="#l1.271"></a><span id="l1.271" class="difflineminus">-    /*</span>
<a href="#l1.272"></a><span id="l1.272" class="difflineminus">-    if (aString.length &gt;= 4) {</span>
<a href="#l1.273"></a><span id="l1.273" class="difflineminus">-      let subjectQuery = Gloda.newQuery(Gloda.NOUN_CONVERSATION);</span>
<a href="#l1.274"></a><span id="l1.274" class="difflineminus">-      subjectQuery.subjectMatches(aString + &quot;*&quot;);</span>
<a href="#l1.275"></a><span id="l1.275" class="difflineminus">-      let convSubjectCollection = subjectQuery.getAllSync();</span>
<a href="#l1.276"></a><span id="l1.276" class="difflineminus">-      matches = matches.concat(convSubjectCollection.items);</span>
<a href="#l1.277"></a><span id="l1.277" class="difflineminus">-    }</span>
<a href="#l1.278"></a><span id="l1.278" class="difflineminus">-    */</span>
<a href="#l1.279"></a><span id="l1.279" class="difflineplus">+</span>
<a href="#l1.280"></a><span id="l1.280" class="difflineplus">+    let rows = [new ResultRowSingle(match, &quot;text&quot;, aResult.searchString)</span>
<a href="#l1.281"></a><span id="l1.281" class="difflineplus">+                for each (match in matches)];</span>
<a href="#l1.282"></a><span id="l1.282" class="difflineplus">+    aResult.addRows(rows);</span>
<a href="#l1.283"></a><span id="l1.283"> </span>
<a href="#l1.284"></a><span id="l1.284">     // - match against database contacts / identities</span>
<a href="#l1.285"></a><span id="l1.285" class="difflineminus">-    // XXX this should be deferred</span>
<a href="#l1.286"></a><span id="l1.286" class="difflineminus">-    // XXX this should also be async (when we have async support)</span>
<a href="#l1.287"></a><span id="l1.287" class="difflineminus">-    if (aString.length &gt;= 3) {</span>
<a href="#l1.288"></a><span id="l1.288" class="difflineminus">-      let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l1.289"></a><span id="l1.289" class="difflineminus">-      let contactColl = contactQuery.nameLike(&quot;%&quot; + aString + &quot;%&quot;).getAllSync();</span>
<a href="#l1.290"></a><span id="l1.290" class="difflineplus">+    let pending = {contactToThing: contactToThing, pendingCount: 2};</span>
<a href="#l1.291"></a><span id="l1.291" class="difflineplus">+    </span>
<a href="#l1.292"></a><span id="l1.292" class="difflineplus">+    let contactQuery = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l1.293"></a><span id="l1.293" class="difflineplus">+    contactQuery.nameLike([contactQuery.WILD, aString, contactQuery.WILD]);</span>
<a href="#l1.294"></a><span id="l1.294" class="difflineplus">+    pending.contactColl = contactQuery.getCollection(this);</span>
<a href="#l1.295"></a><span id="l1.295" class="difflineplus">+    pending.contactColl.data = aResult;</span>
<a href="#l1.296"></a><span id="l1.296" class="difflineplus">+</span>
<a href="#l1.297"></a><span id="l1.297" class="difflineplus">+    let identityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l1.298"></a><span id="l1.298" class="difflineplus">+    identityQuery.kind(&quot;email&quot;).valueLike([identityQuery.WILD, aString,</span>
<a href="#l1.299"></a><span id="l1.299" class="difflineplus">+        identityQuery.WILD]);</span>
<a href="#l1.300"></a><span id="l1.300" class="difflineplus">+    pending.identityColl = identityQuery.getCollection(this);</span>
<a href="#l1.301"></a><span id="l1.301" class="difflineplus">+    pending.identityColl.data = aResult;</span>
<a href="#l1.302"></a><span id="l1.302" class="difflineplus">+    </span>
<a href="#l1.303"></a><span id="l1.303" class="difflineplus">+    aResult._contactCompleterPending = pending;</span>
<a href="#l1.304"></a><span id="l1.304"> </span>
<a href="#l1.305"></a><span id="l1.305" class="difflineminus">-      let identityQuery = Gloda.newQuery(Gloda.NOUN_IDENTITY);</span>
<a href="#l1.306"></a><span id="l1.306" class="difflineminus">-      identityQuery.kind(&quot;email&quot;).valueLike(&quot;%&quot; + aString + &quot;%&quot;);</span>
<a href="#l1.307"></a><span id="l1.307" class="difflineminus">-      let identityColl = identityQuery.getAllSync();</span>
<a href="#l1.308"></a><span id="l1.308" class="difflineplus">+    return true;</span>
<a href="#l1.309"></a><span id="l1.309" class="difflineplus">+  },</span>
<a href="#l1.310"></a><span id="l1.310" class="difflineplus">+  onItemsAdded: function(aItems, aCollection) {</span>
<a href="#l1.311"></a><span id="l1.311" class="difflineplus">+  },</span>
<a href="#l1.312"></a><span id="l1.312" class="difflineplus">+  onItemsModified: function(aItems, aCollection) {</span>
<a href="#l1.313"></a><span id="l1.313" class="difflineplus">+  },</span>
<a href="#l1.314"></a><span id="l1.314" class="difflineplus">+  onItemsRemoved: function(aItems, aCollection) {</span>
<a href="#l1.315"></a><span id="l1.315" class="difflineplus">+  },</span>
<a href="#l1.316"></a><span id="l1.316" class="difflineplus">+  onQueryCompleted: function(aCollection) {</span>
<a href="#l1.317"></a><span id="l1.317" class="difflineplus">+    let result = aCollection.data;</span>
<a href="#l1.318"></a><span id="l1.318" class="difflineplus">+    let pending = result._contactCompleterPending;</span>
<a href="#l1.319"></a><span id="l1.319" class="difflineplus">+    </span>
<a href="#l1.320"></a><span id="l1.320" class="difflineplus">+    if (--pending.pendingCount == 0) {</span>
<a href="#l1.321"></a><span id="l1.321" class="difflineplus">+      let possibleDudes = [];</span>
<a href="#l1.322"></a><span id="l1.322">       </span>
<a href="#l1.323"></a><span id="l1.323" class="difflineminus">-      let possibleDudes = [];</span>
<a href="#l1.324"></a><span id="l1.324" class="difflineplus">+      let contactToThing = pending.contactToThing;</span>
<a href="#l1.325"></a><span id="l1.325" class="difflineplus">+      </span>
<a href="#l1.326"></a><span id="l1.326" class="difflineplus">+      let items;</span>
<a href="#l1.327"></a><span id="l1.327" class="difflineplus">+      </span>
<a href="#l1.328"></a><span id="l1.328">       // check identities first because they are better than contacts in terms</span>
<a href="#l1.329"></a><span id="l1.329">       //  of display</span>
<a href="#l1.330"></a><span id="l1.330" class="difflineminus">-      for (let iIdentity = 0; iIdentity &lt; identityColl.items.length;</span>
<a href="#l1.331"></a><span id="l1.331" class="difflineminus">-          iIdentity++){</span>
<a href="#l1.332"></a><span id="l1.332" class="difflineminus">-        let identity = identityColl.items[iIdentity];</span>
<a href="#l1.333"></a><span id="l1.333" class="difflineplus">+      items = pending.identityColl.items;</span>
<a href="#l1.334"></a><span id="l1.334" class="difflineplus">+      for (let iIdentity = 0; iIdentity &lt; items.length; iIdentity++){</span>
<a href="#l1.335"></a><span id="l1.335" class="difflineplus">+        let identity = items[iIdentity];</span>
<a href="#l1.336"></a><span id="l1.336">         if (!(identity.contactID in contactToThing)) {</span>
<a href="#l1.337"></a><span id="l1.337">           contactToThing[identity.contactID] = identity;</span>
<a href="#l1.338"></a><span id="l1.338">           possibleDudes.push(identity);</span>
<a href="#l1.339"></a><span id="l1.339">           // augment the identity with its contact's popularity</span>
<a href="#l1.340"></a><span id="l1.340">           identity.popularity = identity.contact.popularity;</span>
<a href="#l1.341"></a><span id="l1.341">         }</span>
<a href="#l1.342"></a><span id="l1.342">       }</span>
<a href="#l1.343"></a><span id="l1.343" class="difflineminus">-      for (let iContact = 0; iContact &lt; contactColl.items.length; iContact++) {</span>
<a href="#l1.344"></a><span id="l1.344" class="difflineminus">-        let contact = contactColl.items[iContact];</span>
<a href="#l1.345"></a><span id="l1.345" class="difflineplus">+      items = pending.contactColl.items;</span>
<a href="#l1.346"></a><span id="l1.346" class="difflineplus">+      for (let iContact = 0; iContact &lt; items.length; iContact++) {</span>
<a href="#l1.347"></a><span id="l1.347" class="difflineplus">+        let contact = items[iContact];</span>
<a href="#l1.348"></a><span id="l1.348">         if (!(contact.id in contactToThing)) {</span>
<a href="#l1.349"></a><span id="l1.349">           contactToThing[contact.id] = contact;</span>
<a href="#l1.350"></a><span id="l1.350">           possibleDudes.push(contact.identities[0]);</span>
<a href="#l1.351"></a><span id="l1.351" class="difflineminus">-        } </span>
<a href="#l1.352"></a><span id="l1.352" class="difflineplus">+        }</span>
<a href="#l1.353"></a><span id="l1.353">       }</span>
<a href="#l1.354"></a><span id="l1.354" class="difflineplus">+      </span>
<a href="#l1.355"></a><span id="l1.355">       // sort in order of descending popularity</span>
<a href="#l1.356"></a><span id="l1.356" class="difflineminus">-      possibleDudes.sort(function(a, b){ return b.popularity - a.popularity; });</span>
<a href="#l1.357"></a><span id="l1.357" class="difflineminus">-      matches = matches.concat(possibleDudes);</span>
<a href="#l1.358"></a><span id="l1.358" class="difflineplus">+      possibleDudes.sort(this._popularitySorter);</span>
<a href="#l1.359"></a><span id="l1.359" class="difflineplus">+      let rows = [new ResultRowSingle(dude, &quot;text&quot;, result.searchString)</span>
<a href="#l1.360"></a><span id="l1.360" class="difflineplus">+                  for each (dude in possibleDudes)];</span>
<a href="#l1.361"></a><span id="l1.361" class="difflineplus">+      result.addRows(rows);</span>
<a href="#l1.362"></a><span id="l1.362" class="difflineplus">+      result.markCompleted(this);</span>
<a href="#l1.363"></a><span id="l1.363" class="difflineplus">+      </span>
<a href="#l1.364"></a><span id="l1.364" class="difflineplus">+      // the collections no longer care about the result, make it clear.</span>
<a href="#l1.365"></a><span id="l1.365" class="difflineplus">+      delete pending.identityColl.data;</span>
<a href="#l1.366"></a><span id="l1.366" class="difflineplus">+      delete pending.contactColl.data;</span>
<a href="#l1.367"></a><span id="l1.367" class="difflineplus">+      // the result object no longer needs us or our data</span>
<a href="#l1.368"></a><span id="l1.368" class="difflineplus">+      delete result._contactCompleterPending;</span>
<a href="#l1.369"></a><span id="l1.369" class="difflineplus">+    }</span>
<a href="#l1.370"></a><span id="l1.370" class="difflineplus">+  }</span>
<a href="#l1.371"></a><span id="l1.371" class="difflineplus">+};</span>
<a href="#l1.372"></a><span id="l1.372" class="difflineplus">+</span>
<a href="#l1.373"></a><span id="l1.373" class="difflineplus">+/**</span>
<a href="#l1.374"></a><span id="l1.374" class="difflineplus">+ * Complete tags that are used on contacts.</span>
<a href="#l1.375"></a><span id="l1.375" class="difflineplus">+ */</span>
<a href="#l1.376"></a><span id="l1.376" class="difflineplus">+function ContactTagCompleter() {</span>
<a href="#l1.377"></a><span id="l1.377" class="difflineplus">+  this._buildSuffixTree();</span>
<a href="#l1.378"></a><span id="l1.378" class="difflineplus">+  FreeTagNoun.addListener(this);</span>
<a href="#l1.379"></a><span id="l1.379" class="difflineplus">+}</span>
<a href="#l1.380"></a><span id="l1.380" class="difflineplus">+ContactTagCompleter.prototype = {</span>
<a href="#l1.381"></a><span id="l1.381" class="difflineplus">+  _buildSuffixTree: function() {</span>
<a href="#l1.382"></a><span id="l1.382" class="difflineplus">+    let tagNames = [], tags = [];</span>
<a href="#l1.383"></a><span id="l1.383" class="difflineplus">+    for (let [tagName, tag] in Iterator(FreeTagNoun.knownFreeTags)) {</span>
<a href="#l1.384"></a><span id="l1.384" class="difflineplus">+      tagNames.push(tagName.toLowerCase());</span>
<a href="#l1.385"></a><span id="l1.385" class="difflineplus">+      tags.push(tag);</span>
<a href="#l1.386"></a><span id="l1.386" class="difflineplus">+    }</span>
<a href="#l1.387"></a><span id="l1.387" class="difflineplus">+    this._suffixTree = new MultiSuffixTree(tagNames, tags);</span>
<a href="#l1.388"></a><span id="l1.388" class="difflineplus">+    this._suffixTreeDirty = false;</span>
<a href="#l1.389"></a><span id="l1.389" class="difflineplus">+  },</span>
<a href="#l1.390"></a><span id="l1.390" class="difflineplus">+  onFreeTagAdded: function(aTag) {</span>
<a href="#l1.391"></a><span id="l1.391" class="difflineplus">+    this._suffixTreeDirty = true;</span>
<a href="#l1.392"></a><span id="l1.392" class="difflineplus">+  },</span>
<a href="#l1.393"></a><span id="l1.393" class="difflineplus">+  complete: function ContactTagCompleter_complete(aResult, aString) {</span>
<a href="#l1.394"></a><span id="l1.394" class="difflineplus">+    // now is not the best time to do this; have onFreeTagAdded use a timer.</span>
<a href="#l1.395"></a><span id="l1.395" class="difflineplus">+    if (this.suffixTreeDirty)</span>
<a href="#l1.396"></a><span id="l1.396" class="difflineplus">+      this._buildSuffixTree();</span>
<a href="#l1.397"></a><span id="l1.397" class="difflineplus">+    </span>
<a href="#l1.398"></a><span id="l1.398" class="difflineplus">+    if (aString.length &lt; 2)</span>
<a href="#l1.399"></a><span id="l1.399" class="difflineplus">+      return false; // no async mechanism that will add new rows</span>
<a href="#l1.400"></a><span id="l1.400" class="difflineplus">+      </span>
<a href="#l1.401"></a><span id="l1.401" class="difflineplus">+    tags = this._suffixTree.findMatches(aString.toLowerCase());</span>
<a href="#l1.402"></a><span id="l1.402" class="difflineplus">+    let rows = [];</span>
<a href="#l1.403"></a><span id="l1.403" class="difflineplus">+    for each (let tag in tags) {</span>
<a href="#l1.404"></a><span id="l1.404" class="difflineplus">+      let query = Gloda.newQuery(Gloda.NOUN_CONTACT);</span>
<a href="#l1.405"></a><span id="l1.405" class="difflineplus">+      query.freeTags(tag);</span>
<a href="#l1.406"></a><span id="l1.406" class="difflineplus">+      let resRow = new ResultRowMulti(Gloda.NOUN_CONTACT, &quot;tag&quot;, tag.name,</span>
<a href="#l1.407"></a><span id="l1.407" class="difflineplus">+                                      query);</span>
<a href="#l1.408"></a><span id="l1.408" class="difflineplus">+      rows.push(resRow);</span>
<a href="#l1.409"></a><span id="l1.409" class="difflineplus">+    }</span>
<a href="#l1.410"></a><span id="l1.410" class="difflineplus">+    aResult.addRows(rows);</span>
<a href="#l1.411"></a><span id="l1.411" class="difflineplus">+    </span>
<a href="#l1.412"></a><span id="l1.412" class="difflineplus">+    return false; // no async mechanism that will add new rows</span>
<a href="#l1.413"></a><span id="l1.413" class="difflineplus">+  }</span>
<a href="#l1.414"></a><span id="l1.414" class="difflineplus">+};</span>
<a href="#l1.415"></a><span id="l1.415" class="difflineplus">+</span>
<a href="#l1.416"></a><span id="l1.416" class="difflineplus">+/**</span>
<a href="#l1.417"></a><span id="l1.417" class="difflineplus">+ * Complete tags that are used on messages</span>
<a href="#l1.418"></a><span id="l1.418" class="difflineplus">+ */</span>
<a href="#l1.419"></a><span id="l1.419" class="difflineplus">+function MessageTagCompleter() {</span>
<a href="#l1.420"></a><span id="l1.420" class="difflineplus">+</span>
<a href="#l1.421"></a><span id="l1.421" class="difflineplus">+}</span>
<a href="#l1.422"></a><span id="l1.422" class="difflineplus">+MessageTagCompleter.prototype = {</span>
<a href="#l1.423"></a><span id="l1.423" class="difflineplus">+  complete: function MessageTagCompleter_complete(aResult, aString) {</span>
<a href="#l1.424"></a><span id="l1.424" class="difflineplus">+    return false;</span>
<a href="#l1.425"></a><span id="l1.425" class="difflineplus">+  }</span>
<a href="#l1.426"></a><span id="l1.426" class="difflineplus">+};</span>
<a href="#l1.427"></a><span id="l1.427" class="difflineplus">+</span>
<a href="#l1.428"></a><span id="l1.428" class="difflineplus">+function nsAutoCompleteGloda() {</span>
<a href="#l1.429"></a><span id="l1.429" class="difflineplus">+  this.wrappedJSObject = this;</span>
<a href="#l1.430"></a><span id="l1.430" class="difflineplus">+</span>
<a href="#l1.431"></a><span id="l1.431" class="difflineplus">+  // set up our awesome globals!</span>
<a href="#l1.432"></a><span id="l1.432" class="difflineplus">+  if (Gloda === null) {</span>
<a href="#l1.433"></a><span id="l1.433" class="difflineplus">+    let loadNS = {};</span>
<a href="#l1.434"></a><span id="l1.434" class="difflineplus">+</span>
<a href="#l1.435"></a><span id="l1.435" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/public.js&quot;, loadNS);</span>
<a href="#l1.436"></a><span id="l1.436" class="difflineplus">+    Gloda = loadNS.Gloda;</span>
<a href="#l1.437"></a><span id="l1.437" class="difflineplus">+</span>
<a href="#l1.438"></a><span id="l1.438" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/utils.js&quot;, loadNS);</span>
<a href="#l1.439"></a><span id="l1.439" class="difflineplus">+    GlodaUtils = loadNS.GlodaUtils;</span>
<a href="#l1.440"></a><span id="l1.440" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/suffixtree.js&quot;, loadNS);</span>
<a href="#l1.441"></a><span id="l1.441" class="difflineplus">+    MultiSuffixTree = loadNS.MultiSuffixTree;</span>
<a href="#l1.442"></a><span id="l1.442" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/noun_freetag.js&quot;, loadNS);</span>
<a href="#l1.443"></a><span id="l1.443" class="difflineplus">+    FreeTagNoun = loadNS.FreeTagNoun;</span>
<a href="#l1.444"></a><span id="l1.444" class="difflineplus">+</span>
<a href="#l1.445"></a><span id="l1.445" class="difflineplus">+    Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;, loadNS);</span>
<a href="#l1.446"></a><span id="l1.446" class="difflineplus">+    LOG = loadNS[&quot;Log4Moz&quot;].Service.getLogger(&quot;gloda.autocomp&quot;);</span>
<a href="#l1.447"></a><span id="l1.447" class="difflineplus">+  }</span>
<a href="#l1.448"></a><span id="l1.448" class="difflineplus">+</span>
<a href="#l1.449"></a><span id="l1.449" class="difflineplus">+  LOG.debug(&quot;initializing completers&quot;);</span>
<a href="#l1.450"></a><span id="l1.450" class="difflineplus">+</span>
<a href="#l1.451"></a><span id="l1.451" class="difflineplus">+  this.completers = [];</span>
<a href="#l1.452"></a><span id="l1.452" class="difflineplus">+  </span>
<a href="#l1.453"></a><span id="l1.453" class="difflineplus">+  this.curResult = null;</span>
<a href="#l1.454"></a><span id="l1.454" class="difflineplus">+</span>
<a href="#l1.455"></a><span id="l1.455" class="difflineplus">+  this.completers.push(new ContactIdentityCompleter());</span>
<a href="#l1.456"></a><span id="l1.456" class="difflineplus">+  this.completers.push(new ContactTagCompleter());</span>
<a href="#l1.457"></a><span id="l1.457" class="difflineplus">+  this.completers.push(new MessageTagCompleter());</span>
<a href="#l1.458"></a><span id="l1.458" class="difflineplus">+  </span>
<a href="#l1.459"></a><span id="l1.459" class="difflineplus">+  LOG.debug(&quot;initialized completers&quot;);</span>
<a href="#l1.460"></a><span id="l1.460" class="difflineplus">+}</span>
<a href="#l1.461"></a><span id="l1.461" class="difflineplus">+</span>
<a href="#l1.462"></a><span id="l1.462" class="difflineplus">+nsAutoCompleteGloda.prototype = {</span>
<a href="#l1.463"></a><span id="l1.463" class="difflineplus">+  classDescription: &quot;AutoCompleteGloda&quot;,</span>
<a href="#l1.464"></a><span id="l1.464" class="difflineplus">+  contractID: &quot;@mozilla.org/autocomplete/search;1?name=gloda&quot;,</span>
<a href="#l1.465"></a><span id="l1.465" class="difflineplus">+  classID: Components.ID(&quot;{3bbe4d77-3f70-4252-9500-bc00c26f476c}&quot;),</span>
<a href="#l1.466"></a><span id="l1.466" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([</span>
<a href="#l1.467"></a><span id="l1.467" class="difflineplus">+      Components.interfaces.nsIAutoCompleteSearch]),</span>
<a href="#l1.468"></a><span id="l1.468" class="difflineplus">+</span>
<a href="#l1.469"></a><span id="l1.469" class="difflineplus">+  startSearch: function(aString, aParam, aResult, aListener) {</span>
<a href="#l1.470"></a><span id="l1.470" class="difflineplus">+    let result = new nsAutoCompleteGlodaResult(aListener, this, aString);</span>
<a href="#l1.471"></a><span id="l1.471" class="difflineplus">+    // save this for hacky access to the search.  I somewhat suspect we simply</span>
<a href="#l1.472"></a><span id="l1.472" class="difflineplus">+    //  should not be using the formal autocomplete mechanism at all.</span>
<a href="#l1.473"></a><span id="l1.473" class="difflineplus">+    this.curResult = result;</span>
<a href="#l1.474"></a><span id="l1.474" class="difflineplus">+    </span>
<a href="#l1.475"></a><span id="l1.475" class="difflineplus">+    for each (let completer in this.completers) {</span>
<a href="#l1.476"></a><span id="l1.476" class="difflineplus">+      // they will return true if they have something pending.</span>
<a href="#l1.477"></a><span id="l1.477" class="difflineplus">+      if (completer.complete(result, aString))</span>
<a href="#l1.478"></a><span id="l1.478" class="difflineplus">+        result.markPending(completer);</span>
<a href="#l1.479"></a><span id="l1.479">     }</span>
<a href="#l1.480"></a><span id="l1.480">     </span>
<a href="#l1.481"></a><span id="l1.481" class="difflineminus">-    // XXX what they hey, just nuke them.  making this all very sketchy</span>
<a href="#l1.482"></a><span id="l1.482" class="difflineminus">-    this.outstandingSearches = {};</span>
<a href="#l1.483"></a><span id="l1.483" class="difflineminus">-</span>
<a href="#l1.484"></a><span id="l1.484" class="difflineminus">-    var result = new nsAutoCompleteGlodaResult(this, aString, matches, true);</span>
<a href="#l1.485"></a><span id="l1.485" class="difflineminus">-    this.outstandingSearches[aListener] = result;</span>
<a href="#l1.486"></a><span id="l1.486">     aListener.onSearchResult(this, result);</span>
<a href="#l1.487"></a><span id="l1.487">   },</span>
<a href="#l1.488"></a><span id="l1.488"> </span>
<a href="#l1.489"></a><span id="l1.489">   stopSearch: function() {</span>
<a href="#l1.490"></a><span id="l1.490" class="difflineminus">-    for each (let [controller, search] in Iterator(this.outstandingSearches)) {</span>
<a href="#l1.491"></a><span id="l1.491" class="difflineminus">-      search._stop();</span>
<a href="#l1.492"></a><span id="l1.492" class="difflineminus">-    }</span>
<a href="#l1.493"></a><span id="l1.493" class="difflineminus">-    this.outstandingSearches = {};</span>
<a href="#l1.494"></a><span id="l1.494" class="difflineminus">-  },</span>
<a href="#l1.495"></a><span id="l1.495" class="difflineminus">-  </span>
<a href="#l1.496"></a><span id="l1.496" class="difflineminus">-  getObjectForController: function(aController, aIndex) {</span>
<a href="#l1.497"></a><span id="l1.497" class="difflineminus">-    aController.QueryInterface(Ci.nsIAutoCompleteObserver);</span>
<a href="#l1.498"></a><span id="l1.498" class="difflineminus">-    for each (let [controller, search] in Iterator(this.outstandingSearches)) {</span>
<a href="#l1.499"></a><span id="l1.499" class="difflineminus">-      if (controller.native == aController.native) {</span>
<a href="#l1.500"></a><span id="l1.500" class="difflineminus">-        return [search.getObjectAt(aIndex), 0];</span>
<a href="#l1.501"></a><span id="l1.501" class="difflineminus">-      }</span>
<a href="#l1.502"></a><span id="l1.502" class="difflineminus">-    }</span>
<a href="#l1.503"></a><span id="l1.503" class="difflineminus">-    return [null, 0];</span>
<a href="#l1.504"></a><span id="l1.504">   },</span>
<a href="#l1.505"></a><span id="l1.505"> };</span>
<a href="#l1.506"></a><span id="l1.506"> </span>
<a href="#l1.507"></a><span id="l1.507"> function NSGetModule(compMgr, fileSpec) {</span>
<a href="#l1.508"></a><span id="l1.508">   return XPCOMUtils.generateModule([nsAutoCompleteGloda]);</span>
<a href="#l1.509"></a><span id="l1.509"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1">new file mode 100644</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineminus">--- /dev/null</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineplus">+++ b/content/glodacomplete.css</span>
<a href="#l2.4"></a><span id="l2.4" class="difflineat">@@ -0,0 +1,31 @@</span>
<a href="#l2.5"></a><span id="l2.5" class="difflineplus">+textbox[type=&quot;glodacomplete&quot;] {</span>
<a href="#l2.6"></a><span id="l2.6" class="difflineplus">+  -moz-binding: url(&quot;chrome://global/content/bindings/autocomplete.xml#autocomplete&quot;);</span>
<a href="#l2.7"></a><span id="l2.7" class="difflineplus">+}</span>
<a href="#l2.8"></a><span id="l2.8" class="difflineplus">+</span>
<a href="#l2.9"></a><span id="l2.9" class="difflineplus">+panel[type=&quot;glodacomplete-richlistbox&quot;] {</span>
<a href="#l2.10"></a><span id="l2.10" class="difflineplus">+  -moz-binding: url(&quot;chrome://gloda/content/glodacomplete.xml#glodacomplete-rich-result-popup&quot;);</span>
<a href="#l2.11"></a><span id="l2.11" class="difflineplus">+}</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+.autocomplete-richlistbox {</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+  -moz-binding: url(&quot;chrome://global/content/bindings/autocomplete.xml#autocomplete-richlistbox&quot;);</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+  -moz-user-focus: ignore;</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+  -moz-appearance: none;</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+}</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+.autocomplete-richlistbox &gt; scrollbox {</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+  overflow-x: hidden !important;</span>
<a href="#l2.21"></a><span id="l2.21" class="difflineplus">+}</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineplus">+</span>
<a href="#l2.23"></a><span id="l2.23" class="difflineplus">+.autocomplete-richlistitem[type=&quot;gloda-single-identity&quot;] {</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineplus">+  -moz-binding: url(&quot;chrome://gloda/content/glodacomplete.xml#gloda-single-identity-item&quot;);</span>
<a href="#l2.25"></a><span id="l2.25" class="difflineplus">+  -moz-box-orient: vertical;</span>
<a href="#l2.26"></a><span id="l2.26" class="difflineplus">+  overflow: -moz-hidden-unscrollable;</span>
<a href="#l2.27"></a><span id="l2.27" class="difflineplus">+}</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineplus">+</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineplus">+.autocomplete-richlistitem[type=&quot;gloda-multi-identity&quot;] {</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineplus">+  -moz-binding: url(&quot;chrome://gloda/content/glodacomplete.xml#gloda-multi-identity-item&quot;);</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+  -moz-box-orient: vertical;</span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+  overflow: -moz-hidden-unscrollable;</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+}</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+/* .autocomplete-history-dropmarker wants to be optional, but we don't care */</span>
<a href="#l2.36"></a><span id="l2.36">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1">new file mode 100644</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineminus">--- /dev/null</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineplus">+++ b/content/glodacomplete.xml</span>
<a href="#l3.4"></a><span id="l3.4" class="difflineat">@@ -0,0 +1,224 @@</span>
<a href="#l3.5"></a><span id="l3.5" class="difflineplus">+&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<a href="#l3.6"></a><span id="l3.6" class="difflineplus">+</span>
<a href="#l3.7"></a><span id="l3.7" class="difflineplus">+# -*- Mode: HTML -*-</span>
<a href="#l3.8"></a><span id="l3.8" class="difflineplus">+# ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l3.9"></a><span id="l3.9" class="difflineplus">+# Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l3.10"></a><span id="l3.10" class="difflineplus">+#</span>
<a href="#l3.11"></a><span id="l3.11" class="difflineplus">+# The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+# 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+# the License. You may obtain a copy of the License at</span>
<a href="#l3.14"></a><span id="l3.14" class="difflineplus">+# http://www.mozilla.org/MPL/</span>
<a href="#l3.15"></a><span id="l3.15" class="difflineplus">+#</span>
<a href="#l3.16"></a><span id="l3.16" class="difflineplus">+# Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineplus">+# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l3.18"></a><span id="l3.18" class="difflineplus">+# for the specific language governing rights and limitations under the</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineplus">+# License.</span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+#</span>
<a href="#l3.21"></a><span id="l3.21" class="difflineplus">+# The Original Code is mozilla.org browser.</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineplus">+#</span>
<a href="#l3.23"></a><span id="l3.23" class="difflineplus">+# The Initial Developer of the Original Code is</span>
<a href="#l3.24"></a><span id="l3.24" class="difflineplus">+# Joe Hewitt.</span>
<a href="#l3.25"></a><span id="l3.25" class="difflineplus">+# Portions created by the Initial Developer are Copyright (C) 2003</span>
<a href="#l3.26"></a><span id="l3.26" class="difflineplus">+# the Initial Developer. All Rights Reserved.</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineplus">+#</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineplus">+# Contributor(s):</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+#   Pierre Chanial (p_ch@verizon.net)</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineplus">+#   Dean Tessman   (dean_tessman@hotmail.com)</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+#   Masayuki Nakano (masayuki@d-toybox.com)</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+#   Pamela Greene (pamg.bugs@gmail.com)</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+#   Edward Lee (edward.lee@engineering.uiuc.edu)</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+#   Andrew Sutherland (asutherland@asutherland.org)</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+#</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+# Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+# either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+# the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+# in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+# of those above. If you wish to allow use of your version of this file only</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+# under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+# use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+# decision by deleting the provisions above and replace them with the notice</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineplus">+# and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineplus">+# the provisions above, a recipient may use your version of this file under</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+# the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+#</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineplus">+# ***** END LICENSE BLOCK *****</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+&lt;bindings id=&quot;autocompleteBindings&quot;</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+          xmlns=&quot;http://www.mozilla.org/xbl&quot;</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+          xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot;</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+          xmlns:xul=&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+          xmlns:xbl=&quot;http://www.mozilla.org/xbl&quot;&gt;</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+  &lt;binding id=&quot;glodacomplete-rich-result-popup&quot; extends=&quot;chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup&quot;&gt;</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+    &lt;implementation implements=&quot;nsIAutoCompletePopup&quot;&gt;</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+      &lt;method name=&quot;_appendCurrentResult&quot;&gt;</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l3.60"></a><span id="l3.60" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineplus">+          var controller = this.mInput.controller;</span>
<a href="#l3.62"></a><span id="l3.62" class="difflineplus">+</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+          // Process maxRows per chunk to improve performance and user experience</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+          for (let i = 0; i &lt; this.maxRows; i++) {</span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+            if (this._currentIndex &gt;= this._matchCount)</span>
<a href="#l3.66"></a><span id="l3.66" class="difflineplus">+              return;</span>
<a href="#l3.67"></a><span id="l3.67" class="difflineplus">+</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineplus">+            var existingItemsCount = this.richlistbox.childNodes.length;</span>
<a href="#l3.69"></a><span id="l3.69" class="difflineplus">+            var item;</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineplus">+</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineplus">+            // trim the leading/trailing whitespace</span>
<a href="#l3.72"></a><span id="l3.72" class="difflineplus">+            var trimmedSearchString = controller.searchString.replace(/^\s+/, &quot;&quot;).replace(/\s+$/, &quot;&quot;);</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineplus">+</span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+            // Unescape the URI spec for showing as an entry in the popup</span>
<a href="#l3.75"></a><span id="l3.75" class="difflineplus">+            let url = Components.classes[&quot;@mozilla.org/intl/texttosuburi;1&quot;].</span>
<a href="#l3.76"></a><span id="l3.76" class="difflineplus">+              getService(Components.interfaces.nsITextToSubURI).</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineplus">+              unEscapeURIForUI(&quot;UTF-8&quot;, controller.getValueAt(this._currentIndex));</span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+</span>
<a href="#l3.79"></a><span id="l3.79" class="difflineplus">+            if (this._currentIndex &lt; existingItemsCount) {</span>
<a href="#l3.80"></a><span id="l3.80" class="difflineplus">+              // re-use the existing item</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineplus">+              item = this.richlistbox.childNodes[this._currentIndex];</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+</span>
<a href="#l3.83"></a><span id="l3.83" class="difflineplus">+              // Completely re-use the existing richlistitem if it's the same</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineplus">+              if (item.getAttribute(&quot;text&quot;) == trimmedSearchString &amp;&amp;</span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+                  item.getAttribute(&quot;url&quot;) == url) {</span>
<a href="#l3.86"></a><span id="l3.86" class="difflineplus">+                item.collapsed = false;</span>
<a href="#l3.87"></a><span id="l3.87" class="difflineplus">+                this._currentIndex++;</span>
<a href="#l3.88"></a><span id="l3.88" class="difflineplus">+                continue;</span>
<a href="#l3.89"></a><span id="l3.89" class="difflineplus">+              }</span>
<a href="#l3.90"></a><span id="l3.90" class="difflineplus">+            }</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineplus">+            else {</span>
<a href="#l3.92"></a><span id="l3.92" class="difflineplus">+              // need to create a new item</span>
<a href="#l3.93"></a><span id="l3.93" class="difflineplus">+              item = document.createElementNS(&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;, &quot;richlistitem&quot;);</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineplus">+            }</span>
<a href="#l3.95"></a><span id="l3.95" class="difflineplus">+            </span>
<a href="#l3.96"></a><span id="l3.96" class="difflineplus">+            var glodaCompleter =  Components.</span>
<a href="#l3.97"></a><span id="l3.97" class="difflineplus">+              classes[&quot;@mozilla.org/autocomplete/search;1?name=gloda&quot;].</span>
<a href="#l3.98"></a><span id="l3.98" class="difflineplus">+              getService(). //Components.interfaces.nsIAutoCompleteSearch)</span>
<a href="#l3.99"></a><span id="l3.99" class="difflineplus">+              wrappedJSObject;</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineplus">+            var result = glodaCompleter.curResult;</span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+</span>
<a href="#l3.102"></a><span id="l3.102" class="difflineplus">+            // set these attributes before we set the class</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+            // so that we can use them from the contructor</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+            var row = result.getObjectAt(this._currentIndex);</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+            var obj = row.item;</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+            item.setAttribute(&quot;text&quot;, trimmedSearchString);</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+            item.setAttribute(&quot;type&quot;, result.getStyleAt(this._currentIndex));</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineplus">+</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+            item.row = row;</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineplus">+            item.obj = obj;</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineplus">+</span>
<a href="#l3.112"></a><span id="l3.112" class="difflineplus">+            if (this._currentIndex &lt; existingItemsCount) {</span>
<a href="#l3.113"></a><span id="l3.113" class="difflineplus">+              // re-use the existing item</span>
<a href="#l3.114"></a><span id="l3.114" class="difflineplus">+              item._adjustAcItem();</span>
<a href="#l3.115"></a><span id="l3.115" class="difflineplus">+              item.collapsed = false;</span>
<a href="#l3.116"></a><span id="l3.116" class="difflineplus">+            }</span>
<a href="#l3.117"></a><span id="l3.117" class="difflineplus">+            else {</span>
<a href="#l3.118"></a><span id="l3.118" class="difflineplus">+              // set the class at the end so we can use the attributes</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineplus">+              // in the xbl constructor</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+              item.className = &quot;autocomplete-richlistitem&quot;;</span>
<a href="#l3.121"></a><span id="l3.121" class="difflineplus">+              this.richlistbox.appendChild(item);</span>
<a href="#l3.122"></a><span id="l3.122" class="difflineplus">+            }</span>
<a href="#l3.123"></a><span id="l3.123" class="difflineplus">+</span>
<a href="#l3.124"></a><span id="l3.124" class="difflineplus">+            this._currentIndex++;</span>
<a href="#l3.125"></a><span id="l3.125" class="difflineplus">+          }</span>
<a href="#l3.126"></a><span id="l3.126" class="difflineplus">+</span>
<a href="#l3.127"></a><span id="l3.127" class="difflineplus">+          // yield after each batch of items so that typing the url bar is responsive</span>
<a href="#l3.128"></a><span id="l3.128" class="difflineplus">+          setTimeout(function (self) { self._appendCurrentResult(); }, 0, this);</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineplus">+        ]]&gt;</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l3.131"></a><span id="l3.131" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineplus">+    &lt;/implementation&gt;</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineplus">+  &lt;/binding&gt;</span>
<a href="#l3.134"></a><span id="l3.134" class="difflineplus">+</span>
<a href="#l3.135"></a><span id="l3.135" class="difflineplus">+  &lt;binding id=&quot;gloda-single-identity-item&quot; extends=&quot;chrome://global/content/bindings/autocomplete.xml#autocomplete-richlistitem&quot;&gt;</span>
<a href="#l3.136"></a><span id="l3.136" class="difflineplus">+    &lt;content orient=&quot;horizontal&quot;&gt;</span>
<a href="#l3.137"></a><span id="l3.137" class="difflineplus">+      &lt;xul:image anonid=&quot;picture&quot;/&gt;</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineplus">+      &lt;xul:vbox&gt;</span>
<a href="#l3.139"></a><span id="l3.139" class="difflineplus">+        &lt;xul:hbox&gt;</span>
<a href="#l3.140"></a><span id="l3.140" class="difflineplus">+          &lt;xul:hbox anonid=&quot;name-box&quot; class=&quot;ac-title&quot; flex=&quot;1&quot;</span>
<a href="#l3.141"></a><span id="l3.141" class="difflineplus">+                    onunderflow=&quot;_doUnderflow('_name');&quot;&gt;</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineplus">+            &lt;xul:description anonid=&quot;name&quot; class=&quot;ac-normal-text ac-comment&quot;</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+                             xbl:inherits=&quot;selected&quot;/&gt;</span>
<a href="#l3.144"></a><span id="l3.144" class="difflineplus">+          &lt;/xul:hbox&gt;</span>
<a href="#l3.145"></a><span id="l3.145" class="difflineplus">+          &lt;xul:label anonid=&quot;name-overflow-ellipsis&quot; xbl:inherits=&quot;selected&quot;</span>
<a href="#l3.146"></a><span id="l3.146" class="difflineplus">+	                 class=&quot;ac-ellipsis-after ac-comment&quot; hidden=&quot;true&quot;/&gt;</span>
<a href="#l3.147"></a><span id="l3.147" class="difflineplus">+        &lt;/xul:hbox&gt;</span>
<a href="#l3.148"></a><span id="l3.148" class="difflineplus">+        &lt;xul:hbox&gt;</span>
<a href="#l3.149"></a><span id="l3.149" class="difflineplus">+          &lt;xul:hbox anonid=&quot;identity-box&quot; class=&quot;ac-url&quot; flex=&quot;1&quot;</span>
<a href="#l3.150"></a><span id="l3.150" class="difflineplus">+                    onunderflow=&quot;_doUnderflow('_identity');&quot;&gt;</span>
<a href="#l3.151"></a><span id="l3.151" class="difflineplus">+            &lt;xul:description anonid=&quot;identity&quot; class=&quot;ac-normal-text ac-url-text&quot;</span>
<a href="#l3.152"></a><span id="l3.152" class="difflineplus">+                             xbl:inherits=&quot;selected&quot;/&gt;</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineplus">+          &lt;/xul:hbox&gt;</span>
<a href="#l3.154"></a><span id="l3.154" class="difflineplus">+          &lt;xul:label anonid=&quot;identity-overflow-ellipsis&quot; xbl:inherits=&quot;selected&quot;</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineplus">+                     class=&quot;ac-ellipsis-after ac-url-text&quot; hidden=&quot;true&quot;/&gt;</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineplus">+          &lt;xul:image anonid=&quot;type-image&quot; class=&quot;ac-type-icon&quot;/&gt;</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+        &lt;/xul:hbox&gt;</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineplus">+      &lt;/xul:vbox&gt;</span>
<a href="#l3.159"></a><span id="l3.159" class="difflineplus">+    &lt;/content&gt;</span>
<a href="#l3.160"></a><span id="l3.160" class="difflineplus">+    &lt;implementation implements=&quot;nsIDOMXULSelectControlItemElement&quot;&gt;</span>
<a href="#l3.161"></a><span id="l3.161" class="difflineplus">+      &lt;constructor&gt;</span>
<a href="#l3.162"></a><span id="l3.162" class="difflineplus">+        &lt;![CDATA[</span>
<a href="#l3.163"></a><span id="l3.163" class="difflineplus">+            let ellipsis = &quot;\u2026&quot;;</span>
<a href="#l3.164"></a><span id="l3.164" class="difflineplus">+            try {</span>
<a href="#l3.165"></a><span id="l3.165" class="difflineplus">+              ellipsis = Components.classes[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l3.166"></a><span id="l3.166" class="difflineplus">+                getService(Components.interfaces.nsIPrefBranch).</span>
<a href="#l3.167"></a><span id="l3.167" class="difflineplus">+                getComplexValue(&quot;intl.ellipsis&quot;,</span>
<a href="#l3.168"></a><span id="l3.168" class="difflineplus">+                  Components.interfaces.nsIPrefLocalizedString).data;</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineplus">+            } catch (ex) {</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineplus">+              // Do nothing.. we already have a default</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineplus">+            }</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineplus">+            this._identityOverflowEllipsis = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;identity-overflow-ellipsis&quot;);</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineplus">+            this._nameOverflowEllipsis = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;name-overflow-ellipsis&quot;);</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineplus">+</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineplus">+            this._identityOverflowEllipsis.value = ellipsis;</span>
<a href="#l3.177"></a><span id="l3.177" class="difflineplus">+            this._nameOverflowEllipsis.value = ellipsis;</span>
<a href="#l3.178"></a><span id="l3.178" class="difflineplus">+</span>
<a href="#l3.179"></a><span id="l3.179" class="difflineplus">+            this._typeImage = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;type-image&quot;);</span>
<a href="#l3.180"></a><span id="l3.180" class="difflineplus">+</span>
<a href="#l3.181"></a><span id="l3.181" class="difflineplus">+            this._identityBox = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;identity-box&quot;);</span>
<a href="#l3.182"></a><span id="l3.182" class="difflineplus">+            this._identity = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;identity&quot;);</span>
<a href="#l3.183"></a><span id="l3.183" class="difflineplus">+</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineplus">+            this._nameBox = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;name-box&quot;);</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineplus">+            this._name = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;name&quot;);</span>
<a href="#l3.186"></a><span id="l3.186" class="difflineplus">+            </span>
<a href="#l3.187"></a><span id="l3.187" class="difflineplus">+            this._picture = document.getAnonymousElementByAttribute(this, &quot;anonid&quot;, &quot;picture&quot;);</span>
<a href="#l3.188"></a><span id="l3.188" class="difflineplus">+</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineplus">+            this._adjustAcItem();</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineplus">+          ]]&gt;</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineplus">+      &lt;/constructor&gt;</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineplus">+      </span>
<a href="#l3.193"></a><span id="l3.193" class="difflineplus">+      &lt;property name=&quot;label&quot; readonly=&quot;true&quot;&gt;</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineplus">+        &lt;getter&gt;</span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+            var item = this.getAttribute(&quot;item&quot;);</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+            return item.accessibleLabel;</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+          ]]&gt;</span>
<a href="#l3.199"></a><span id="l3.199" class="difflineplus">+        &lt;/getter&gt;</span>
<a href="#l3.200"></a><span id="l3.200" class="difflineplus">+      &lt;/property&gt;</span>
<a href="#l3.201"></a><span id="l3.201" class="difflineplus">+      </span>
<a href="#l3.202"></a><span id="l3.202" class="difflineplus">+      &lt;method name=&quot;_adjustAcItem&quot;&gt;</span>
<a href="#l3.203"></a><span id="l3.203" class="difflineplus">+        &lt;body&gt;</span>
<a href="#l3.204"></a><span id="l3.204" class="difflineplus">+          &lt;![CDATA[</span>
<a href="#l3.205"></a><span id="l3.205" class="difflineplus">+          var identity = this.obj;</span>
<a href="#l3.206"></a><span id="l3.206" class="difflineplus">+          </span>
<a href="#l3.207"></a><span id="l3.207" class="difflineplus">+          if (identity == null)</span>
<a href="#l3.208"></a><span id="l3.208" class="difflineplus">+            return;</span>
<a href="#l3.209"></a><span id="l3.209" class="difflineplus">+          </span>
<a href="#l3.210"></a><span id="l3.210" class="difflineplus">+          // I guess we should get the picture size from CSS or something?</span>
<a href="#l3.211"></a><span id="l3.211" class="difflineplus">+          this._picture.src = identity.pictureURL(32);</span>
<a href="#l3.212"></a><span id="l3.212" class="difflineplus">+          </span>
<a href="#l3.213"></a><span id="l3.213" class="difflineplus">+          // Emphasize the matching search terms for the description</span>
<a href="#l3.214"></a><span id="l3.214" class="difflineplus">+          this._setUpDescription(this._name, identity.contact.name);</span>
<a href="#l3.215"></a><span id="l3.215" class="difflineplus">+          this._setUpDescription(this._identity, identity.value);</span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+</span>
<a href="#l3.217"></a><span id="l3.217" class="difflineplus">+          // Set up overflow on a timeout because the contents of the box</span>
<a href="#l3.218"></a><span id="l3.218" class="difflineplus">+          // might not have a width yet even though we just changed them</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineplus">+          setTimeout(this._setUpOverflow, 0, this._nameBox, this._nameOverflowEllipsis);</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+          setTimeout(this._setUpOverflow, 0, this._identityBox, this._identityOverflowEllipsis);</span>
<a href="#l3.221"></a><span id="l3.221" class="difflineplus">+          ]]&gt;</span>
<a href="#l3.222"></a><span id="l3.222" class="difflineplus">+        &lt;/body&gt;</span>
<a href="#l3.223"></a><span id="l3.223" class="difflineplus">+      &lt;/method&gt;</span>
<a href="#l3.224"></a><span id="l3.224" class="difflineplus">+</span>
<a href="#l3.225"></a><span id="l3.225" class="difflineplus">+    &lt;/implementation&gt;</span>
<a href="#l3.226"></a><span id="l3.226" class="difflineplus">+  &lt;/binding&gt;</span>
<a href="#l3.227"></a><span id="l3.227" class="difflineplus">+</span>
<a href="#l3.228"></a><span id="l3.228" class="difflineplus">+&lt;/bindings&gt;</span>
<a href="#l3.229"></a><span id="l3.229">\ No newline at end of file</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/content/thunderbirdOverlay.xul</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/content/thunderbirdOverlay.xul</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -31,17 +31,16 @@</span>
<a href="#l4.4"></a><span id="l4.4">   - use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l4.5"></a><span id="l4.5">   - decision by deleting the provisions above and replace them with the notice</span>
<a href="#l4.6"></a><span id="l4.6">   - and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l4.7"></a><span id="l4.7">   - the provisions above, a recipient may use your version of this file under</span>
<a href="#l4.8"></a><span id="l4.8">   - the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l4.9"></a><span id="l4.9">   - </span>
<a href="#l4.10"></a><span id="l4.10">   - ***** END LICENSE BLOCK ***** --&gt;</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-&lt;?xml-stylesheet href=&quot;chrome://gloda/skin/overlay.css&quot; type=&quot;text/css&quot;?&gt;</span>
<a href="#l4.13"></a><span id="l4.13"> &lt;!DOCTYPE overlay SYSTEM &quot;chrome://gloda/locale/gloda.dtd&quot;&gt;</span>
<a href="#l4.14"></a><span id="l4.14"> &lt;overlay id=&quot;gloda-overlay&quot;</span>
<a href="#l4.15"></a><span id="l4.15">          xmlns=&quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;&gt;</span>
<a href="#l4.16"></a><span id="l4.16">   &lt;script src=&quot;overlay.js&quot;/&gt;</span>
<a href="#l4.17"></a><span id="l4.17">   &lt;stringbundleset id=&quot;stringbundleset&quot;&gt;</span>
<a href="#l4.18"></a><span id="l4.18">     &lt;stringbundle id=&quot;gloda-strings&quot; src=&quot;chrome://gloda/locale/gloda.properties&quot;/&gt;</span>
<a href="#l4.19"></a><span id="l4.19">   &lt;/stringbundleset&gt;</span>
<a href="#l4.20"></a><span id="l4.20"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/jar.mn</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/jar.mn</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -2,8 +2,10 @@ gloda.jar:</span>
<a href="#l5.4"></a><span id="l5.4"> % content gloda   %content/</span>
<a href="#l5.5"></a><span id="l5.5"> % locale  gloda   en-US   %locale/en-US/</span>
<a href="#l5.6"></a><span id="l5.6"> % overlay chrome://messenger/content/messenger.xul    chrome://gloda/content/thunderbirdOverlay.xul</span>
<a href="#l5.7"></a><span id="l5.7"> % resource gloda ../</span>
<a href="#l5.8"></a><span id="l5.8">   locale/en-US/gloda.dtd</span>
<a href="#l5.9"></a><span id="l5.9">   locale/en-US/gloda.properties</span>
<a href="#l5.10"></a><span id="l5.10">   content/overlay.js</span>
<a href="#l5.11"></a><span id="l5.11">   content/thunderbirdOverlay.xul</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+  content/glodacomplete.css</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+* content/glodacomplete.xml</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -429,22 +429,22 @@ GlodaCollection.prototype = {</span>
<a href="#l6.4"></a><span id="l6.4">       }</span>
<a href="#l6.5"></a><span id="l6.5">     }</span>
<a href="#l6.6"></a><span id="l6.6">     else {</span>
<a href="#l6.7"></a><span id="l6.7">       for each (let item in this.items) {</span>
<a href="#l6.8"></a><span id="l6.8">         this._idMap[item.id] = item;</span>
<a href="#l6.9"></a><span id="l6.9">       }</span>
<a href="#l6.10"></a><span id="l6.10">     }</span>
<a href="#l6.11"></a><span id="l6.11">     if (this._listener)</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-      this._listener.onItemsAdded(aItems);</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+      this._listener.onItemsAdded(aItems, this);</span>
<a href="#l6.14"></a><span id="l6.14">   },</span>
<a href="#l6.15"></a><span id="l6.15">   </span>
<a href="#l6.16"></a><span id="l6.16">   _onItemsModified: function gloda_coll_onItemsModified(aItems) {</span>
<a href="#l6.17"></a><span id="l6.17">     if (this._listener)</span>
<a href="#l6.18"></a><span id="l6.18" class="difflineminus">-      this._listener.onItemsModified(aItems);</span>
<a href="#l6.19"></a><span id="l6.19" class="difflineplus">+      this._listener.onItemsModified(aItems, this);</span>
<a href="#l6.20"></a><span id="l6.20">   },</span>
<a href="#l6.21"></a><span id="l6.21">   </span>
<a href="#l6.22"></a><span id="l6.22">   /**</span>
<a href="#l6.23"></a><span id="l6.23">    * Given a list of items that definitely no longer belong in this collection,</span>
<a href="#l6.24"></a><span id="l6.24">    *  remove them from the collection and notify the listener.  The 'tricky'</span>
<a href="#l6.25"></a><span id="l6.25">    *  part is that we need to remove the deleted items from our list of items.</span>
<a href="#l6.26"></a><span id="l6.26">    */</span>
<a href="#l6.27"></a><span id="l6.27">   _onItemsRemoved: function gloda_coll_onItemsRemoved(aItems) {</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineat">@@ -465,18 +465,23 @@ GlodaCollection.prototype = {</span>
<a href="#l6.29"></a><span id="l6.29">     for (let iRead = 0; iRead &lt; items.length; iRead++) {</span>
<a href="#l6.30"></a><span id="l6.30">       let item = items[iRead];</span>
<a href="#l6.31"></a><span id="l6.31">       if (!(item.id in deleteMap))</span>
<a href="#l6.32"></a><span id="l6.32">         items[iWrite++] = item;</span>
<a href="#l6.33"></a><span id="l6.33">     }</span>
<a href="#l6.34"></a><span id="l6.34">     items.slice(iWrite);</span>
<a href="#l6.35"></a><span id="l6.35">     </span>
<a href="#l6.36"></a><span id="l6.36">     if (this._listener)</span>
<a href="#l6.37"></a><span id="l6.37" class="difflineminus">-      this._listener.onItemsRemoved(aItems);</span>
<a href="#l6.38"></a><span id="l6.38" class="difflineplus">+      this._listener.onItemsRemoved(aItems, this);</span>
<a href="#l6.39"></a><span id="l6.39">   },</span>
<a href="#l6.40"></a><span id="l6.40" class="difflineplus">+</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineplus">+  _onQueryCompleted: function gloda_coll_onQueryCompleted() {</span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+    if (this._listener &amp;&amp; this._listener.onQueryCompleted)</span>
<a href="#l6.43"></a><span id="l6.43" class="difflineplus">+      this._listener.onQueryCompleted(this);</span>
<a href="#l6.44"></a><span id="l6.44" class="difflineplus">+  }</span>
<a href="#l6.45"></a><span id="l6.45"> };</span>
<a href="#l6.46"></a><span id="l6.46"> </span>
<a href="#l6.47"></a><span id="l6.47"> /**</span>
<a href="#l6.48"></a><span id="l6.48">  * Create an LRU cache collection for the given noun with the given size.</span>
<a href="#l6.49"></a><span id="l6.49">  * @constructor</span>
<a href="#l6.50"></a><span id="l6.50">  */</span>
<a href="#l6.51"></a><span id="l6.51"> function GlodaLRUCacheCollection(aNounMeta, aCacheSize) {</span>
<a href="#l6.52"></a><span id="l6.52">   GlodaCollection.call(this, aNounMeta, null, null, null);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -42,16 +42,18 @@ EXPORTED_SYMBOLS = [&quot;GlodaAttributeDef&quot;,</span>
<a href="#l7.4"></a><span id="l7.4"> const Cc = Components.classes;</span>
<a href="#l7.5"></a><span id="l7.5"> const Ci = Components.interfaces;</span>
<a href="#l7.6"></a><span id="l7.6"> const Cr = Components.results;</span>
<a href="#l7.7"></a><span id="l7.7"> const Cu = Components.utils;</span>
<a href="#l7.8"></a><span id="l7.8"> </span>
<a href="#l7.9"></a><span id="l7.9"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l7.10"></a><span id="l7.10"> const LOG = Log4Moz.Service.getLogger(&quot;gloda.datamodel&quot;);</span>
<a href="#l7.11"></a><span id="l7.11"> </span>
<a href="#l7.12"></a><span id="l7.12" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+</span>
<a href="#l7.14"></a><span id="l7.14"> /**</span>
<a href="#l7.15"></a><span id="l7.15">  * @class Represents a gloda attribute definition.</span>
<a href="#l7.16"></a><span id="l7.16">  */</span>
<a href="#l7.17"></a><span id="l7.17"> function GlodaAttributeDef(aDatastore, aID, aCompoundName, aProvider, aAttrType,</span>
<a href="#l7.18"></a><span id="l7.18">                            aPluginName, aAttrName, aSubjectTypes,</span>
<a href="#l7.19"></a><span id="l7.19">                            aObjectType, aObjectNounMeta,</span>
<a href="#l7.20"></a><span id="l7.20">                            aExplanationFormat) {</span>
<a href="#l7.21"></a><span id="l7.21">   this._datastore = aDatastore;</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineat">@@ -60,68 +62,68 @@ function GlodaAttributeDef(aDatastore, a</span>
<a href="#l7.23"></a><span id="l7.23">   this._provider = aProvider;</span>
<a href="#l7.24"></a><span id="l7.24">   this._attrType = aAttrType;</span>
<a href="#l7.25"></a><span id="l7.25">   this._pluginName = aPluginName;</span>
<a href="#l7.26"></a><span id="l7.26">   this._attrName = aAttrName;</span>
<a href="#l7.27"></a><span id="l7.27">   this._subjectTypes = aSubjectTypes;</span>
<a href="#l7.28"></a><span id="l7.28">   this._objectType = aObjectType;</span>
<a href="#l7.29"></a><span id="l7.29">   this._objectNounMeta = aObjectNounMeta;</span>
<a href="#l7.30"></a><span id="l7.30">   this._explanationFormat = aExplanationFormat;</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-  </span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+</span>
<a href="#l7.33"></a><span id="l7.33">   this._boundName = null;</span>
<a href="#l7.34"></a><span id="l7.34">   this._singular = null;</span>
<a href="#l7.35"></a><span id="l7.35" class="difflineminus">-  </span>
<a href="#l7.36"></a><span id="l7.36" class="difflineplus">+</span>
<a href="#l7.37"></a><span id="l7.37">   this._special = 0; // not special</span>
<a href="#l7.38"></a><span id="l7.38">   this._specialColumnName = null;</span>
<a href="#l7.39"></a><span id="l7.39" class="difflineminus">-  </span>
<a href="#l7.40"></a><span id="l7.40" class="difflineplus">+</span>
<a href="#l7.41"></a><span id="l7.41">   /** Map parameter values to the underlying database id. */</span>
<a href="#l7.42"></a><span id="l7.42">   this._parameterBindings = {};</span>
<a href="#l7.43"></a><span id="l7.43"> }</span>
<a href="#l7.44"></a><span id="l7.44"> </span>
<a href="#l7.45"></a><span id="l7.45"> GlodaAttributeDef.prototype = {</span>
<a href="#l7.46"></a><span id="l7.46">   get id() { return this._id; },</span>
<a href="#l7.47"></a><span id="l7.47">   get provider() { return this._provider; },</span>
<a href="#l7.48"></a><span id="l7.48">   get attributeName() { return this._attrName; },</span>
<a href="#l7.49"></a><span id="l7.49"> </span>
<a href="#l7.50"></a><span id="l7.50">   get objectNoun() { return this._objectType; },</span>
<a href="#l7.51"></a><span id="l7.51">   get objectNounMeta() { return this._objectNounMeta; },</span>
<a href="#l7.52"></a><span id="l7.52"> </span>
<a href="#l7.53"></a><span id="l7.53">   get isBound() { return this._boundName !== null; },</span>
<a href="#l7.54"></a><span id="l7.54">   get boundName() { return this._boundName; },</span>
<a href="#l7.55"></a><span id="l7.55">   get singular() { return this._singular; },</span>
<a href="#l7.56"></a><span id="l7.56" class="difflineminus">-  </span>
<a href="#l7.57"></a><span id="l7.57" class="difflineplus">+</span>
<a href="#l7.58"></a><span id="l7.58">   get special() { return this._special; },</span>
<a href="#l7.59"></a><span id="l7.59">   get specialColumnName() { return this._specialColumnName; },</span>
<a href="#l7.60"></a><span id="l7.60"> </span>
<a href="#l7.61"></a><span id="l7.61">   /**</span>
<a href="#l7.62"></a><span id="l7.62">    * Bind a parameter value to the attribute definition, allowing use of the</span>
<a href="#l7.63"></a><span id="l7.63">    *  attribute-parameter as an attribute.</span>
<a href="#l7.64"></a><span id="l7.64">    *</span>
<a href="#l7.65"></a><span id="l7.65" class="difflineminus">-   * @return </span>
<a href="#l7.66"></a><span id="l7.66" class="difflineplus">+   * @return</span>
<a href="#l7.67"></a><span id="l7.67">    */</span>
<a href="#l7.68"></a><span id="l7.68">   bindParameter: function gloda_attr_bindParameter(aValue) {</span>
<a href="#l7.69"></a><span id="l7.69">     // people probably shouldn't call us with null, but handle it</span>
<a href="#l7.70"></a><span id="l7.70">     if (aValue == null) {</span>
<a href="#l7.71"></a><span id="l7.71">       return this._id;</span>
<a href="#l7.72"></a><span id="l7.72">     }</span>
<a href="#l7.73"></a><span id="l7.73">     if (aValue in this._parameterBindings) {</span>
<a href="#l7.74"></a><span id="l7.74">       return this._parameterBindings[aValue];</span>
<a href="#l7.75"></a><span id="l7.75">     }</span>
<a href="#l7.76"></a><span id="l7.76">     // no database entry exists if we are here, so we must create it...</span>
<a href="#l7.77"></a><span id="l7.77">     let id = this._datastore._createAttributeDef(this._attrType,</span>
<a href="#l7.78"></a><span id="l7.78">                  this._pluginName, this._attrName, aValue);</span>
<a href="#l7.79"></a><span id="l7.79">     this._parameterBindings[aValue] = id;</span>
<a href="#l7.80"></a><span id="l7.80">     this._datastore.reportBinding(id, this, aValue);</span>
<a href="#l7.81"></a><span id="l7.81">     return id;</span>
<a href="#l7.82"></a><span id="l7.82">   },</span>
<a href="#l7.83"></a><span id="l7.83" class="difflineminus">-  </span>
<a href="#l7.84"></a><span id="l7.84" class="difflineplus">+</span>
<a href="#l7.85"></a><span id="l7.85">   explain: function gloda_attr_explain(aSubject, aValue) {</span>
<a href="#l7.86"></a><span id="l7.86">     return &quot;deprecated. stop calling.&quot;;</span>
<a href="#l7.87"></a><span id="l7.87">   },</span>
<a href="#l7.88"></a><span id="l7.88" class="difflineminus">-  </span>
<a href="#l7.89"></a><span id="l7.89" class="difflineplus">+</span>
<a href="#l7.90"></a><span id="l7.90">   /**</span>
<a href="#l7.91"></a><span id="l7.91">    * Given an instance of an object with this attribute, return the value</span>
<a href="#l7.92"></a><span id="l7.92">    *  of the attribute.  This handles bound and un-bound attributes.  For</span>
<a href="#l7.93"></a><span id="l7.93">    *  singular attributes, the value is null or the value; for non-singular</span>
<a href="#l7.94"></a><span id="l7.94">    *  attributes the value is a list.</span>
<a href="#l7.95"></a><span id="l7.95">    */</span>
<a href="#l7.96"></a><span id="l7.96">   getValueFromInstance: function gloda_attr_getValueFromInstance(aObj) {</span>
<a href="#l7.97"></a><span id="l7.97">     // if it's bound, we can just use the binding and trigger his caching</span>
<a href="#l7.98"></a><span id="l7.98" class="difflineat">@@ -148,22 +150,132 @@ GlodaAttributeDef.prototype = {</span>
<a href="#l7.99"></a><span id="l7.99">         }</span>
<a href="#l7.100"></a><span id="l7.100">       }</span>
<a href="#l7.101"></a><span id="l7.101">       else {</span>
<a href="#l7.102"></a><span id="l7.102">         values = instances; // empty is empty</span>
<a href="#l7.103"></a><span id="l7.103">       }</span>
<a href="#l7.104"></a><span id="l7.104">       return values;</span>
<a href="#l7.105"></a><span id="l7.105">     }</span>
<a href="#l7.106"></a><span id="l7.106">   },</span>
<a href="#l7.107"></a><span id="l7.107" class="difflineminus">-  </span>
<a href="#l7.108"></a><span id="l7.108" class="difflineplus">+</span>
<a href="#l7.109"></a><span id="l7.109">   toString: function() {</span>
<a href="#l7.110"></a><span id="l7.110">     return this._compoundName;</span>
<a href="#l7.111"></a><span id="l7.111" class="difflineplus">+  }</span>
<a href="#l7.112"></a><span id="l7.112" class="difflineplus">+};</span>
<a href="#l7.113"></a><span id="l7.113" class="difflineplus">+</span>
<a href="#l7.114"></a><span id="l7.114" class="difflineplus">+</span>
<a href="#l7.115"></a><span id="l7.115" class="difflineplus">+let GlodaHasAttributesMixIn = {</span>
<a href="#l7.116"></a><span id="l7.116" class="difflineplus">+  _attributes: null,</span>
<a href="#l7.117"></a><span id="l7.117" class="difflineplus">+  /**</span>
<a href="#l7.118"></a><span id="l7.118" class="difflineplus">+   * Return the (normalized, not stored on the row) attributes in a raw form,</span>
<a href="#l7.119"></a><span id="l7.119" class="difflineplus">+   *  aka tuples of [attribute id, parameter, value].  If you want to</span>
<a href="#l7.120"></a><span id="l7.120" class="difflineplus">+   *  generically know about the attributes available, use attributes.</span>
<a href="#l7.121"></a><span id="l7.121" class="difflineplus">+   */</span>
<a href="#l7.122"></a><span id="l7.122" class="difflineplus">+  get_rawAttributes: function() {</span>
<a href="#l7.123"></a><span id="l7.123" class="difflineplus">+    if (this._attributes == null)</span>
<a href="#l7.124"></a><span id="l7.124" class="difflineplus">+      this._attributes = this._datastore.getMessageAttributes(this);</span>
<a href="#l7.125"></a><span id="l7.125" class="difflineplus">+    return this._attributes;</span>
<a href="#l7.126"></a><span id="l7.126">   },</span>
<a href="#l7.127"></a><span id="l7.127" class="difflineplus">+</span>
<a href="#l7.128"></a><span id="l7.128" class="difflineplus">+  /**</span>
<a href="#l7.129"></a><span id="l7.129" class="difflineplus">+   * For consistency of caching with the bound attributes, we try and access the</span>
<a href="#l7.130"></a><span id="l7.130" class="difflineplus">+   *  attributes through their bound names if they are bound.</span>
<a href="#l7.131"></a><span id="l7.131" class="difflineplus">+   */</span>
<a href="#l7.132"></a><span id="l7.132" class="difflineplus">+  get_attributes: function() {</span>
<a href="#l7.133"></a><span id="l7.133" class="difflineplus">+    let seenDefs = {};</span>
<a href="#l7.134"></a><span id="l7.134" class="difflineplus">+    let attribs = [];</span>
<a href="#l7.135"></a><span id="l7.135" class="difflineplus">+    for each (let attrParamVal in this.rawAttributes) {</span>
<a href="#l7.136"></a><span id="l7.136" class="difflineplus">+      let attrDef = attrParamVal[0];</span>
<a href="#l7.137"></a><span id="l7.137" class="difflineplus">+      if (!(attrDef in seenDefs)) {</span>
<a href="#l7.138"></a><span id="l7.138" class="difflineplus">+        if (attrDef.isBound) {</span>
<a href="#l7.139"></a><span id="l7.139" class="difflineplus">+          if (attrDef.singular) {</span>
<a href="#l7.140"></a><span id="l7.140" class="difflineplus">+            attribs.push([attrDef, this[attrDef.boundName]]);</span>
<a href="#l7.141"></a><span id="l7.141" class="difflineplus">+          }</span>
<a href="#l7.142"></a><span id="l7.142" class="difflineplus">+          else {</span>
<a href="#l7.143"></a><span id="l7.143" class="difflineplus">+            let values = this[attrDef.boundName];</span>
<a href="#l7.144"></a><span id="l7.144" class="difflineplus">+            for (let iValue = 0; iValue &lt; values.length; iValue++)</span>
<a href="#l7.145"></a><span id="l7.145" class="difflineplus">+              attribs.push([attrDef, values[iValue]]);</span>
<a href="#l7.146"></a><span id="l7.146" class="difflineplus">+          }</span>
<a href="#l7.147"></a><span id="l7.147" class="difflineplus">+          seenDefs[attrDef] = true;</span>
<a href="#l7.148"></a><span id="l7.148" class="difflineplus">+        }</span>
<a href="#l7.149"></a><span id="l7.149" class="difflineplus">+        else {</span>
<a href="#l7.150"></a><span id="l7.150" class="difflineplus">+          // TODO: actually deal with unbound attributes</span>
<a href="#l7.151"></a><span id="l7.151" class="difflineplus">+          LOG.info(&quot;unbound attribute ignored in traversal: &quot; + attrDef +</span>
<a href="#l7.152"></a><span id="l7.152" class="difflineplus">+                   &quot; value: &quot; + attrParamVal[2]);</span>
<a href="#l7.153"></a><span id="l7.153" class="difflineplus">+        }</span>
<a href="#l7.154"></a><span id="l7.154" class="difflineplus">+      }</span>
<a href="#l7.155"></a><span id="l7.155" class="difflineplus">+    }</span>
<a href="#l7.156"></a><span id="l7.156" class="difflineplus">+</span>
<a href="#l7.157"></a><span id="l7.157" class="difflineplus">+    return attribs;</span>
<a href="#l7.158"></a><span id="l7.158" class="difflineplus">+  },</span>
<a href="#l7.159"></a><span id="l7.159" class="difflineplus">+</span>
<a href="#l7.160"></a><span id="l7.160" class="difflineplus">+  /**</span>
<a href="#l7.161"></a><span id="l7.161" class="difflineplus">+   * Replace the set of attributes on us.  We need to make sure we purge</span>
<a href="#l7.162"></a><span id="l7.162" class="difflineplus">+   *  existing cached values off this instance.  For simplicity and because of</span>
<a href="#l7.163"></a><span id="l7.163" class="difflineplus">+   *  how we cache things currently (we define getters on the instance), we</span>
<a href="#l7.164"></a><span id="l7.164" class="difflineplus">+   *  force the prototype-resident getters to be activated and to cache</span>
<a href="#l7.165"></a><span id="l7.165" class="difflineplus">+   *  everything anew.  This is arguably wasteful; it might be better to go</span>
<a href="#l7.166"></a><span id="l7.166" class="difflineplus">+   *  back to just using storage properties, possibly on a sub-object that</span>
<a href="#l7.167"></a><span id="l7.167" class="difflineplus">+   *  we could just replace with a new one...</span>
<a href="#l7.168"></a><span id="l7.168" class="difflineplus">+   * Note: We actually avoid doing this if the attributes weren't previously</span>
<a href="#l7.169"></a><span id="l7.169" class="difflineplus">+   *  fetched.  Of course, since we do set _attributes with these new</span>
<a href="#l7.170"></a><span id="l7.170" class="difflineplus">+   *  attributes, this check does not steady-state.</span>
<a href="#l7.171"></a><span id="l7.171" class="difflineplus">+   *</span>
<a href="#l7.172"></a><span id="l7.172" class="difflineplus">+   * @XXX Try and avoid compelling ourselves to cache every bound attribute.</span>
<a href="#l7.173"></a><span id="l7.173" class="difflineplus">+   *  (If we stored the cached values in a sub-object, we could just trash the</span>
<a href="#l7.174"></a><span id="l7.174" class="difflineplus">+   *   sub-object.  This would imply a return to having the getters just create</span>
<a href="#l7.175"></a><span id="l7.175" class="difflineplus">+   *   a storage field rather than creating magic getters.)</span>
<a href="#l7.176"></a><span id="l7.176" class="difflineplus">+   */</span>
<a href="#l7.177"></a><span id="l7.177" class="difflineplus">+  _replaceAttributes: function gloda_message_replaceAttributes(aNewAttribs) {</span>
<a href="#l7.178"></a><span id="l7.178" class="difflineplus">+    let hadAttributes = this._attributes !== null;</span>
<a href="#l7.179"></a><span id="l7.179" class="difflineplus">+    this._attributes = aNewAttribs;</span>
<a href="#l7.180"></a><span id="l7.180" class="difflineplus">+    // if this guy didn't already have attributes, we don't actually need to</span>
<a href="#l7.181"></a><span id="l7.181" class="difflineplus">+    //  do any caching work.</span>
<a href="#l7.182"></a><span id="l7.182" class="difflineplus">+    if (!hadAttributes)</span>
<a href="#l7.183"></a><span id="l7.183" class="difflineplus">+      return;</span>
<a href="#l7.184"></a><span id="l7.184" class="difflineplus">+</span>
<a href="#l7.185"></a><span id="l7.185" class="difflineplus">+    let seenDefs = {};</span>
<a href="#l7.186"></a><span id="l7.186" class="difflineplus">+    for each (let attrParamVal in this._attributes) {</span>
<a href="#l7.187"></a><span id="l7.187" class="difflineplus">+      let attrDef = attrParamVal[0];</span>
<a href="#l7.188"></a><span id="l7.188" class="difflineplus">+      if (!(attrDef in seenDefs)) {</span>
<a href="#l7.189"></a><span id="l7.189" class="difflineplus">+        if (attrDef.isBound) {</span>
<a href="#l7.190"></a><span id="l7.190" class="difflineplus">+          // get the getter from our _prototype_ (not us!)</span>
<a href="#l7.191"></a><span id="l7.191" class="difflineplus">+          let getterFunc = this.__proto__.__lookupGetter__(attrDef.boundName);</span>
<a href="#l7.192"></a><span id="l7.192" class="difflineplus">+          // force the getter to do his work (on us)</span>
<a href="#l7.193"></a><span id="l7.193" class="difflineplus">+          getterFunc.call(this);</span>
<a href="#l7.194"></a><span id="l7.194" class="difflineplus">+          seenDefs[attrDef] = true;</span>
<a href="#l7.195"></a><span id="l7.195" class="difflineplus">+        }</span>
<a href="#l7.196"></a><span id="l7.196" class="difflineplus">+      }</span>
<a href="#l7.197"></a><span id="l7.197" class="difflineplus">+    }</span>
<a href="#l7.198"></a><span id="l7.198" class="difflineplus">+  },</span>
<a href="#l7.199"></a><span id="l7.199" class="difflineplus">+</span>
<a href="#l7.200"></a><span id="l7.200" class="difflineplus">+  getAttributeInstances: function gloda_message_getAttributeInstances(aAttr) {</span>
<a href="#l7.201"></a><span id="l7.201" class="difflineplus">+    return [attrParamVal for each (attrParamVal in this.rawAttributes) if</span>
<a href="#l7.202"></a><span id="l7.202" class="difflineplus">+            (attrParamVal[0] == aAttr)];</span>
<a href="#l7.203"></a><span id="l7.203" class="difflineplus">+  },</span>
<a href="#l7.204"></a><span id="l7.204" class="difflineplus">+</span>
<a href="#l7.205"></a><span id="l7.205" class="difflineplus">+  getSingleAttribute: function gloda_message_getSingleAttribute(aAttr) {</span>
<a href="#l7.206"></a><span id="l7.206" class="difflineplus">+    let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l7.207"></a><span id="l7.207" class="difflineplus">+    if (instances.length &gt; 0)</span>
<a href="#l7.208"></a><span id="l7.208" class="difflineplus">+      return instances[0];</span>
<a href="#l7.209"></a><span id="l7.209" class="difflineplus">+    else</span>
<a href="#l7.210"></a><span id="l7.210" class="difflineplus">+      return null;</span>
<a href="#l7.211"></a><span id="l7.211" class="difflineplus">+  }</span>
<a href="#l7.212"></a><span id="l7.212"> };</span>
<a href="#l7.213"></a><span id="l7.213"> </span>
<a href="#l7.214"></a><span id="l7.214" class="difflineplus">+function MixIn(aConstructor, aMixIn) {</span>
<a href="#l7.215"></a><span id="l7.215" class="difflineplus">+  let proto = aConstructor.prototype;</span>
<a href="#l7.216"></a><span id="l7.216" class="difflineplus">+  for (let [name, func] in Iterator(aMixIn)) {</span>
<a href="#l7.217"></a><span id="l7.217" class="difflineplus">+    if (name.substring(0, 4) == &quot;get_&quot;)</span>
<a href="#l7.218"></a><span id="l7.218" class="difflineplus">+      proto.__defineGetter__(name.substring(4), func);</span>
<a href="#l7.219"></a><span id="l7.219" class="difflineplus">+    else</span>
<a href="#l7.220"></a><span id="l7.220" class="difflineplus">+      proto[name] = func;</span>
<a href="#l7.221"></a><span id="l7.221" class="difflineplus">+  }</span>
<a href="#l7.222"></a><span id="l7.222" class="difflineplus">+}</span>
<a href="#l7.223"></a><span id="l7.223" class="difflineplus">+</span>
<a href="#l7.224"></a><span id="l7.224"> /**</span>
<a href="#l7.225"></a><span id="l7.225">  * @class A gloda conversation (thread) exists so that messages can belong.</span>
<a href="#l7.226"></a><span id="l7.226">  */</span>
<a href="#l7.227"></a><span id="l7.227"> function GlodaConversation(aDatastore, aID, aSubject, aOldestMessageDate,</span>
<a href="#l7.228"></a><span id="l7.228">                            aNewestMessageDate) {</span>
<a href="#l7.229"></a><span id="l7.229">   this._datastore = aDatastore;</span>
<a href="#l7.230"></a><span id="l7.230">   this._id = aID;</span>
<a href="#l7.231"></a><span id="l7.231">   this._subject = aSubject;</span>
<a href="#l7.232"></a><span id="l7.232" class="difflineat">@@ -187,17 +299,17 @@ GlodaConversation.prototype = {</span>
<a href="#l7.233"></a><span id="l7.233">    */</span>
<a href="#l7.234"></a><span id="l7.234">   get messages() {</span>
<a href="#l7.235"></a><span id="l7.235">     if (this._messages == null) {</span>
<a href="#l7.236"></a><span id="l7.236">       this._messages = this._datastore.getMessagesByConversationID(this._id,</span>
<a href="#l7.237"></a><span id="l7.237">                                                                    false);</span>
<a href="#l7.238"></a><span id="l7.238">     }</span>
<a href="#l7.239"></a><span id="l7.239">     return this._messages;</span>
<a href="#l7.240"></a><span id="l7.240">   },</span>
<a href="#l7.241"></a><span id="l7.241" class="difflineminus">-  </span>
<a href="#l7.242"></a><span id="l7.242" class="difflineplus">+</span>
<a href="#l7.243"></a><span id="l7.243">   toString: function gloda_conversation_toString() {</span>
<a href="#l7.244"></a><span id="l7.244">     return this._subject;</span>
<a href="#l7.245"></a><span id="l7.245">   },</span>
<a href="#l7.246"></a><span id="l7.246"> };</span>
<a href="#l7.247"></a><span id="l7.247"> </span>
<a href="#l7.248"></a><span id="l7.248"> /**</span>
<a href="#l7.249"></a><span id="l7.249">  * @class A message representation.</span>
<a href="#l7.250"></a><span id="l7.250">  */</span>
<a href="#l7.251"></a><span id="l7.251" class="difflineat">@@ -212,19 +324,16 @@ function GlodaMessage(aDatastore, aID, a</span>
<a href="#l7.252"></a><span id="l7.252">   this._conversation = aConversation;</span>
<a href="#l7.253"></a><span id="l7.253">   this.date = aDate;</span>
<a href="#l7.254"></a><span id="l7.254">   this._headerMessageID = aHeaderMessageID;</span>
<a href="#l7.255"></a><span id="l7.255"> </span>
<a href="#l7.256"></a><span id="l7.256">   // only set _deleted if we're deleted, otherwise the undefined does our</span>
<a href="#l7.257"></a><span id="l7.257">   //  speaking for us.</span>
<a href="#l7.258"></a><span id="l7.258">   if (aDeleted)</span>
<a href="#l7.259"></a><span id="l7.259">     this._deleted = aDeleted;</span>
<a href="#l7.260"></a><span id="l7.260" class="difflineminus">-</span>
<a href="#l7.261"></a><span id="l7.261" class="difflineminus">-  // the list of attributes, un-processed</span>
<a href="#l7.262"></a><span id="l7.262" class="difflineminus">-  this._attributes = null;</span>
<a href="#l7.263"></a><span id="l7.263"> }</span>
<a href="#l7.264"></a><span id="l7.264"> </span>
<a href="#l7.265"></a><span id="l7.265"> GlodaMessage.prototype = {</span>
<a href="#l7.266"></a><span id="l7.266">   NOUN_ID: 102,</span>
<a href="#l7.267"></a><span id="l7.267">   get id() { return this._id; },</span>
<a href="#l7.268"></a><span id="l7.268">   get folderID() { return this._folderID; },</span>
<a href="#l7.269"></a><span id="l7.269">   get messageKey() { return this._messageKey; },</span>
<a href="#l7.270"></a><span id="l7.270">   get conversationID() { return this._conversationID; },</span>
<a href="#l7.271"></a><span id="l7.271" class="difflineat">@@ -244,39 +353,39 @@ GlodaMessage.prototype = {</span>
<a href="#l7.272"></a><span id="l7.272">     }</span>
<a href="#l7.273"></a><span id="l7.273">     return this._conversation;</span>
<a href="#l7.274"></a><span id="l7.274">   },</span>
<a href="#l7.275"></a><span id="l7.275"> </span>
<a href="#l7.276"></a><span id="l7.276">   set messageKey(aMessageKey) { this._messageKey = aMessageKey; },</span>
<a href="#l7.277"></a><span id="l7.277">   set folderURI(aFolderURI) {</span>
<a href="#l7.278"></a><span id="l7.278">     this._folderID = this._datastore._mapFolderURI(aFolderURI);</span>
<a href="#l7.279"></a><span id="l7.279">   },</span>
<a href="#l7.280"></a><span id="l7.280" class="difflineminus">-  </span>
<a href="#l7.281"></a><span id="l7.281" class="difflineplus">+</span>
<a href="#l7.282"></a><span id="l7.282">   toString: function gloda_message_toString() {</span>
<a href="#l7.283"></a><span id="l7.283">     // uh, this is a tough one...</span>
<a href="#l7.284"></a><span id="l7.284" class="difflineminus">-    return &quot;Message &quot; + this._id; </span>
<a href="#l7.285"></a><span id="l7.285" class="difflineplus">+    return &quot;Message &quot; + this._id;</span>
<a href="#l7.286"></a><span id="l7.286">   },</span>
<a href="#l7.287"></a><span id="l7.287" class="difflineminus">-  </span>
<a href="#l7.288"></a><span id="l7.288" class="difflineplus">+</span>
<a href="#l7.289"></a><span id="l7.289">   _ghost: function gloda_message_ghost() {</span>
<a href="#l7.290"></a><span id="l7.290">     this._folderID = null;</span>
<a href="#l7.291"></a><span id="l7.291">     this._messageKey = null;</span>
<a href="#l7.292"></a><span id="l7.292">   },</span>
<a href="#l7.293"></a><span id="l7.293" class="difflineminus">-  </span>
<a href="#l7.294"></a><span id="l7.294" class="difflineplus">+</span>
<a href="#l7.295"></a><span id="l7.295">   _nuke: function gloda_message_nuke() {</span>
<a href="#l7.296"></a><span id="l7.296">     this._id = null;</span>
<a href="#l7.297"></a><span id="l7.297">     this._folderID = null;</span>
<a href="#l7.298"></a><span id="l7.298">     this._messageKey = null;</span>
<a href="#l7.299"></a><span id="l7.299">     this._conversationID = null;</span>
<a href="#l7.300"></a><span id="l7.300">     this._conversation = null;</span>
<a href="#l7.301"></a><span id="l7.301">     this.date = null;</span>
<a href="#l7.302"></a><span id="l7.302">     this._headerMessageID = null;</span>
<a href="#l7.303"></a><span id="l7.303" class="difflineminus">-    </span>
<a href="#l7.304"></a><span id="l7.304" class="difflineplus">+</span>
<a href="#l7.305"></a><span id="l7.305">     this._datastore = null;</span>
<a href="#l7.306"></a><span id="l7.306">   },</span>
<a href="#l7.307"></a><span id="l7.307" class="difflineminus">-  </span>
<a href="#l7.308"></a><span id="l7.308" class="difflineplus">+</span>
<a href="#l7.309"></a><span id="l7.309">   /**</span>
<a href="#l7.310"></a><span id="l7.310">    * Return the underlying nsIMsgDBHdr from the folder storage for this, or</span>
<a href="#l7.311"></a><span id="l7.311">    *  null if the message does not exist for one reason or another.</span>
<a href="#l7.312"></a><span id="l7.312">    * This method no longer caches the result, so it's up to you.</span>
<a href="#l7.313"></a><span id="l7.313">    */</span>
<a href="#l7.314"></a><span id="l7.314">   get folderMessage() {</span>
<a href="#l7.315"></a><span id="l7.315">     if (this._folderID === null || this._messageKey === null)</span>
<a href="#l7.316"></a><span id="l7.316">       return null;</span>
<a href="#l7.317"></a><span id="l7.317" class="difflineat">@@ -306,162 +415,73 @@ GlodaMessage.prototype = {</span>
<a href="#l7.318"></a><span id="l7.318">     return null;</span>
<a href="#l7.319"></a><span id="l7.319">   },</span>
<a href="#l7.320"></a><span id="l7.320">   get folderMessageURI() {</span>
<a href="#l7.321"></a><span id="l7.321">     let folderMessage = this.folderMessage;</span>
<a href="#l7.322"></a><span id="l7.322">     if (folderMessage)</span>
<a href="#l7.323"></a><span id="l7.323">       return folderMessage.folder.getUriForMsg(folderMessage);</span>
<a href="#l7.324"></a><span id="l7.324">     else</span>
<a href="#l7.325"></a><span id="l7.325">       return null;</span>
<a href="#l7.326"></a><span id="l7.326" class="difflineminus">-  },</span>
<a href="#l7.327"></a><span id="l7.327" class="difflineminus">-  </span>
<a href="#l7.328"></a><span id="l7.328" class="difflineminus">-  /**</span>
<a href="#l7.329"></a><span id="l7.329" class="difflineminus">-   * Return the (normalized, not stored on the row) attributes in a raw form,</span>
<a href="#l7.330"></a><span id="l7.330" class="difflineminus">-   *  aka tuples of [attribute id, parameter, value].  If you want to</span>
<a href="#l7.331"></a><span id="l7.331" class="difflineminus">-   *  generically know about the attributes available, use attributes.</span>
<a href="#l7.332"></a><span id="l7.332" class="difflineminus">-   */</span>
<a href="#l7.333"></a><span id="l7.333" class="difflineminus">-  get rawAttributes() {</span>
<a href="#l7.334"></a><span id="l7.334" class="difflineminus">-    if (this._attributes == null)</span>
<a href="#l7.335"></a><span id="l7.335" class="difflineminus">-      this._attributes = this._datastore.getMessageAttributes(this); </span>
<a href="#l7.336"></a><span id="l7.336" class="difflineminus">-    return this._attributes;</span>
<a href="#l7.337"></a><span id="l7.337" class="difflineminus">-  },</span>
<a href="#l7.338"></a><span id="l7.338" class="difflineminus">-  </span>
<a href="#l7.339"></a><span id="l7.339" class="difflineminus">-  /**</span>
<a href="#l7.340"></a><span id="l7.340" class="difflineminus">-   * For consistency of caching with the bound attributes, we try and access the</span>
<a href="#l7.341"></a><span id="l7.341" class="difflineminus">-   *  attributes through their bound names if they are bound.</span>
<a href="#l7.342"></a><span id="l7.342" class="difflineminus">-   */</span>
<a href="#l7.343"></a><span id="l7.343" class="difflineminus">-  get attributes() {</span>
<a href="#l7.344"></a><span id="l7.344" class="difflineminus">-    let seenDefs = {};</span>
<a href="#l7.345"></a><span id="l7.345" class="difflineminus">-    let attribs = [];</span>
<a href="#l7.346"></a><span id="l7.346" class="difflineminus">-    for each (let attrParamVal in this.rawAttributes) {</span>
<a href="#l7.347"></a><span id="l7.347" class="difflineminus">-      let attrDef = attrParamVal[0];</span>
<a href="#l7.348"></a><span id="l7.348" class="difflineminus">-      if (!(attrDef in seenDefs)) {</span>
<a href="#l7.349"></a><span id="l7.349" class="difflineminus">-        if (attrDef.isBound) {</span>
<a href="#l7.350"></a><span id="l7.350" class="difflineminus">-          if (attrDef.singular) {</span>
<a href="#l7.351"></a><span id="l7.351" class="difflineminus">-            attribs.push([attrDef, this[attrDef.boundName]]);</span>
<a href="#l7.352"></a><span id="l7.352" class="difflineminus">-          }</span>
<a href="#l7.353"></a><span id="l7.353" class="difflineminus">-          else {</span>
<a href="#l7.354"></a><span id="l7.354" class="difflineminus">-            let values = this[attrDef.boundName];</span>
<a href="#l7.355"></a><span id="l7.355" class="difflineminus">-            for (let iValue = 0; iValue &lt; values.length; iValue++)</span>
<a href="#l7.356"></a><span id="l7.356" class="difflineminus">-              attribs.push([attrDef, values[iValue]]);</span>
<a href="#l7.357"></a><span id="l7.357" class="difflineminus">-          }</span>
<a href="#l7.358"></a><span id="l7.358" class="difflineminus">-          seenDefs[attrDef] = true;</span>
<a href="#l7.359"></a><span id="l7.359" class="difflineminus">-        }</span>
<a href="#l7.360"></a><span id="l7.360" class="difflineminus">-        else {</span>
<a href="#l7.361"></a><span id="l7.361" class="difflineminus">-          // TODO: actually deal with unbound attributes</span>
<a href="#l7.362"></a><span id="l7.362" class="difflineminus">-          LOG.info(&quot;unbound attribute ignored in traversal: &quot; + attrDef +</span>
<a href="#l7.363"></a><span id="l7.363" class="difflineminus">-                   &quot; value: &quot; + attrParamVal[2]);</span>
<a href="#l7.364"></a><span id="l7.364" class="difflineminus">-        }</span>
<a href="#l7.365"></a><span id="l7.365" class="difflineminus">-      }</span>
<a href="#l7.366"></a><span id="l7.366" class="difflineminus">-    }</span>
<a href="#l7.367"></a><span id="l7.367" class="difflineminus">-    </span>
<a href="#l7.368"></a><span id="l7.368" class="difflineminus">-    return attribs;</span>
<a href="#l7.369"></a><span id="l7.369" class="difflineminus">-  },</span>
<a href="#l7.370"></a><span id="l7.370" class="difflineminus">-  </span>
<a href="#l7.371"></a><span id="l7.371" class="difflineminus">-  /**</span>
<a href="#l7.372"></a><span id="l7.372" class="difflineminus">-   * Replace the set of attributes on us.  We need to make sure we purge</span>
<a href="#l7.373"></a><span id="l7.373" class="difflineminus">-   *  existing cached values off this instance.  For simplicity and because of</span>
<a href="#l7.374"></a><span id="l7.374" class="difflineminus">-   *  how we cache things currently (we define getters on the instance), we</span>
<a href="#l7.375"></a><span id="l7.375" class="difflineminus">-   *  force the prototype-resident getters to be activated and to cache</span>
<a href="#l7.376"></a><span id="l7.376" class="difflineminus">-   *  everything anew.  This is arguably wasteful; it might be better to go</span>
<a href="#l7.377"></a><span id="l7.377" class="difflineminus">-   *  back to just using storage properties, possibly on a sub-object that</span>
<a href="#l7.378"></a><span id="l7.378" class="difflineminus">-   *  we could just replace with a new one...</span>
<a href="#l7.379"></a><span id="l7.379" class="difflineminus">-   * Note: We actually avoid doing this if the attributes weren't previously</span>
<a href="#l7.380"></a><span id="l7.380" class="difflineminus">-   *  fetched.  Of course, since we do set _attributes with these new</span>
<a href="#l7.381"></a><span id="l7.381" class="difflineminus">-   *  attributes, this check does not steady-state.</span>
<a href="#l7.382"></a><span id="l7.382" class="difflineminus">-   *</span>
<a href="#l7.383"></a><span id="l7.383" class="difflineminus">-   * @XXX Try and avoid compelling ourselves to cache every bound attribute.</span>
<a href="#l7.384"></a><span id="l7.384" class="difflineminus">-   *  (If we stored the cached values in a sub-object, we could just trash the</span>
<a href="#l7.385"></a><span id="l7.385" class="difflineminus">-   *   sub-object.  This would imply a return to having the getters just create</span>
<a href="#l7.386"></a><span id="l7.386" class="difflineminus">-   *   a storage field rather than creating magic getters.)</span>
<a href="#l7.387"></a><span id="l7.387" class="difflineminus">-   */</span>
<a href="#l7.388"></a><span id="l7.388" class="difflineminus">-  _replaceAttributes: function gloda_message_replaceAttributes(aNewAttribs) {</span>
<a href="#l7.389"></a><span id="l7.389" class="difflineminus">-    let hadAttributes = this._attributes !== null;</span>
<a href="#l7.390"></a><span id="l7.390" class="difflineminus">-    this._attributes = aNewAttribs;</span>
<a href="#l7.391"></a><span id="l7.391" class="difflineminus">-    // if this guy didn't already have attributes, we don't actually need to</span>
<a href="#l7.392"></a><span id="l7.392" class="difflineminus">-    //  do any caching work.</span>
<a href="#l7.393"></a><span id="l7.393" class="difflineminus">-    if (!hadAttributes)</span>
<a href="#l7.394"></a><span id="l7.394" class="difflineminus">-      return;</span>
<a href="#l7.395"></a><span id="l7.395" class="difflineminus">-      </span>
<a href="#l7.396"></a><span id="l7.396" class="difflineminus">-    let seenDefs = {};</span>
<a href="#l7.397"></a><span id="l7.397" class="difflineminus">-    for each (let attrParamVal in this._attributes) {</span>
<a href="#l7.398"></a><span id="l7.398" class="difflineminus">-      let attrDef = attrParamVal[0];</span>
<a href="#l7.399"></a><span id="l7.399" class="difflineminus">-      if (!(attrDef in seenDefs)) {</span>
<a href="#l7.400"></a><span id="l7.400" class="difflineminus">-        if (attrDef.isBound) {</span>
<a href="#l7.401"></a><span id="l7.401" class="difflineminus">-          // get the getter from our _prototype_ (not us!)</span>
<a href="#l7.402"></a><span id="l7.402" class="difflineminus">-          let getterFunc = this.__proto__.__lookupGetter__(attrDef.boundName);</span>
<a href="#l7.403"></a><span id="l7.403" class="difflineminus">-          // force the getter to do his work (on us)</span>
<a href="#l7.404"></a><span id="l7.404" class="difflineminus">-          getterFunc.call(this);</span>
<a href="#l7.405"></a><span id="l7.405" class="difflineminus">-          seenDefs[attrDef] = true;</span>
<a href="#l7.406"></a><span id="l7.406" class="difflineminus">-        }</span>
<a href="#l7.407"></a><span id="l7.407" class="difflineminus">-      }</span>
<a href="#l7.408"></a><span id="l7.408" class="difflineminus">-    }</span>
<a href="#l7.409"></a><span id="l7.409" class="difflineminus">-  },</span>
<a href="#l7.410"></a><span id="l7.410" class="difflineminus">-  </span>
<a href="#l7.411"></a><span id="l7.411" class="difflineminus">-  getAttributeInstances: function gloda_message_getAttributeInstances(aAttr) {</span>
<a href="#l7.412"></a><span id="l7.412" class="difflineminus">-    return [attrParamVal for each (attrParamVal in this.rawAttributes) if</span>
<a href="#l7.413"></a><span id="l7.413" class="difflineminus">-            (attrParamVal[0] == aAttr)];</span>
<a href="#l7.414"></a><span id="l7.414" class="difflineminus">-  },</span>
<a href="#l7.415"></a><span id="l7.415" class="difflineminus">-  </span>
<a href="#l7.416"></a><span id="l7.416" class="difflineminus">-  getSingleAttribute: function gloda_message_getSingleAttribute(aAttr) {</span>
<a href="#l7.417"></a><span id="l7.417" class="difflineminus">-    let instances = this.getAttributeInstances(aAttr);</span>
<a href="#l7.418"></a><span id="l7.418" class="difflineminus">-    if (instances.length &gt; 0)</span>
<a href="#l7.419"></a><span id="l7.419" class="difflineminus">-      return instances[0];</span>
<a href="#l7.420"></a><span id="l7.420" class="difflineminus">-    else</span>
<a href="#l7.421"></a><span id="l7.421" class="difflineminus">-      return null;</span>
<a href="#l7.422"></a><span id="l7.422" class="difflineminus">-  },</span>
<a href="#l7.423"></a><span id="l7.423" class="difflineplus">+  }</span>
<a href="#l7.424"></a><span id="l7.424"> };</span>
<a href="#l7.425"></a><span id="l7.425" class="difflineplus">+MixIn(GlodaMessage, GlodaHasAttributesMixIn);</span>
<a href="#l7.426"></a><span id="l7.426"> </span>
<a href="#l7.427"></a><span id="l7.427"> /**</span>
<a href="#l7.428"></a><span id="l7.428">  * @class Contacts correspond to people (one per person), and may own multiple</span>
<a href="#l7.429"></a><span id="l7.429" class="difflineminus">- *  identities (e-mail address, IM account, etc.) </span>
<a href="#l7.430"></a><span id="l7.430" class="difflineplus">+ *  identities (e-mail address, IM account, etc.)</span>
<a href="#l7.431"></a><span id="l7.431">  */</span>
<a href="#l7.432"></a><span id="l7.432"> function GlodaContact(aDatastore, aID, aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l7.433"></a><span id="l7.433">                       aPopularity, aFrecency) {</span>
<a href="#l7.434"></a><span id="l7.434">   this._datastore = aDatastore;</span>
<a href="#l7.435"></a><span id="l7.435">   this._id = aID;</span>
<a href="#l7.436"></a><span id="l7.436">   this._directoryUUID = aDirectoryUUID;</span>
<a href="#l7.437"></a><span id="l7.437">   this._contactUUID = aContactUUID;</span>
<a href="#l7.438"></a><span id="l7.438">   this._name = aName;</span>
<a href="#l7.439"></a><span id="l7.439">   this._popularity = aPopularity;</span>
<a href="#l7.440"></a><span id="l7.440">   this._frecency = aFrecency;</span>
<a href="#l7.441"></a><span id="l7.441" class="difflineminus">-  </span>
<a href="#l7.442"></a><span id="l7.442" class="difflineplus">+</span>
<a href="#l7.443"></a><span id="l7.443">   this._identities = null;</span>
<a href="#l7.444"></a><span id="l7.444"> }</span>
<a href="#l7.445"></a><span id="l7.445"> </span>
<a href="#l7.446"></a><span id="l7.446"> GlodaContact.prototype = {</span>
<a href="#l7.447"></a><span id="l7.447">   NOUN_ID: 103,</span>
<a href="#l7.448"></a><span id="l7.448"> </span>
<a href="#l7.449"></a><span id="l7.449">   get id() { return this._id; },</span>
<a href="#l7.450"></a><span id="l7.450">   get directoryUUID() { return this._directoryUUID; },</span>
<a href="#l7.451"></a><span id="l7.451">   get contactUUID() { return this._contactUUID; },</span>
<a href="#l7.452"></a><span id="l7.452">   get name() { return this._name },</span>
<a href="#l7.453"></a><span id="l7.453" class="difflineminus">-  </span>
<a href="#l7.454"></a><span id="l7.454" class="difflineplus">+</span>
<a href="#l7.455"></a><span id="l7.455">   get popularity() { return this._popularity; },</span>
<a href="#l7.456"></a><span id="l7.456">   set popularity(aPopularity) {</span>
<a href="#l7.457"></a><span id="l7.457">     this._popularity = aPopularity;</span>
<a href="#l7.458"></a><span id="l7.458">     this.dirty = true;</span>
<a href="#l7.459"></a><span id="l7.459">   },</span>
<a href="#l7.460"></a><span id="l7.460"> </span>
<a href="#l7.461"></a><span id="l7.461">   get frecency() { return this._frecency; },</span>
<a href="#l7.462"></a><span id="l7.462">   set frecency(aFrecency) {</span>
<a href="#l7.463"></a><span id="l7.463">     this._frecency = aFrecency;</span>
<a href="#l7.464"></a><span id="l7.464">     this.dirty = true;</span>
<a href="#l7.465"></a><span id="l7.465">   },</span>
<a href="#l7.466"></a><span id="l7.466" class="difflineminus">-  </span>
<a href="#l7.467"></a><span id="l7.467" class="difflineplus">+</span>
<a href="#l7.468"></a><span id="l7.468">   get identities() {</span>
<a href="#l7.469"></a><span id="l7.469">     if (this._identities === null)</span>
<a href="#l7.470"></a><span id="l7.470">       this._identities = this._datastore.getIdentitiesByContactID(this._id);</span>
<a href="#l7.471"></a><span id="l7.471">     return this._identities;</span>
<a href="#l7.472"></a><span id="l7.472">   },</span>
<a href="#l7.473"></a><span id="l7.473" class="difflineminus">-  </span>
<a href="#l7.474"></a><span id="l7.474" class="difflineplus">+</span>
<a href="#l7.475"></a><span id="l7.475">   toString: function gloda_contact_toString() {</span>
<a href="#l7.476"></a><span id="l7.476">     return this._name;</span>
<a href="#l7.477"></a><span id="l7.477" class="difflineplus">+  },</span>
<a href="#l7.478"></a><span id="l7.478" class="difflineplus">+  </span>
<a href="#l7.479"></a><span id="l7.479" class="difflineplus">+  get accessibleLabel() {</span>
<a href="#l7.480"></a><span id="l7.480" class="difflineplus">+    return &quot;Contact: &quot; + this._name;</span>
<a href="#l7.481"></a><span id="l7.481">   }</span>
<a href="#l7.482"></a><span id="l7.482"> };</span>
<a href="#l7.483"></a><span id="l7.483" class="difflineplus">+MixIn(GlodaContact, GlodaHasAttributesMixIn);</span>
<a href="#l7.484"></a><span id="l7.484" class="difflineplus">+</span>
<a href="#l7.485"></a><span id="l7.485"> </span>
<a href="#l7.486"></a><span id="l7.486"> /**</span>
<a href="#l7.487"></a><span id="l7.487">  * @class A specific means of communication for a contact.</span>
<a href="#l7.488"></a><span id="l7.488">  */</span>
<a href="#l7.489"></a><span id="l7.489"> function GlodaIdentity(aDatastore, aID, aContactID, aContact, aKind, aValue,</span>
<a href="#l7.490"></a><span id="l7.490">                        aDescription, aIsRelay) {</span>
<a href="#l7.491"></a><span id="l7.491">   this._datastore = aDatastore;</span>
<a href="#l7.492"></a><span id="l7.492">   this._id = aID;</span>
<a href="#l7.493"></a><span id="l7.493" class="difflineat">@@ -471,36 +491,36 @@ function GlodaIdentity(aDatastore, aID, </span>
<a href="#l7.494"></a><span id="l7.494">   this._value = aValue;</span>
<a href="#l7.495"></a><span id="l7.495">   this._description = aDescription;</span>
<a href="#l7.496"></a><span id="l7.496">   this._isRelay = aIsRelay;</span>
<a href="#l7.497"></a><span id="l7.497"> }</span>
<a href="#l7.498"></a><span id="l7.498"> </span>
<a href="#l7.499"></a><span id="l7.499"> GlodaIdentity.prototype = {</span>
<a href="#l7.500"></a><span id="l7.500">   NOUN_ID: 104,</span>
<a href="#l7.501"></a><span id="l7.501">   get id() { return this._id; },</span>
<a href="#l7.502"></a><span id="l7.502" class="difflineminus">-  get contactID() { return this._contactID; }, </span>
<a href="#l7.503"></a><span id="l7.503" class="difflineplus">+  get contactID() { return this._contactID; },</span>
<a href="#l7.504"></a><span id="l7.504">   get kind() { return this._kind; },</span>
<a href="#l7.505"></a><span id="l7.505">   get value() { return this._value; },</span>
<a href="#l7.506"></a><span id="l7.506">   get description() { return this._description; },</span>
<a href="#l7.507"></a><span id="l7.507">   get isRelay() { return this._isRelay; },</span>
<a href="#l7.508"></a><span id="l7.508" class="difflineminus">-  </span>
<a href="#l7.509"></a><span id="l7.509" class="difflineplus">+</span>
<a href="#l7.510"></a><span id="l7.510">   get uniqueValue() {</span>
<a href="#l7.511"></a><span id="l7.511">     return this._kind + &quot;@&quot; + this._value;</span>
<a href="#l7.512"></a><span id="l7.512">   },</span>
<a href="#l7.513"></a><span id="l7.513" class="difflineminus">-  </span>
<a href="#l7.514"></a><span id="l7.514" class="difflineplus">+</span>
<a href="#l7.515"></a><span id="l7.515">   get contact() {</span>
<a href="#l7.516"></a><span id="l7.516">     if (this._contact === null)</span>
<a href="#l7.517"></a><span id="l7.517">       this._contact = this._datastore.getContactByID(this._contactID);</span>
<a href="#l7.518"></a><span id="l7.518">     return this._contact;</span>
<a href="#l7.519"></a><span id="l7.519">   },</span>
<a href="#l7.520"></a><span id="l7.520" class="difflineminus">-  </span>
<a href="#l7.521"></a><span id="l7.521" class="difflineplus">+</span>
<a href="#l7.522"></a><span id="l7.522">   toString: function gloda_identity_toString() {</span>
<a href="#l7.523"></a><span id="l7.523">     return this._value;</span>
<a href="#l7.524"></a><span id="l7.524">   },</span>
<a href="#l7.525"></a><span id="l7.525" class="difflineminus">-  </span>
<a href="#l7.526"></a><span id="l7.526" class="difflineplus">+</span>
<a href="#l7.527"></a><span id="l7.527">   get abCard() {</span>
<a href="#l7.528"></a><span id="l7.528">     // search through all of our local address books looking for a match.</span>
<a href="#l7.529"></a><span id="l7.529">     let enumerator = Components.classes[&quot;@mozilla.org/abmanager;1&quot;]</span>
<a href="#l7.530"></a><span id="l7.530">                                .getService(Ci.nsIAbManager)</span>
<a href="#l7.531"></a><span id="l7.531">                                .directories;</span>
<a href="#l7.532"></a><span id="l7.532">     let cardForEmailAddress;</span>
<a href="#l7.533"></a><span id="l7.533">     let addrbook;</span>
<a href="#l7.534"></a><span id="l7.534">     while (!cardForEmailAddress &amp;&amp; enumerator.hasMoreElements())</span>
<a href="#l7.535"></a><span id="l7.535" class="difflineat">@@ -508,12 +528,19 @@ GlodaIdentity.prototype = {</span>
<a href="#l7.536"></a><span id="l7.536">       addrbook = enumerator.getNext().QueryInterface(Ci.nsIAbDirectory);</span>
<a href="#l7.537"></a><span id="l7.537">       try</span>
<a href="#l7.538"></a><span id="l7.538">       {</span>
<a href="#l7.539"></a><span id="l7.539">         cardForEmailAddress = addrbook.cardForEmailAddress(this._value);</span>
<a href="#l7.540"></a><span id="l7.540">         if (cardForEmailAddress)</span>
<a href="#l7.541"></a><span id="l7.541">           return cardForEmailAddress;</span>
<a href="#l7.542"></a><span id="l7.542">       } catch (ex) {}</span>
<a href="#l7.543"></a><span id="l7.543">     }</span>
<a href="#l7.544"></a><span id="l7.544" class="difflineminus">-  </span>
<a href="#l7.545"></a><span id="l7.545" class="difflineplus">+</span>
<a href="#l7.546"></a><span id="l7.546">     return null;</span>
<a href="#l7.547"></a><span id="l7.547">   },</span>
<a href="#l7.548"></a><span id="l7.548" class="difflineplus">+  </span>
<a href="#l7.549"></a><span id="l7.549" class="difflineplus">+  pictureURL: function(aSize) {</span>
<a href="#l7.550"></a><span id="l7.550" class="difflineplus">+    let md5hash = GlodaUtils.md5HashString(this._value);</span>
<a href="#l7.551"></a><span id="l7.551" class="difflineplus">+    let gravURL = &quot;http://www.gravatar.com/avatar/&quot; + md5hash +</span>
<a href="#l7.552"></a><span id="l7.552" class="difflineplus">+                                &quot;?d=identicon&amp;s=&quot; + aSize + &quot;&amp;r=g&quot;;</span>
<a href="#l7.553"></a><span id="l7.553" class="difflineplus">+    return gravURL;</span>
<a href="#l7.554"></a><span id="l7.554" class="difflineplus">+  }</span>
<a href="#l7.555"></a><span id="l7.555"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l8.4"></a><span id="l8.4"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l8.5"></a><span id="l8.5">  *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l8.6"></a><span id="l8.6">  *</span>
<a href="#l8.7"></a><span id="l8.7">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l8.8"></a><span id="l8.8">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l8.9"></a><span id="l8.9">  * the License. You may obtain a copy of the License at</span>
<a href="#l8.10"></a><span id="l8.10">  * http://www.mozilla.org/MPL/</span>
<a href="#l8.11"></a><span id="l8.11" class="difflineminus">- * </span>
<a href="#l8.12"></a><span id="l8.12" class="difflineplus">+ *</span>
<a href="#l8.13"></a><span id="l8.13">  * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l8.14"></a><span id="l8.14">  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l8.15"></a><span id="l8.15">  * for the specific language governing rights and limitations under the</span>
<a href="#l8.16"></a><span id="l8.16">  * License.</span>
<a href="#l8.17"></a><span id="l8.17">  *</span>
<a href="#l8.18"></a><span id="l8.18">  * The Original Code is Thunderbird Global Database.</span>
<a href="#l8.19"></a><span id="l8.19">  *</span>
<a href="#l8.20"></a><span id="l8.20">  * The Initial Developer of the Original Code is</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineat">@@ -27,24 +27,24 @@</span>
<a href="#l8.22"></a><span id="l8.22">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l8.23"></a><span id="l8.23">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l8.24"></a><span id="l8.24">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l8.25"></a><span id="l8.25">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l8.26"></a><span id="l8.26">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l8.27"></a><span id="l8.27">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l8.28"></a><span id="l8.28">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l8.29"></a><span id="l8.29">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineminus">- * </span>
<a href="#l8.31"></a><span id="l8.31" class="difflineplus">+ *</span>
<a href="#l8.32"></a><span id="l8.32">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l8.33"></a><span id="l8.33"> </span>
<a href="#l8.34"></a><span id="l8.34"> /* This file looks to Myk Melez &lt;myk@mozilla.org&gt;'s Mozilla Labs snowl</span>
<a href="#l8.35"></a><span id="l8.35">  * project's (http://hg.mozilla.org/labs/snowl/) modules/datastore.js</span>
<a href="#l8.36"></a><span id="l8.36">  * for inspiration and idioms (and also a name :).</span>
<a href="#l8.37"></a><span id="l8.37">  */</span>
<a href="#l8.38"></a><span id="l8.38" class="difflineminus">- </span>
<a href="#l8.39"></a><span id="l8.39" class="difflineplus">+</span>
<a href="#l8.40"></a><span id="l8.40"> EXPORTED_SYMBOLS = [&quot;GlodaDatastore&quot;];</span>
<a href="#l8.41"></a><span id="l8.41"> </span>
<a href="#l8.42"></a><span id="l8.42"> const Cc = Components.classes;</span>
<a href="#l8.43"></a><span id="l8.43"> const Ci = Components.interfaces;</span>
<a href="#l8.44"></a><span id="l8.44"> const Cr = Components.results;</span>
<a href="#l8.45"></a><span id="l8.45"> const Cu = Components.utils;</span>
<a href="#l8.46"></a><span id="l8.46"> </span>
<a href="#l8.47"></a><span id="l8.47"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineat">@@ -72,61 +72,61 @@ const kSpecialFulltext = 3;</span>
<a href="#l8.49"></a><span id="l8.49"> function MessagesByMessageIdCallback(aStatement, aMsgIDToIndex, aResults,</span>
<a href="#l8.50"></a><span id="l8.50">                                      aCallback, aCallbackThis, aCallbackArgs) {</span>
<a href="#l8.51"></a><span id="l8.51">   this.statement = aStatement;</span>
<a href="#l8.52"></a><span id="l8.52">   this.msgIDToIndex = aMsgIDToIndex;</span>
<a href="#l8.53"></a><span id="l8.53">   this.results = aResults;</span>
<a href="#l8.54"></a><span id="l8.54">   this.callback = aCallback;</span>
<a href="#l8.55"></a><span id="l8.55">   this.callbackThis = aCallbackThis;</span>
<a href="#l8.56"></a><span id="l8.56">   this.callbackArgs = aCallbackArgs;</span>
<a href="#l8.57"></a><span id="l8.57" class="difflineminus">-  </span>
<a href="#l8.58"></a><span id="l8.58" class="difflineplus">+</span>
<a href="#l8.59"></a><span id="l8.59">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l8.60"></a><span id="l8.60"> }</span>
<a href="#l8.61"></a><span id="l8.61"> </span>
<a href="#l8.62"></a><span id="l8.62"> MessagesByMessageIdCallback.prototype = {</span>
<a href="#l8.63"></a><span id="l8.63">   handleResult: function gloda_ds_mbmi_handleResult(aResultSet) {</span>
<a href="#l8.64"></a><span id="l8.64">     let row;</span>
<a href="#l8.65"></a><span id="l8.65">     while (row = aResultSet.getNextRow()) {</span>
<a href="#l8.66"></a><span id="l8.66">       let message = GlodaDatastore._messageFromRow(row);</span>
<a href="#l8.67"></a><span id="l8.67">       this.results[this.msgIDToIndex[message.headerMessageID]].push(message);</span>
<a href="#l8.68"></a><span id="l8.68">     }</span>
<a href="#l8.69"></a><span id="l8.69">   },</span>
<a href="#l8.70"></a><span id="l8.70" class="difflineminus">-  </span>
<a href="#l8.71"></a><span id="l8.71" class="difflineplus">+</span>
<a href="#l8.72"></a><span id="l8.72">   handleError: function gloda_ds_mbmi_handleError(aError) {</span>
<a href="#l8.73"></a><span id="l8.73">     GlodaDatastore._log.error(&quot;Async getMessagesByMessageId error: &quot; +</span>
<a href="#l8.74"></a><span id="l8.74">       aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l8.75"></a><span id="l8.75">   },</span>
<a href="#l8.76"></a><span id="l8.76" class="difflineminus">-  </span>
<a href="#l8.77"></a><span id="l8.77" class="difflineplus">+</span>
<a href="#l8.78"></a><span id="l8.78">   handleCompletion: function gloda_ds_mbmi_handleCompletion(aReason) {</span>
<a href="#l8.79"></a><span id="l8.79">     for (let iResult = 0; iResult &lt; this.results.length; iResult++) {</span>
<a href="#l8.80"></a><span id="l8.80">       if (this.results[iResult].length)</span>
<a href="#l8.81"></a><span id="l8.81">         GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l8.82"></a><span id="l8.82">                                               this.results[iResult]);</span>
<a href="#l8.83"></a><span id="l8.83">     }</span>
<a href="#l8.84"></a><span id="l8.84"> </span>
<a href="#l8.85"></a><span id="l8.85">     let args = [this.results].concat(this.callbackArgs);</span>
<a href="#l8.86"></a><span id="l8.86"> </span>
<a href="#l8.87"></a><span id="l8.87">     this.statement.finalize();</span>
<a href="#l8.88"></a><span id="l8.88">     this.statement = null;</span>
<a href="#l8.89"></a><span id="l8.89"> </span>
<a href="#l8.90"></a><span id="l8.90">     this.callback.apply(this.callbackThis, args);</span>
<a href="#l8.91"></a><span id="l8.91" class="difflineminus">-    </span>
<a href="#l8.92"></a><span id="l8.92" class="difflineplus">+</span>
<a href="#l8.93"></a><span id="l8.93">     GlodaDatastore._asyncCompleted();</span>
<a href="#l8.94"></a><span id="l8.94">   }</span>
<a href="#l8.95"></a><span id="l8.95"> };</span>
<a href="#l8.96"></a><span id="l8.96"> </span>
<a href="#l8.97"></a><span id="l8.97"> /**</span>
<a href="#l8.98"></a><span id="l8.98">  * @class Handles the results from a GlodaDatastore.queryFromQuery call.</span>
<a href="#l8.99"></a><span id="l8.99">  * @constructor</span>
<a href="#l8.100"></a><span id="l8.100">  */</span>
<a href="#l8.101"></a><span id="l8.101"> function QueryFromQueryCallback(aStatement, aNounMeta, aCollection) {</span>
<a href="#l8.102"></a><span id="l8.102">   this.statement = aStatement;</span>
<a href="#l8.103"></a><span id="l8.103">   this.nounMeta = aNounMeta;</span>
<a href="#l8.104"></a><span id="l8.104">   this.collection = aCollection;</span>
<a href="#l8.105"></a><span id="l8.105" class="difflineminus">-  </span>
<a href="#l8.106"></a><span id="l8.106" class="difflineplus">+</span>
<a href="#l8.107"></a><span id="l8.107">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l8.108"></a><span id="l8.108"> }</span>
<a href="#l8.109"></a><span id="l8.109"> </span>
<a href="#l8.110"></a><span id="l8.110"> QueryFromQueryCallback.prototype = {</span>
<a href="#l8.111"></a><span id="l8.111">   handleResult: function gloda_ds_qfq_handleResult(aResultSet) {</span>
<a href="#l8.112"></a><span id="l8.112">     let newItems = [];</span>
<a href="#l8.113"></a><span id="l8.113">     let row;</span>
<a href="#l8.114"></a><span id="l8.114">     let nounMeta = this.nounMeta;</span>
<a href="#l8.115"></a><span id="l8.115" class="difflineat">@@ -140,32 +140,34 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l8.116"></a><span id="l8.116">     //  knowledge of what index is the 'id' index and knowing what objFromRow</span>
<a href="#l8.117"></a><span id="l8.117">     //  method to call if it needs to realize the row.</span>
<a href="#l8.118"></a><span id="l8.118">     // queries have the potential to easily exceed the size of our cache, and</span>
<a href="#l8.119"></a><span id="l8.119">     //  will cause needless churn if so.  as such, indicate that we never want</span>
<a href="#l8.120"></a><span id="l8.120">     //  to have our items added to the cache.  after all, as long as our</span>
<a href="#l8.121"></a><span id="l8.121">     //  collection is alive, they can just be found there anyways.  (and when</span>
<a href="#l8.122"></a><span id="l8.122">     //  found there, they may be promoted to the cache anyways.)</span>
<a href="#l8.123"></a><span id="l8.123">     GlodaCollectionManager.cacheLoadUnify(nounMeta.id, newItems, false);</span>
<a href="#l8.124"></a><span id="l8.124" class="difflineminus">-    </span>
<a href="#l8.125"></a><span id="l8.125" class="difflineplus">+</span>
<a href="#l8.126"></a><span id="l8.126">     // just directly tell the collection about the items.  we know the query</span>
<a href="#l8.127"></a><span id="l8.127">     //  matches (at least until we introduce predicates that we cannot express</span>
<a href="#l8.128"></a><span id="l8.128">     //  in SQL.)</span>
<a href="#l8.129"></a><span id="l8.129">     this.collection._onItemsAdded(newItems);</span>
<a href="#l8.130"></a><span id="l8.130">   },</span>
<a href="#l8.131"></a><span id="l8.131" class="difflineminus">-  </span>
<a href="#l8.132"></a><span id="l8.132" class="difflineplus">+</span>
<a href="#l8.133"></a><span id="l8.133">   handleError: function gloda_ds_qfq_handleError(aError) {</span>
<a href="#l8.134"></a><span id="l8.134">     GlodaDatastore._log.error(&quot;Async queryFromQuery error: &quot; +</span>
<a href="#l8.135"></a><span id="l8.135">       aError.result + &quot;: &quot; + aError.message);</span>
<a href="#l8.136"></a><span id="l8.136">   },</span>
<a href="#l8.137"></a><span id="l8.137" class="difflineminus">-  </span>
<a href="#l8.138"></a><span id="l8.138" class="difflineplus">+</span>
<a href="#l8.139"></a><span id="l8.139">   handleCompletion: function gloda_ds_qfq_handleCompletion(aReason) {</span>
<a href="#l8.140"></a><span id="l8.140">     this.statement.finalize();</span>
<a href="#l8.141"></a><span id="l8.141">     this.statement = null;</span>
<a href="#l8.142"></a><span id="l8.142">     </span>
<a href="#l8.143"></a><span id="l8.143" class="difflineplus">+    this.collection._onQueryCompleted();</span>
<a href="#l8.144"></a><span id="l8.144" class="difflineplus">+</span>
<a href="#l8.145"></a><span id="l8.145">     GlodaDatastore._asyncCompleted();</span>
<a href="#l8.146"></a><span id="l8.146">   }</span>
<a href="#l8.147"></a><span id="l8.147"> };</span>
<a href="#l8.148"></a><span id="l8.148"> </span>
<a href="#l8.149"></a><span id="l8.149"> </span>
<a href="#l8.150"></a><span id="l8.150"> /**</span>
<a href="#l8.151"></a><span id="l8.151">  * Database abstraction layer.  Contains explicit SQL schemas for our</span>
<a href="#l8.152"></a><span id="l8.152">  *  fundamental representations (core 'nouns', if you will) as well as</span>
<a href="#l8.153"></a><span id="l8.153" class="difflineat">@@ -230,17 +232,17 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l8.154"></a><span id="l8.154">  *</span>
<a href="#l8.155"></a><span id="l8.155">  * The current strategy may not be the optimal one, feel free to propose and/or</span>
<a href="#l8.156"></a><span id="l8.156">  *  implement better ones, especially if you have numbers.</span>
<a href="#l8.157"></a><span id="l8.157">  * The current strategy is not fully implemented in this file, but the common</span>
<a href="#l8.158"></a><span id="l8.158">  *  cases are believed to be covered.  (Namely, we fail to purge items from the</span>
<a href="#l8.159"></a><span id="l8.159">  *  cache as they are purged from the database.)</span>
<a href="#l8.160"></a><span id="l8.160">  *</span>
<a href="#l8.161"></a><span id="l8.161">  * === Things That May Not Be Obvious (Gotchas)</span>
<a href="#l8.162"></a><span id="l8.162" class="difflineminus">- * </span>
<a href="#l8.163"></a><span id="l8.163" class="difflineplus">+ *</span>
<a href="#l8.164"></a><span id="l8.164">  * Although the schema includes &quot;triggers&quot;, they are currently not used</span>
<a href="#l8.165"></a><span id="l8.165">  *  and were added when thinking about implementing the feature.  We will</span>
<a href="#l8.166"></a><span id="l8.166">  *  probably implement this feature at some point, which is why they are still</span>
<a href="#l8.167"></a><span id="l8.167">  *  in there.</span>
<a href="#l8.168"></a><span id="l8.168">  *</span>
<a href="#l8.169"></a><span id="l8.169">  * We, and the layers above us, are not sufficiently thorough at cleaning out</span>
<a href="#l8.170"></a><span id="l8.170">  *  data from the database, and may potentially orphan it _as new functionality</span>
<a href="#l8.171"></a><span id="l8.171">  *  is added in the future at layers above us_.  That is, currently we should</span>
<a href="#l8.172"></a><span id="l8.172" class="difflineat">@@ -257,55 +259,55 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l8.173"></a><span id="l8.173">  *  datastore.js.</span>
<a href="#l8.174"></a><span id="l8.174">  * @namespace</span>
<a href="#l8.175"></a><span id="l8.175">  */</span>
<a href="#l8.176"></a><span id="l8.176"> var GlodaDatastore = {</span>
<a href="#l8.177"></a><span id="l8.177">   _log: null,</span>
<a href="#l8.178"></a><span id="l8.178"> </span>
<a href="#l8.179"></a><span id="l8.179">   /* ******************* SCHEMA ******************* */</span>
<a href="#l8.180"></a><span id="l8.180"> </span>
<a href="#l8.181"></a><span id="l8.181" class="difflineminus">-  _schemaVersion: 8,</span>
<a href="#l8.182"></a><span id="l8.182" class="difflineplus">+  _schemaVersion: 9,</span>
<a href="#l8.183"></a><span id="l8.183">   _schema: {</span>
<a href="#l8.184"></a><span id="l8.184">     tables: {</span>
<a href="#l8.185"></a><span id="l8.185" class="difflineminus">-      </span>
<a href="#l8.186"></a><span id="l8.186" class="difflineplus">+</span>
<a href="#l8.187"></a><span id="l8.187">       // ----- Messages</span>
<a href="#l8.188"></a><span id="l8.188">       folderLocations: {</span>
<a href="#l8.189"></a><span id="l8.189">         columns: [</span>
<a href="#l8.190"></a><span id="l8.190">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l8.191"></a><span id="l8.191">           &quot;folderURI TEXT NOT NULL&quot;,</span>
<a href="#l8.192"></a><span id="l8.192">         ],</span>
<a href="#l8.193"></a><span id="l8.193" class="difflineminus">-        </span>
<a href="#l8.194"></a><span id="l8.194" class="difflineplus">+</span>
<a href="#l8.195"></a><span id="l8.195">         triggers: {</span>
<a href="#l8.196"></a><span id="l8.196">           delete: &quot;DELETE from messages WHERE folderID = OLD.id&quot;,</span>
<a href="#l8.197"></a><span id="l8.197">         },</span>
<a href="#l8.198"></a><span id="l8.198">       },</span>
<a href="#l8.199"></a><span id="l8.199" class="difflineminus">-      </span>
<a href="#l8.200"></a><span id="l8.200" class="difflineplus">+</span>
<a href="#l8.201"></a><span id="l8.201">       conversations: {</span>
<a href="#l8.202"></a><span id="l8.202">         columns: [</span>
<a href="#l8.203"></a><span id="l8.203">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l8.204"></a><span id="l8.204">           &quot;subject TEXT NOT NULL&quot;,</span>
<a href="#l8.205"></a><span id="l8.205">           &quot;oldestMessageDate INTEGER&quot;,</span>
<a href="#l8.206"></a><span id="l8.206">           &quot;newestMessageDate INTEGER&quot;,</span>
<a href="#l8.207"></a><span id="l8.207">         ],</span>
<a href="#l8.208"></a><span id="l8.208" class="difflineminus">-        </span>
<a href="#l8.209"></a><span id="l8.209" class="difflineplus">+</span>
<a href="#l8.210"></a><span id="l8.210">         indices: {</span>
<a href="#l8.211"></a><span id="l8.211">           subject: ['subject'],</span>
<a href="#l8.212"></a><span id="l8.212">           oldestMessageDate: ['oldestMessageDate'],</span>
<a href="#l8.213"></a><span id="l8.213">           newestMessageDate: ['newestMessageDate'],</span>
<a href="#l8.214"></a><span id="l8.214">         },</span>
<a href="#l8.215"></a><span id="l8.215" class="difflineminus">-        </span>
<a href="#l8.216"></a><span id="l8.216" class="difflineplus">+</span>
<a href="#l8.217"></a><span id="l8.217">         fulltextColumns: [</span>
<a href="#l8.218"></a><span id="l8.218">           &quot;subject TEXT&quot;,</span>
<a href="#l8.219"></a><span id="l8.219">         ],</span>
<a href="#l8.220"></a><span id="l8.220" class="difflineminus">-        </span>
<a href="#l8.221"></a><span id="l8.221" class="difflineplus">+</span>
<a href="#l8.222"></a><span id="l8.222">         triggers: {</span>
<a href="#l8.223"></a><span id="l8.223">           delete: &quot;DELETE from messages WHERE conversationID = OLD.id&quot;,</span>
<a href="#l8.224"></a><span id="l8.224">         },</span>
<a href="#l8.225"></a><span id="l8.225">       },</span>
<a href="#l8.226"></a><span id="l8.226" class="difflineminus">-      </span>
<a href="#l8.227"></a><span id="l8.227" class="difflineplus">+</span>
<a href="#l8.228"></a><span id="l8.228">       /**</span>
<a href="#l8.229"></a><span id="l8.229">        * A message record correspond to an actual message stored in a folder</span>
<a href="#l8.230"></a><span id="l8.230">        *  somewhere, or is a ghost record indicating a message that we know</span>
<a href="#l8.231"></a><span id="l8.231">        *  should exist, but which we have not seen (and which we may never see).</span>
<a href="#l8.232"></a><span id="l8.232">        *  We represent these ghost messages by storing NULL values in the</span>
<a href="#l8.233"></a><span id="l8.233">        *  folderID and messageKey fields; this may need to change to other</span>
<a href="#l8.234"></a><span id="l8.234">        *  sentinel values if this somehow impacts performance.</span>
<a href="#l8.235"></a><span id="l8.235">        */</span>
<a href="#l8.236"></a><span id="l8.236" class="difflineat">@@ -317,74 +319,74 @@ var GlodaDatastore = {</span>
<a href="#l8.237"></a><span id="l8.237">           &quot;conversationID INTEGER NOT NULL REFERENCES conversations(id)&quot;,</span>
<a href="#l8.238"></a><span id="l8.238">           &quot;date INTEGER&quot;,</span>
<a href="#l8.239"></a><span id="l8.239">           // we used to have the parentID, but because of the very real</span>
<a href="#l8.240"></a><span id="l8.240">           //  possibility of multiple copies of a message with a given</span>
<a href="#l8.241"></a><span id="l8.241">           //  message-id, the parentID concept is unreliable.</span>
<a href="#l8.242"></a><span id="l8.242">           &quot;headerMessageID TEXT&quot;,</span>
<a href="#l8.243"></a><span id="l8.243">           &quot;deleted INTEGER NOT NULL default 0&quot;,</span>
<a href="#l8.244"></a><span id="l8.244">         ],</span>
<a href="#l8.245"></a><span id="l8.245" class="difflineminus">-        </span>
<a href="#l8.246"></a><span id="l8.246" class="difflineplus">+</span>
<a href="#l8.247"></a><span id="l8.247">         indices: {</span>
<a href="#l8.248"></a><span id="l8.248">           messageLocation: ['folderID', 'messageKey'],</span>
<a href="#l8.249"></a><span id="l8.249">           headerMessageID: ['headerMessageID'],</span>
<a href="#l8.250"></a><span id="l8.250">           conversationID: ['conversationID'],</span>
<a href="#l8.251"></a><span id="l8.251">           date: ['date'],</span>
<a href="#l8.252"></a><span id="l8.252">           deleted: ['deleted'],</span>
<a href="#l8.253"></a><span id="l8.253">         },</span>
<a href="#l8.254"></a><span id="l8.254" class="difflineminus">-        </span>
<a href="#l8.255"></a><span id="l8.255" class="difflineplus">+</span>
<a href="#l8.256"></a><span id="l8.256">         fulltextColumns: [</span>
<a href="#l8.257"></a><span id="l8.257">           &quot;subject TEXT&quot;,</span>
<a href="#l8.258"></a><span id="l8.258">           &quot;body TEXT&quot;,</span>
<a href="#l8.259"></a><span id="l8.259">           &quot;attachmentNames TEXT&quot;,</span>
<a href="#l8.260"></a><span id="l8.260">         ],</span>
<a href="#l8.261"></a><span id="l8.261" class="difflineminus">-        </span>
<a href="#l8.262"></a><span id="l8.262" class="difflineplus">+</span>
<a href="#l8.263"></a><span id="l8.263">         triggers: {</span>
<a href="#l8.264"></a><span id="l8.264">           delete: &quot;DELETE FROM messageAttributes WHERE messageID = OLD.id&quot;,</span>
<a href="#l8.265"></a><span id="l8.265">         },</span>
<a href="#l8.266"></a><span id="l8.266">       },</span>
<a href="#l8.267"></a><span id="l8.267" class="difflineminus">-      </span>
<a href="#l8.268"></a><span id="l8.268" class="difflineplus">+</span>
<a href="#l8.269"></a><span id="l8.269">       // ----- Attributes</span>
<a href="#l8.270"></a><span id="l8.270">       attributeDefinitions: {</span>
<a href="#l8.271"></a><span id="l8.271">         columns: [</span>
<a href="#l8.272"></a><span id="l8.272">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l8.273"></a><span id="l8.273">           &quot;attributeType INTEGER NOT NULL&quot;,</span>
<a href="#l8.274"></a><span id="l8.274">           &quot;extensionName TEXT NOT NULL&quot;,</span>
<a href="#l8.275"></a><span id="l8.275">           &quot;name TEXT NOT NULL&quot;,</span>
<a href="#l8.276"></a><span id="l8.276">           &quot;parameter BLOB&quot;,</span>
<a href="#l8.277"></a><span id="l8.277">         ],</span>
<a href="#l8.278"></a><span id="l8.278" class="difflineminus">-        </span>
<a href="#l8.279"></a><span id="l8.279" class="difflineplus">+</span>
<a href="#l8.280"></a><span id="l8.280">         triggers: {</span>
<a href="#l8.281"></a><span id="l8.281">           delete: &quot;DELETE FROM messageAttributes WHERE attributeID = OLD.id&quot;,</span>
<a href="#l8.282"></a><span id="l8.282">         },</span>
<a href="#l8.283"></a><span id="l8.283">       },</span>
<a href="#l8.284"></a><span id="l8.284" class="difflineminus">-      </span>
<a href="#l8.285"></a><span id="l8.285" class="difflineplus">+</span>
<a href="#l8.286"></a><span id="l8.286">       messageAttributes: {</span>
<a href="#l8.287"></a><span id="l8.287">         columns: [</span>
<a href="#l8.288"></a><span id="l8.288">           &quot;conversationID INTEGER NOT NULL REFERENCES conversations(id)&quot;,</span>
<a href="#l8.289"></a><span id="l8.289">           &quot;messageID INTEGER NOT NULL REFERENCES messages(id)&quot;,</span>
<a href="#l8.290"></a><span id="l8.290">           &quot;attributeID INTEGER NOT NULL REFERENCES attributeDefinitions(id)&quot;,</span>
<a href="#l8.291"></a><span id="l8.291">           &quot;value NUMERIC&quot;,</span>
<a href="#l8.292"></a><span id="l8.292">         ],</span>
<a href="#l8.293"></a><span id="l8.293" class="difflineminus">-        </span>
<a href="#l8.294"></a><span id="l8.294" class="difflineplus">+</span>
<a href="#l8.295"></a><span id="l8.295">         indices: {</span>
<a href="#l8.296"></a><span id="l8.296">           attribQuery: [</span>
<a href="#l8.297"></a><span id="l8.297">             &quot;attributeID&quot;, &quot;value&quot;,</span>
<a href="#l8.298"></a><span id="l8.298">             /* covering: */ &quot;conversationID&quot;, &quot;messageID&quot;],</span>
<a href="#l8.299"></a><span id="l8.299">           messageAttribFetch: [</span>
<a href="#l8.300"></a><span id="l8.300">             &quot;messageID&quot;,</span>
<a href="#l8.301"></a><span id="l8.301">             /* covering required: */ &quot;attributeID&quot;, &quot;value&quot;],</span>
<a href="#l8.302"></a><span id="l8.302">           conversationAttribFetch: [</span>
<a href="#l8.303"></a><span id="l8.303">             &quot;conversationID&quot;,</span>
<a href="#l8.304"></a><span id="l8.304">             /* covering: */ &quot;messageID&quot;, &quot;attributeID&quot;, &quot;value&quot;],</span>
<a href="#l8.305"></a><span id="l8.305">         },</span>
<a href="#l8.306"></a><span id="l8.306">       },</span>
<a href="#l8.307"></a><span id="l8.307" class="difflineminus">-    </span>
<a href="#l8.308"></a><span id="l8.308" class="difflineplus">+</span>
<a href="#l8.309"></a><span id="l8.309">       // ----- Contacts / Identities</span>
<a href="#l8.310"></a><span id="l8.310" class="difflineminus">-    </span>
<a href="#l8.311"></a><span id="l8.311" class="difflineplus">+</span>
<a href="#l8.312"></a><span id="l8.312">       /**</span>
<a href="#l8.313"></a><span id="l8.313">        * Corresponds to a human being and roughly to an address book entry.</span>
<a href="#l8.314"></a><span id="l8.314">        *  Constrast with an identity, which is a specific e-mail address, IRC</span>
<a href="#l8.315"></a><span id="l8.315">        *  nick, etc.  Identities belong to contacts, and this relationship is</span>
<a href="#l8.316"></a><span id="l8.316">        *  expressed on the identityAttributes table.</span>
<a href="#l8.317"></a><span id="l8.317">        */</span>
<a href="#l8.318"></a><span id="l8.318">       contacts: {</span>
<a href="#l8.319"></a><span id="l8.319">         columns: [</span>
<a href="#l8.320"></a><span id="l8.320" class="difflineat">@@ -395,311 +397,338 @@ var GlodaDatastore = {</span>
<a href="#l8.321"></a><span id="l8.321">           &quot;frecency INTEGER&quot;,</span>
<a href="#l8.322"></a><span id="l8.322">           &quot;name TEXT&quot;</span>
<a href="#l8.323"></a><span id="l8.323">         ],</span>
<a href="#l8.324"></a><span id="l8.324">         indices: {</span>
<a href="#l8.325"></a><span id="l8.325">           popularity: [&quot;popularity&quot;],</span>
<a href="#l8.326"></a><span id="l8.326">           frecency: [&quot;frecency&quot;],</span>
<a href="#l8.327"></a><span id="l8.327">         },</span>
<a href="#l8.328"></a><span id="l8.328">       },</span>
<a href="#l8.329"></a><span id="l8.329" class="difflineminus">-      </span>
<a href="#l8.330"></a><span id="l8.330" class="difflineplus">+</span>
<a href="#l8.331"></a><span id="l8.331" class="difflineplus">+      contactAttributes: {</span>
<a href="#l8.332"></a><span id="l8.332" class="difflineplus">+        columns: [</span>
<a href="#l8.333"></a><span id="l8.333" class="difflineplus">+          &quot;contactID INTEGER NOT NULL REFERENCES contacts(id)&quot;,</span>
<a href="#l8.334"></a><span id="l8.334" class="difflineplus">+          &quot;attributeID INTEGER NOT NULL REFERENCES attributeDefinitions(id)&quot;,</span>
<a href="#l8.335"></a><span id="l8.335" class="difflineplus">+          &quot;value NUMERIC&quot;</span>
<a href="#l8.336"></a><span id="l8.336" class="difflineplus">+        ],</span>
<a href="#l8.337"></a><span id="l8.337" class="difflineplus">+        indices: {</span>
<a href="#l8.338"></a><span id="l8.338" class="difflineplus">+          contactAttribQuery: [</span>
<a href="#l8.339"></a><span id="l8.339" class="difflineplus">+            &quot;attributeID&quot;, &quot;value&quot;,</span>
<a href="#l8.340"></a><span id="l8.340" class="difflineplus">+            /* covering: */ &quot;contactID&quot;],</span>
<a href="#l8.341"></a><span id="l8.341" class="difflineplus">+          contactAttribFetch: [</span>
<a href="#l8.342"></a><span id="l8.342" class="difflineplus">+            &quot;contactID&quot;,</span>
<a href="#l8.343"></a><span id="l8.343" class="difflineplus">+            /* covering */ &quot;attributeID&quot;, &quot;value&quot;]</span>
<a href="#l8.344"></a><span id="l8.344" class="difflineplus">+        }</span>
<a href="#l8.345"></a><span id="l8.345" class="difflineplus">+      },</span>
<a href="#l8.346"></a><span id="l8.346" class="difflineplus">+</span>
<a href="#l8.347"></a><span id="l8.347">       /**</span>
<a href="#l8.348"></a><span id="l8.348">        * Identities correspond to specific e-mail addresses, IRC nicks, etc.</span>
<a href="#l8.349"></a><span id="l8.349">        */</span>
<a href="#l8.350"></a><span id="l8.350">       identities: {</span>
<a href="#l8.351"></a><span id="l8.351">         columns: [</span>
<a href="#l8.352"></a><span id="l8.352">           &quot;id INTEGER PRIMARY KEY&quot;,</span>
<a href="#l8.353"></a><span id="l8.353">           &quot;contactID INTEGER NOT NULL REFERENCES contacts(id)&quot;,</span>
<a href="#l8.354"></a><span id="l8.354">           &quot;kind TEXT NOT NULL&quot;, // ex: email, irc, etc.</span>
<a href="#l8.355"></a><span id="l8.355">           &quot;value TEXT NOT NULL&quot;, // ex: e-mail address, irc nick/handle, etc.</span>
<a href="#l8.356"></a><span id="l8.356">           &quot;description NOT NULL&quot;, // what makes this identity different from the</span>
<a href="#l8.357"></a><span id="l8.357" class="difflineminus">-          // others? (ex: home, work, etc.) </span>
<a href="#l8.358"></a><span id="l8.358" class="difflineplus">+          // others? (ex: home, work, etc.)</span>
<a href="#l8.359"></a><span id="l8.359">           &quot;relay INTEGER NOT NULL&quot;, // is the identity just a relay mechanism?</span>
<a href="#l8.360"></a><span id="l8.360">           // (ex: mailing list, twitter 'bouncer', IRC gateway, etc.)</span>
<a href="#l8.361"></a><span id="l8.361">         ],</span>
<a href="#l8.362"></a><span id="l8.362" class="difflineminus">-        </span>
<a href="#l8.363"></a><span id="l8.363" class="difflineplus">+</span>
<a href="#l8.364"></a><span id="l8.364">         indices: {</span>
<a href="#l8.365"></a><span id="l8.365">           contactQuery: [&quot;contactID&quot;],</span>
<a href="#l8.366"></a><span id="l8.366">           valueQuery: [&quot;kind&quot;, &quot;value&quot;]</span>
<a href="#l8.367"></a><span id="l8.367">         }</span>
<a href="#l8.368"></a><span id="l8.368">       },</span>
<a href="#l8.369"></a><span id="l8.369" class="difflineminus">-      </span>
<a href="#l8.370"></a><span id="l8.370" class="difflineplus">+</span>
<a href="#l8.371"></a><span id="l8.371">       //identityAttributes: {</span>
<a href="#l8.372"></a><span id="l8.372">       //},</span>
<a href="#l8.373"></a><span id="l8.373" class="difflineminus">-    </span>
<a href="#l8.374"></a><span id="l8.374" class="difflineplus">+</span>
<a href="#l8.375"></a><span id="l8.375">     },</span>
<a href="#l8.376"></a><span id="l8.376">   },</span>
<a href="#l8.377"></a><span id="l8.377"> </span>
<a href="#l8.378"></a><span id="l8.378"> </span>
<a href="#l8.379"></a><span id="l8.379">   /* ******************* LOGIC ******************* */</span>
<a href="#l8.380"></a><span id="l8.380">   /**</span>
<a href="#l8.381"></a><span id="l8.381">    * Our synchronous connection, primarily intended for read-only use, so as to</span>
<a href="#l8.382"></a><span id="l8.382">    *  avoid stepping on the toes of our asynchronous connection that will do</span>
<a href="#l8.383"></a><span id="l8.383">    *  most/all of our updating.</span>
<a href="#l8.384"></a><span id="l8.384">    */</span>
<a href="#l8.385"></a><span id="l8.385">   syncConnection: null,</span>
<a href="#l8.386"></a><span id="l8.386">   /**</span>
<a href="#l8.387"></a><span id="l8.387">    * Our connection reused for asynchronous usage, intended for database write</span>
<a href="#l8.388"></a><span id="l8.388">    *  purposes.</span>
<a href="#l8.389"></a><span id="l8.389">    */</span>
<a href="#l8.390"></a><span id="l8.390">   asyncConnection: null,</span>
<a href="#l8.391"></a><span id="l8.391" class="difflineminus">-  </span>
<a href="#l8.392"></a><span id="l8.392" class="difflineplus">+</span>
<a href="#l8.393"></a><span id="l8.393">   /**</span>
<a href="#l8.394"></a><span id="l8.394">    * Initialize logging, create the database if it doesn't exist, &quot;upgrade&quot; it</span>
<a href="#l8.395"></a><span id="l8.395">    *  if it does and it's not up-to-date, fill our authoritative folder uri/id</span>
<a href="#l8.396"></a><span id="l8.396">    *  mapping.</span>
<a href="#l8.397"></a><span id="l8.397">    */</span>
<a href="#l8.398"></a><span id="l8.398">   _init: function gloda_ds_init() {</span>
<a href="#l8.399"></a><span id="l8.399">     this._log = Log4Moz.Service.getLogger(&quot;gloda.datastore&quot;);</span>
<a href="#l8.400"></a><span id="l8.400" class="difflineminus">-  </span>
<a href="#l8.401"></a><span id="l8.401" class="difflineplus">+</span>
<a href="#l8.402"></a><span id="l8.402">     // Get the path to our global database</span>
<a href="#l8.403"></a><span id="l8.403">     var dirService = Cc[&quot;@mozilla.org/file/directory_service;1&quot;].</span>
<a href="#l8.404"></a><span id="l8.404">                      getService(Ci.nsIProperties);</span>
<a href="#l8.405"></a><span id="l8.405">     var dbFile = dirService.get(&quot;ProfD&quot;, Ci.nsIFile);</span>
<a href="#l8.406"></a><span id="l8.406">     dbFile.append(&quot;global-messages-db.sqlite&quot;);</span>
<a href="#l8.407"></a><span id="l8.407" class="difflineminus">-    </span>
<a href="#l8.408"></a><span id="l8.408" class="difflineplus">+</span>
<a href="#l8.409"></a><span id="l8.409">     // Get the storage (sqlite) service</span>
<a href="#l8.410"></a><span id="l8.410">     var dbService = Cc[&quot;@mozilla.org/storage/service;1&quot;].</span>
<a href="#l8.411"></a><span id="l8.411">                     getService(Ci.mozIStorageService);</span>
<a href="#l8.412"></a><span id="l8.412" class="difflineminus">-    </span>
<a href="#l8.413"></a><span id="l8.413" class="difflineplus">+</span>
<a href="#l8.414"></a><span id="l8.414">     var dbConnection;</span>
<a href="#l8.415"></a><span id="l8.415" class="difflineminus">-    </span>
<a href="#l8.416"></a><span id="l8.416" class="difflineplus">+</span>
<a href="#l8.417"></a><span id="l8.417">     // Create the file if it does not exist</span>
<a href="#l8.418"></a><span id="l8.418">     if (!dbFile.exists()) {</span>
<a href="#l8.419"></a><span id="l8.419">       dbConnection = this._createDB(dbService, dbFile);</span>
<a href="#l8.420"></a><span id="l8.420">     }</span>
<a href="#l8.421"></a><span id="l8.421">     // It does exist, but we (someday) might need to upgrade the schema</span>
<a href="#l8.422"></a><span id="l8.422">     else {</span>
<a href="#l8.423"></a><span id="l8.423">       // (Exceptions may be thrown if the database is corrupt)</span>
<a href="#l8.424"></a><span id="l8.424">       { // try {</span>
<a href="#l8.425"></a><span id="l8.425">         dbConnection = dbService.openUnsharedDatabase(dbFile);</span>
<a href="#l8.426"></a><span id="l8.426" class="difflineminus">-      </span>
<a href="#l8.427"></a><span id="l8.427" class="difflineplus">+</span>
<a href="#l8.428"></a><span id="l8.428">         if (dbConnection.schemaVersion != this._schemaVersion) {</span>
<a href="#l8.429"></a><span id="l8.429">           dbConnection = this._migrate(dbService, dbFile,</span>
<a href="#l8.430"></a><span id="l8.430">                                        dbConnection,</span>
<a href="#l8.431"></a><span id="l8.431">                                        dbConnection.schemaVersion,</span>
<a href="#l8.432"></a><span id="l8.432">                                        this._schemaVersion);</span>
<a href="#l8.433"></a><span id="l8.433">         }</span>
<a href="#l8.434"></a><span id="l8.434">       }</span>
<a href="#l8.435"></a><span id="l8.435">       // Handle corrupt databases, other oddities</span>
<a href="#l8.436"></a><span id="l8.436">       // ... in the future. for now, let us die</span>
<a href="#l8.437"></a><span id="l8.437">     }</span>
<a href="#l8.438"></a><span id="l8.438" class="difflineminus">-    </span>
<a href="#l8.439"></a><span id="l8.439" class="difflineplus">+</span>
<a href="#l8.440"></a><span id="l8.440">     this.syncConnection = dbConnection;</span>
<a href="#l8.441"></a><span id="l8.441">     this.asyncConnection = dbService.openUnsharedDatabase(dbFile);</span>
<a href="#l8.442"></a><span id="l8.442" class="difflineminus">-    </span>
<a href="#l8.443"></a><span id="l8.443" class="difflineplus">+</span>
<a href="#l8.444"></a><span id="l8.444">     this._getAllFolderMappings();</span>
<a href="#l8.445"></a><span id="l8.445">     // we need to figure out the next id's for all of the tables where we</span>
<a href="#l8.446"></a><span id="l8.446">     //  manage that.</span>
<a href="#l8.447"></a><span id="l8.447">     this._populateAttributeDefManagedId();</span>
<a href="#l8.448"></a><span id="l8.448">     this._populateConversationManagedId();</span>
<a href="#l8.449"></a><span id="l8.449">     this._populateMessageManagedId();</span>
<a href="#l8.450"></a><span id="l8.450">     this._populateContactManagedId();</span>
<a href="#l8.451"></a><span id="l8.451">     this._populateIdentityManagedId();</span>
<a href="#l8.452"></a><span id="l8.452">   },</span>
<a href="#l8.453"></a><span id="l8.453" class="difflineminus">-  </span>
<a href="#l8.454"></a><span id="l8.454" class="difflineplus">+</span>
<a href="#l8.455"></a><span id="l8.455">   /**</span>
<a href="#l8.456"></a><span id="l8.456">    * Initiate database shutdown; because this might requiring waiting for</span>
<a href="#l8.457"></a><span id="l8.457">    *  outstanding synchronous events to drain, we allow the caller to pass in</span>
<a href="#l8.458"></a><span id="l8.458">    *  a callback to invoke if we are unable to complete shutdown within this</span>
<a href="#l8.459"></a><span id="l8.459">    *  call.</span>
<a href="#l8.460"></a><span id="l8.460">    * @return true if we were able to shutdown fully, false if we were not.  The</span>
<a href="#l8.461"></a><span id="l8.461">    *   callback, if provided, will be notified if we return false.  It will</span>
<a href="#l8.462"></a><span id="l8.462" class="difflineminus">-   *   not be called if we return true.  </span>
<a href="#l8.463"></a><span id="l8.463" class="difflineplus">+   *   not be called if we return true.</span>
<a href="#l8.464"></a><span id="l8.464">    */</span>
<a href="#l8.465"></a><span id="l8.465">   shutdown: function gloda_ds_shutdown(aCallback, aCallbackThis) {</span>
<a href="#l8.466"></a><span id="l8.466">     // clear out any transaction</span>
<a href="#l8.467"></a><span id="l8.467">     while (this._transactionDepth) {</span>
<a href="#l8.468"></a><span id="l8.468">       this._log.info(&quot;Closing pending transaction out for shutdown.&quot;);</span>
<a href="#l8.469"></a><span id="l8.469">       // just schedule this function to be run again once the transaction has</span>
<a href="#l8.470"></a><span id="l8.470">       //  been closed out.</span>
<a href="#l8.471"></a><span id="l8.471">       this._commitTransaction();</span>
<a href="#l8.472"></a><span id="l8.472">     }</span>
<a href="#l8.473"></a><span id="l8.473" class="difflineminus">-    </span>
<a href="#l8.474"></a><span id="l8.474" class="difflineplus">+</span>
<a href="#l8.475"></a><span id="l8.475">     let datastore = this;</span>
<a href="#l8.476"></a><span id="l8.476" class="difflineminus">-    </span>
<a href="#l8.477"></a><span id="l8.477" class="difflineplus">+</span>
<a href="#l8.478"></a><span id="l8.478">     function finish_cleanup() {</span>
<a href="#l8.479"></a><span id="l8.479">       datastore._cleanupAsyncStatements();</span>
<a href="#l8.480"></a><span id="l8.480">       datastore._log.info(&quot;Closing async connection&quot;);</span>
<a href="#l8.481"></a><span id="l8.481">       datastore.asyncConnection.close();</span>
<a href="#l8.482"></a><span id="l8.482">       datastore.asyncConnection = null;</span>
<a href="#l8.483"></a><span id="l8.483" class="difflineminus">-      </span>
<a href="#l8.484"></a><span id="l8.484" class="difflineplus">+</span>
<a href="#l8.485"></a><span id="l8.485">       datastore._cleanupSyncStatements();</span>
<a href="#l8.486"></a><span id="l8.486">       datastore._log.info(&quot;Closing sync connection&quot;);</span>
<a href="#l8.487"></a><span id="l8.487">       datastore.syncConnection.close();</span>
<a href="#l8.488"></a><span id="l8.488">       datastore.syncConnection = null;</span>
<a href="#l8.489"></a><span id="l8.489" class="difflineminus">-      </span>
<a href="#l8.490"></a><span id="l8.490" class="difflineplus">+</span>
<a href="#l8.491"></a><span id="l8.491">       if (aCallback)</span>
<a href="#l8.492"></a><span id="l8.492">         aCallback.call(aCallbackThis);</span>
<a href="#l8.493"></a><span id="l8.493">     }</span>
<a href="#l8.494"></a><span id="l8.494"> </span>
<a href="#l8.495"></a><span id="l8.495">     if (this._pendingAsyncStatements) {</span>
<a href="#l8.496"></a><span id="l8.496">       this._pendingAsyncCompletedListener = finish_cleanup;</span>
<a href="#l8.497"></a><span id="l8.497">       return false;</span>
<a href="#l8.498"></a><span id="l8.498">     }</span>
<a href="#l8.499"></a><span id="l8.499">     else {</span>
<a href="#l8.500"></a><span id="l8.500">       finish_cleanup();</span>
<a href="#l8.501"></a><span id="l8.501">       return true;</span>
<a href="#l8.502"></a><span id="l8.502">     }</span>
<a href="#l8.503"></a><span id="l8.503">   },</span>
<a href="#l8.504"></a><span id="l8.504" class="difflineminus">-  </span>
<a href="#l8.505"></a><span id="l8.505" class="difflineplus">+</span>
<a href="#l8.506"></a><span id="l8.506">   /**</span>
<a href="#l8.507"></a><span id="l8.507">    * Create our database; basically a wrapper around _createSchema.</span>
<a href="#l8.508"></a><span id="l8.508">    */</span>
<a href="#l8.509"></a><span id="l8.509">   _createDB: function gloda_ds_createDB(aDBService, aDBFile) {</span>
<a href="#l8.510"></a><span id="l8.510">     var dbConnection = aDBService.openUnsharedDatabase(aDBFile);</span>
<a href="#l8.511"></a><span id="l8.511" class="difflineminus">-    </span>
<a href="#l8.512"></a><span id="l8.512" class="difflineplus">+</span>
<a href="#l8.513"></a><span id="l8.513">     dbConnection.beginTransaction();</span>
<a href="#l8.514"></a><span id="l8.514">     try {</span>
<a href="#l8.515"></a><span id="l8.515">       this._createSchema(dbConnection);</span>
<a href="#l8.516"></a><span id="l8.516">       dbConnection.commitTransaction();</span>
<a href="#l8.517"></a><span id="l8.517">     }</span>
<a href="#l8.518"></a><span id="l8.518">     catch(ex) {</span>
<a href="#l8.519"></a><span id="l8.519">       dbConnection.rollbackTransaction();</span>
<a href="#l8.520"></a><span id="l8.520">       throw ex;</span>
<a href="#l8.521"></a><span id="l8.521">     }</span>
<a href="#l8.522"></a><span id="l8.522" class="difflineminus">-    </span>
<a href="#l8.523"></a><span id="l8.523" class="difflineplus">+</span>
<a href="#l8.524"></a><span id="l8.524">     return dbConnection;</span>
<a href="#l8.525"></a><span id="l8.525">   },</span>
<a href="#l8.526"></a><span id="l8.526" class="difflineminus">-  </span>
<a href="#l8.527"></a><span id="l8.527" class="difflineplus">+</span>
<a href="#l8.528"></a><span id="l8.528" class="difflineplus">+  _createTableSchema: function gloda_ds_createTableSchema(aDBConnection,</span>
<a href="#l8.529"></a><span id="l8.529" class="difflineplus">+      aTableName) {</span>
<a href="#l8.530"></a><span id="l8.530" class="difflineplus">+    let table = this._schema.tables[aTableName];</span>
<a href="#l8.531"></a><span id="l8.531" class="difflineplus">+</span>
<a href="#l8.532"></a><span id="l8.532" class="difflineplus">+    // - Create the table</span>
<a href="#l8.533"></a><span id="l8.533" class="difflineplus">+    aDBConnection.createTable(aTableName, table.columns.join(&quot;, &quot;));</span>
<a href="#l8.534"></a><span id="l8.534" class="difflineplus">+</span>
<a href="#l8.535"></a><span id="l8.535" class="difflineplus">+    // - Create the fulltext table if applicable</span>
<a href="#l8.536"></a><span id="l8.536" class="difflineplus">+    if (&quot;fulltextColumns&quot; in table) {</span>
<a href="#l8.537"></a><span id="l8.537" class="difflineplus">+      let createFulltextSQL = &quot;CREATE VIRTUAL TABLE &quot; + aTableName + &quot;Text&quot; +</span>
<a href="#l8.538"></a><span id="l8.538" class="difflineplus">+        &quot; USING fts3(tokenize porter, &quot; + table.fulltextColumns.join(&quot;, &quot;) +</span>
<a href="#l8.539"></a><span id="l8.539" class="difflineplus">+        &quot;)&quot;;</span>
<a href="#l8.540"></a><span id="l8.540" class="difflineplus">+      this._log.info(&quot;Create fulltext: &quot; + createFulltextSQL);</span>
<a href="#l8.541"></a><span id="l8.541" class="difflineplus">+      aDBConnection.executeSimpleSQL(createFulltextSQL);</span>
<a href="#l8.542"></a><span id="l8.542" class="difflineplus">+    }</span>
<a href="#l8.543"></a><span id="l8.543" class="difflineplus">+</span>
<a href="#l8.544"></a><span id="l8.544" class="difflineplus">+    // - Create its indices</span>
<a href="#l8.545"></a><span id="l8.545" class="difflineplus">+    for (let indexName in table.indices) {</span>
<a href="#l8.546"></a><span id="l8.546" class="difflineplus">+      let indexColumns = table.indices[indexName];</span>
<a href="#l8.547"></a><span id="l8.547" class="difflineplus">+</span>
<a href="#l8.548"></a><span id="l8.548" class="difflineplus">+      aDBConnection.executeSimpleSQL(</span>
<a href="#l8.549"></a><span id="l8.549" class="difflineplus">+        &quot;CREATE INDEX &quot; + indexName + &quot; ON &quot; + aTableName +</span>
<a href="#l8.550"></a><span id="l8.550" class="difflineplus">+        &quot;(&quot; + indexColumns.join(&quot;, &quot;) + &quot;)&quot;);</span>
<a href="#l8.551"></a><span id="l8.551" class="difflineplus">+    }</span>
<a href="#l8.552"></a><span id="l8.552" class="difflineplus">+  },</span>
<a href="#l8.553"></a><span id="l8.553" class="difflineplus">+</span>
<a href="#l8.554"></a><span id="l8.554">   /**</span>
<a href="#l8.555"></a><span id="l8.555">    * Create our database schema assuming a newly created database.  This</span>
<a href="#l8.556"></a><span id="l8.556">    *  comes down to creating normal tables, their full-text variants (if</span>
<a href="#l8.557"></a><span id="l8.557">    *  applicable), and their indices.</span>
<a href="#l8.558"></a><span id="l8.558">    */</span>
<a href="#l8.559"></a><span id="l8.559">   _createSchema: function gloda_ds_createSchema(aDBConnection) {</span>
<a href="#l8.560"></a><span id="l8.560">     // -- For each table...</span>
<a href="#l8.561"></a><span id="l8.561">     for (let tableName in this._schema.tables) {</span>
<a href="#l8.562"></a><span id="l8.562" class="difflineminus">-      let table = this._schema.tables[tableName];</span>
<a href="#l8.563"></a><span id="l8.563" class="difflineminus">-      </span>
<a href="#l8.564"></a><span id="l8.564" class="difflineminus">-      // - Create the table</span>
<a href="#l8.565"></a><span id="l8.565" class="difflineminus">-      aDBConnection.createTable(tableName, table.columns.join(&quot;, &quot;));</span>
<a href="#l8.566"></a><span id="l8.566" class="difflineminus">-      </span>
<a href="#l8.567"></a><span id="l8.567" class="difflineminus">-      // - Create the fulltext table if applicable</span>
<a href="#l8.568"></a><span id="l8.568" class="difflineminus">-      if (&quot;fulltextColumns&quot; in table) {</span>
<a href="#l8.569"></a><span id="l8.569" class="difflineminus">-        let createFulltextSQL = &quot;CREATE VIRTUAL TABLE &quot; + tableName + &quot;Text&quot; +</span>
<a href="#l8.570"></a><span id="l8.570" class="difflineminus">-          &quot; USING fts3(tokenize porter, &quot; + table.fulltextColumns.join(&quot;, &quot;) +</span>
<a href="#l8.571"></a><span id="l8.571" class="difflineminus">-          &quot;)&quot;;</span>
<a href="#l8.572"></a><span id="l8.572" class="difflineminus">-        this._log.info(&quot;Create fulltext: &quot; + createFulltextSQL);</span>
<a href="#l8.573"></a><span id="l8.573" class="difflineminus">-        aDBConnection.executeSimpleSQL(createFulltextSQL);</span>
<a href="#l8.574"></a><span id="l8.574" class="difflineminus">-      }</span>
<a href="#l8.575"></a><span id="l8.575" class="difflineminus">-      </span>
<a href="#l8.576"></a><span id="l8.576" class="difflineminus">-      // - Create its indices</span>
<a href="#l8.577"></a><span id="l8.577" class="difflineminus">-      for (let indexName in table.indices) {</span>
<a href="#l8.578"></a><span id="l8.578" class="difflineminus">-        let indexColumns = table.indices[indexName];</span>
<a href="#l8.579"></a><span id="l8.579" class="difflineminus">-        </span>
<a href="#l8.580"></a><span id="l8.580" class="difflineminus">-        aDBConnection.executeSimpleSQL(</span>
<a href="#l8.581"></a><span id="l8.581" class="difflineminus">-          &quot;CREATE INDEX &quot; + indexName + &quot; ON &quot; + tableName +</span>
<a href="#l8.582"></a><span id="l8.582" class="difflineminus">-          &quot;(&quot; + indexColumns.join(&quot;, &quot;) + &quot;)&quot;); </span>
<a href="#l8.583"></a><span id="l8.583" class="difflineminus">-      }</span>
<a href="#l8.584"></a><span id="l8.584" class="difflineplus">+      this._createTableSchema(tableName);</span>
<a href="#l8.585"></a><span id="l8.585">     }</span>
<a href="#l8.586"></a><span id="l8.586" class="difflineminus">-    </span>
<a href="#l8.587"></a><span id="l8.587" class="difflineminus">-    aDBConnection.schemaVersion = this._schemaVersion;  </span>
<a href="#l8.588"></a><span id="l8.588" class="difflineplus">+</span>
<a href="#l8.589"></a><span id="l8.589" class="difflineplus">+    aDBConnection.schemaVersion = this._schemaVersion;</span>
<a href="#l8.590"></a><span id="l8.590">   },</span>
<a href="#l8.591"></a><span id="l8.591" class="difflineminus">-  </span>
<a href="#l8.592"></a><span id="l8.592" class="difflineplus">+</span>
<a href="#l8.593"></a><span id="l8.593">   /**</span>
<a href="#l8.594"></a><span id="l8.594">    * Our table definition used here is slightly different from that used</span>
<a href="#l8.595"></a><span id="l8.595">    *  internally, because we are potentially creating a sort of crappy ORM and</span>
<a href="#l8.596"></a><span id="l8.596">    *  we don't want to have to parse the column names out.</span>
<a href="#l8.597"></a><span id="l8.597">    */</span>
<a href="#l8.598"></a><span id="l8.598">   createTableIfNotExists: function gloda_ds_createTableIfNotExists(aTableDef) {</span>
<a href="#l8.599"></a><span id="l8.599">     aTableDef._realName = &quot;plugin_&quot; + aTableDef.name;</span>
<a href="#l8.600"></a><span id="l8.600" class="difflineminus">-    </span>
<a href="#l8.601"></a><span id="l8.601" class="difflineplus">+</span>
<a href="#l8.602"></a><span id="l8.602">     // first, check if the table exists</span>
<a href="#l8.603"></a><span id="l8.603">     if (!this.syncConnection.tableExists(aTableDef._realName)) {</span>
<a href="#l8.604"></a><span id="l8.604">       try {</span>
<a href="#l8.605"></a><span id="l8.605">         this.syncConnection.createTable(aTableDef._realName,</span>
<a href="#l8.606"></a><span id="l8.606">                                         [coldef.join(&quot; &quot;) for each</span>
<a href="#l8.607"></a><span id="l8.607">                                      (coldef in aTableDef.columns)].join(&quot;, &quot;));</span>
<a href="#l8.608"></a><span id="l8.608">       }</span>
<a href="#l8.609"></a><span id="l8.609">       catch (ex) {</span>
<a href="#l8.610"></a><span id="l8.610">          this._log.error(&quot;Problem creating table &quot; + aTableDef.name + &quot; &quot; +</span>
<a href="#l8.611"></a><span id="l8.611">            &quot;because: &quot; + ex + &quot; at &quot; + ex.fileName + &quot;:&quot; + ex.lineNumber);</span>
<a href="#l8.612"></a><span id="l8.612">          return null;</span>
<a href="#l8.613"></a><span id="l8.613">       }</span>
<a href="#l8.614"></a><span id="l8.614"> </span>
<a href="#l8.615"></a><span id="l8.615">       for (let indexName in aTableDef.indices) {</span>
<a href="#l8.616"></a><span id="l8.616">         let indexColumns = aTableDef.indices[indexName];</span>
<a href="#l8.617"></a><span id="l8.617" class="difflineminus">-        </span>
<a href="#l8.618"></a><span id="l8.618" class="difflineplus">+</span>
<a href="#l8.619"></a><span id="l8.619">         try {</span>
<a href="#l8.620"></a><span id="l8.620">           let indexSql = &quot;CREATE INDEX &quot; + indexName + &quot; ON &quot; +</span>
<a href="#l8.621"></a><span id="l8.621">             aTableDef._realName + &quot; (&quot; + indexColumns.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l8.622"></a><span id="l8.622">           this.syncConnection.executeSimpleSQL(indexSql);</span>
<a href="#l8.623"></a><span id="l8.623">         }</span>
<a href="#l8.624"></a><span id="l8.624">         catch (ex) {</span>
<a href="#l8.625"></a><span id="l8.625">           this._log.error(&quot;Problem creating index &quot; + indexName + &quot; for &quot; +</span>
<a href="#l8.626"></a><span id="l8.626">             &quot;table &quot; + aTableDef.name + &quot; because &quot; + ex + &quot; at &quot; +</span>
<a href="#l8.627"></a><span id="l8.627">             ex.fileName + &quot;:&quot; + ex.lineNumber);</span>
<a href="#l8.628"></a><span id="l8.628">         }</span>
<a href="#l8.629"></a><span id="l8.629">       }</span>
<a href="#l8.630"></a><span id="l8.630">     }</span>
<a href="#l8.631"></a><span id="l8.631" class="difflineminus">-    </span>
<a href="#l8.632"></a><span id="l8.632" class="difflineplus">+</span>
<a href="#l8.633"></a><span id="l8.633">     return new GlodaDatabind(aTableDef, this);</span>
<a href="#l8.634"></a><span id="l8.634">   },</span>
<a href="#l8.635"></a><span id="l8.635" class="difflineminus">-  </span>
<a href="#l8.636"></a><span id="l8.636" class="difflineplus">+</span>
<a href="#l8.637"></a><span id="l8.637">   _migrate: function gloda_ds_migrate(aDBService, aDBFile, aDBConnection,</span>
<a href="#l8.638"></a><span id="l8.638">                                       aCurVersion, aNewVersion) {</span>
<a href="#l8.639"></a><span id="l8.639" class="difflineminus">-    // the 4-to-5 migration is the only possible case right now, and is so</span>
<a href="#l8.640"></a><span id="l8.640" class="difflineminus">-    //  significant that we want everything purged anyways.</span>
<a href="#l8.641"></a><span id="l8.641" class="difflineminus">-    // generalize me in the future.</span>
<a href="#l8.642"></a><span id="l8.642" class="difflineminus">-    aDBConnection.close();</span>
<a href="#l8.643"></a><span id="l8.643" class="difflineminus">-    aDBFile.remove(false);</span>
<a href="#l8.644"></a><span id="l8.644" class="difflineminus">-    this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l8.645"></a><span id="l8.645" class="difflineplus">+    // we purged our way up to version 8, so we can/must purge prior to 8.</span>
<a href="#l8.646"></a><span id="l8.646" class="difflineplus">+    if (aCurVersion &lt; 8) {</span>
<a href="#l8.647"></a><span id="l8.647" class="difflineplus">+      aDBConnection.close();</span>
<a href="#l8.648"></a><span id="l8.648" class="difflineplus">+      aDBFile.remove(false);</span>
<a href="#l8.649"></a><span id="l8.649" class="difflineplus">+      this._log.warn(&quot;Global database has been purged due to schema change.&quot;);</span>
<a href="#l8.650"></a><span id="l8.650" class="difflineplus">+      return this._createDB(aDBService, aDBFile);</span>
<a href="#l8.651"></a><span id="l8.651" class="difflineplus">+    }</span>
<a href="#l8.652"></a><span id="l8.652" class="difflineplus">+    // version 9 just adds the contactAttributes table</span>
<a href="#l8.653"></a><span id="l8.653" class="difflineplus">+    if (aCurVersion &lt; 9) {</span>
<a href="#l8.654"></a><span id="l8.654" class="difflineplus">+      this._createTableSchema(aDBConnection, &quot;contactAttributes&quot;);</span>
<a href="#l8.655"></a><span id="l8.655" class="difflineplus">+    }</span>
<a href="#l8.656"></a><span id="l8.656" class="difflineplus">+    aDBConnection.schemaVersion = aNewVersion;</span>
<a href="#l8.657"></a><span id="l8.657">     </span>
<a href="#l8.658"></a><span id="l8.658" class="difflineminus">-    return this._createDB(aDBService, aDBFile);</span>
<a href="#l8.659"></a><span id="l8.659" class="difflineplus">+    return aDBConnection;</span>
<a href="#l8.660"></a><span id="l8.660">   },</span>
<a href="#l8.661"></a><span id="l8.661" class="difflineminus">-  </span>
<a href="#l8.662"></a><span id="l8.662" class="difflineplus">+</span>
<a href="#l8.663"></a><span id="l8.663">   _outstandingAsyncStatements: [],</span>
<a href="#l8.664"></a><span id="l8.664" class="difflineminus">-  </span>
<a href="#l8.665"></a><span id="l8.665" class="difflineplus">+</span>
<a href="#l8.666"></a><span id="l8.666">   _createAsyncStatement: function gloda_ds_createAsyncStatement(aSQLString,</span>
<a href="#l8.667"></a><span id="l8.667">                                                                 aWillFinalize) {</span>
<a href="#l8.668"></a><span id="l8.668">     let statement = null;</span>
<a href="#l8.669"></a><span id="l8.669">     try {</span>
<a href="#l8.670"></a><span id="l8.670">       statement = this.asyncConnection.createStatement(aSQLString);</span>
<a href="#l8.671"></a><span id="l8.671">     }</span>
<a href="#l8.672"></a><span id="l8.672">     catch(ex) {</span>
<a href="#l8.673"></a><span id="l8.673">        throw(&quot;error creating async statement &quot; + aSQLString + &quot; - &quot; +</span>
<a href="#l8.674"></a><span id="l8.674">              this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l8.675"></a><span id="l8.675">              this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l8.676"></a><span id="l8.676">     }</span>
<a href="#l8.677"></a><span id="l8.677" class="difflineminus">-    </span>
<a href="#l8.678"></a><span id="l8.678" class="difflineplus">+</span>
<a href="#l8.679"></a><span id="l8.679">     if (!aWillFinalize)</span>
<a href="#l8.680"></a><span id="l8.680">       this._outstandingAsyncStatements.push(statement);</span>
<a href="#l8.681"></a><span id="l8.681" class="difflineminus">-    </span>
<a href="#l8.682"></a><span id="l8.682" class="difflineplus">+</span>
<a href="#l8.683"></a><span id="l8.683">     return statement;</span>
<a href="#l8.684"></a><span id="l8.684">   },</span>
<a href="#l8.685"></a><span id="l8.685" class="difflineminus">-  </span>
<a href="#l8.686"></a><span id="l8.686" class="difflineplus">+</span>
<a href="#l8.687"></a><span id="l8.687">   _cleanupAsyncStatements: function gloda_ds_cleanupAsyncStatements() {</span>
<a href="#l8.688"></a><span id="l8.688">     [stmt.finalize() for each (stmt in this._outstandingAsyncStatements)];</span>
<a href="#l8.689"></a><span id="l8.689">   },</span>
<a href="#l8.690"></a><span id="l8.690" class="difflineminus">-  </span>
<a href="#l8.691"></a><span id="l8.691" class="difflineplus">+</span>
<a href="#l8.692"></a><span id="l8.692">   _outstandingSyncStatements: [],</span>
<a href="#l8.693"></a><span id="l8.693" class="difflineminus">-  </span>
<a href="#l8.694"></a><span id="l8.694" class="difflineplus">+</span>
<a href="#l8.695"></a><span id="l8.695">   _createSyncStatement: function gloda_ds_createSyncStatement(aSQLString,</span>
<a href="#l8.696"></a><span id="l8.696">                                                               aWillFinalize) {</span>
<a href="#l8.697"></a><span id="l8.697">     let statement = null;</span>
<a href="#l8.698"></a><span id="l8.698">     try {</span>
<a href="#l8.699"></a><span id="l8.699">       statement = this.syncConnection.createStatement(aSQLString);</span>
<a href="#l8.700"></a><span id="l8.700">     }</span>
<a href="#l8.701"></a><span id="l8.701">     catch(ex) {</span>
<a href="#l8.702"></a><span id="l8.702">        throw(&quot;error creating sync statement &quot; + aSQLString + &quot; - &quot; +</span>
<a href="#l8.703"></a><span id="l8.703">              this.syncConnection.lastError + &quot;: &quot; +</span>
<a href="#l8.704"></a><span id="l8.704">              this.syncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l8.705"></a><span id="l8.705">     }</span>
<a href="#l8.706"></a><span id="l8.706"> </span>
<a href="#l8.707"></a><span id="l8.707">     if (!aWillFinalize)</span>
<a href="#l8.708"></a><span id="l8.708">       this._outstandingSyncStatements.push(statement);</span>
<a href="#l8.709"></a><span id="l8.709" class="difflineminus">-    </span>
<a href="#l8.710"></a><span id="l8.710" class="difflineplus">+</span>
<a href="#l8.711"></a><span id="l8.711">     return statement;</span>
<a href="#l8.712"></a><span id="l8.712">   },</span>
<a href="#l8.713"></a><span id="l8.713"> </span>
<a href="#l8.714"></a><span id="l8.714">   _cleanupSyncStatements: function gloda_ds_cleanupSyncStatements() {</span>
<a href="#l8.715"></a><span id="l8.715">     [stmt.finalize() for each (stmt in this._outstandingSyncStatements)];</span>
<a href="#l8.716"></a><span id="l8.716">   },</span>
<a href="#l8.717"></a><span id="l8.717" class="difflineminus">-  </span>
<a href="#l8.718"></a><span id="l8.718" class="difflineplus">+</span>
<a href="#l8.719"></a><span id="l8.719">   /**</span>
<a href="#l8.720"></a><span id="l8.720">    * Perform a synchronous executeStep on the statement, handling any</span>
<a href="#l8.721"></a><span id="l8.721">    *  SQLITE_BUSY fallout that could conceivably happen from a collision on our</span>
<a href="#l8.722"></a><span id="l8.722">    *  read with the async writes.</span>
<a href="#l8.723"></a><span id="l8.723">    * Basically we keep trying until we succeed or run out of tries.</span>
<a href="#l8.724"></a><span id="l8.724">    * We believe this to be a reasonable course of action because we don't</span>
<a href="#l8.725"></a><span id="l8.725">    *  expect this to happen much.</span>
<a href="#l8.726"></a><span id="l8.726">    */</span>
<a href="#l8.727"></a><span id="l8.727" class="difflineat">@@ -721,17 +750,17 @@ var GlodaDatastore = {</span>
<a href="#l8.728"></a><span id="l8.728">         //  dangerous and 'notxpcom' suggests it ain't happening anyways...</span>
<a href="#l8.729"></a><span id="l8.729">         // so, let's just be dumb and hope that the underlying file I/O going</span>
<a href="#l8.730"></a><span id="l8.730">         //  on makes us more likely to yield to the other thread so it can</span>
<a href="#l8.731"></a><span id="l8.731">         //  finish what it is doing...</span>
<a href="#l8.732"></a><span id="l8.732">       }</span>
<a href="#l8.733"></a><span id="l8.733">     }</span>
<a href="#l8.734"></a><span id="l8.734">     this._log.error(&quot;Synchronous step gave up after &quot; + tries + &quot; tries.&quot;);</span>
<a href="#l8.735"></a><span id="l8.735">   },</span>
<a href="#l8.736"></a><span id="l8.736" class="difflineminus">-  </span>
<a href="#l8.737"></a><span id="l8.737" class="difflineplus">+</span>
<a href="#l8.738"></a><span id="l8.738">   /**</span>
<a href="#l8.739"></a><span id="l8.739">    * Helper to bind based on the actual type of the javascript value.  Note</span>
<a href="#l8.740"></a><span id="l8.740">    *  that we always use int64 because under the hood sqlite just promotes the</span>
<a href="#l8.741"></a><span id="l8.741">    *  normal 'int' call to 'int64' anyways.</span>
<a href="#l8.742"></a><span id="l8.742">    */</span>
<a href="#l8.743"></a><span id="l8.743">   _bindVariant: function gloda_ds_bindBlob(aStatement, aIndex, aVariant) {</span>
<a href="#l8.744"></a><span id="l8.744">     if (aVariant == null) // catch both null and undefined</span>
<a href="#l8.745"></a><span id="l8.745">       aStatement.bindNullParameter(aIndex);</span>
<a href="#l8.746"></a><span id="l8.746" class="difflineat">@@ -743,57 +772,57 @@ var GlodaDatastore = {</span>
<a href="#l8.747"></a><span id="l8.747">         aStatement.bindInt64Parameter(aIndex, aVariant);</span>
<a href="#l8.748"></a><span id="l8.748">       else</span>
<a href="#l8.749"></a><span id="l8.749">         aStatement.bindDoubleParameter(aIndex, aVariant);</span>
<a href="#l8.750"></a><span id="l8.750">     }</span>
<a href="#l8.751"></a><span id="l8.751">     else</span>
<a href="#l8.752"></a><span id="l8.752">       throw(&quot;Attempt to bind variant with unsupported type: &quot; +</span>
<a href="#l8.753"></a><span id="l8.753">             (typeof aVariant));</span>
<a href="#l8.754"></a><span id="l8.754">   },</span>
<a href="#l8.755"></a><span id="l8.755" class="difflineminus">-  </span>
<a href="#l8.756"></a><span id="l8.756" class="difflineplus">+</span>
<a href="#l8.757"></a><span id="l8.757">   _getVariant: function gloda_ds_getBlob(aRow, aIndex) {</span>
<a href="#l8.758"></a><span id="l8.758">     let typeOfIndex = aRow.getTypeOfIndex(aIndex);</span>
<a href="#l8.759"></a><span id="l8.759">     if (typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l8.760"></a><span id="l8.760">       return null;</span>
<a href="#l8.761"></a><span id="l8.761">     // XPConnect would just end up going through an intermediary double stage</span>
<a href="#l8.762"></a><span id="l8.762">     //  for the int64 case anyways...</span>
<a href="#l8.763"></a><span id="l8.763">     else if (typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_INTEGER ||</span>
<a href="#l8.764"></a><span id="l8.764">              typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_DOUBLE)</span>
<a href="#l8.765"></a><span id="l8.765">       return aRow.getDouble(aIndex);</span>
<a href="#l8.766"></a><span id="l8.766">     else // typeOfIndex == Ci.mozIStorageValueArray.VALUE_TYPE_TEXT</span>
<a href="#l8.767"></a><span id="l8.767">       return aRow.getString(aIndex);</span>
<a href="#l8.768"></a><span id="l8.768">   },</span>
<a href="#l8.769"></a><span id="l8.769"> </span>
<a href="#l8.770"></a><span id="l8.770" class="difflineminus">-  /** Simple nested transaction support as a performance optimization. */  </span>
<a href="#l8.771"></a><span id="l8.771" class="difflineplus">+  /** Simple nested transaction support as a performance optimization. */</span>
<a href="#l8.772"></a><span id="l8.772">   _transactionDepth: 0,</span>
<a href="#l8.773"></a><span id="l8.773">   _transactionGood: false,</span>
<a href="#l8.774"></a><span id="l8.774" class="difflineminus">-  </span>
<a href="#l8.775"></a><span id="l8.775" class="difflineplus">+</span>
<a href="#l8.776"></a><span id="l8.776">   get _beginTransactionStatement() {</span>
<a href="#l8.777"></a><span id="l8.777">     let statement = this._createAsyncStatement(&quot;BEGIN TRANSACTION&quot;);</span>
<a href="#l8.778"></a><span id="l8.778">     this.__defineGetter__(&quot;_beginTransactionStatement&quot;, function() statement);</span>
<a href="#l8.779"></a><span id="l8.779" class="difflineminus">-    return this._beginTransactionStatement; </span>
<a href="#l8.780"></a><span id="l8.780" class="difflineplus">+    return this._beginTransactionStatement;</span>
<a href="#l8.781"></a><span id="l8.781">   },</span>
<a href="#l8.782"></a><span id="l8.782"> </span>
<a href="#l8.783"></a><span id="l8.783">   get _commitTransactionStatement() {</span>
<a href="#l8.784"></a><span id="l8.784">     let statement = this._createAsyncStatement(&quot;COMMIT&quot;);</span>
<a href="#l8.785"></a><span id="l8.785">     this.__defineGetter__(&quot;_commitTransactionStatement&quot;, function() statement);</span>
<a href="#l8.786"></a><span id="l8.786" class="difflineminus">-    return this._commitTransactionStatement; </span>
<a href="#l8.787"></a><span id="l8.787" class="difflineplus">+    return this._commitTransactionStatement;</span>
<a href="#l8.788"></a><span id="l8.788">   },</span>
<a href="#l8.789"></a><span id="l8.789"> </span>
<a href="#l8.790"></a><span id="l8.790">   get _rollbackTransactionStatement() {</span>
<a href="#l8.791"></a><span id="l8.791">     let statement = this._createAsyncStatement(&quot;ROLLBACK&quot;);</span>
<a href="#l8.792"></a><span id="l8.792">     this.__defineGetter__(&quot;_rollbackTransactionStatement&quot;, function() statement);</span>
<a href="#l8.793"></a><span id="l8.793" class="difflineminus">-    return this._rollbackTransactionStatement; </span>
<a href="#l8.794"></a><span id="l8.794" class="difflineplus">+    return this._rollbackTransactionStatement;</span>
<a href="#l8.795"></a><span id="l8.795">   },</span>
<a href="#l8.796"></a><span id="l8.796" class="difflineminus">-  </span>
<a href="#l8.797"></a><span id="l8.797" class="difflineplus">+</span>
<a href="#l8.798"></a><span id="l8.798">   /**</span>
<a href="#l8.799"></a><span id="l8.799">    * Begin a potentially nested transaction; only the outermost transaction gets</span>
<a href="#l8.800"></a><span id="l8.800">    *  to be an actual transaction, and the failure of any nested transaction</span>
<a href="#l8.801"></a><span id="l8.801">    *  results in a rollback of the entire outer transaction.  If you really</span>
<a href="#l8.802"></a><span id="l8.802" class="difflineminus">-   *  need an atomic transaction </span>
<a href="#l8.803"></a><span id="l8.803" class="difflineplus">+   *  need an atomic transaction</span>
<a href="#l8.804"></a><span id="l8.804">    */</span>
<a href="#l8.805"></a><span id="l8.805">   _beginTransaction: function gloda_ds_beginTransaction() {</span>
<a href="#l8.806"></a><span id="l8.806">     if (this._transactionDepth == 0) {</span>
<a href="#l8.807"></a><span id="l8.807">       this._beginTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l8.808"></a><span id="l8.808">       this._transactionGood = true;</span>
<a href="#l8.809"></a><span id="l8.809">     }</span>
<a href="#l8.810"></a><span id="l8.810">     this._transactionDepth++;</span>
<a href="#l8.811"></a><span id="l8.811">   },</span>
<a href="#l8.812"></a><span id="l8.812" class="difflineat">@@ -828,17 +857,17 @@ var GlodaDatastore = {</span>
<a href="#l8.813"></a><span id="l8.813">       try {</span>
<a href="#l8.814"></a><span id="l8.814">         this._rollbackTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l8.815"></a><span id="l8.815">       }</span>
<a href="#l8.816"></a><span id="l8.816">       catch (ex) {</span>
<a href="#l8.817"></a><span id="l8.817">         this._log.error(&quot;Rollback problem: &quot; + ex);</span>
<a href="#l8.818"></a><span id="l8.818">       }</span>
<a href="#l8.819"></a><span id="l8.819">     }</span>
<a href="#l8.820"></a><span id="l8.820">   },</span>
<a href="#l8.821"></a><span id="l8.821" class="difflineminus">-  </span>
<a href="#l8.822"></a><span id="l8.822" class="difflineplus">+</span>
<a href="#l8.823"></a><span id="l8.823">   _pendingAsyncStatements: 0,</span>
<a href="#l8.824"></a><span id="l8.824">   /**</span>
<a href="#l8.825"></a><span id="l8.825">    * The function to call, if any, when we hit 0 pending async statements.</span>
<a href="#l8.826"></a><span id="l8.826">    */</span>
<a href="#l8.827"></a><span id="l8.827">   _pendingAsyncCompletedListener: null,</span>
<a href="#l8.828"></a><span id="l8.828">   _asyncCompleted: function () {</span>
<a href="#l8.829"></a><span id="l8.829">     if (--this._pendingAsyncStatements == 0) {</span>
<a href="#l8.830"></a><span id="l8.830">       if (this._pendingAsyncCompletedListener !== null) {</span>
<a href="#l8.831"></a><span id="l8.831" class="difflineat">@@ -858,100 +887,100 @@ var GlodaDatastore = {</span>
<a href="#l8.832"></a><span id="l8.832">   /**</span>
<a href="#l8.833"></a><span id="l8.833">    * Increments _pendingAsyncStatements and returns a listener that will</span>
<a href="#l8.834"></a><span id="l8.834">    *  decrement the value when the statement completes.</span>
<a href="#l8.835"></a><span id="l8.835">    */</span>
<a href="#l8.836"></a><span id="l8.836">   trackAsync: function() {</span>
<a href="#l8.837"></a><span id="l8.837">     this._pendingAsyncStatements++;</span>
<a href="#l8.838"></a><span id="l8.838">     return this._asyncTrackerListener;</span>
<a href="#l8.839"></a><span id="l8.839">   },</span>
<a href="#l8.840"></a><span id="l8.840" class="difflineminus">-  </span>
<a href="#l8.841"></a><span id="l8.841" class="difflineplus">+</span>
<a href="#l8.842"></a><span id="l8.842">   /* ********** Attribute Definitions ********** */</span>
<a href="#l8.843"></a><span id="l8.843">   /** Maps (attribute def) compound names to the GlodaAttributeDef objects. */</span>
<a href="#l8.844"></a><span id="l8.844">   _attributes: {},</span>
<a href="#l8.845"></a><span id="l8.845">   /** Map attribute ID to the definition and parameter value that produce it. */</span>
<a href="#l8.846"></a><span id="l8.846">   _attributeIDToDef: {},</span>
<a href="#l8.847"></a><span id="l8.847">   /**</span>
<a href="#l8.848"></a><span id="l8.848">    * We maintain the attributeDefinitions next id counter mainly because we can.</span>
<a href="#l8.849"></a><span id="l8.849">    *  Since we mediate the access, there's no real risk to doing so, and it</span>
<a href="#l8.850"></a><span id="l8.850">    *  allows us to keep the writes on the async connection without having to</span>
<a href="#l8.851"></a><span id="l8.851">    *  wait for a completion notification.</span>
<a href="#l8.852"></a><span id="l8.852">    */</span>
<a href="#l8.853"></a><span id="l8.853">   _nextAttributeId: 1,</span>
<a href="#l8.854"></a><span id="l8.854" class="difflineminus">-  </span>
<a href="#l8.855"></a><span id="l8.855" class="difflineplus">+</span>
<a href="#l8.856"></a><span id="l8.856">   _populateAttributeDefManagedId: function () {</span>
<a href="#l8.857"></a><span id="l8.857">     let stmt = this._createSyncStatement(</span>
<a href="#l8.858"></a><span id="l8.858">       &quot;SELECT MAX(id) FROM attributeDefinitions&quot;, true);</span>
<a href="#l8.859"></a><span id="l8.859">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l8.860"></a><span id="l8.860">       this._nextAttributeId = stmt.getInt64(0) + 1;</span>
<a href="#l8.861"></a><span id="l8.861">     }</span>
<a href="#l8.862"></a><span id="l8.862">     stmt.finalize();</span>
<a href="#l8.863"></a><span id="l8.863">   },</span>
<a href="#l8.864"></a><span id="l8.864" class="difflineminus">-  </span>
<a href="#l8.865"></a><span id="l8.865" class="difflineplus">+</span>
<a href="#l8.866"></a><span id="l8.866">   get _insertAttributeDefStatement() {</span>
<a href="#l8.867"></a><span id="l8.867">     let statement = this._createAsyncStatement(</span>
<a href="#l8.868"></a><span id="l8.868">       &quot;INSERT INTO attributeDefinitions (id, attributeType, extensionName, \</span>
<a href="#l8.869"></a><span id="l8.869">                                   name, parameter) \</span>
<a href="#l8.870"></a><span id="l8.870">               VALUES (?1, ?2, ?3, ?4, ?5)&quot;);</span>
<a href="#l8.871"></a><span id="l8.871">     this.__defineGetter__(&quot;_insertAttributeDefStatement&quot;, function() statement);</span>
<a href="#l8.872"></a><span id="l8.872" class="difflineminus">-    return this._insertAttributeDefStatement; </span>
<a href="#l8.873"></a><span id="l8.873" class="difflineplus">+    return this._insertAttributeDefStatement;</span>
<a href="#l8.874"></a><span id="l8.874">   },</span>
<a href="#l8.875"></a><span id="l8.875"> </span>
<a href="#l8.876"></a><span id="l8.876">   /**</span>
<a href="#l8.877"></a><span id="l8.877">    * Create an attribute definition and return the row ID.  Special/atypical</span>
<a href="#l8.878"></a><span id="l8.878">    *  in that it doesn't directly return a GlodaAttributeDef; we leave that up</span>
<a href="#l8.879"></a><span id="l8.879">    *  to the caller since they know much more than actually needs to go in the</span>
<a href="#l8.880"></a><span id="l8.880">    *  database.</span>
<a href="#l8.881"></a><span id="l8.881">    *</span>
<a href="#l8.882"></a><span id="l8.882">    * @return The attribute id allocated to this attribute.</span>
<a href="#l8.883"></a><span id="l8.883">    */</span>
<a href="#l8.884"></a><span id="l8.884">   _createAttributeDef: function gloda_ds_createAttributeDef(aAttrType,</span>
<a href="#l8.885"></a><span id="l8.885">                                     aExtensionName, aAttrName, aParameter) {</span>
<a href="#l8.886"></a><span id="l8.886">     let attributeId = this._nextAttributeId++;</span>
<a href="#l8.887"></a><span id="l8.887" class="difflineminus">-                                    </span>
<a href="#l8.888"></a><span id="l8.888" class="difflineplus">+</span>
<a href="#l8.889"></a><span id="l8.889">     let iads = this._insertAttributeDefStatement;</span>
<a href="#l8.890"></a><span id="l8.890">     iads.bindInt64Parameter(0, attributeId);</span>
<a href="#l8.891"></a><span id="l8.891">     iads.bindInt64Parameter(1, aAttrType);</span>
<a href="#l8.892"></a><span id="l8.892">     iads.bindStringParameter(2, aExtensionName);</span>
<a href="#l8.893"></a><span id="l8.893">     iads.bindStringParameter(3, aAttrName);</span>
<a href="#l8.894"></a><span id="l8.894">     this._bindVariant(iads, 4, aParameter);</span>
<a href="#l8.895"></a><span id="l8.895" class="difflineminus">-    </span>
<a href="#l8.896"></a><span id="l8.896" class="difflineplus">+</span>
<a href="#l8.897"></a><span id="l8.897">     iads.executeAsync(this.trackAsync());</span>
<a href="#l8.898"></a><span id="l8.898" class="difflineminus">-    </span>
<a href="#l8.899"></a><span id="l8.899" class="difflineplus">+</span>
<a href="#l8.900"></a><span id="l8.900">     return attributeId;</span>
<a href="#l8.901"></a><span id="l8.901">   },</span>
<a href="#l8.902"></a><span id="l8.902" class="difflineminus">-  </span>
<a href="#l8.903"></a><span id="l8.903" class="difflineplus">+</span>
<a href="#l8.904"></a><span id="l8.904">   /**</span>
<a href="#l8.905"></a><span id="l8.905" class="difflineminus">-   * Sync-ly look-up all the attribute definitions, populating our authoritative </span>
<a href="#l8.906"></a><span id="l8.906" class="difflineplus">+   * Sync-ly look-up all the attribute definitions, populating our authoritative</span>
<a href="#l8.907"></a><span id="l8.907">    *  _attributes and _attributeIDToDef maps.  (In other words, once this method</span>
<a href="#l8.908"></a><span id="l8.908">    *  is called, those maps should always be in sync with the underlying</span>
<a href="#l8.909"></a><span id="l8.909">    *  database.)</span>
<a href="#l8.910"></a><span id="l8.910">    */</span>
<a href="#l8.911"></a><span id="l8.911">   getAllAttributes: function gloda_ds_getAllAttributes() {</span>
<a href="#l8.912"></a><span id="l8.912">     let stmt = this._createSyncStatement(</span>
<a href="#l8.913"></a><span id="l8.913">       &quot;SELECT id, attributeType, extensionName, name, parameter \</span>
<a href="#l8.914"></a><span id="l8.914">          FROM attributeDefinitions&quot;, true);</span>
<a href="#l8.915"></a><span id="l8.915"> </span>
<a href="#l8.916"></a><span id="l8.916">     // map compound name to the attribute</span>
<a href="#l8.917"></a><span id="l8.917">     let attribs = {};</span>
<a href="#l8.918"></a><span id="l8.918">     // map the attribute id to [attribute, parameter] where parameter is null</span>
<a href="#l8.919"></a><span id="l8.919">     //  in cases where parameter is unused.</span>
<a href="#l8.920"></a><span id="l8.920">     let idToAttribAndParam = {}</span>
<a href="#l8.921"></a><span id="l8.921"> </span>
<a href="#l8.922"></a><span id="l8.922">     this._log.info(&quot;loading all attribute defs&quot;);</span>
<a href="#l8.923"></a><span id="l8.923" class="difflineminus">-    </span>
<a href="#l8.924"></a><span id="l8.924" class="difflineplus">+</span>
<a href="#l8.925"></a><span id="l8.925">     while (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l8.926"></a><span id="l8.926">       let rowId = stmt.getInt64(0);</span>
<a href="#l8.927"></a><span id="l8.927">       let rowAttributeType = stmt.getInt64(1);</span>
<a href="#l8.928"></a><span id="l8.928">       let rowExtensionName = stmt.getString(2);</span>
<a href="#l8.929"></a><span id="l8.929">       let rowName = stmt.getString(3);</span>
<a href="#l8.930"></a><span id="l8.930" class="difflineminus">-      let rowParameter = this._getVariant(stmt, 4); </span>
<a href="#l8.931"></a><span id="l8.931" class="difflineminus">-      </span>
<a href="#l8.932"></a><span id="l8.932" class="difflineplus">+      let rowParameter = this._getVariant(stmt, 4);</span>
<a href="#l8.933"></a><span id="l8.933" class="difflineplus">+</span>
<a href="#l8.934"></a><span id="l8.934">       let compoundName = rowExtensionName + &quot;:&quot; + rowName;</span>
<a href="#l8.935"></a><span id="l8.935" class="difflineminus">-      </span>
<a href="#l8.936"></a><span id="l8.936" class="difflineplus">+</span>
<a href="#l8.937"></a><span id="l8.937">       let attrib;</span>
<a href="#l8.938"></a><span id="l8.938">       if (compoundName in attribs) {</span>
<a href="#l8.939"></a><span id="l8.939">         attrib = attribs[compoundName];</span>
<a href="#l8.940"></a><span id="l8.940">       } else {</span>
<a href="#l8.941"></a><span id="l8.941">         attrib = new GlodaAttributeDef(this, null,</span>
<a href="#l8.942"></a><span id="l8.942">                                        compoundName, null, rowAttributeType,</span>
<a href="#l8.943"></a><span id="l8.943">                                        rowExtensionName, rowName,</span>
<a href="#l8.944"></a><span id="l8.944">                                        null, null, null, null);</span>
<a href="#l8.945"></a><span id="l8.945" class="difflineat">@@ -965,307 +994,307 @@ var GlodaDatastore = {</span>
<a href="#l8.946"></a><span id="l8.946">       } else {</span>
<a href="#l8.947"></a><span id="l8.947">         attrib._parameterBindings[rowParameter] = rowId;</span>
<a href="#l8.948"></a><span id="l8.948">         idToAttribAndParam[rowId] = [attrib, rowParameter];</span>
<a href="#l8.949"></a><span id="l8.949">       }</span>
<a href="#l8.950"></a><span id="l8.950">     }</span>
<a href="#l8.951"></a><span id="l8.951">     stmt.finalize();</span>
<a href="#l8.952"></a><span id="l8.952"> </span>
<a href="#l8.953"></a><span id="l8.953">     this._log.info(&quot;done loading all attribute defs&quot;);</span>
<a href="#l8.954"></a><span id="l8.954" class="difflineminus">-    </span>
<a href="#l8.955"></a><span id="l8.955" class="difflineplus">+</span>
<a href="#l8.956"></a><span id="l8.956">     this._attributes = attribs;</span>
<a href="#l8.957"></a><span id="l8.957">     this._attributeIDToDef = idToAttribAndParam;</span>
<a href="#l8.958"></a><span id="l8.958">   },</span>
<a href="#l8.959"></a><span id="l8.959" class="difflineminus">-  </span>
<a href="#l8.960"></a><span id="l8.960" class="difflineplus">+</span>
<a href="#l8.961"></a><span id="l8.961">   /**</span>
<a href="#l8.962"></a><span id="l8.962">    * Helper method for GlodaAttributeDef to tell us when their bindParameter</span>
<a href="#l8.963"></a><span id="l8.963">    *  method is called and they have created a new binding (using</span>
<a href="#l8.964"></a><span id="l8.964">    *  GlodaDatastore._createAttributeDef).  In theory, that method could take</span>
<a href="#l8.965"></a><span id="l8.965">    *  an additional argument and obviate the need for this method.</span>
<a href="#l8.966"></a><span id="l8.966">    */</span>
<a href="#l8.967"></a><span id="l8.967">   reportBinding: function gloda_ds_reportBinding(aID, aAttrDef, aParamValue) {</span>
<a href="#l8.968"></a><span id="l8.968">     this._attributeIDToDef[aID] = [aAttrDef, aParamValue];</span>
<a href="#l8.969"></a><span id="l8.969">   },</span>
<a href="#l8.970"></a><span id="l8.970" class="difflineminus">-  </span>
<a href="#l8.971"></a><span id="l8.971" class="difflineplus">+</span>
<a href="#l8.972"></a><span id="l8.972">   /* ********** Folders ********** */</span>
<a href="#l8.973"></a><span id="l8.973">   /** next folder (row) id to issue, populated by _getAllFolderMappings. */</span>
<a href="#l8.974"></a><span id="l8.974">   _nextFolderId: 1,</span>
<a href="#l8.975"></a><span id="l8.975" class="difflineminus">-  </span>
<a href="#l8.976"></a><span id="l8.976" class="difflineplus">+</span>
<a href="#l8.977"></a><span id="l8.977">   get _insertFolderLocationStatement() {</span>
<a href="#l8.978"></a><span id="l8.978">     let statement = this._createAsyncStatement(</span>
<a href="#l8.979"></a><span id="l8.979">       &quot;INSERT INTO folderLocations (id, folderURI) VALUES (?1, ?2)&quot;);</span>
<a href="#l8.980"></a><span id="l8.980">     this.__defineGetter__(&quot;_insertFolderLocationStatement&quot;,</span>
<a href="#l8.981"></a><span id="l8.981">       function() statement);</span>
<a href="#l8.982"></a><span id="l8.982">     return this._insertFolderLocationStatement;</span>
<a href="#l8.983"></a><span id="l8.983">   },</span>
<a href="#l8.984"></a><span id="l8.984" class="difflineminus">-  </span>
<a href="#l8.985"></a><span id="l8.985" class="difflineplus">+</span>
<a href="#l8.986"></a><span id="l8.986">   /**</span>
<a href="#l8.987"></a><span id="l8.987">    * Authoritative map from folder URI to folder ID.  (Authoritative in the</span>
<a href="#l8.988"></a><span id="l8.988">    *  sense that this map exactly represents the state of the underlying</span>
<a href="#l8.989"></a><span id="l8.989">    *  database.  If it does not, it's a bug in updating the database.)</span>
<a href="#l8.990"></a><span id="l8.990">    */</span>
<a href="#l8.991"></a><span id="l8.991">   _folderURIs: {},</span>
<a href="#l8.992"></a><span id="l8.992">   /** Authoritative map from folder ID to folder URI */</span>
<a href="#l8.993"></a><span id="l8.993">   _folderIDs: {},</span>
<a href="#l8.994"></a><span id="l8.994" class="difflineminus">-  </span>
<a href="#l8.995"></a><span id="l8.995" class="difflineplus">+</span>
<a href="#l8.996"></a><span id="l8.996">   /** Intialize our _folderURIs/_folderIDs mappings, called by _init(). */</span>
<a href="#l8.997"></a><span id="l8.997">   _getAllFolderMappings: function gloda_ds_getAllFolderMappings() {</span>
<a href="#l8.998"></a><span id="l8.998">     let stmt = this._createSyncStatement(</span>
<a href="#l8.999"></a><span id="l8.999">       &quot;SELECT id, folderURI FROM folderLocations&quot;, true);</span>
<a href="#l8.1000"></a><span id="l8.1000"> </span>
<a href="#l8.1001"></a><span id="l8.1001">     while (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l8.1002"></a><span id="l8.1002">       let folderID = stmt.getInt64(0);</span>
<a href="#l8.1003"></a><span id="l8.1003">       let folderURI = stmt.getString(1);</span>
<a href="#l8.1004"></a><span id="l8.1004">       this._folderURIs[folderURI] = folderID;</span>
<a href="#l8.1005"></a><span id="l8.1005">       this._folderIDs[folderID] = folderURI;</span>
<a href="#l8.1006"></a><span id="l8.1006" class="difflineminus">-      </span>
<a href="#l8.1007"></a><span id="l8.1007" class="difflineplus">+</span>
<a href="#l8.1008"></a><span id="l8.1008">       if (folderID + 1 &gt; this._nextFolderId)</span>
<a href="#l8.1009"></a><span id="l8.1009">         this._nextFolderId = folderID + 1;</span>
<a href="#l8.1010"></a><span id="l8.1010">     }</span>
<a href="#l8.1011"></a><span id="l8.1011">     stmt.finalize();</span>
<a href="#l8.1012"></a><span id="l8.1012">   },</span>
<a href="#l8.1013"></a><span id="l8.1013" class="difflineminus">-  </span>
<a href="#l8.1014"></a><span id="l8.1014" class="difflineplus">+</span>
<a href="#l8.1015"></a><span id="l8.1015">   _folderURIKnown: function gloda_ds_folderURIKnown(aFolderURI) {</span>
<a href="#l8.1016"></a><span id="l8.1016">     return aFolderURI in this._folderURIs;</span>
<a href="#l8.1017"></a><span id="l8.1017">   },</span>
<a href="#l8.1018"></a><span id="l8.1018" class="difflineminus">-  </span>
<a href="#l8.1019"></a><span id="l8.1019" class="difflineplus">+</span>
<a href="#l8.1020"></a><span id="l8.1020">   /**</span>
<a href="#l8.1021"></a><span id="l8.1021">    * Map a folder URI to a folder ID, creating the mapping if it does not yet</span>
<a href="#l8.1022"></a><span id="l8.1022">    *  exist.</span>
<a href="#l8.1023"></a><span id="l8.1023">    */</span>
<a href="#l8.1024"></a><span id="l8.1024">   _mapFolderURI: function gloda_ds_mapFolderURI(aFolderURI) {</span>
<a href="#l8.1025"></a><span id="l8.1025">     if (aFolderURI in this._folderURIs) {</span>
<a href="#l8.1026"></a><span id="l8.1026">       return this._folderURIs[aFolderURI];</span>
<a href="#l8.1027"></a><span id="l8.1027">     }</span>
<a href="#l8.1028"></a><span id="l8.1028" class="difflineminus">-    </span>
<a href="#l8.1029"></a><span id="l8.1029" class="difflineplus">+</span>
<a href="#l8.1030"></a><span id="l8.1030">     let folderID = this._nextFolderId++;</span>
<a href="#l8.1031"></a><span id="l8.1031">     this._insertFolderLocationStatement.bindInt64Parameter(0, folderID)</span>
<a href="#l8.1032"></a><span id="l8.1032">     this._insertFolderLocationStatement.bindStringParameter(1, aFolderURI);</span>
<a href="#l8.1033"></a><span id="l8.1033">     this._insertFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l8.1034"></a><span id="l8.1034"> </span>
<a href="#l8.1035"></a><span id="l8.1035">     this._folderURIs[aFolderURI] = folderID;</span>
<a href="#l8.1036"></a><span id="l8.1036">     this._folderIDs[folderID] = aFolderURI;</span>
<a href="#l8.1037"></a><span id="l8.1037">     this._log.info(&quot;mapping URI &quot; + aFolderURI + &quot; to &quot; + folderID);</span>
<a href="#l8.1038"></a><span id="l8.1038">     return folderID;</span>
<a href="#l8.1039"></a><span id="l8.1039">   },</span>
<a href="#l8.1040"></a><span id="l8.1040" class="difflineminus">-  </span>
<a href="#l8.1041"></a><span id="l8.1041" class="difflineplus">+</span>
<a href="#l8.1042"></a><span id="l8.1042">   _mapFolderID: function gloda_ds_mapFolderID(aFolderID) {</span>
<a href="#l8.1043"></a><span id="l8.1043">     if (aFolderID === null)</span>
<a href="#l8.1044"></a><span id="l8.1044">       return null;</span>
<a href="#l8.1045"></a><span id="l8.1045">     if (aFolderID in this._folderIDs)</span>
<a href="#l8.1046"></a><span id="l8.1046">       return this._folderIDs[aFolderID];</span>
<a href="#l8.1047"></a><span id="l8.1047">     throw &quot;Got impossible folder ID: &quot; + aFolderID;</span>
<a href="#l8.1048"></a><span id="l8.1048">   },</span>
<a href="#l8.1049"></a><span id="l8.1049"> </span>
<a href="#l8.1050"></a><span id="l8.1050">   get _updateFolderLocationStatement() {</span>
<a href="#l8.1051"></a><span id="l8.1051">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1052"></a><span id="l8.1052">       &quot;UPDATE folderLocations SET folderURI = ?1 \</span>
<a href="#l8.1053"></a><span id="l8.1053">               WHERE folderURI = ?2&quot;);</span>
<a href="#l8.1054"></a><span id="l8.1054">     this.__defineGetter__(&quot;_updateFolderLocationStatement&quot;,</span>
<a href="#l8.1055"></a><span id="l8.1055">       function() statement);</span>
<a href="#l8.1056"></a><span id="l8.1056">     return this._updateFolderLocationStatement;</span>
<a href="#l8.1057"></a><span id="l8.1057">   },</span>
<a href="#l8.1058"></a><span id="l8.1058" class="difflineminus">-  </span>
<a href="#l8.1059"></a><span id="l8.1059" class="difflineplus">+</span>
<a href="#l8.1060"></a><span id="l8.1060">   /**</span>
<a href="#l8.1061"></a><span id="l8.1061">    * Non-recursive asynchronous folder renaming based on the URI.</span>
<a href="#l8.1062"></a><span id="l8.1062">    *</span>
<a href="#l8.1063"></a><span id="l8.1063">    * @TODO provide a mechanism for recursive folder renames or have a higher</span>
<a href="#l8.1064"></a><span id="l8.1064">    *     layer deal with it and remove this note.</span>
<a href="#l8.1065"></a><span id="l8.1065">    */</span>
<a href="#l8.1066"></a><span id="l8.1066">   renameFolder: function gloda_ds_renameFolder(aOldURI, aNewURI) {</span>
<a href="#l8.1067"></a><span id="l8.1067">     let folderID = this._mapFolderURI(aOldURI); // ensure the URI is mapped...</span>
<a href="#l8.1068"></a><span id="l8.1068">     this._folderURIs[aNewURI] = folderID;</span>
<a href="#l8.1069"></a><span id="l8.1069">     this._folderIDs[folderID] = aNewURI;</span>
<a href="#l8.1070"></a><span id="l8.1070">     this._log.info(&quot;renaming folder URI &quot; + aOldURI + &quot; to &quot; + aNewURI);</span>
<a href="#l8.1071"></a><span id="l8.1071">     this._updateFolderLocationStatement.bindStringParameter(1, aOldURI);</span>
<a href="#l8.1072"></a><span id="l8.1072">     this._updateFolderLocationStatement.bindStringParameter(0, aNewURI);</span>
<a href="#l8.1073"></a><span id="l8.1073">     this._updateFolderLocationStatement.executeAsync(this.trackAsync());</span>
<a href="#l8.1074"></a><span id="l8.1074">     delete this._folderURIs[aOldURI];</span>
<a href="#l8.1075"></a><span id="l8.1075">   },</span>
<a href="#l8.1076"></a><span id="l8.1076" class="difflineminus">-  </span>
<a href="#l8.1077"></a><span id="l8.1077" class="difflineplus">+</span>
<a href="#l8.1078"></a><span id="l8.1078">   get _deleteFolderByIDStatement() {</span>
<a href="#l8.1079"></a><span id="l8.1079">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1080"></a><span id="l8.1080">       &quot;DELETE FROM folderLocations WHERE id = ?1&quot;);</span>
<a href="#l8.1081"></a><span id="l8.1081">     this.__defineGetter__(&quot;_deleteFolderByIDStatement&quot;,</span>
<a href="#l8.1082"></a><span id="l8.1082">       function() statement);</span>
<a href="#l8.1083"></a><span id="l8.1083">     return this._deleteFolderByIDStatement;</span>
<a href="#l8.1084"></a><span id="l8.1084">   },</span>
<a href="#l8.1085"></a><span id="l8.1085" class="difflineminus">-  </span>
<a href="#l8.1086"></a><span id="l8.1086" class="difflineplus">+</span>
<a href="#l8.1087"></a><span id="l8.1087">   deleteFolderByID: function gloda_ds_deleteFolder(aFolderID) {</span>
<a href="#l8.1088"></a><span id="l8.1088">     let dfbis = this._deleteFolderByIDStatement;</span>
<a href="#l8.1089"></a><span id="l8.1089">     dfbis.bindInt64Parameter(0, aFolderID);</span>
<a href="#l8.1090"></a><span id="l8.1090">     dfbis.executeAsync(this.trackAsync());</span>
<a href="#l8.1091"></a><span id="l8.1091">   },</span>
<a href="#l8.1092"></a><span id="l8.1092" class="difflineminus">-  </span>
<a href="#l8.1093"></a><span id="l8.1093" class="difflineplus">+</span>
<a href="#l8.1094"></a><span id="l8.1094">   /* ********** Conversation ********** */</span>
<a href="#l8.1095"></a><span id="l8.1095">   /** The next conversation id to allocate.  Initialize at startup. */</span>
<a href="#l8.1096"></a><span id="l8.1096">   _nextConversationId: 1,</span>
<a href="#l8.1097"></a><span id="l8.1097" class="difflineminus">-  </span>
<a href="#l8.1098"></a><span id="l8.1098" class="difflineplus">+</span>
<a href="#l8.1099"></a><span id="l8.1099">   _populateConversationManagedId: function () {</span>
<a href="#l8.1100"></a><span id="l8.1100">     let stmt = this._createSyncStatement(</span>
<a href="#l8.1101"></a><span id="l8.1101">       &quot;SELECT MAX(id) FROM conversations&quot;, true);</span>
<a href="#l8.1102"></a><span id="l8.1102">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l8.1103"></a><span id="l8.1103">       this._nextConversationId = stmt.getInt64(0) + 1;</span>
<a href="#l8.1104"></a><span id="l8.1104">     }</span>
<a href="#l8.1105"></a><span id="l8.1105">     stmt.finalize();</span>
<a href="#l8.1106"></a><span id="l8.1106">   },</span>
<a href="#l8.1107"></a><span id="l8.1107" class="difflineminus">-  </span>
<a href="#l8.1108"></a><span id="l8.1108" class="difflineplus">+</span>
<a href="#l8.1109"></a><span id="l8.1109">   get _insertConversationStatement() {</span>
<a href="#l8.1110"></a><span id="l8.1110">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1111"></a><span id="l8.1111">       &quot;INSERT INTO conversations (id, subject, oldestMessageDate, \</span>
<a href="#l8.1112"></a><span id="l8.1112">                                   newestMessageDate) \</span>
<a href="#l8.1113"></a><span id="l8.1113">               VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l8.1114"></a><span id="l8.1114">     this.__defineGetter__(&quot;_insertConversationStatement&quot;, function() statement);</span>
<a href="#l8.1115"></a><span id="l8.1115" class="difflineminus">-    return this._insertConversationStatement; </span>
<a href="#l8.1116"></a><span id="l8.1116" class="difflineminus">-  }, </span>
<a href="#l8.1117"></a><span id="l8.1117" class="difflineplus">+    return this._insertConversationStatement;</span>
<a href="#l8.1118"></a><span id="l8.1118" class="difflineplus">+  },</span>
<a href="#l8.1119"></a><span id="l8.1119"> </span>
<a href="#l8.1120"></a><span id="l8.1120">   get _insertConversationTextStatement() {</span>
<a href="#l8.1121"></a><span id="l8.1121">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1122"></a><span id="l8.1122">       &quot;INSERT INTO conversationsText (docid, subject) \</span>
<a href="#l8.1123"></a><span id="l8.1123">               VALUES (?1, ?2)&quot;);</span>
<a href="#l8.1124"></a><span id="l8.1124">     this.__defineGetter__(&quot;_insertConversationTextStatement&quot;,</span>
<a href="#l8.1125"></a><span id="l8.1125">       function() statement);</span>
<a href="#l8.1126"></a><span id="l8.1126" class="difflineminus">-    return this._insertConversationTextStatement; </span>
<a href="#l8.1127"></a><span id="l8.1127" class="difflineminus">-  }, </span>
<a href="#l8.1128"></a><span id="l8.1128" class="difflineminus">-  </span>
<a href="#l8.1129"></a><span id="l8.1129" class="difflineplus">+    return this._insertConversationTextStatement;</span>
<a href="#l8.1130"></a><span id="l8.1130" class="difflineplus">+  },</span>
<a href="#l8.1131"></a><span id="l8.1131" class="difflineplus">+</span>
<a href="#l8.1132"></a><span id="l8.1132">   /**</span>
<a href="#l8.1133"></a><span id="l8.1133">    * Asynchronously create a conversation.</span>
<a href="#l8.1134"></a><span id="l8.1134">    */</span>
<a href="#l8.1135"></a><span id="l8.1135">   createConversation: function gloda_ds_createConversation(aSubject,</span>
<a href="#l8.1136"></a><span id="l8.1136">         aOldestMessageDate, aNewestMessageDate) {</span>
<a href="#l8.1137"></a><span id="l8.1137"> </span>
<a href="#l8.1138"></a><span id="l8.1138" class="difflineminus">-    // create the data row    </span>
<a href="#l8.1139"></a><span id="l8.1139" class="difflineplus">+    // create the data row</span>
<a href="#l8.1140"></a><span id="l8.1140">     let conversationID = this._nextConversationId++;</span>
<a href="#l8.1141"></a><span id="l8.1141">     let ics = this._insertConversationStatement;</span>
<a href="#l8.1142"></a><span id="l8.1142">     ics.bindInt64Parameter(0, conversationID);</span>
<a href="#l8.1143"></a><span id="l8.1143">     ics.bindStringParameter(1, aSubject);</span>
<a href="#l8.1144"></a><span id="l8.1144">     if (aOldestMessageDate == null)</span>
<a href="#l8.1145"></a><span id="l8.1145">       ics.bindNullParameter(2);</span>
<a href="#l8.1146"></a><span id="l8.1146">     else</span>
<a href="#l8.1147"></a><span id="l8.1147">       ics.bindInt64Parameter(2, aOldestMessageDate);</span>
<a href="#l8.1148"></a><span id="l8.1148">     if (aNewestMessageDate == null)</span>
<a href="#l8.1149"></a><span id="l8.1149">       ics.bindNullParameter(3);</span>
<a href="#l8.1150"></a><span id="l8.1150">     else</span>
<a href="#l8.1151"></a><span id="l8.1151">       ics.bindInt64Parameter(3, aNewestMessageDate);</span>
<a href="#l8.1152"></a><span id="l8.1152">     ics.executeAsync(this.trackAsync());</span>
<a href="#l8.1153"></a><span id="l8.1153" class="difflineminus">-    </span>
<a href="#l8.1154"></a><span id="l8.1154" class="difflineplus">+</span>
<a href="#l8.1155"></a><span id="l8.1155">     // create the fulltext row, using the same rowid/docid</span>
<a href="#l8.1156"></a><span id="l8.1156">     let icts = this._insertConversationTextStatement;</span>
<a href="#l8.1157"></a><span id="l8.1157">     icts.bindInt64Parameter(0, conversationID);</span>
<a href="#l8.1158"></a><span id="l8.1158">     icts.bindStringParameter(1, aSubject);</span>
<a href="#l8.1159"></a><span id="l8.1159">     icts.executeAsync(this.trackAsync());</span>
<a href="#l8.1160"></a><span id="l8.1160" class="difflineminus">-    </span>
<a href="#l8.1161"></a><span id="l8.1161" class="difflineplus">+</span>
<a href="#l8.1162"></a><span id="l8.1162">     // create it</span>
<a href="#l8.1163"></a><span id="l8.1163">     let conversation = new GlodaConversation(this, conversationID,</span>
<a href="#l8.1164"></a><span id="l8.1164">                                  aSubject, aOldestMessageDate,</span>
<a href="#l8.1165"></a><span id="l8.1165">                                  aNewestMessageDate);</span>
<a href="#l8.1166"></a><span id="l8.1166">     // it's new! let the collection manager know about it.</span>
<a href="#l8.1167"></a><span id="l8.1167">     GlodaCollectionManager.itemsAdded(conversation.NOUN_ID, [conversation]);</span>
<a href="#l8.1168"></a><span id="l8.1168">     // return it</span>
<a href="#l8.1169"></a><span id="l8.1169">     return conversation;</span>
<a href="#l8.1170"></a><span id="l8.1170">   },</span>
<a href="#l8.1171"></a><span id="l8.1171"> </span>
<a href="#l8.1172"></a><span id="l8.1172">   get _deleteConversationByIDStatement() {</span>
<a href="#l8.1173"></a><span id="l8.1173">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1174"></a><span id="l8.1174">       &quot;DELETE FROM conversations WHERE id = ?1&quot;);</span>
<a href="#l8.1175"></a><span id="l8.1175">     this.__defineGetter__(&quot;_deleteConversationByIDStatement&quot;,</span>
<a href="#l8.1176"></a><span id="l8.1176">                           function() statement);</span>
<a href="#l8.1177"></a><span id="l8.1177" class="difflineminus">-    return this._deleteConversationByIDStatement; </span>
<a href="#l8.1178"></a><span id="l8.1178" class="difflineplus">+    return this._deleteConversationByIDStatement;</span>
<a href="#l8.1179"></a><span id="l8.1179">   },</span>
<a href="#l8.1180"></a><span id="l8.1180"> </span>
<a href="#l8.1181"></a><span id="l8.1181">   /**</span>
<a href="#l8.1182"></a><span id="l8.1182">    * Asynchronously delete a conversation given its ID.</span>
<a href="#l8.1183"></a><span id="l8.1183">    */</span>
<a href="#l8.1184"></a><span id="l8.1184">   deleteConversationByID: function gloda_ds_deleteConversationByID(</span>
<a href="#l8.1185"></a><span id="l8.1185">                                       aConversationID) {</span>
<a href="#l8.1186"></a><span id="l8.1186">     let dcbids = this._deleteConversationByIDStatement;</span>
<a href="#l8.1187"></a><span id="l8.1187">     dcbids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l8.1188"></a><span id="l8.1188">     dcbids.executeAsync(this.trackAsync());</span>
<a href="#l8.1189"></a><span id="l8.1189" class="difflineminus">-    </span>
<a href="#l8.1190"></a><span id="l8.1190" class="difflineplus">+</span>
<a href="#l8.1191"></a><span id="l8.1191">     // TODO: collection manager implications</span>
<a href="#l8.1192"></a><span id="l8.1192">     //GlodaCollectionManager.removeByID()</span>
<a href="#l8.1193"></a><span id="l8.1193">   },</span>
<a href="#l8.1194"></a><span id="l8.1194"> </span>
<a href="#l8.1195"></a><span id="l8.1195">   get _selectConversationByIDStatement() {</span>
<a href="#l8.1196"></a><span id="l8.1196">     let statement = this._createSyncStatement(</span>
<a href="#l8.1197"></a><span id="l8.1197">       &quot;SELECT id, subject, oldestMessageDate, newestMessageDate \</span>
<a href="#l8.1198"></a><span id="l8.1198">          FROM conversations WHERE id = ?1&quot;);</span>
<a href="#l8.1199"></a><span id="l8.1199">     this.__defineGetter__(&quot;_selectConversationByIDStatement&quot;,</span>
<a href="#l8.1200"></a><span id="l8.1200">       function() statement);</span>
<a href="#l8.1201"></a><span id="l8.1201">     return this._selectConversationByIDStatement;</span>
<a href="#l8.1202"></a><span id="l8.1202" class="difflineminus">-  }, </span>
<a href="#l8.1203"></a><span id="l8.1203" class="difflineplus">+  },</span>
<a href="#l8.1204"></a><span id="l8.1204"> </span>
<a href="#l8.1205"></a><span id="l8.1205">   _conversationFromRow: function gloda_ds_conversationFromRow(aStmt) {</span>
<a href="#l8.1206"></a><span id="l8.1206">       let oldestMessageDate, newestMessageDate;</span>
<a href="#l8.1207"></a><span id="l8.1207">       if (aStmt.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l8.1208"></a><span id="l8.1208">         oldestMessageDate = null;</span>
<a href="#l8.1209"></a><span id="l8.1209">       else</span>
<a href="#l8.1210"></a><span id="l8.1210">         oldestMessageDate = aStmt.getInt64(2);</span>
<a href="#l8.1211"></a><span id="l8.1211">       if (aStmt.getTypeOfIndex(3) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l8.1212"></a><span id="l8.1212">         newestMessageDate = null;</span>
<a href="#l8.1213"></a><span id="l8.1213">       else</span>
<a href="#l8.1214"></a><span id="l8.1214">         newestMessageDate = aStmt.getInt64(3);</span>
<a href="#l8.1215"></a><span id="l8.1215">       return new GlodaConversation(this, aStmt.getInt64(0),</span>
<a href="#l8.1216"></a><span id="l8.1216" class="difflineminus">-        aStmt.getString(1), oldestMessageDate, newestMessageDate);  </span>
<a href="#l8.1217"></a><span id="l8.1217" class="difflineplus">+        aStmt.getString(1), oldestMessageDate, newestMessageDate);</span>
<a href="#l8.1218"></a><span id="l8.1218">   },</span>
<a href="#l8.1219"></a><span id="l8.1219"> </span>
<a href="#l8.1220"></a><span id="l8.1220">   /**</span>
<a href="#l8.1221"></a><span id="l8.1221">    * Synchronously look up a conversation given its ID.</span>
<a href="#l8.1222"></a><span id="l8.1222">    */</span>
<a href="#l8.1223"></a><span id="l8.1223">   getConversationByID: function gloda_ds_getConversationByID(aConversationID) {</span>
<a href="#l8.1224"></a><span id="l8.1224">     let conversation = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l8.1225"></a><span id="l8.1225">       GlodaConversation.prototype.NOUN_ID, aConversationID);</span>
<a href="#l8.1226"></a><span id="l8.1226"> </span>
<a href="#l8.1227"></a><span id="l8.1227">     if (conversation === null) {</span>
<a href="#l8.1228"></a><span id="l8.1228">       let scbids = this._selectConversationByIDStatement;</span>
<a href="#l8.1229"></a><span id="l8.1229" class="difflineminus">-      </span>
<a href="#l8.1230"></a><span id="l8.1230" class="difflineplus">+</span>
<a href="#l8.1231"></a><span id="l8.1231">       scbids.bindInt64Parameter(0, aConversationID);</span>
<a href="#l8.1232"></a><span id="l8.1232">       if (this._syncStep(scbids)) {</span>
<a href="#l8.1233"></a><span id="l8.1233">         conversation = this._conversationFromRow(scbids);</span>
<a href="#l8.1234"></a><span id="l8.1234">         GlodaCollectionManager.itemLoaded(conversation);</span>
<a href="#l8.1235"></a><span id="l8.1235">       }</span>
<a href="#l8.1236"></a><span id="l8.1236">       scbids.reset();</span>
<a href="#l8.1237"></a><span id="l8.1237">     }</span>
<a href="#l8.1238"></a><span id="l8.1238" class="difflineminus">-    </span>
<a href="#l8.1239"></a><span id="l8.1239" class="difflineplus">+</span>
<a href="#l8.1240"></a><span id="l8.1240">     return conversation;</span>
<a href="#l8.1241"></a><span id="l8.1241">   },</span>
<a href="#l8.1242"></a><span id="l8.1242" class="difflineminus">-  </span>
<a href="#l8.1243"></a><span id="l8.1243" class="difflineplus">+</span>
<a href="#l8.1244"></a><span id="l8.1244">   /* ********** Message ********** */</span>
<a href="#l8.1245"></a><span id="l8.1245">   /**</span>
<a href="#l8.1246"></a><span id="l8.1246">    * Next message id, managed because of our use of asynchronous inserts.</span>
<a href="#l8.1247"></a><span id="l8.1247">    * Initialized by _populateMessageManagedId called by _init.</span>
<a href="#l8.1248"></a><span id="l8.1248">    */</span>
<a href="#l8.1249"></a><span id="l8.1249">   _nextMessageId: 1,</span>
<a href="#l8.1250"></a><span id="l8.1250" class="difflineminus">-  </span>
<a href="#l8.1251"></a><span id="l8.1251" class="difflineplus">+</span>
<a href="#l8.1252"></a><span id="l8.1252">   _populateMessageManagedId: function () {</span>
<a href="#l8.1253"></a><span id="l8.1253">     let stmt = this._createSyncStatement(</span>
<a href="#l8.1254"></a><span id="l8.1254">       &quot;SELECT MAX(id) FROM messages&quot;, true);</span>
<a href="#l8.1255"></a><span id="l8.1255">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l8.1256"></a><span id="l8.1256">       this._nextMessageId = stmt.getInt64(0) + 1;</span>
<a href="#l8.1257"></a><span id="l8.1257">     }</span>
<a href="#l8.1258"></a><span id="l8.1258">     stmt.finalize();</span>
<a href="#l8.1259"></a><span id="l8.1259">   },</span>
<a href="#l8.1260"></a><span id="l8.1260" class="difflineminus">-  </span>
<a href="#l8.1261"></a><span id="l8.1261" class="difflineplus">+</span>
<a href="#l8.1262"></a><span id="l8.1262">   get _insertMessageStatement() {</span>
<a href="#l8.1263"></a><span id="l8.1263">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1264"></a><span id="l8.1264">       &quot;INSERT INTO messages (id, folderID, messageKey, conversationID, date, \</span>
<a href="#l8.1265"></a><span id="l8.1265">                              headerMessageID) \</span>
<a href="#l8.1266"></a><span id="l8.1266">               VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l8.1267"></a><span id="l8.1267">     this.__defineGetter__(&quot;_insertMessageStatement&quot;, function() statement);</span>
<a href="#l8.1268"></a><span id="l8.1268" class="difflineminus">-    return this._insertMessageStatement; </span>
<a href="#l8.1269"></a><span id="l8.1269" class="difflineminus">-  }, </span>
<a href="#l8.1270"></a><span id="l8.1270" class="difflineplus">+    return this._insertMessageStatement;</span>
<a href="#l8.1271"></a><span id="l8.1271" class="difflineplus">+  },</span>
<a href="#l8.1272"></a><span id="l8.1272"> </span>
<a href="#l8.1273"></a><span id="l8.1273">   get _insertMessageTextStatement() {</span>
<a href="#l8.1274"></a><span id="l8.1274">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1275"></a><span id="l8.1275">       &quot;INSERT INTO messagesText (docid, subject, body, attachmentNames) \</span>
<a href="#l8.1276"></a><span id="l8.1276">               VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l8.1277"></a><span id="l8.1277">     this.__defineGetter__(&quot;_insertMessageTextStatement&quot;, function() statement);</span>
<a href="#l8.1278"></a><span id="l8.1278" class="difflineminus">-    return this._insertMessageTextStatement; </span>
<a href="#l8.1279"></a><span id="l8.1279" class="difflineplus">+    return this._insertMessageTextStatement;</span>
<a href="#l8.1280"></a><span id="l8.1280">   },</span>
<a href="#l8.1281"></a><span id="l8.1281" class="difflineminus">-  </span>
<a href="#l8.1282"></a><span id="l8.1282" class="difflineplus">+</span>
<a href="#l8.1283"></a><span id="l8.1283">   /**</span>
<a href="#l8.1284"></a><span id="l8.1284">    * Create a GlodaMessage with the given properties.  Because this is only half</span>
<a href="#l8.1285"></a><span id="l8.1285">    *  of the process of creating a message (the attributes still need to be</span>
<a href="#l8.1286"></a><span id="l8.1286">    *  completed), it's on the caller's head to call GlodaCollectionManager's</span>
<a href="#l8.1287"></a><span id="l8.1287">    *  itemAdded method once the message is fully created.</span>
<a href="#l8.1288"></a><span id="l8.1288">    *</span>
<a href="#l8.1289"></a><span id="l8.1289">    * This method uses the async connection, any downstream logic that depends on</span>
<a href="#l8.1290"></a><span id="l8.1290">    *  this message actually existing in the database must be done using an</span>
<a href="#l8.1291"></a><span id="l8.1291" class="difflineat">@@ -1278,17 +1307,17 @@ var GlodaDatastore = {</span>
<a href="#l8.1292"></a><span id="l8.1292">     if (aFolderURI != null) {</span>
<a href="#l8.1293"></a><span id="l8.1293">       folderID = this._mapFolderURI(aFolderURI);</span>
<a href="#l8.1294"></a><span id="l8.1294">     }</span>
<a href="#l8.1295"></a><span id="l8.1295">     else {</span>
<a href="#l8.1296"></a><span id="l8.1296">       folderID = null;</span>
<a href="#l8.1297"></a><span id="l8.1297">     }</span>
<a href="#l8.1298"></a><span id="l8.1298"> </span>
<a href="#l8.1299"></a><span id="l8.1299">     let messageID = this._nextMessageId++;</span>
<a href="#l8.1300"></a><span id="l8.1300" class="difflineminus">-    </span>
<a href="#l8.1301"></a><span id="l8.1301" class="difflineplus">+</span>
<a href="#l8.1302"></a><span id="l8.1302">     let ims = this._insertMessageStatement;</span>
<a href="#l8.1303"></a><span id="l8.1303">     ims.bindInt64Parameter(0, messageID);</span>
<a href="#l8.1304"></a><span id="l8.1304">     if (folderID === null)</span>
<a href="#l8.1305"></a><span id="l8.1305">       ims.bindNullParameter(1);</span>
<a href="#l8.1306"></a><span id="l8.1306">     else</span>
<a href="#l8.1307"></a><span id="l8.1307">       ims.bindInt64Parameter(1, folderID);</span>
<a href="#l8.1308"></a><span id="l8.1308">     if (aMessageKey === null)</span>
<a href="#l8.1309"></a><span id="l8.1309">       ims.bindNullParameter(2);</span>
<a href="#l8.1310"></a><span id="l8.1310" class="difflineat">@@ -1307,66 +1336,66 @@ var GlodaDatastore = {</span>
<a href="#l8.1311"></a><span id="l8.1311">     catch(ex) {</span>
<a href="#l8.1312"></a><span id="l8.1312">        throw(&quot;error executing statement... &quot; +</span>
<a href="#l8.1313"></a><span id="l8.1313">              this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l8.1314"></a><span id="l8.1314">              this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l8.1315"></a><span id="l8.1315">     }</span>
<a href="#l8.1316"></a><span id="l8.1316"> </span>
<a href="#l8.1317"></a><span id="l8.1317">     this._log.debug(&quot;CreateMessage: &quot; + folderID + &quot;, &quot; + aMessageKey + &quot;, &quot; +</span>
<a href="#l8.1318"></a><span id="l8.1318">                     aConversationID + &quot;, &quot; + aDatePRTime + &quot;, &quot; +</span>
<a href="#l8.1319"></a><span id="l8.1319" class="difflineminus">-                    aHeaderMessageID); </span>
<a href="#l8.1320"></a><span id="l8.1320" class="difflineminus">-    </span>
<a href="#l8.1321"></a><span id="l8.1321" class="difflineplus">+                    aHeaderMessageID);</span>
<a href="#l8.1322"></a><span id="l8.1322" class="difflineplus">+</span>
<a href="#l8.1323"></a><span id="l8.1323">     // we only create the full-text row if the body is non-null.</span>
<a href="#l8.1324"></a><span id="l8.1324">     // so, even though body might be null, we still want to create the</span>
<a href="#l8.1325"></a><span id="l8.1325">     //  full-text search row</span>
<a href="#l8.1326"></a><span id="l8.1326">     if (aBody) {</span>
<a href="#l8.1327"></a><span id="l8.1327">       let imts = this._insertMessageTextStatement;</span>
<a href="#l8.1328"></a><span id="l8.1328">       imts.bindInt64Parameter(0, messageID);</span>
<a href="#l8.1329"></a><span id="l8.1329">       imts.bindStringParameter(1, aSubject);</span>
<a href="#l8.1330"></a><span id="l8.1330">       imts.bindStringParameter(2, aBody);</span>
<a href="#l8.1331"></a><span id="l8.1331">       if (aAttachmentNames === null)</span>
<a href="#l8.1332"></a><span id="l8.1332">         imts.bindNullParameter(3);</span>
<a href="#l8.1333"></a><span id="l8.1333">       else</span>
<a href="#l8.1334"></a><span id="l8.1334">         imts.bindStringParameter(3, aAttachmentNames);</span>
<a href="#l8.1335"></a><span id="l8.1335" class="difflineminus">-      </span>
<a href="#l8.1336"></a><span id="l8.1336" class="difflineplus">+</span>
<a href="#l8.1337"></a><span id="l8.1337">       try {</span>
<a href="#l8.1338"></a><span id="l8.1338">          imts.executeAsync(this.trackAsync());</span>
<a href="#l8.1339"></a><span id="l8.1339">       }</span>
<a href="#l8.1340"></a><span id="l8.1340">       catch(ex) {</span>
<a href="#l8.1341"></a><span id="l8.1341">          throw(&quot;error executing fulltext statement... &quot; +</span>
<a href="#l8.1342"></a><span id="l8.1342">                this.asyncConnection.lastError + &quot;: &quot; +</span>
<a href="#l8.1343"></a><span id="l8.1343">                this.asyncConnection.lastErrorString + &quot; - &quot; + ex);</span>
<a href="#l8.1344"></a><span id="l8.1344">       }</span>
<a href="#l8.1345"></a><span id="l8.1345">     }</span>
<a href="#l8.1346"></a><span id="l8.1346" class="difflineminus">-    </span>
<a href="#l8.1347"></a><span id="l8.1347" class="difflineplus">+</span>
<a href="#l8.1348"></a><span id="l8.1348">     let message = new GlodaMessage(this, messageID, folderID,</span>
<a href="#l8.1349"></a><span id="l8.1349">                             aMessageKey, aConversationID, null,</span>
<a href="#l8.1350"></a><span id="l8.1350">                             aDatePRTime ? new Date(aDatePRTime / 1000) : null,</span>
<a href="#l8.1351"></a><span id="l8.1351">                             aHeaderMessageID);</span>
<a href="#l8.1352"></a><span id="l8.1352" class="difflineminus">-    </span>
<a href="#l8.1353"></a><span id="l8.1353" class="difflineplus">+</span>
<a href="#l8.1354"></a><span id="l8.1354">     // We would love to notify the collection manager about the message at this</span>
<a href="#l8.1355"></a><span id="l8.1355">     //  point (at least if it's not a ghost), but we can't yet.  We need to wait</span>
<a href="#l8.1356"></a><span id="l8.1356">     //  until the attributes have been indexed, which means it's out of our</span>
<a href="#l8.1357"></a><span id="l8.1357">     //  hands.  (Gloda.processMessage does it.)</span>
<a href="#l8.1358"></a><span id="l8.1358" class="difflineminus">-    </span>
<a href="#l8.1359"></a><span id="l8.1359" class="difflineplus">+</span>
<a href="#l8.1360"></a><span id="l8.1360">     return message;</span>
<a href="#l8.1361"></a><span id="l8.1361">   },</span>
<a href="#l8.1362"></a><span id="l8.1362" class="difflineminus">-  </span>
<a href="#l8.1363"></a><span id="l8.1363" class="difflineplus">+</span>
<a href="#l8.1364"></a><span id="l8.1364">   get _updateMessageStatement() {</span>
<a href="#l8.1365"></a><span id="l8.1365">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1366"></a><span id="l8.1366">       &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l8.1367"></a><span id="l8.1367">                            messageKey = ?2, \</span>
<a href="#l8.1368"></a><span id="l8.1368">                            conversationID = ?3, \</span>
<a href="#l8.1369"></a><span id="l8.1369">                            date = ?4, \</span>
<a href="#l8.1370"></a><span id="l8.1370">                            headerMessageID = ?5 \</span>
<a href="#l8.1371"></a><span id="l8.1371">               WHERE id = ?6&quot;);</span>
<a href="#l8.1372"></a><span id="l8.1372">     this.__defineGetter__(&quot;_updateMessageStatement&quot;, function() statement);</span>
<a href="#l8.1373"></a><span id="l8.1373">     return this._updateMessageStatement;</span>
<a href="#l8.1374"></a><span id="l8.1374" class="difflineminus">-  }, </span>
<a href="#l8.1375"></a><span id="l8.1375" class="difflineminus">-  </span>
<a href="#l8.1376"></a><span id="l8.1376" class="difflineplus">+  },</span>
<a href="#l8.1377"></a><span id="l8.1377" class="difflineplus">+</span>
<a href="#l8.1378"></a><span id="l8.1378">   /**</span>
<a href="#l8.1379"></a><span id="l8.1379">    * Update the database row associated with the message.  If aBody is supplied,</span>
<a href="#l8.1380"></a><span id="l8.1380">    *  the associated full-text row is created; it is assumed that it did not</span>
<a href="#l8.1381"></a><span id="l8.1381">    *  previously exist.</span>
<a href="#l8.1382"></a><span id="l8.1382">    */</span>
<a href="#l8.1383"></a><span id="l8.1383">   updateMessage: function gloda_ds_updateMessage(aMessage, aSubject, aBody,</span>
<a href="#l8.1384"></a><span id="l8.1384">                                                  aAttachmentNames) {</span>
<a href="#l8.1385"></a><span id="l8.1385">     let ums = this._updateMessageStatement;</span>
<a href="#l8.1386"></a><span id="l8.1386" class="difflineat">@@ -1380,82 +1409,82 @@ var GlodaDatastore = {</span>
<a href="#l8.1387"></a><span id="l8.1387">     else</span>
<a href="#l8.1388"></a><span id="l8.1388">       ums.bindInt64Parameter(1, aMessage.messageKey);</span>
<a href="#l8.1389"></a><span id="l8.1389">     ums.bindInt64Parameter(2, aMessage.conversationID);</span>
<a href="#l8.1390"></a><span id="l8.1390">     if (aMessage.date === null)</span>
<a href="#l8.1391"></a><span id="l8.1391">       ums.bindNullParameter(3);</span>
<a href="#l8.1392"></a><span id="l8.1392">     else</span>
<a href="#l8.1393"></a><span id="l8.1393">       ums.bindInt64Parameter(3, aMessage.date * 1000);</span>
<a href="#l8.1394"></a><span id="l8.1394">     ums.bindStringParameter(4, aMessage.headerMessageID);</span>
<a href="#l8.1395"></a><span id="l8.1395" class="difflineminus">-    </span>
<a href="#l8.1396"></a><span id="l8.1396" class="difflineplus">+</span>
<a href="#l8.1397"></a><span id="l8.1397">     ums.executeAsync(this.trackAsync());</span>
<a href="#l8.1398"></a><span id="l8.1398" class="difflineminus">-    </span>
<a href="#l8.1399"></a><span id="l8.1399" class="difflineplus">+</span>
<a href="#l8.1400"></a><span id="l8.1400">     if (aBody) {</span>
<a href="#l8.1401"></a><span id="l8.1401">       let imts = this._insertMessageTextStatement;</span>
<a href="#l8.1402"></a><span id="l8.1402">       imts.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l8.1403"></a><span id="l8.1403">       imts.bindStringParameter(1, aSubject);</span>
<a href="#l8.1404"></a><span id="l8.1404">       imts.bindStringParameter(2, aBody);</span>
<a href="#l8.1405"></a><span id="l8.1405">       if (aAttachmentNames === null)</span>
<a href="#l8.1406"></a><span id="l8.1406">         imts.bindNullParameter(3);</span>
<a href="#l8.1407"></a><span id="l8.1407">       else</span>
<a href="#l8.1408"></a><span id="l8.1408">         imts.bindStringParameter(3, aAttachmentNames);</span>
<a href="#l8.1409"></a><span id="l8.1409" class="difflineminus">-      </span>
<a href="#l8.1410"></a><span id="l8.1410" class="difflineplus">+</span>
<a href="#l8.1411"></a><span id="l8.1411">       imts.executeAsync(this.trackAsync());</span>
<a href="#l8.1412"></a><span id="l8.1412">     }</span>
<a href="#l8.1413"></a><span id="l8.1413" class="difflineminus">-    </span>
<a href="#l8.1414"></a><span id="l8.1414" class="difflineplus">+</span>
<a href="#l8.1415"></a><span id="l8.1415">     // In completely abstract theory, this is where we would call</span>
<a href="#l8.1416"></a><span id="l8.1416">     //  GlodaCollectionManager.itemsModified, except that the attributes may</span>
<a href="#l8.1417"></a><span id="l8.1417">     //  also have changed, so it's out of our hands.  (Gloda.processMessage</span>
<a href="#l8.1418"></a><span id="l8.1418">     //  handles it.)</span>
<a href="#l8.1419"></a><span id="l8.1419">   },</span>
<a href="#l8.1420"></a><span id="l8.1420"> </span>
<a href="#l8.1421"></a><span id="l8.1421">   get _updateMessageLocationStatement() {</span>
<a href="#l8.1422"></a><span id="l8.1422">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1423"></a><span id="l8.1423">       &quot;UPDATE messages SET folderID = ?1, messageKey = ?2 WHERE id = ?3&quot;);</span>
<a href="#l8.1424"></a><span id="l8.1424">     this.__defineGetter__(&quot;_updateMessageLocationStatement&quot;,</span>
<a href="#l8.1425"></a><span id="l8.1425">                           function() statement);</span>
<a href="#l8.1426"></a><span id="l8.1426">     return this._updateMessageLocationStatement;</span>
<a href="#l8.1427"></a><span id="l8.1427" class="difflineminus">-  }, </span>
<a href="#l8.1428"></a><span id="l8.1428" class="difflineplus">+  },</span>
<a href="#l8.1429"></a><span id="l8.1429"> </span>
<a href="#l8.1430"></a><span id="l8.1430">   /**</span>
<a href="#l8.1431"></a><span id="l8.1431">    * Given a list of gloda message ids, and a list of their new message keys in</span>
<a href="#l8.1432"></a><span id="l8.1432">    *  the given new folder location, asynchronously update the message's</span>
<a href="#l8.1433"></a><span id="l8.1433">    *  database locations.  Also, update the in-memory representations.</span>
<a href="#l8.1434"></a><span id="l8.1434">    */</span>
<a href="#l8.1435"></a><span id="l8.1435">   updateMessageLocations: function gloda_ds_updateMessageLocations(aMessageIds,</span>
<a href="#l8.1436"></a><span id="l8.1436">       aNewMessageKeys, aDestFolderURI) {</span>
<a href="#l8.1437"></a><span id="l8.1437">     let statement = this._updateMessageLocationStatement;</span>
<a href="#l8.1438"></a><span id="l8.1438">     let destFolderID = this._mapFolderURI(aDestFolderURI);</span>
<a href="#l8.1439"></a><span id="l8.1439" class="difflineminus">-    </span>
<a href="#l8.1440"></a><span id="l8.1440" class="difflineplus">+</span>
<a href="#l8.1441"></a><span id="l8.1441">     let modifiedItems = [];</span>
<a href="#l8.1442"></a><span id="l8.1442" class="difflineminus">-    </span>
<a href="#l8.1443"></a><span id="l8.1443" class="difflineplus">+</span>
<a href="#l8.1444"></a><span id="l8.1444">     for (let iMsg = 0; iMsg &lt; aMessageIds.length; iMsg++) {</span>
<a href="#l8.1445"></a><span id="l8.1445">       let id = aMessageIds[iMsg]</span>
<a href="#l8.1446"></a><span id="l8.1446">       statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l8.1447"></a><span id="l8.1447">       statement.bindInt64Parameter(1, aNewMessageKeys[iMsg]);</span>
<a href="#l8.1448"></a><span id="l8.1448">       statement.bindInt64Parameter(2, id);</span>
<a href="#l8.1449"></a><span id="l8.1449">       statement.executeAsync(this.trackAsync());</span>
<a href="#l8.1450"></a><span id="l8.1450" class="difflineminus">-      </span>
<a href="#l8.1451"></a><span id="l8.1451" class="difflineplus">+</span>
<a href="#l8.1452"></a><span id="l8.1452">       // so, if the message is currently loaded, we also need to change it up...</span>
<a href="#l8.1453"></a><span id="l8.1453">       let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l8.1454"></a><span id="l8.1454">         GlodaMessage.prototype.NOUN_ID, id);</span>
<a href="#l8.1455"></a><span id="l8.1455">       if (message) {</span>
<a href="#l8.1456"></a><span id="l8.1456">         message._folderID = destFolderID;</span>
<a href="#l8.1457"></a><span id="l8.1457">         modifiedItems.push(message);</span>
<a href="#l8.1458"></a><span id="l8.1458">       }</span>
<a href="#l8.1459"></a><span id="l8.1459">     }</span>
<a href="#l8.1460"></a><span id="l8.1460"> </span>
<a href="#l8.1461"></a><span id="l8.1461">     // if we're talking about a lot of messages, it's worth committing after</span>
<a href="#l8.1462"></a><span id="l8.1462">     //  this to ensure that we don't spill to disk and cause contention with</span>
<a href="#l8.1463"></a><span id="l8.1463">     //  synchronous reads off (this) the main thread.</span>
<a href="#l8.1464"></a><span id="l8.1464">     if ((aMessageIds.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l8.1465"></a><span id="l8.1465">       this._commitTransaction();</span>
<a href="#l8.1466"></a><span id="l8.1466">       this._beginTransaction();</span>
<a href="#l8.1467"></a><span id="l8.1467">     }</span>
<a href="#l8.1468"></a><span id="l8.1468" class="difflineminus">-    </span>
<a href="#l8.1469"></a><span id="l8.1469" class="difflineplus">+</span>
<a href="#l8.1470"></a><span id="l8.1470">     // tell the collection manager about the modified messages so it can update</span>
<a href="#l8.1471"></a><span id="l8.1471">     //  any existing views...</span>
<a href="#l8.1472"></a><span id="l8.1472">     if (modifiedItems.length) {</span>
<a href="#l8.1473"></a><span id="l8.1473">       GlodaCollectionManager.itemsModified(GlodaMessage.prototype.NOUN,</span>
<a href="#l8.1474"></a><span id="l8.1474">                                            modifiedItems);</span>
<a href="#l8.1475"></a><span id="l8.1475">     }</span>
<a href="#l8.1476"></a><span id="l8.1476">   },</span>
<a href="#l8.1477"></a><span id="l8.1477"> </span>
<a href="#l8.1478"></a><span id="l8.1478" class="difflineat">@@ -1464,17 +1493,17 @@ var GlodaDatastore = {</span>
<a href="#l8.1479"></a><span id="l8.1479">    *  messages, indicating that we are moving them to the target folder, but</span>
<a href="#l8.1480"></a><span id="l8.1480">    *  don't yet know their target message keys.</span>
<a href="#l8.1481"></a><span id="l8.1481">    */</span>
<a href="#l8.1482"></a><span id="l8.1482">   updateMessageFoldersByKeyPurging:</span>
<a href="#l8.1483"></a><span id="l8.1483">       function gloda_ds_updateMessageFoldersByKeyPurging(aSrcFolderURI,</span>
<a href="#l8.1484"></a><span id="l8.1484">         aMessageKeys, aDestFolderURI) {</span>
<a href="#l8.1485"></a><span id="l8.1485">     let srcFolderID = this._mapFolderURI(aSrcFolderURI);</span>
<a href="#l8.1486"></a><span id="l8.1486">     let destFolderID = this._mapFolderURI(aDestFolderURI);</span>
<a href="#l8.1487"></a><span id="l8.1487" class="difflineminus">-    </span>
<a href="#l8.1488"></a><span id="l8.1488" class="difflineplus">+</span>
<a href="#l8.1489"></a><span id="l8.1489">     let sqlStr = &quot;UPDATE messages SET folderID = ?1, \</span>
<a href="#l8.1490"></a><span id="l8.1490">                                       messageKey = ?2 \</span>
<a href="#l8.1491"></a><span id="l8.1491">                    WHERE folderID = ?3 \</span>
<a href="#l8.1492"></a><span id="l8.1492">                      AND messageKey IN (&quot; + aMessageKeys.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l8.1493"></a><span id="l8.1493">     let statement = this._createAsyncStatement(sqlStr, true);</span>
<a href="#l8.1494"></a><span id="l8.1494">     statement.bindInt64Parameter(2, srcFolderID);</span>
<a href="#l8.1495"></a><span id="l8.1495">     statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l8.1496"></a><span id="l8.1496">     statement.bindNullParameter(1);</span>
<a href="#l8.1497"></a><span id="l8.1497" class="difflineat">@@ -1484,17 +1513,17 @@ var GlodaDatastore = {</span>
<a href="#l8.1498"></a><span id="l8.1498">     // if we're talking about a lot of messages, it's worth committing after</span>
<a href="#l8.1499"></a><span id="l8.1499">     //  this to ensure that we don't spill to disk and cause contention with</span>
<a href="#l8.1500"></a><span id="l8.1500">     //  synchronous reads off (this) the main thread.</span>
<a href="#l8.1501"></a><span id="l8.1501">     if ((aMessageKeys.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l8.1502"></a><span id="l8.1502">       this._commitTransaction();</span>
<a href="#l8.1503"></a><span id="l8.1503">       this._beginTransaction();</span>
<a href="#l8.1504"></a><span id="l8.1504">     }</span>
<a href="#l8.1505"></a><span id="l8.1505">   },</span>
<a href="#l8.1506"></a><span id="l8.1506" class="difflineminus">-  </span>
<a href="#l8.1507"></a><span id="l8.1507" class="difflineplus">+</span>
<a href="#l8.1508"></a><span id="l8.1508">   _messageFromRow: function gloda_ds_messageFromRow(aRow) {</span>
<a href="#l8.1509"></a><span id="l8.1509">     let folderId, messageKey, date;</span>
<a href="#l8.1510"></a><span id="l8.1510">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l8.1511"></a><span id="l8.1511">       folderId = null;</span>
<a href="#l8.1512"></a><span id="l8.1512">     else</span>
<a href="#l8.1513"></a><span id="l8.1513">       folderId = aRow.getInt64(1);</span>
<a href="#l8.1514"></a><span id="l8.1514">     if (aRow.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l8.1515"></a><span id="l8.1515">       messageKey = null;</span>
<a href="#l8.1516"></a><span id="l8.1516" class="difflineat">@@ -1519,88 +1548,88 @@ var GlodaDatastore = {</span>
<a href="#l8.1517"></a><span id="l8.1517">   },</span>
<a href="#l8.1518"></a><span id="l8.1518"> </span>
<a href="#l8.1519"></a><span id="l8.1519">   /**</span>
<a href="#l8.1520"></a><span id="l8.1520">    * Synchronously retrieve the given message given its gloda message id.</span>
<a href="#l8.1521"></a><span id="l8.1521">    */</span>
<a href="#l8.1522"></a><span id="l8.1522">   getMessageByID: function gloda_ds_getMessageByID(aID) {</span>
<a href="#l8.1523"></a><span id="l8.1523">     let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l8.1524"></a><span id="l8.1524">       GlodaMessage.prototype.NOUN_ID, aID);</span>
<a href="#l8.1525"></a><span id="l8.1525" class="difflineminus">-  </span>
<a href="#l8.1526"></a><span id="l8.1526" class="difflineplus">+</span>
<a href="#l8.1527"></a><span id="l8.1527">     if (message === null) {</span>
<a href="#l8.1528"></a><span id="l8.1528">       let smbis = this._selectMessageByIDStatement;</span>
<a href="#l8.1529"></a><span id="l8.1529" class="difflineminus">-      </span>
<a href="#l8.1530"></a><span id="l8.1530" class="difflineplus">+</span>
<a href="#l8.1531"></a><span id="l8.1531">       smbis.bindInt64Parameter(0, aID);</span>
<a href="#l8.1532"></a><span id="l8.1532">       if (this._syncStep(smbis)) {</span>
<a href="#l8.1533"></a><span id="l8.1533">         message = this._messageFromRow(smbis);</span>
<a href="#l8.1534"></a><span id="l8.1534">         GlodaCollectionManager.itemLoaded(message);</span>
<a href="#l8.1535"></a><span id="l8.1535">       }</span>
<a href="#l8.1536"></a><span id="l8.1536">       smbis.reset();</span>
<a href="#l8.1537"></a><span id="l8.1537">     }</span>
<a href="#l8.1538"></a><span id="l8.1538" class="difflineminus">-    </span>
<a href="#l8.1539"></a><span id="l8.1539" class="difflineplus">+</span>
<a href="#l8.1540"></a><span id="l8.1540">     return message;</span>
<a href="#l8.1541"></a><span id="l8.1541">   },</span>
<a href="#l8.1542"></a><span id="l8.1542"> </span>
<a href="#l8.1543"></a><span id="l8.1543">   get _selectMessageByLocationStatement() {</span>
<a href="#l8.1544"></a><span id="l8.1544">     let statement = this._createSyncStatement(</span>
<a href="#l8.1545"></a><span id="l8.1545">       &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageId, \</span>
<a href="#l8.1546"></a><span id="l8.1546">        deleted FROM messages WHERE folderID = ?1 AND messageKey = ?2&quot;);</span>
<a href="#l8.1547"></a><span id="l8.1547">     this.__defineGetter__(&quot;_selectMessageByLocationStatement&quot;,</span>
<a href="#l8.1548"></a><span id="l8.1548">       function() statement);</span>
<a href="#l8.1549"></a><span id="l8.1549">     return this._selectMessageByLocationStatement;</span>
<a href="#l8.1550"></a><span id="l8.1550">   },</span>
<a href="#l8.1551"></a><span id="l8.1551"> </span>
<a href="#l8.1552"></a><span id="l8.1552">   /**</span>
<a href="#l8.1553"></a><span id="l8.1553" class="difflineminus">-   * Synchronously retrieve the message that we believe to correspond to the </span>
<a href="#l8.1554"></a><span id="l8.1554" class="difflineplus">+   * Synchronously retrieve the message that we believe to correspond to the</span>
<a href="#l8.1555"></a><span id="l8.1555">    *  given message key in the given folder.</span>
<a href="#l8.1556"></a><span id="l8.1556">    * @return null on failure to locate the message, the message on success.</span>
<a href="#l8.1557"></a><span id="l8.1557">    *</span>
<a href="#l8.1558"></a><span id="l8.1558">    * @XXX on failure, attempt to resolve the problem through re-indexing, etc.</span>
<a href="#l8.1559"></a><span id="l8.1559">    */</span>
<a href="#l8.1560"></a><span id="l8.1560">   getMessageFromLocation: function gloda_ds_getMessageFromLocation(aFolderURI,</span>
<a href="#l8.1561"></a><span id="l8.1561">                                                                  aMessageKey) {</span>
<a href="#l8.1562"></a><span id="l8.1562">     this._selectMessageByLocationStatement.bindInt64Parameter(0,</span>
<a href="#l8.1563"></a><span id="l8.1563">       this._mapFolderURI(aFolderURI));</span>
<a href="#l8.1564"></a><span id="l8.1564">     this._selectMessageByLocationStatement.bindInt64Parameter(1, aMessageKey);</span>
<a href="#l8.1565"></a><span id="l8.1565" class="difflineminus">-    </span>
<a href="#l8.1566"></a><span id="l8.1566" class="difflineplus">+</span>
<a href="#l8.1567"></a><span id="l8.1567">     let message = null;</span>
<a href="#l8.1568"></a><span id="l8.1568">     if (this._syncStep(this._selectMessageByLocationStatement))</span>
<a href="#l8.1569"></a><span id="l8.1569">       message = this._messageFromRow(this._selectMessageByLocationStatement);</span>
<a href="#l8.1570"></a><span id="l8.1570">     this._selectMessageByLocationStatement.reset();</span>
<a href="#l8.1571"></a><span id="l8.1571" class="difflineminus">-    </span>
<a href="#l8.1572"></a><span id="l8.1572" class="difflineplus">+</span>
<a href="#l8.1573"></a><span id="l8.1573">     if (message === null)</span>
<a href="#l8.1574"></a><span id="l8.1574">       this._log.info(&quot;Error locating message with key=&quot; + aMessageKey +</span>
<a href="#l8.1575"></a><span id="l8.1575">                      &quot; and URI &quot; + aFolderURI);</span>
<a href="#l8.1576"></a><span id="l8.1576" class="difflineminus">-    </span>
<a href="#l8.1577"></a><span id="l8.1577" class="difflineplus">+</span>
<a href="#l8.1578"></a><span id="l8.1578">     return message &amp;&amp; GlodaCollectionManager.cacheLoadUnifyOne(message);</span>
<a href="#l8.1579"></a><span id="l8.1579">   },</span>
<a href="#l8.1580"></a><span id="l8.1580"> </span>
<a href="#l8.1581"></a><span id="l8.1581">   get _selectMessageIDsByFolderStatement() {</span>
<a href="#l8.1582"></a><span id="l8.1582">     let statement = this._createSyncStatement(</span>
<a href="#l8.1583"></a><span id="l8.1583">       &quot;SELECT id FROM messages WHERE folderID = ?1&quot;);</span>
<a href="#l8.1584"></a><span id="l8.1584">     this.__defineGetter__(&quot;_selectMessageIDsByFolderStatement&quot;,</span>
<a href="#l8.1585"></a><span id="l8.1585">       function() statement);</span>
<a href="#l8.1586"></a><span id="l8.1586">     return this._selectMessageIDsByFolderStatement;</span>
<a href="#l8.1587"></a><span id="l8.1587">   },</span>
<a href="#l8.1588"></a><span id="l8.1588" class="difflineminus">-  </span>
<a href="#l8.1589"></a><span id="l8.1589" class="difflineplus">+</span>
<a href="#l8.1590"></a><span id="l8.1590">   getMessageIDsByFolderID:</span>
<a href="#l8.1591"></a><span id="l8.1591">       function gloda_ds_getMessageIDsFromFolderID(aFolderID) {</span>
<a href="#l8.1592"></a><span id="l8.1592">     let messageIDs = [];</span>
<a href="#l8.1593"></a><span id="l8.1593" class="difflineminus">-    </span>
<a href="#l8.1594"></a><span id="l8.1594" class="difflineplus">+</span>
<a href="#l8.1595"></a><span id="l8.1595">     let smidbfs = this._selectMessageIDsByFolderStatement;</span>
<a href="#l8.1596"></a><span id="l8.1596">     smidbfs.bindInt64Parameter(0, aFolderID);</span>
<a href="#l8.1597"></a><span id="l8.1597" class="difflineminus">-    </span>
<a href="#l8.1598"></a><span id="l8.1598" class="difflineplus">+</span>
<a href="#l8.1599"></a><span id="l8.1599">     while (this._syncStep(smidbfs)) {</span>
<a href="#l8.1600"></a><span id="l8.1600">       messageIDs.push(smidbfs.getInt64(0));</span>
<a href="#l8.1601"></a><span id="l8.1601">     }</span>
<a href="#l8.1602"></a><span id="l8.1602">     smidbfs.reset();</span>
<a href="#l8.1603"></a><span id="l8.1603" class="difflineminus">-    </span>
<a href="#l8.1604"></a><span id="l8.1604" class="difflineplus">+</span>
<a href="#l8.1605"></a><span id="l8.1605">     return messageIDs;</span>
<a href="#l8.1606"></a><span id="l8.1606">   },</span>
<a href="#l8.1607"></a><span id="l8.1607" class="difflineminus">-  </span>
<a href="#l8.1608"></a><span id="l8.1608" class="difflineplus">+</span>
<a href="#l8.1609"></a><span id="l8.1609">   /**</span>
<a href="#l8.1610"></a><span id="l8.1610">    * Given a list of Message-ID's, return a matching list of lists of messages</span>
<a href="#l8.1611"></a><span id="l8.1611">    *  matching those Message-ID's.  So if you pass an array with three</span>
<a href="#l8.1612"></a><span id="l8.1612">    *  Message-ID's [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], you would get back an array containing</span>
<a href="#l8.1613"></a><span id="l8.1613">    *  3 lists, where the first list contains all the messages with a message-id</span>
<a href="#l8.1614"></a><span id="l8.1614">    *  of &quot;a&quot;, and so forth.  The reason a list is returned rather than null/a</span>
<a href="#l8.1615"></a><span id="l8.1615">    *  message is that we accept the reality that we have multiple copies of</span>
<a href="#l8.1616"></a><span id="l8.1616">    *  messages with the same ID.</span>
<a href="#l8.1617"></a><span id="l8.1617" class="difflineat">@@ -1614,27 +1643,27 @@ var GlodaDatastore = {</span>
<a href="#l8.1618"></a><span id="l8.1618">   getMessagesByMessageID: function gloda_ds_getMessagesByMessageID(aMessageIDs,</span>
<a href="#l8.1619"></a><span id="l8.1619">       aCallback, aCallbackThis, aCallbackArgs) {</span>
<a href="#l8.1620"></a><span id="l8.1620">     let msgIDToIndex = {};</span>
<a href="#l8.1621"></a><span id="l8.1621">     let results = [];</span>
<a href="#l8.1622"></a><span id="l8.1622">     for (let iID = 0; iID &lt; aMessageIDs.length; ++iID) {</span>
<a href="#l8.1623"></a><span id="l8.1623">       let msgID = aMessageIDs[iID];</span>
<a href="#l8.1624"></a><span id="l8.1624">       results.push([]);</span>
<a href="#l8.1625"></a><span id="l8.1625">       msgIDToIndex[msgID] = iID;</span>
<a href="#l8.1626"></a><span id="l8.1626" class="difflineminus">-    } </span>
<a href="#l8.1627"></a><span id="l8.1627" class="difflineplus">+    }</span>
<a href="#l8.1628"></a><span id="l8.1628"> </span>
<a href="#l8.1629"></a><span id="l8.1629">     // Unfortunately, IN doesn't work with statement binding mechanisms, and</span>
<a href="#l8.1630"></a><span id="l8.1630">     //  a chain of ORed tests really can't be bound unless we create one per</span>
<a href="#l8.1631"></a><span id="l8.1631">     //  value of N (seems silly).</span>
<a href="#l8.1632"></a><span id="l8.1632">     let quotedIDs = [&quot;'&quot; + msgID.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot; for each</span>
<a href="#l8.1633"></a><span id="l8.1633">                      (msgID in aMessageIDs)]</span>
<a href="#l8.1634"></a><span id="l8.1634">     let sqlString = &quot;SELECT * FROM messages WHERE headerMessageID IN (&quot; +</span>
<a href="#l8.1635"></a><span id="l8.1635">                     quotedIDs + &quot;)&quot;;</span>
<a href="#l8.1636"></a><span id="l8.1636">     let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l8.1637"></a><span id="l8.1637" class="difflineminus">-    </span>
<a href="#l8.1638"></a><span id="l8.1638" class="difflineplus">+</span>
<a href="#l8.1639"></a><span id="l8.1639">     statement.executeAsync(new MessagesByMessageIdCallback(statement,</span>
<a href="#l8.1640"></a><span id="l8.1640">       msgIDToIndex, results, aCallback, aCallbackThis, aCallbackArgs));</span>
<a href="#l8.1641"></a><span id="l8.1641">     statement.finalize();</span>
<a href="#l8.1642"></a><span id="l8.1642">   },</span>
<a href="#l8.1643"></a><span id="l8.1643"> </span>
<a href="#l8.1644"></a><span id="l8.1644">   get _updateMessagesMarkDeletedByFolderID() {</span>
<a href="#l8.1645"></a><span id="l8.1645">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1646"></a><span id="l8.1646">       &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, \</span>
<a href="#l8.1647"></a><span id="l8.1647" class="difflineat">@@ -1649,23 +1678,23 @@ var GlodaDatastore = {</span>
<a href="#l8.1648"></a><span id="l8.1648">     let statement = this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l8.1649"></a><span id="l8.1649">     statement.bindInt64Parameter(0, aFolderID);</span>
<a href="#l8.1650"></a><span id="l8.1650">     statement.executeAsync(this.trackAsync());</span>
<a href="#l8.1651"></a><span id="l8.1651">     statement.finalize();</span>
<a href="#l8.1652"></a><span id="l8.1652">   },</span>
<a href="#l8.1653"></a><span id="l8.1653"> </span>
<a href="#l8.1654"></a><span id="l8.1654">   markMessagesDeletedByIDs: function gloda_ds_markMessagesDeletedByIDs(</span>
<a href="#l8.1655"></a><span id="l8.1655">       aMessageIDs) {</span>
<a href="#l8.1656"></a><span id="l8.1656" class="difflineminus">-    let sqlString = &quot;UPDATE messages SET deleted = 1 WHERE id IN (&quot; + </span>
<a href="#l8.1657"></a><span id="l8.1657" class="difflineplus">+    let sqlString = &quot;UPDATE messages SET deleted = 1 WHERE id IN (&quot; +</span>
<a href="#l8.1658"></a><span id="l8.1658">       aMessageIDs.join(&quot;,&quot;) + &quot;)&quot;;</span>
<a href="#l8.1659"></a><span id="l8.1659" class="difflineminus">-    </span>
<a href="#l8.1660"></a><span id="l8.1660" class="difflineplus">+</span>
<a href="#l8.1661"></a><span id="l8.1661">     let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l8.1662"></a><span id="l8.1662">     statement.executeAsync(this.trackAsync());</span>
<a href="#l8.1663"></a><span id="l8.1663">     statement.finalize();</span>
<a href="#l8.1664"></a><span id="l8.1664" class="difflineminus">-    </span>
<a href="#l8.1665"></a><span id="l8.1665" class="difflineplus">+</span>
<a href="#l8.1666"></a><span id="l8.1666">     // some people are inclined to deleting ridiculous numbers of messages at</span>
<a href="#l8.1667"></a><span id="l8.1667">     //  a time.  if we are in a transaction, this has the potential to cause us</span>
<a href="#l8.1668"></a><span id="l8.1668">     //  to spill the transaction to disk prior to disk, resulting in a lock</span>
<a href="#l8.1669"></a><span id="l8.1669">     //  escalation and making any synchronous reads from the main thread need</span>
<a href="#l8.1670"></a><span id="l8.1670">     //  to become blocking.  We don't want that, so:</span>
<a href="#l8.1671"></a><span id="l8.1671">     // If we are in a transaction and there are a &quot;lot&quot; of messages being</span>
<a href="#l8.1672"></a><span id="l8.1672">     //  marked as deleted, issue a commit and then re-open the transaction.</span>
<a href="#l8.1673"></a><span id="l8.1673">     if ((aMessageIDs.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l8.1674"></a><span id="l8.1674" class="difflineat">@@ -1674,32 +1703,32 @@ var GlodaDatastore = {</span>
<a href="#l8.1675"></a><span id="l8.1675">     }</span>
<a href="#l8.1676"></a><span id="l8.1676">   },</span>
<a href="#l8.1677"></a><span id="l8.1677"> </span>
<a href="#l8.1678"></a><span id="l8.1678">   get _deleteMessageByIDStatement() {</span>
<a href="#l8.1679"></a><span id="l8.1679">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1680"></a><span id="l8.1680">       &quot;DELETE FROM messages WHERE id = ?1&quot;);</span>
<a href="#l8.1681"></a><span id="l8.1681">     this.__defineGetter__(&quot;_deleteMessageByIDStatement&quot;,</span>
<a href="#l8.1682"></a><span id="l8.1682">                           function() statement);</span>
<a href="#l8.1683"></a><span id="l8.1683" class="difflineminus">-    return this._deleteMessageByIDStatement; </span>
<a href="#l8.1684"></a><span id="l8.1684" class="difflineplus">+    return this._deleteMessageByIDStatement;</span>
<a href="#l8.1685"></a><span id="l8.1685">   },</span>
<a href="#l8.1686"></a><span id="l8.1686" class="difflineminus">-  </span>
<a href="#l8.1687"></a><span id="l8.1687" class="difflineplus">+</span>
<a href="#l8.1688"></a><span id="l8.1688">   deleteMessageByID: function gloda_ds_deleteMessageByID(aMessageID) {</span>
<a href="#l8.1689"></a><span id="l8.1689">     // TODO: collection manager implications</span>
<a href="#l8.1690"></a><span id="l8.1690">     let dmbids = this._deleteMessageByIDStatement;</span>
<a href="#l8.1691"></a><span id="l8.1691">     dmbids.bindInt64Parameter(0, aMessageID);</span>
<a href="#l8.1692"></a><span id="l8.1692">     dmbids.executeAsync(this.trackAsync());</span>
<a href="#l8.1693"></a><span id="l8.1693">   },</span>
<a href="#l8.1694"></a><span id="l8.1694"> </span>
<a href="#l8.1695"></a><span id="l8.1695">   get _deleteMessagesByConversationIDStatement() {</span>
<a href="#l8.1696"></a><span id="l8.1696">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1697"></a><span id="l8.1697">       &quot;DELETE FROM messages WHERE conversationID = ?1&quot;);</span>
<a href="#l8.1698"></a><span id="l8.1698">     this.__defineGetter__(&quot;_deleteMessagesByConversationIDStatement&quot;,</span>
<a href="#l8.1699"></a><span id="l8.1699">                           function() statement);</span>
<a href="#l8.1700"></a><span id="l8.1700" class="difflineminus">-    return this._deleteMessagesByConversationIDStatement; </span>
<a href="#l8.1701"></a><span id="l8.1701" class="difflineplus">+    return this._deleteMessagesByConversationIDStatement;</span>
<a href="#l8.1702"></a><span id="l8.1702">   },</span>
<a href="#l8.1703"></a><span id="l8.1703"> </span>
<a href="#l8.1704"></a><span id="l8.1704">   /**</span>
<a href="#l8.1705"></a><span id="l8.1705">    * Delete messages by conversation ID.  For use by the indexer's deletion</span>
<a href="#l8.1706"></a><span id="l8.1706">    *  logic, NOT you.</span>
<a href="#l8.1707"></a><span id="l8.1707">    */</span>
<a href="#l8.1708"></a><span id="l8.1708">   deleteMessagesByConversationID:</span>
<a href="#l8.1709"></a><span id="l8.1709">     // TODO: collection manager implications</span>
<a href="#l8.1710"></a><span id="l8.1710" class="difflineat">@@ -1744,42 +1773,42 @@ var GlodaDatastore = {</span>
<a href="#l8.1711"></a><span id="l8.1711">    */</span>
<a href="#l8.1712"></a><span id="l8.1712">   getMessagesByConversationID: function gloda_ds_getMessagesByConversationID(</span>
<a href="#l8.1713"></a><span id="l8.1713">         aConversationID, aIncludeGhosts) {</span>
<a href="#l8.1714"></a><span id="l8.1714">     let statement;</span>
<a href="#l8.1715"></a><span id="l8.1715">     if (aIncludeGhosts)</span>
<a href="#l8.1716"></a><span id="l8.1716">       statement = this._selectMessagesByConversationIDStatement;</span>
<a href="#l8.1717"></a><span id="l8.1717">     else</span>
<a href="#l8.1718"></a><span id="l8.1718">       statement = this._selectMessagesByConversationIDNoGhostsStatement;</span>
<a href="#l8.1719"></a><span id="l8.1719" class="difflineminus">-    statement.bindInt64Parameter(0, aConversationID); </span>
<a href="#l8.1720"></a><span id="l8.1720" class="difflineminus">-    </span>
<a href="#l8.1721"></a><span id="l8.1721" class="difflineplus">+    statement.bindInt64Parameter(0, aConversationID);</span>
<a href="#l8.1722"></a><span id="l8.1722" class="difflineplus">+</span>
<a href="#l8.1723"></a><span id="l8.1723">     let messages = [];</span>
<a href="#l8.1724"></a><span id="l8.1724">     while (this._syncStep(statement)) {</span>
<a href="#l8.1725"></a><span id="l8.1725">       messages.push(this._messageFromRow(statement));</span>
<a href="#l8.1726"></a><span id="l8.1726">     }</span>
<a href="#l8.1727"></a><span id="l8.1727">     statement.reset();</span>
<a href="#l8.1728"></a><span id="l8.1728"> </span>
<a href="#l8.1729"></a><span id="l8.1729">     if (messages.length)</span>
<a href="#l8.1730"></a><span id="l8.1730">       GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l8.1731"></a><span id="l8.1731">                                             messages);</span>
<a href="#l8.1732"></a><span id="l8.1732" class="difflineminus">-    </span>
<a href="#l8.1733"></a><span id="l8.1733" class="difflineplus">+</span>
<a href="#l8.1734"></a><span id="l8.1734">     return messages;</span>
<a href="#l8.1735"></a><span id="l8.1735">   },</span>
<a href="#l8.1736"></a><span id="l8.1736" class="difflineminus">-  </span>
<a href="#l8.1737"></a><span id="l8.1737" class="difflineplus">+</span>
<a href="#l8.1738"></a><span id="l8.1738">   /* ********** Message Attributes ********** */</span>
<a href="#l8.1739"></a><span id="l8.1739">   get _insertMessageAttributeStatement() {</span>
<a href="#l8.1740"></a><span id="l8.1740">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1741"></a><span id="l8.1741">       &quot;INSERT INTO messageAttributes (conversationID, messageID, attributeID, \</span>
<a href="#l8.1742"></a><span id="l8.1742">                              value) \</span>
<a href="#l8.1743"></a><span id="l8.1743">               VALUES (?1, ?2, ?3, ?4)&quot;);</span>
<a href="#l8.1744"></a><span id="l8.1744">     this.__defineGetter__(&quot;_insertMessageAttributeStatement&quot;,</span>
<a href="#l8.1745"></a><span id="l8.1745">       function() statement);</span>
<a href="#l8.1746"></a><span id="l8.1746">     return this._insertMessageAttributeStatement;</span>
<a href="#l8.1747"></a><span id="l8.1747">   },</span>
<a href="#l8.1748"></a><span id="l8.1748" class="difflineminus">-  </span>
<a href="#l8.1749"></a><span id="l8.1749" class="difflineplus">+</span>
<a href="#l8.1750"></a><span id="l8.1750">   /**</span>
<a href="#l8.1751"></a><span id="l8.1751">    * Insert a bunch of attributes relating to a GlodaMessage.  This is performed</span>
<a href="#l8.1752"></a><span id="l8.1752">    *  inside a pseudo-transaction (we create one if we aren't in one, using</span>
<a href="#l8.1753"></a><span id="l8.1753">    *  our _beginTransaction wrapper, but if we are in one, no additional</span>
<a href="#l8.1754"></a><span id="l8.1754">    *  meaningful semantics are added).</span>
<a href="#l8.1755"></a><span id="l8.1755">    * No attempt is made to verify uniqueness of inserted attributes, either</span>
<a href="#l8.1756"></a><span id="l8.1756">    *  against the current database or within the provided list of attributes.</span>
<a href="#l8.1757"></a><span id="l8.1757">    *  The caller is responsible for ensuring that unwanted duplicates are</span>
<a href="#l8.1758"></a><span id="l8.1758" class="difflineat">@@ -1814,25 +1843,25 @@ var GlodaDatastore = {</span>
<a href="#l8.1759"></a><span id="l8.1759">         if (attribValueTuple[1] == null)</span>
<a href="#l8.1760"></a><span id="l8.1760">           imas.bindInt64Parameter(3, 0);</span>
<a href="#l8.1761"></a><span id="l8.1761">         else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l8.1762"></a><span id="l8.1762">           imas.bindInt64Parameter(3, attribValueTuple[1]);</span>
<a href="#l8.1763"></a><span id="l8.1763">         else</span>
<a href="#l8.1764"></a><span id="l8.1764">           imas.bindDoubleParameter(3, attribValueTuple[1]);</span>
<a href="#l8.1765"></a><span id="l8.1765">         imas.executeAsync(this.trackAsync());</span>
<a href="#l8.1766"></a><span id="l8.1766">       }</span>
<a href="#l8.1767"></a><span id="l8.1767" class="difflineminus">-      </span>
<a href="#l8.1768"></a><span id="l8.1768" class="difflineplus">+</span>
<a href="#l8.1769"></a><span id="l8.1769">       this._commitTransaction();</span>
<a href="#l8.1770"></a><span id="l8.1770">     }</span>
<a href="#l8.1771"></a><span id="l8.1771">     catch (ex) {</span>
<a href="#l8.1772"></a><span id="l8.1772">       this._rollbackTransaction();</span>
<a href="#l8.1773"></a><span id="l8.1773">       throw ex;</span>
<a href="#l8.1774"></a><span id="l8.1774">     }</span>
<a href="#l8.1775"></a><span id="l8.1775">   },</span>
<a href="#l8.1776"></a><span id="l8.1776" class="difflineminus">-  </span>
<a href="#l8.1777"></a><span id="l8.1777" class="difflineplus">+</span>
<a href="#l8.1778"></a><span id="l8.1778">   get _deleteMessageAttributesByMessageIDStatement() {</span>
<a href="#l8.1779"></a><span id="l8.1779">     let statement = this._createAsyncStatement(</span>
<a href="#l8.1780"></a><span id="l8.1780">       &quot;DELETE FROM messageAttributes WHERE messageID = ?1&quot;);</span>
<a href="#l8.1781"></a><span id="l8.1781">     this.__defineGetter__(&quot;_deleteMessageAttributesByMessageIDStatement&quot;,</span>
<a href="#l8.1782"></a><span id="l8.1782">       function() statement);</span>
<a href="#l8.1783"></a><span id="l8.1783">     return this._deleteMessageAttributesByMessageIDStatement;</span>
<a href="#l8.1784"></a><span id="l8.1784">   },</span>
<a href="#l8.1785"></a><span id="l8.1785"> </span>
<a href="#l8.1786"></a><span id="l8.1786" class="difflineat">@@ -1847,111 +1876,177 @@ var GlodaDatastore = {</span>
<a href="#l8.1787"></a><span id="l8.1787">   clearMessageAttributes: function gloda_ds_clearMessageAttributes(aMessage) {</span>
<a href="#l8.1788"></a><span id="l8.1788">     if (aMessage.id != null) {</span>
<a href="#l8.1789"></a><span id="l8.1789">       this._deleteMessageAttributesByMessageIDStatement.bindInt64Parameter(0,</span>
<a href="#l8.1790"></a><span id="l8.1790">         aMessage.id);</span>
<a href="#l8.1791"></a><span id="l8.1791">       this._deleteMessageAttributesByMessageIDStatement.executeAsync(</span>
<a href="#l8.1792"></a><span id="l8.1792">         this.trackAsync());</span>
<a href="#l8.1793"></a><span id="l8.1793">     }</span>
<a href="#l8.1794"></a><span id="l8.1794">   },</span>
<a href="#l8.1795"></a><span id="l8.1795" class="difflineminus">-  </span>
<a href="#l8.1796"></a><span id="l8.1796" class="difflineplus">+</span>
<a href="#l8.1797"></a><span id="l8.1797">   get _selectMessageAttributesByMessageIDStatement() {</span>
<a href="#l8.1798"></a><span id="l8.1798">     let statement = this._createSyncStatement(</span>
<a href="#l8.1799"></a><span id="l8.1799">       &quot;SELECT attributeID, value FROM messageAttributes \</span>
<a href="#l8.1800"></a><span id="l8.1800">          WHERE messageID = ?1&quot;);</span>
<a href="#l8.1801"></a><span id="l8.1801">     this.__defineGetter__(&quot;_selectMessageAttributesByMessageIDStatement&quot;,</span>
<a href="#l8.1802"></a><span id="l8.1802">       function() statement);</span>
<a href="#l8.1803"></a><span id="l8.1803">     return this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l8.1804"></a><span id="l8.1804">   },</span>
<a href="#l8.1805"></a><span id="l8.1805" class="difflineminus">-  </span>
<a href="#l8.1806"></a><span id="l8.1806" class="difflineplus">+</span>
<a href="#l8.1807"></a><span id="l8.1807">   /**</span>
<a href="#l8.1808"></a><span id="l8.1808">    * Look-up the attributes associated with the given GlodaMessage instance,</span>
<a href="#l8.1809"></a><span id="l8.1809">    *  returning them in APV form (a tuple of Attribute definition object,</span>
<a href="#l8.1810"></a><span id="l8.1810">    *  attribute Parameter, and attribute Value).</span>
<a href="#l8.1811"></a><span id="l8.1811">    *</span>
<a href="#l8.1812"></a><span id="l8.1812">    * @param aMessage The GlodaMessage whose attributes you want retrieved.</span>
<a href="#l8.1813"></a><span id="l8.1813">    * @return An APV list of the attributes.</span>
<a href="#l8.1814"></a><span id="l8.1814">    */</span>
<a href="#l8.1815"></a><span id="l8.1815">   getMessageAttributes: function gloda_ds_getMessageAttributes(aMessage) {</span>
<a href="#l8.1816"></a><span id="l8.1816">     // A list of [attribute def object, (attr) parameter value, attribute value]</span>
<a href="#l8.1817"></a><span id="l8.1817">     let attribParamVals = []</span>
<a href="#l8.1818"></a><span id="l8.1818" class="difflineminus">-    </span>
<a href="#l8.1819"></a><span id="l8.1819" class="difflineplus">+</span>
<a href="#l8.1820"></a><span id="l8.1820">     let smas = this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l8.1821"></a><span id="l8.1821" class="difflineminus">-    </span>
<a href="#l8.1822"></a><span id="l8.1822" class="difflineplus">+</span>
<a href="#l8.1823"></a><span id="l8.1823">     smas.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l8.1824"></a><span id="l8.1824">     while (this._syncStep(smas)) {</span>
<a href="#l8.1825"></a><span id="l8.1825">       let attributeID = smas.getInt64(0);</span>
<a href="#l8.1826"></a><span id="l8.1826">       if (!(attributeID in this._attributeIDToDef)) {</span>
<a href="#l8.1827"></a><span id="l8.1827">         this._log.error(&quot;Attribute ID &quot; + attributeID + &quot; not in our map!&quot;);</span>
<a href="#l8.1828"></a><span id="l8.1828" class="difflineminus">-      } </span>
<a href="#l8.1829"></a><span id="l8.1829" class="difflineplus">+      }</span>
<a href="#l8.1830"></a><span id="l8.1830">       let attribAndParam = this._attributeIDToDef[attributeID];</span>
<a href="#l8.1831"></a><span id="l8.1831">       let val = smas.getDouble(1);</span>
<a href="#l8.1832"></a><span id="l8.1832">       attribParamVals.push([attribAndParam[0], attribAndParam[1], val]);</span>
<a href="#l8.1833"></a><span id="l8.1833">     }</span>
<a href="#l8.1834"></a><span id="l8.1834">     smas.reset();</span>
<a href="#l8.1835"></a><span id="l8.1835" class="difflineminus">-    </span>
<a href="#l8.1836"></a><span id="l8.1836" class="difflineplus">+</span>
<a href="#l8.1837"></a><span id="l8.1837">     return attribParamVals;</span>
<a href="#l8.1838"></a><span id="l8.1838">   },</span>
<a href="#l8.1839"></a><span id="l8.1839" class="difflineminus">-  </span>
<a href="#l8.1840"></a><span id="l8.1840" class="difflineplus">+</span>
<a href="#l8.1841"></a><span id="l8.1841">   _stringSQLQuoter: function(aString) {</span>
<a href="#l8.1842"></a><span id="l8.1842">     return &quot;'&quot; + aString.replace(&quot;'&quot;, &quot;''&quot;, &quot;g&quot;) + &quot;'&quot;;</span>
<a href="#l8.1843"></a><span id="l8.1843">   },</span>
<a href="#l8.1844"></a><span id="l8.1844">   _numberQuoter: function(aNum) {</span>
<a href="#l8.1845"></a><span id="l8.1845">     return aNum;</span>
<a href="#l8.1846"></a><span id="l8.1846">   },</span>
<a href="#l8.1847"></a><span id="l8.1847" class="difflineplus">+</span>
<a href="#l8.1848"></a><span id="l8.1848" class="difflineplus">+  /* ===== Generic Attribute Support ===== */</span>
<a href="#l8.1849"></a><span id="l8.1849" class="difflineplus">+  insertAttributes: function gloda_ds_insertAttributes(aItem,</span>
<a href="#l8.1850"></a><span id="l8.1850" class="difflineplus">+                                        aAttributes) {</span>
<a href="#l8.1851"></a><span id="l8.1851" class="difflineplus">+    let nounMeta = aItem.NOUN_META;</span>
<a href="#l8.1852"></a><span id="l8.1852" class="difflineplus">+    let dbMeta = nounMeta._dbMeta;</span>
<a href="#l8.1853"></a><span id="l8.1853" class="difflineplus">+    if (dbMeta.insertAttrStatement === undefined) {</span>
<a href="#l8.1854"></a><span id="l8.1854" class="difflineplus">+      dbMeta.insertAttrStatement = this._createAsyncStatement(</span>
<a href="#l8.1855"></a><span id="l8.1855" class="difflineplus">+        &quot;INSERT INTO &quot; + nounMeta.attrTableName +</span>
<a href="#l8.1856"></a><span id="l8.1856" class="difflineplus">+        &quot; (&quot; + nounMeta.attrIDColumnName + &quot;, attributeID, value) &quot; +</span>
<a href="#l8.1857"></a><span id="l8.1857" class="difflineplus">+        &quot; VALUES (?1, ?2, ?3)&quot;);</span>
<a href="#l8.1858"></a><span id="l8.1858" class="difflineplus">+    }</span>
<a href="#l8.1859"></a><span id="l8.1859" class="difflineplus">+</span>
<a href="#l8.1860"></a><span id="l8.1860" class="difflineplus">+    let ias = dbMeta.insertAttrStatement;</span>
<a href="#l8.1861"></a><span id="l8.1861" class="difflineplus">+    this._beginTransaction();</span>
<a href="#l8.1862"></a><span id="l8.1862" class="difflineplus">+    try {</span>
<a href="#l8.1863"></a><span id="l8.1863" class="difflineplus">+      for (let iAttribute = 0; iAttribute &lt; aAttributes.length; iAttribute++) {</span>
<a href="#l8.1864"></a><span id="l8.1864" class="difflineplus">+        let attribValueTuple = aAttributes[iAttribute];</span>
<a href="#l8.1865"></a><span id="l8.1865" class="difflineplus">+</span>
<a href="#l8.1866"></a><span id="l8.1866" class="difflineplus">+        ias.bindInt64Parameter(0, aItem.id);</span>
<a href="#l8.1867"></a><span id="l8.1867" class="difflineplus">+        ias.bindInt64Parameter(1, attribValueTuple[0]);</span>
<a href="#l8.1868"></a><span id="l8.1868" class="difflineplus">+        // use 0 instead of null, otherwise the db gets upset.  (and we don't</span>
<a href="#l8.1869"></a><span id="l8.1869" class="difflineplus">+        //  really care anyways.)</span>
<a href="#l8.1870"></a><span id="l8.1870" class="difflineplus">+        if (attribValueTuple[1] == null)</span>
<a href="#l8.1871"></a><span id="l8.1871" class="difflineplus">+          ias.bindInt64Parameter(2, 0);</span>
<a href="#l8.1872"></a><span id="l8.1872" class="difflineplus">+        else if (Math.floor(attribValueTuple[1]) == attribValueTuple[1])</span>
<a href="#l8.1873"></a><span id="l8.1873" class="difflineplus">+          ias.bindInt64Parameter(2, attribValueTuple[1]);</span>
<a href="#l8.1874"></a><span id="l8.1874" class="difflineplus">+        else</span>
<a href="#l8.1875"></a><span id="l8.1875" class="difflineplus">+          ias.bindDoubleParameter(2, attribValueTuple[1]);</span>
<a href="#l8.1876"></a><span id="l8.1876" class="difflineplus">+        ias.executeAsync(this.trackAsync());</span>
<a href="#l8.1877"></a><span id="l8.1877" class="difflineplus">+      }</span>
<a href="#l8.1878"></a><span id="l8.1878" class="difflineplus">+</span>
<a href="#l8.1879"></a><span id="l8.1879" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l8.1880"></a><span id="l8.1880" class="difflineplus">+    }</span>
<a href="#l8.1881"></a><span id="l8.1881" class="difflineplus">+    catch (ex) {</span>
<a href="#l8.1882"></a><span id="l8.1882" class="difflineplus">+      this._rollbackTransaction();</span>
<a href="#l8.1883"></a><span id="l8.1883" class="difflineplus">+      throw ex;</span>
<a href="#l8.1884"></a><span id="l8.1884" class="difflineplus">+    }</span>
<a href="#l8.1885"></a><span id="l8.1885" class="difflineplus">+  },</span>
<a href="#l8.1886"></a><span id="l8.1886" class="difflineplus">+</span>
<a href="#l8.1887"></a><span id="l8.1887" class="difflineplus">+  clearAttributes: function gloda_ds_clearAttributes(aItem) {</span>
<a href="#l8.1888"></a><span id="l8.1888" class="difflineplus">+    let nounMeta = aItem.NOUN_META;</span>
<a href="#l8.1889"></a><span id="l8.1889" class="difflineplus">+    let dbMeta = nounMeta._dbMeta;</span>
<a href="#l8.1890"></a><span id="l8.1890" class="difflineplus">+    if (dbMeta.clearAttrStatement === undefined) {</span>
<a href="#l8.1891"></a><span id="l8.1891" class="difflineplus">+      dbMeta.clearAttrStatement = this._createAsyncStatement(</span>
<a href="#l8.1892"></a><span id="l8.1892" class="difflineplus">+        &quot;DELETE FROM &quot; + nounMeta.attrTableName + &quot; WHERE &quot; +</span>
<a href="#l8.1893"></a><span id="l8.1893" class="difflineplus">+        nounMeta.attrIDColumnName + &quot; = ?1&quot;);</span>
<a href="#l8.1894"></a><span id="l8.1894" class="difflineplus">+    }</span>
<a href="#l8.1895"></a><span id="l8.1895">   </span>
<a href="#l8.1896"></a><span id="l8.1896" class="difflineplus">+    if (aItem.id != null) {</span>
<a href="#l8.1897"></a><span id="l8.1897" class="difflineplus">+      dbMeta.clearAttrStatement.bindInt64Parameter(0, aItem.id);</span>
<a href="#l8.1898"></a><span id="l8.1898" class="difflineplus">+      dbMeta.clearAttrStatement.executeAsync(this.trackAsync());</span>
<a href="#l8.1899"></a><span id="l8.1899" class="difflineplus">+    }</span>
<a href="#l8.1900"></a><span id="l8.1900" class="difflineplus">+  },</span>
<a href="#l8.1901"></a><span id="l8.1901" class="difflineplus">+</span>
<a href="#l8.1902"></a><span id="l8.1902" class="difflineplus">+  /**</span>
<a href="#l8.1903"></a><span id="l8.1903" class="difflineplus">+   * escapeStringForLIKE is only available on statements, and sometimes we want</span>
<a href="#l8.1904"></a><span id="l8.1904" class="difflineplus">+   *  to use it before we create our statement, so we create a statement just</span>
<a href="#l8.1905"></a><span id="l8.1905" class="difflineplus">+   *  for this reason.</span>
<a href="#l8.1906"></a><span id="l8.1906" class="difflineplus">+   */</span>
<a href="#l8.1907"></a><span id="l8.1907" class="difflineplus">+  get _escapeLikeStatement() {</span>
<a href="#l8.1908"></a><span id="l8.1908" class="difflineplus">+    let statement = this._createAsyncStatement(&quot;SELECT 0&quot;);</span>
<a href="#l8.1909"></a><span id="l8.1909" class="difflineplus">+    this.__defineGetter__(&quot;_escapeLikeStatement&quot;, function() statement);</span>
<a href="#l8.1910"></a><span id="l8.1910" class="difflineplus">+    return this._escapeLikeStatement;</span>
<a href="#l8.1911"></a><span id="l8.1911" class="difflineplus">+  },</span>
<a href="#l8.1912"></a><span id="l8.1912" class="difflineplus">+</span>
<a href="#l8.1913"></a><span id="l8.1913">   /**</span>
<a href="#l8.1914"></a><span id="l8.1914">    * Perform a database query given a GlodaQueryClass instance that specifies</span>
<a href="#l8.1915"></a><span id="l8.1915">    *  a set of constraints relating to the noun type associated with the query.</span>
<a href="#l8.1916"></a><span id="l8.1916">    *  A GlodaCollection is returned containing the results of the look-up.</span>
<a href="#l8.1917"></a><span id="l8.1917">    *  By default the collection is &quot;live&quot;, and will mutate (generating events to</span>
<a href="#l8.1918"></a><span id="l8.1918">    *  its listener) as the state of the database changes.</span>
<a href="#l8.1919"></a><span id="l8.1919">    * This functionality is made user/extension visible by the Query's</span>
<a href="#l8.1920"></a><span id="l8.1920">    *  getCollection (asynchronous) and getAllSync (synchronous).</span>
<a href="#l8.1921"></a><span id="l8.1921">    */</span>
<a href="#l8.1922"></a><span id="l8.1922">   queryFromQuery: function gloda_ds_queryFromQuery(aQuery, aListener, bSynchronous) {</span>
<a href="#l8.1923"></a><span id="l8.1923">     // when changing this method, be sure that GlodaQuery's testMatch function</span>
<a href="#l8.1924"></a><span id="l8.1924">     //  likewise has its changes made.</span>
<a href="#l8.1925"></a><span id="l8.1925">     let nounMeta = aQuery._nounMeta;</span>
<a href="#l8.1926"></a><span id="l8.1926" class="difflineminus">-    </span>
<a href="#l8.1927"></a><span id="l8.1927" class="difflineplus">+</span>
<a href="#l8.1928"></a><span id="l8.1928">     let whereClauses = [];</span>
<a href="#l8.1929"></a><span id="l8.1929">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l8.1930"></a><span id="l8.1930" class="difflineminus">-    </span>
<a href="#l8.1931"></a><span id="l8.1931" class="difflineplus">+    let boundArgs = [];</span>
<a href="#l8.1932"></a><span id="l8.1932" class="difflineplus">+</span>
<a href="#l8.1933"></a><span id="l8.1933">     for (let iUnion = 0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l8.1934"></a><span id="l8.1934">       let curQuery = unionQueries[iUnion];</span>
<a href="#l8.1935"></a><span id="l8.1935">       let selects = [];</span>
<a href="#l8.1936"></a><span id="l8.1936" class="difflineminus">-      </span>
<a href="#l8.1937"></a><span id="l8.1937" class="difflineminus">-      for (let iConstraint = 0; iConstraint &lt; curQuery._constraints.length; </span>
<a href="#l8.1938"></a><span id="l8.1938" class="difflineplus">+</span>
<a href="#l8.1939"></a><span id="l8.1939" class="difflineplus">+      for (let iConstraint = 0; iConstraint &lt; curQuery._constraints.length;</span>
<a href="#l8.1940"></a><span id="l8.1940">            iConstraint++) {</span>
<a href="#l8.1941"></a><span id="l8.1941">         let attr_ors = curQuery._constraints[iConstraint];</span>
<a href="#l8.1942"></a><span id="l8.1942" class="difflineminus">-        </span>
<a href="#l8.1943"></a><span id="l8.1943" class="difflineplus">+</span>
<a href="#l8.1944"></a><span id="l8.1944">         let lastAttributeID = null;</span>
<a href="#l8.1945"></a><span id="l8.1945">         let attrValueTests = [];</span>
<a href="#l8.1946"></a><span id="l8.1946">         let valueTests = null;</span>
<a href="#l8.1947"></a><span id="l8.1947" class="difflineminus">-        </span>
<a href="#l8.1948"></a><span id="l8.1948" class="difflineplus">+</span>
<a href="#l8.1949"></a><span id="l8.1949">         // our implementation requires that everyone in attr_ors has the same</span>
<a href="#l8.1950"></a><span id="l8.1950">         //  attribute.</span>
<a href="#l8.1951"></a><span id="l8.1951">         let presumedAttr = attr_ors[0][0];</span>
<a href="#l8.1952"></a><span id="l8.1952" class="difflineminus">-        </span>
<a href="#l8.1953"></a><span id="l8.1953" class="difflineplus">+</span>
<a href="#l8.1954"></a><span id="l8.1954">         // -- handle full-text specially here, it's different than the other</span>
<a href="#l8.1955"></a><span id="l8.1955">         //  cases...</span>
<a href="#l8.1956"></a><span id="l8.1956">         if (presumedAttr.special == kSpecialFulltext) {</span>
<a href="#l8.1957"></a><span id="l8.1957">           let matchStr = [APV[2] for each (APV in attr_ors)].join(&quot; OR &quot;);</span>
<a href="#l8.1958"></a><span id="l8.1958">           matchStr.replace(&quot;'&quot;, &quot;''&quot;);</span>
<a href="#l8.1959"></a><span id="l8.1959" class="difflineminus">-        </span>
<a href="#l8.1960"></a><span id="l8.1960" class="difflineminus">-          // for example, the match </span>
<a href="#l8.1961"></a><span id="l8.1961" class="difflineplus">+</span>
<a href="#l8.1962"></a><span id="l8.1962" class="difflineplus">+          // for example, the match</span>
<a href="#l8.1963"></a><span id="l8.1963">           let ftSelect = &quot;SELECT docid FROM &quot; + nounMeta.tableName + &quot;Text&quot; +</span>
<a href="#l8.1964"></a><span id="l8.1964">             &quot; WHERE &quot; + presumedAttr.specialColumnName + &quot; MATCH '&quot; +</span>
<a href="#l8.1965"></a><span id="l8.1965">             matchStr + &quot;'&quot;;</span>
<a href="#l8.1966"></a><span id="l8.1966">           selects.push(ftSelect);</span>
<a href="#l8.1967"></a><span id="l8.1967" class="difflineminus">-        </span>
<a href="#l8.1968"></a><span id="l8.1968" class="difflineplus">+</span>
<a href="#l8.1969"></a><span id="l8.1969">           // bypass the logic used by the other cases</span>
<a href="#l8.1970"></a><span id="l8.1970">           continue;</span>
<a href="#l8.1971"></a><span id="l8.1971">         }</span>
<a href="#l8.1972"></a><span id="l8.1972" class="difflineminus">-        </span>
<a href="#l8.1973"></a><span id="l8.1973" class="difflineplus">+</span>
<a href="#l8.1974"></a><span id="l8.1974">         let tableName, idColumnName, valueColumnName, valueQuoter;</span>
<a href="#l8.1975"></a><span id="l8.1975">         if (presumedAttr.special == kSpecialColumn ||</span>
<a href="#l8.1976"></a><span id="l8.1976">             presumedAttr.special == kSpecialString) {</span>
<a href="#l8.1977"></a><span id="l8.1977">           tableName = nounMeta.tableName;</span>
<a href="#l8.1978"></a><span id="l8.1978">           idColumnName = &quot;id&quot;; // canonical id for a table is &quot;id&quot;.</span>
<a href="#l8.1979"></a><span id="l8.1979">           valueColumnName = presumedAttr.specialColumnName;</span>
<a href="#l8.1980"></a><span id="l8.1980">           if (presumedAttr.special == kSpecialString)</span>
<a href="#l8.1981"></a><span id="l8.1981">             valueQuoter = this._stringSQLQuoter;</span>
<a href="#l8.1982"></a><span id="l8.1982" class="difflineat">@@ -1959,47 +2054,47 @@ var GlodaDatastore = {</span>
<a href="#l8.1983"></a><span id="l8.1983">             valueQuoter = this._numberQuoter;</span>
<a href="#l8.1984"></a><span id="l8.1984">         }</span>
<a href="#l8.1985"></a><span id="l8.1985">         else {</span>
<a href="#l8.1986"></a><span id="l8.1986">           tableName = nounMeta.attrTableName;</span>
<a href="#l8.1987"></a><span id="l8.1987">           idColumnName = nounMeta.attrIDColumnName;</span>
<a href="#l8.1988"></a><span id="l8.1988">           valueColumnName = &quot;value&quot;;</span>
<a href="#l8.1989"></a><span id="l8.1989">           valueQuoter = this._numberQuoter;</span>
<a href="#l8.1990"></a><span id="l8.1990">         }</span>
<a href="#l8.1991"></a><span id="l8.1991" class="difflineminus">-        </span>
<a href="#l8.1992"></a><span id="l8.1992" class="difflineplus">+</span>
<a href="#l8.1993"></a><span id="l8.1993">         // we want a net 'or' for everyone in here, where 'everyone' is presumed</span>
<a href="#l8.1994"></a><span id="l8.1994">         //  to have been generated from a single attribute.  Since a single</span>
<a href="#l8.1995"></a><span id="l8.1995">         //  attribute can actually map to multiple attribute id's because of the</span>
<a href="#l8.1996"></a><span id="l8.1996">         //  parameters, we actually need to make this slightly more complicated</span>
<a href="#l8.1997"></a><span id="l8.1997">         //  than it could be.  We want to OR together the clauses for testing</span>
<a href="#l8.1998"></a><span id="l8.1998">         //  each attributeID, where within each clause we OR the value.</span>
<a href="#l8.1999"></a><span id="l8.1999">         // ex: (attributeID=1 AND (value=1 OR value=2)) OR (attributeID=2 AND</span>
<a href="#l8.2000"></a><span id="l8.2000">         //      (value=7))</span>
<a href="#l8.2001"></a><span id="l8.2001">         // note that we don't consolidate things into an IN clause (although</span>
<a href="#l8.2002"></a><span id="l8.2002">         //  we could) and it's okay because the optimizer makes all such things</span>
<a href="#l8.2003"></a><span id="l8.2003">         //  equal.</span>
<a href="#l8.2004"></a><span id="l8.2004">         for (let iOrIndex = 0; iOrIndex &lt; attr_ors.length; iOrIndex++) {</span>
<a href="#l8.2005"></a><span id="l8.2005">           let APV = attr_ors[iOrIndex];</span>
<a href="#l8.2006"></a><span id="l8.2006" class="difflineminus">-        </span>
<a href="#l8.2007"></a><span id="l8.2007" class="difflineplus">+</span>
<a href="#l8.2008"></a><span id="l8.2008">           let attributeID;</span>
<a href="#l8.2009"></a><span id="l8.2009">           if (APV[1] != null)</span>
<a href="#l8.2010"></a><span id="l8.2010">             attributeID = APV[0].bindParameter(APV[1]);</span>
<a href="#l8.2011"></a><span id="l8.2011">           else</span>
<a href="#l8.2012"></a><span id="l8.2012">             attributeID = APV[0].id;</span>
<a href="#l8.2013"></a><span id="l8.2013">           if (attributeID != lastAttributeID) {</span>
<a href="#l8.2014"></a><span id="l8.2014">             valueTests = [];</span>
<a href="#l8.2015"></a><span id="l8.2015">             if (APV[0].special == kSpecialColumn ||</span>
<a href="#l8.2016"></a><span id="l8.2016">                 APV[0].special == kSpecialString)</span>
<a href="#l8.2017"></a><span id="l8.2017">               attrValueTests.push([&quot;&quot;, valueTests]);</span>
<a href="#l8.2018"></a><span id="l8.2018">             else</span>
<a href="#l8.2019"></a><span id="l8.2019">               attrValueTests.push([&quot;attributeID = &quot; + attributeID + &quot; AND &quot;,</span>
<a href="#l8.2020"></a><span id="l8.2020">                                    valueTests]);</span>
<a href="#l8.2021"></a><span id="l8.2021">             lastAttributeID = attributeID;</span>
<a href="#l8.2022"></a><span id="l8.2022">           }</span>
<a href="#l8.2023"></a><span id="l8.2023" class="difflineminus">-          </span>
<a href="#l8.2024"></a><span id="l8.2024" class="difflineplus">+</span>
<a href="#l8.2025"></a><span id="l8.2025">           // straight value match?</span>
<a href="#l8.2026"></a><span id="l8.2026">           if (APV.length == 3) {</span>
<a href="#l8.2027"></a><span id="l8.2027">             if (APV[2] != null)</span>
<a href="#l8.2028"></a><span id="l8.2028">               valueTests.push(valueColumnName + &quot; = &quot; + valueQuoter(APV[2]));</span>
<a href="#l8.2029"></a><span id="l8.2029">           }</span>
<a href="#l8.2030"></a><span id="l8.2030">           // (quoting is not required for ranges because we only support ranges</span>
<a href="#l8.2031"></a><span id="l8.2031">           //  for numbers.  as such, no use of valueQuoter in here.)</span>
<a href="#l8.2032"></a><span id="l8.2032">           else { // APV.length == 4, so range match</span>
<a href="#l8.2033"></a><span id="l8.2033" class="difflineat">@@ -2014,80 +2109,96 @@ var GlodaDatastore = {</span>
<a href="#l8.2034"></a><span id="l8.2034">               else</span>
<a href="#l8.2035"></a><span id="l8.2035">                 valueTests.push(valueColumnName + &quot; BETWEEN &quot; + APV[2] +</span>
<a href="#l8.2036"></a><span id="l8.2036">                                   &quot; AND &quot; + APV[3]);</span>
<a href="#l8.2037"></a><span id="l8.2037">             }</span>
<a href="#l8.2038"></a><span id="l8.2038">             // - string case (LIKE)</span>
<a href="#l8.2039"></a><span id="l8.2039">             else {</span>
<a href="#l8.2040"></a><span id="l8.2040">               // this will result in a warning in debug builds.  as we move to</span>
<a href="#l8.2041"></a><span id="l8.2041">               //  supporting async operation, we should also move to binding all</span>
<a href="#l8.2042"></a><span id="l8.2042" class="difflineminus">-              //  arguments for dynamic queries too. </span>
<a href="#l8.2043"></a><span id="l8.2043" class="difflineminus">-              valueTests.push(valueColumnName + &quot; LIKE &quot; + valueQuoter(APV[2]));</span>
<a href="#l8.2044"></a><span id="l8.2044" class="difflineplus">+              //  arguments for dynamic queries too.</span>
<a href="#l8.2045"></a><span id="l8.2045" class="difflineplus">+              likePayload = '';</span>
<a href="#l8.2046"></a><span id="l8.2046" class="difflineplus">+              for each (let valuePart in APV[2]) {</span>
<a href="#l8.2047"></a><span id="l8.2047" class="difflineplus">+                if (typeof valuePart == &quot;string&quot;)</span>
<a href="#l8.2048"></a><span id="l8.2048" class="difflineplus">+                  likePayload += this._escapeLikeStatement.escapeStringForLIKE(</span>
<a href="#l8.2049"></a><span id="l8.2049" class="difflineplus">+                    valuePart, &quot;/&quot;);</span>
<a href="#l8.2050"></a><span id="l8.2050" class="difflineplus">+                else</span>
<a href="#l8.2051"></a><span id="l8.2051" class="difflineplus">+                  likePayload += &quot;%&quot;;</span>
<a href="#l8.2052"></a><span id="l8.2052" class="difflineplus">+              }</span>
<a href="#l8.2053"></a><span id="l8.2053" class="difflineplus">+              valueTests.push(valueColumnName + &quot; LIKE ? ESCAPE '/'&quot;);</span>
<a href="#l8.2054"></a><span id="l8.2054" class="difflineplus">+              boundArgs.push(likePayload);</span>
<a href="#l8.2055"></a><span id="l8.2055">             }</span>
<a href="#l8.2056"></a><span id="l8.2056">           }</span>
<a href="#l8.2057"></a><span id="l8.2057">         }</span>
<a href="#l8.2058"></a><span id="l8.2058" class="difflineminus">-        let select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName + </span>
<a href="#l8.2059"></a><span id="l8.2059" class="difflineplus">+        let select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName +</span>
<a href="#l8.2060"></a><span id="l8.2060">                      &quot; WHERE &quot; +</span>
<a href="#l8.2061"></a><span id="l8.2061">                      [(&quot;(&quot; + avt[0] + &quot;(&quot; + avt[1].join(&quot; OR &quot;) + &quot;))&quot;)</span>
<a href="#l8.2062"></a><span id="l8.2062">                       for each (avt in attrValueTests)].join(&quot; OR &quot;);</span>
<a href="#l8.2063"></a><span id="l8.2063">         selects.push(select);</span>
<a href="#l8.2064"></a><span id="l8.2064">       }</span>
<a href="#l8.2065"></a><span id="l8.2065" class="difflineminus">-      </span>
<a href="#l8.2066"></a><span id="l8.2066" class="difflineplus">+</span>
<a href="#l8.2067"></a><span id="l8.2067">       if (selects.length)</span>
<a href="#l8.2068"></a><span id="l8.2068">         whereClauses.push(&quot;id IN (&quot; + selects.join(&quot; INTERSECT &quot;) + &quot; )&quot;);</span>
<a href="#l8.2069"></a><span id="l8.2069">     }</span>
<a href="#l8.2070"></a><span id="l8.2070" class="difflineminus">-    </span>
<a href="#l8.2071"></a><span id="l8.2071" class="difflineplus">+</span>
<a href="#l8.2072"></a><span id="l8.2072">     let sqlString = &quot;SELECT * FROM &quot; + nounMeta.tableName;</span>
<a href="#l8.2073"></a><span id="l8.2073">     if (whereClauses.length)</span>
<a href="#l8.2074"></a><span id="l8.2074">       sqlString += &quot; WHERE &quot; + whereClauses.join(&quot; OR &quot;);</span>
<a href="#l8.2075"></a><span id="l8.2075" class="difflineminus">-    </span>
<a href="#l8.2076"></a><span id="l8.2076" class="difflineplus">+</span>
<a href="#l8.2077"></a><span id="l8.2077">     this._log.debug(&quot;QUERY FROM QUERY: &quot; + sqlString);</span>
<a href="#l8.2078"></a><span id="l8.2078" class="difflineminus">-    </span>
<a href="#l8.2079"></a><span id="l8.2079" class="difflineplus">+</span>
<a href="#l8.2080"></a><span id="l8.2080">     let collection;</span>
<a href="#l8.2081"></a><span id="l8.2081">     if (bSynchronous) {</span>
<a href="#l8.2082"></a><span id="l8.2082">       let statement = this._createSyncStatement(sqlString, true);</span>
<a href="#l8.2083"></a><span id="l8.2083" class="difflineminus">-    </span>
<a href="#l8.2084"></a><span id="l8.2084" class="difflineplus">+      for (let [iBinding, bindingValue] in Iterator(boundArgs)) {</span>
<a href="#l8.2085"></a><span id="l8.2085" class="difflineplus">+        this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l8.2086"></a><span id="l8.2086" class="difflineplus">+      }</span>
<a href="#l8.2087"></a><span id="l8.2087" class="difflineplus">+</span>
<a href="#l8.2088"></a><span id="l8.2088">       let items = [];</span>
<a href="#l8.2089"></a><span id="l8.2089">       while (this._syncStep(statement)) {</span>
<a href="#l8.2090"></a><span id="l8.2090">         items.push(nounMeta.objFromRow.call(nounMeta.datastore, statement));</span>
<a href="#l8.2091"></a><span id="l8.2091">       }</span>
<a href="#l8.2092"></a><span id="l8.2092">       statement.finalize();</span>
<a href="#l8.2093"></a><span id="l8.2093" class="difflineminus">-      </span>
<a href="#l8.2094"></a><span id="l8.2094" class="difflineplus">+</span>
<a href="#l8.2095"></a><span id="l8.2095">       // have the collection manager attempt to replace the instances we just</span>
<a href="#l8.2096"></a><span id="l8.2096">       //  created with pre-existing instances.  if the instance didn't exist,</span>
<a href="#l8.2097"></a><span id="l8.2097">       //  cache the newly observed ones.  We are trading off wastes here; we don't</span>
<a href="#l8.2098"></a><span id="l8.2098">       //  want to have to ask the collection manager about every row, and we don't</span>
<a href="#l8.2099"></a><span id="l8.2099">       //  want to invent some alternate row storage.</span>
<a href="#l8.2100"></a><span id="l8.2100">       GlodaCollectionManager.cacheLoadUnify(nounMeta.id, items);</span>
<a href="#l8.2101"></a><span id="l8.2101">       collection = new GlodaCollection(nounMeta, items, aQuery, aListener);</span>
<a href="#l8.2102"></a><span id="l8.2102" class="difflineminus">-      </span>
<a href="#l8.2103"></a><span id="l8.2103" class="difflineplus">+</span>
<a href="#l8.2104"></a><span id="l8.2104">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l8.2105"></a><span id="l8.2105">     }</span>
<a href="#l8.2106"></a><span id="l8.2106">     else { // async!</span>
<a href="#l8.2107"></a><span id="l8.2107">       let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l8.2108"></a><span id="l8.2108" class="difflineminus">-      let collection = new GlodaCollection(nounMeta, [], aQuery, aListener);    </span>
<a href="#l8.2109"></a><span id="l8.2109" class="difflineplus">+      for (let [iBinding, bindingValue] in Iterator(boundArgs)) {</span>
<a href="#l8.2110"></a><span id="l8.2110" class="difflineplus">+        this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l8.2111"></a><span id="l8.2111" class="difflineplus">+      }</span>
<a href="#l8.2112"></a><span id="l8.2112" class="difflineplus">+</span>
<a href="#l8.2113"></a><span id="l8.2113" class="difflineplus">+      collection = new GlodaCollection(nounMeta, [], aQuery, aListener);</span>
<a href="#l8.2114"></a><span id="l8.2114">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l8.2115"></a><span id="l8.2115"> </span>
<a href="#l8.2116"></a><span id="l8.2116">       statement.executeAsync(new QueryFromQueryCallback(statement, nounMeta,</span>
<a href="#l8.2117"></a><span id="l8.2117">         collection));</span>
<a href="#l8.2118"></a><span id="l8.2118">       statement.finalize();</span>
<a href="#l8.2119"></a><span id="l8.2119">     }</span>
<a href="#l8.2120"></a><span id="l8.2120">     return collection;</span>
<a href="#l8.2121"></a><span id="l8.2121">   },</span>
<a href="#l8.2122"></a><span id="l8.2122" class="difflineminus">-  </span>
<a href="#l8.2123"></a><span id="l8.2123" class="difflineplus">+</span>
<a href="#l8.2124"></a><span id="l8.2124">   /**</span>
<a href="#l8.2125"></a><span id="l8.2125">    * Deprecated, but still in existence for the benefit of expmess code that</span>
<a href="#l8.2126"></a><span id="l8.2126">    *  needs to go away anyways and can take this with it.</span>
<a href="#l8.2127"></a><span id="l8.2127">    */</span>
<a href="#l8.2128"></a><span id="l8.2128">   queryMessagesAPV: function gloda_ds_queryMessagesAPV(aAPVs) {</span>
<a href="#l8.2129"></a><span id="l8.2129">     let selects = [];</span>
<a href="#l8.2130"></a><span id="l8.2130" class="difflineminus">-    </span>
<a href="#l8.2131"></a><span id="l8.2131" class="difflineplus">+</span>
<a href="#l8.2132"></a><span id="l8.2132">     for (let iAPV = 0; iAPV &lt; aAPVs.length; iAPV++) {</span>
<a href="#l8.2133"></a><span id="l8.2133">       let APV = aAPVs[iAPV];</span>
<a href="#l8.2134"></a><span id="l8.2134" class="difflineminus">-      </span>
<a href="#l8.2135"></a><span id="l8.2135" class="difflineplus">+</span>
<a href="#l8.2136"></a><span id="l8.2136">       let attributeID;</span>
<a href="#l8.2137"></a><span id="l8.2137">       if (APV[1] != null)</span>
<a href="#l8.2138"></a><span id="l8.2138">         attributeID = APV[0].bindParameter(APV[1]);</span>
<a href="#l8.2139"></a><span id="l8.2139">       else</span>
<a href="#l8.2140"></a><span id="l8.2140">         attributeID = APV[0].id;</span>
<a href="#l8.2141"></a><span id="l8.2141">       let select = &quot;SELECT messageID FROM messageAttributes WHERE attributeID&quot; +</span>
<a href="#l8.2142"></a><span id="l8.2142">                    &quot; = &quot; + attributeID;</span>
<a href="#l8.2143"></a><span id="l8.2143">       // straight value match?</span>
<a href="#l8.2144"></a><span id="l8.2144" class="difflineat">@@ -2097,256 +2208,256 @@ var GlodaDatastore = {</span>
<a href="#l8.2145"></a><span id="l8.2145">       }</span>
<a href="#l8.2146"></a><span id="l8.2146">       else { // APV.length == 4, so range match</span>
<a href="#l8.2147"></a><span id="l8.2147">         // BETWEEN is optimized to &gt;= and &lt;=, or we could just do that ourself.</span>
<a href="#l8.2148"></a><span id="l8.2148">         //  (in other words, this shouldn't hurt our use of indices)</span>
<a href="#l8.2149"></a><span id="l8.2149">         select += &quot; AND value BETWEEN &quot; + APV[2] + &quot; AND &quot; + APV[3];</span>
<a href="#l8.2150"></a><span id="l8.2150">       }</span>
<a href="#l8.2151"></a><span id="l8.2151">       selects.push(select);</span>
<a href="#l8.2152"></a><span id="l8.2152">     }</span>
<a href="#l8.2153"></a><span id="l8.2153" class="difflineminus">-    </span>
<a href="#l8.2154"></a><span id="l8.2154" class="difflineplus">+</span>
<a href="#l8.2155"></a><span id="l8.2155">     let sqlString = &quot;SELECT * FROM messages WHERE id IN (&quot; +</span>
<a href="#l8.2156"></a><span id="l8.2156">                     selects.join(&quot; INTERSECT &quot;) + &quot; )&quot;;</span>
<a href="#l8.2157"></a><span id="l8.2157">     let statement = this._createSyncStatement(sqlString, true);</span>
<a href="#l8.2158"></a><span id="l8.2158" class="difflineminus">-    </span>
<a href="#l8.2159"></a><span id="l8.2159" class="difflineplus">+</span>
<a href="#l8.2160"></a><span id="l8.2160">     let messages = [];</span>
<a href="#l8.2161"></a><span id="l8.2161">     while (this._syncStep(statement)) {</span>
<a href="#l8.2162"></a><span id="l8.2162">       messages.push(this._messageFromRow(statement));</span>
<a href="#l8.2163"></a><span id="l8.2163">     }</span>
<a href="#l8.2164"></a><span id="l8.2164">     statement.finalize();</span>
<a href="#l8.2165"></a><span id="l8.2165" class="difflineminus">-    </span>
<a href="#l8.2166"></a><span id="l8.2166" class="difflineplus">+</span>
<a href="#l8.2167"></a><span id="l8.2167">     if (messages.length)</span>
<a href="#l8.2168"></a><span id="l8.2168">       GlodaCollectionManager.cacheLoadUnify(GlodaMessage.prototype.NOUN_ID,</span>
<a href="#l8.2169"></a><span id="l8.2169">                                             messages);</span>
<a href="#l8.2170"></a><span id="l8.2170" class="difflineminus">-     </span>
<a href="#l8.2171"></a><span id="l8.2171" class="difflineplus">+</span>
<a href="#l8.2172"></a><span id="l8.2172">     return messages;</span>
<a href="#l8.2173"></a><span id="l8.2173">   },</span>
<a href="#l8.2174"></a><span id="l8.2174" class="difflineminus">-  </span>
<a href="#l8.2175"></a><span id="l8.2175" class="difflineplus">+</span>
<a href="#l8.2176"></a><span id="l8.2176">   /* ********** Contact ********** */</span>
<a href="#l8.2177"></a><span id="l8.2177">   _nextContactId: 1,</span>
<a href="#l8.2178"></a><span id="l8.2178"> </span>
<a href="#l8.2179"></a><span id="l8.2179">   _populateContactManagedId: function () {</span>
<a href="#l8.2180"></a><span id="l8.2180">     let stmt = this._createSyncStatement(&quot;SELECT MAX(id) FROM contacts&quot;, true);</span>
<a href="#l8.2181"></a><span id="l8.2181">     if (stmt.executeStep()) {  // no chance of this SQLITE_BUSY on this call</span>
<a href="#l8.2182"></a><span id="l8.2182">       this._nextContactId = stmt.getInt64(0) + 1;</span>
<a href="#l8.2183"></a><span id="l8.2183">     }</span>
<a href="#l8.2184"></a><span id="l8.2184">     stmt.finalize();</span>
<a href="#l8.2185"></a><span id="l8.2185">   },</span>
<a href="#l8.2186"></a><span id="l8.2186" class="difflineminus">-  </span>
<a href="#l8.2187"></a><span id="l8.2187" class="difflineplus">+</span>
<a href="#l8.2188"></a><span id="l8.2188">   get _insertContactStatement() {</span>
<a href="#l8.2189"></a><span id="l8.2189">     let statement = this._createAsyncStatement(</span>
<a href="#l8.2190"></a><span id="l8.2190">       &quot;INSERT INTO contacts (id, directoryUUID, contactUUID, name, popularity,\</span>
<a href="#l8.2191"></a><span id="l8.2191">                              frecency) \</span>
<a href="#l8.2192"></a><span id="l8.2192">               VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l8.2193"></a><span id="l8.2193">     this.__defineGetter__(&quot;_insertContactStatement&quot;, function() statement);</span>
<a href="#l8.2194"></a><span id="l8.2194" class="difflineminus">-    return this._insertContactStatement; </span>
<a href="#l8.2195"></a><span id="l8.2195" class="difflineplus">+    return this._insertContactStatement;</span>
<a href="#l8.2196"></a><span id="l8.2196">   },</span>
<a href="#l8.2197"></a><span id="l8.2197" class="difflineminus">-  </span>
<a href="#l8.2198"></a><span id="l8.2198" class="difflineplus">+</span>
<a href="#l8.2199"></a><span id="l8.2199">   createContact: function gloda_ds_createContact(aDirectoryUUID, aContactUUID,</span>
<a href="#l8.2200"></a><span id="l8.2200">       aName, aPopularity, aFrecency) {</span>
<a href="#l8.2201"></a><span id="l8.2201">     let contactID = this._nextContactId++;</span>
<a href="#l8.2202"></a><span id="l8.2202">     let ics = this._insertContactStatement;</span>
<a href="#l8.2203"></a><span id="l8.2203">     ics.bindInt64Parameter(0, contactID);</span>
<a href="#l8.2204"></a><span id="l8.2204">     if (aDirectoryUUID == null)</span>
<a href="#l8.2205"></a><span id="l8.2205">       ics.bindNullParameter(1);</span>
<a href="#l8.2206"></a><span id="l8.2206">     else</span>
<a href="#l8.2207"></a><span id="l8.2207">       ics.bindStringParameter(1, aDirectoryUUID);</span>
<a href="#l8.2208"></a><span id="l8.2208">     if (aContactUUID == null)</span>
<a href="#l8.2209"></a><span id="l8.2209">       ics.bindNullParameter(2);</span>
<a href="#l8.2210"></a><span id="l8.2210">     else</span>
<a href="#l8.2211"></a><span id="l8.2211">       ics.bindStringParameter(2, aContactUUID);</span>
<a href="#l8.2212"></a><span id="l8.2212">     ics.bindStringParameter(3, aName);</span>
<a href="#l8.2213"></a><span id="l8.2213">     ics.bindInt64Parameter(4, aPopularity);</span>
<a href="#l8.2214"></a><span id="l8.2214">     ics.bindInt64Parameter(5, aFrecency);</span>
<a href="#l8.2215"></a><span id="l8.2215" class="difflineminus">-    </span>
<a href="#l8.2216"></a><span id="l8.2216" class="difflineplus">+</span>
<a href="#l8.2217"></a><span id="l8.2217">     ics.executeAsync(this.trackAsync());</span>
<a href="#l8.2218"></a><span id="l8.2218" class="difflineminus">-    </span>
<a href="#l8.2219"></a><span id="l8.2219" class="difflineplus">+</span>
<a href="#l8.2220"></a><span id="l8.2220">     let contact = new GlodaContact(this, contactID,</span>
<a href="#l8.2221"></a><span id="l8.2221">                                    aDirectoryUUID, aContactUUID, aName,</span>
<a href="#l8.2222"></a><span id="l8.2222">                                    aPopularity, aFrecency);</span>
<a href="#l8.2223"></a><span id="l8.2223">     GlodaCollectionManager.itemsAdded(contact.NOUN_ID, [contact]);</span>
<a href="#l8.2224"></a><span id="l8.2224">     return contact;</span>
<a href="#l8.2225"></a><span id="l8.2225">   },</span>
<a href="#l8.2226"></a><span id="l8.2226"> </span>
<a href="#l8.2227"></a><span id="l8.2227">   get _updateContactStatement() {</span>
<a href="#l8.2228"></a><span id="l8.2228">     let statement = this._createAsyncStatement(</span>
<a href="#l8.2229"></a><span id="l8.2229">       &quot;UPDATE contacts SET directoryUUID = ?1, \</span>
<a href="#l8.2230"></a><span id="l8.2230">                            contactUUID = ?2, \</span>
<a href="#l8.2231"></a><span id="l8.2231">                            name = ?3, \</span>
<a href="#l8.2232"></a><span id="l8.2232">                            popularity = ?4, \</span>
<a href="#l8.2233"></a><span id="l8.2233">                            frecency = ?5 \</span>
<a href="#l8.2234"></a><span id="l8.2234">                        WHERE id = ?6&quot;);</span>
<a href="#l8.2235"></a><span id="l8.2235">     this.__defineGetter__(&quot;_updateContactStatement&quot;, function() statement);</span>
<a href="#l8.2236"></a><span id="l8.2236" class="difflineminus">-    return this._updateContactStatement; </span>
<a href="#l8.2237"></a><span id="l8.2237" class="difflineplus">+    return this._updateContactStatement;</span>
<a href="#l8.2238"></a><span id="l8.2238">   },</span>
<a href="#l8.2239"></a><span id="l8.2239"> </span>
<a href="#l8.2240"></a><span id="l8.2240">   updateContact: function gloda_ds_updateContact(aContact) {</span>
<a href="#l8.2241"></a><span id="l8.2241">     let ucs = this._updateContactStatement;</span>
<a href="#l8.2242"></a><span id="l8.2242">     ucs.bindInt64Parameter(5, aContact.id);</span>
<a href="#l8.2243"></a><span id="l8.2243">     ucs.bindStringParameter(0, aContact.directoryUUID);</span>
<a href="#l8.2244"></a><span id="l8.2244">     ucs.bindStringParameter(1, aContact.contactUUID);</span>
<a href="#l8.2245"></a><span id="l8.2245">     ucs.bindStringParameter(2, aContact.name);</span>
<a href="#l8.2246"></a><span id="l8.2246">     ucs.bindInt64Parameter(3, aContact.popularity);</span>
<a href="#l8.2247"></a><span id="l8.2247">     ucs.bindInt64Parameter(4, aContact.frecency);</span>
<a href="#l8.2248"></a><span id="l8.2248" class="difflineminus">-    </span>
<a href="#l8.2249"></a><span id="l8.2249" class="difflineplus">+</span>
<a href="#l8.2250"></a><span id="l8.2250">     ucs.executeAsync(this.trackAsync());</span>
<a href="#l8.2251"></a><span id="l8.2251">   },</span>
<a href="#l8.2252"></a><span id="l8.2252" class="difflineminus">-  </span>
<a href="#l8.2253"></a><span id="l8.2253" class="difflineplus">+</span>
<a href="#l8.2254"></a><span id="l8.2254">   _contactFromRow: function gloda_ds_contactFromRow(aRow) {</span>
<a href="#l8.2255"></a><span id="l8.2255">     let directoryUUID, contactUUID;</span>
<a href="#l8.2256"></a><span id="l8.2256">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l8.2257"></a><span id="l8.2257">       directoryUUID = null;</span>
<a href="#l8.2258"></a><span id="l8.2258">     else</span>
<a href="#l8.2259"></a><span id="l8.2259">       directoryUUID = aRow.getString(1);</span>
<a href="#l8.2260"></a><span id="l8.2260">     if (aRow.getTypeOfIndex(2) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l8.2261"></a><span id="l8.2261">       contactUUID = null;</span>
<a href="#l8.2262"></a><span id="l8.2262">     else</span>
<a href="#l8.2263"></a><span id="l8.2263">       contactUUID = aRow.getString(2);</span>
<a href="#l8.2264"></a><span id="l8.2264" class="difflineminus">-      </span>
<a href="#l8.2265"></a><span id="l8.2265" class="difflineplus">+</span>
<a href="#l8.2266"></a><span id="l8.2266">     return new GlodaContact(this, aRow.getInt64(0), directoryUUID,</span>
<a href="#l8.2267"></a><span id="l8.2267">                             contactUUID, aRow.getString(5),</span>
<a href="#l8.2268"></a><span id="l8.2268">                             aRow.getInt64(3), aRow.getInt64(4));</span>
<a href="#l8.2269"></a><span id="l8.2269">   },</span>
<a href="#l8.2270"></a><span id="l8.2270" class="difflineminus">-  </span>
<a href="#l8.2271"></a><span id="l8.2271" class="difflineplus">+</span>
<a href="#l8.2272"></a><span id="l8.2272">   get _selectContactByIDStatement() {</span>
<a href="#l8.2273"></a><span id="l8.2273">     let statement = this._createSyncStatement(</span>
<a href="#l8.2274"></a><span id="l8.2274">       &quot;SELECT * FROM contacts WHERE id = ?1&quot;);</span>
<a href="#l8.2275"></a><span id="l8.2275">     this.__defineGetter__(&quot;_selectContactByIDStatement&quot;,</span>
<a href="#l8.2276"></a><span id="l8.2276">       function() statement);</span>
<a href="#l8.2277"></a><span id="l8.2277">     return this._selectContactByIDStatement;</span>
<a href="#l8.2278"></a><span id="l8.2278">   },</span>
<a href="#l8.2279"></a><span id="l8.2279"> </span>
<a href="#l8.2280"></a><span id="l8.2280">   getContactByID: function gloda_ds_getContactByID(aContactID) {</span>
<a href="#l8.2281"></a><span id="l8.2281">     let contact = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l8.2282"></a><span id="l8.2282">       GlodaContact.prototype.NOUN_ID, aContactID);</span>
<a href="#l8.2283"></a><span id="l8.2283" class="difflineminus">-    </span>
<a href="#l8.2284"></a><span id="l8.2284" class="difflineplus">+</span>
<a href="#l8.2285"></a><span id="l8.2285">     if (contact === null) {</span>
<a href="#l8.2286"></a><span id="l8.2286">       let scbi = this._selectContactByIDStatement;</span>
<a href="#l8.2287"></a><span id="l8.2287">       scbi.bindInt64Parameter(0, aContactID);</span>
<a href="#l8.2288"></a><span id="l8.2288">       if (this._syncStep(scbi)) {</span>
<a href="#l8.2289"></a><span id="l8.2289">         contact = this._contactFromRow(scbi);</span>
<a href="#l8.2290"></a><span id="l8.2290">         GlodaCollectionManager.itemLoaded(contact);</span>
<a href="#l8.2291"></a><span id="l8.2291">       }</span>
<a href="#l8.2292"></a><span id="l8.2292">       scbi.reset();</span>
<a href="#l8.2293"></a><span id="l8.2293">     }</span>
<a href="#l8.2294"></a><span id="l8.2294" class="difflineminus">-    </span>
<a href="#l8.2295"></a><span id="l8.2295" class="difflineplus">+</span>
<a href="#l8.2296"></a><span id="l8.2296">     return contact;</span>
<a href="#l8.2297"></a><span id="l8.2297">   },</span>
<a href="#l8.2298"></a><span id="l8.2298" class="difflineminus">-  </span>
<a href="#l8.2299"></a><span id="l8.2299" class="difflineplus">+</span>
<a href="#l8.2300"></a><span id="l8.2300">   /* ********** Identity ********** */</span>
<a href="#l8.2301"></a><span id="l8.2301">   /** next identity id, managed for async use reasons. */</span>
<a href="#l8.2302"></a><span id="l8.2302">   _nextIdentityId: 1,</span>
<a href="#l8.2303"></a><span id="l8.2303" class="difflineminus">-  _populateIdentityManagedId: function () { </span>
<a href="#l8.2304"></a><span id="l8.2304" class="difflineplus">+  _populateIdentityManagedId: function () {</span>
<a href="#l8.2305"></a><span id="l8.2305">     let stmt = this._createSyncStatement(</span>
<a href="#l8.2306"></a><span id="l8.2306">       &quot;SELECT MAX(id) FROM identities&quot;, true);</span>
<a href="#l8.2307"></a><span id="l8.2307">     if (stmt.executeStep()) { // no chance of this SQLITE_BUSY on this call</span>
<a href="#l8.2308"></a><span id="l8.2308">       this._nextIdentityId = stmt.getInt64(0) + 1;</span>
<a href="#l8.2309"></a><span id="l8.2309">     }</span>
<a href="#l8.2310"></a><span id="l8.2310">     stmt.finalize();</span>
<a href="#l8.2311"></a><span id="l8.2311">   },</span>
<a href="#l8.2312"></a><span id="l8.2312" class="difflineminus">-  </span>
<a href="#l8.2313"></a><span id="l8.2313" class="difflineplus">+</span>
<a href="#l8.2314"></a><span id="l8.2314">   get _insertIdentityStatement() {</span>
<a href="#l8.2315"></a><span id="l8.2315">     let statement = this._createAsyncStatement(</span>
<a href="#l8.2316"></a><span id="l8.2316">       &quot;INSERT INTO identities (id, contactID, kind, value, description, relay) \</span>
<a href="#l8.2317"></a><span id="l8.2317">               VALUES (?1, ?2, ?3, ?4, ?5, ?6)&quot;);</span>
<a href="#l8.2318"></a><span id="l8.2318">     this.__defineGetter__(&quot;_insertIdentityStatement&quot;, function() statement);</span>
<a href="#l8.2319"></a><span id="l8.2319" class="difflineminus">-    return this._insertIdentityStatement; </span>
<a href="#l8.2320"></a><span id="l8.2320" class="difflineplus">+    return this._insertIdentityStatement;</span>
<a href="#l8.2321"></a><span id="l8.2321">   },</span>
<a href="#l8.2322"></a><span id="l8.2322" class="difflineminus">-  </span>
<a href="#l8.2323"></a><span id="l8.2323" class="difflineplus">+</span>
<a href="#l8.2324"></a><span id="l8.2324">   createIdentity: function gloda_ds_createIdentity(aContactID, aContact, aKind,</span>
<a href="#l8.2325"></a><span id="l8.2325">                                                    aValue, aDescription,</span>
<a href="#l8.2326"></a><span id="l8.2326">                                                    aIsRelay) {</span>
<a href="#l8.2327"></a><span id="l8.2327">     let identityID = this._nextIdentityId++;</span>
<a href="#l8.2328"></a><span id="l8.2328">     let iis = this._insertIdentityStatement;</span>
<a href="#l8.2329"></a><span id="l8.2329">     iis.bindInt64Parameter(0, identityID);</span>
<a href="#l8.2330"></a><span id="l8.2330">     iis.bindInt64Parameter(1, aContactID);</span>
<a href="#l8.2331"></a><span id="l8.2331">     iis.bindStringParameter(2, aKind);</span>
<a href="#l8.2332"></a><span id="l8.2332">     iis.bindStringParameter(3, aValue);</span>
<a href="#l8.2333"></a><span id="l8.2333">     iis.bindStringParameter(4, aDescription);</span>
<a href="#l8.2334"></a><span id="l8.2334">     iis.bindInt64Parameter(5, aIsRelay ? 1 : 0);</span>
<a href="#l8.2335"></a><span id="l8.2335">     iis.executeAsync(this.trackAsync());</span>
<a href="#l8.2336"></a><span id="l8.2336" class="difflineminus">-  </span>
<a href="#l8.2337"></a><span id="l8.2337" class="difflineplus">+</span>
<a href="#l8.2338"></a><span id="l8.2338">     let identity = new GlodaIdentity(this, identityID,</span>
<a href="#l8.2339"></a><span id="l8.2339">                                      aContactID, aContact, aKind, aValue,</span>
<a href="#l8.2340"></a><span id="l8.2340">                                      aDescription, aIsRelay);</span>
<a href="#l8.2341"></a><span id="l8.2341">     GlodaCollectionManager.itemsAdded(identity.NOUN_ID, [identity]);</span>
<a href="#l8.2342"></a><span id="l8.2342">     return identity;</span>
<a href="#l8.2343"></a><span id="l8.2343">   },</span>
<a href="#l8.2344"></a><span id="l8.2344" class="difflineminus">-  </span>
<a href="#l8.2345"></a><span id="l8.2345" class="difflineplus">+</span>
<a href="#l8.2346"></a><span id="l8.2346">   _identityFromRow: function gloda_ds_identityFromRow(aRow) {</span>
<a href="#l8.2347"></a><span id="l8.2347">     return new GlodaIdentity(this, aRow.getInt64(0), aRow.getInt64(1), null,</span>
<a href="#l8.2348"></a><span id="l8.2348">                              aRow.getString(2), aRow.getString(3),</span>
<a href="#l8.2349"></a><span id="l8.2349">                              aRow.getString(4),</span>
<a href="#l8.2350"></a><span id="l8.2350">                              aRow.getInt32(5) ? true : false);</span>
<a href="#l8.2351"></a><span id="l8.2351">   },</span>
<a href="#l8.2352"></a><span id="l8.2352" class="difflineminus">-  </span>
<a href="#l8.2353"></a><span id="l8.2353" class="difflineplus">+</span>
<a href="#l8.2354"></a><span id="l8.2354">   get _selectIdentityByKindValueStatement() {</span>
<a href="#l8.2355"></a><span id="l8.2355">     let statement = this._createSyncStatement(</span>
<a href="#l8.2356"></a><span id="l8.2356">       &quot;SELECT * FROM identities WHERE kind = ?1 AND value = ?2&quot;);</span>
<a href="#l8.2357"></a><span id="l8.2357">     this.__defineGetter__(&quot;_selectIdentityByKindValueStatement&quot;,</span>
<a href="#l8.2358"></a><span id="l8.2358">       function() statement);</span>
<a href="#l8.2359"></a><span id="l8.2359">     return this._selectIdentityByKindValueStatement;</span>
<a href="#l8.2360"></a><span id="l8.2360">   },</span>
<a href="#l8.2361"></a><span id="l8.2361"> </span>
<a href="#l8.2362"></a><span id="l8.2362">   /** Lookup an identity by kind and value.  Ex: (email, foo@bar.com) */</span>
<a href="#l8.2363"></a><span id="l8.2363">   getIdentity: function gloda_ds_getIdentity(aKind, aValue) {</span>
<a href="#l8.2364"></a><span id="l8.2364">     let identity = GlodaCollectionManager.cacheLookupOneByUniqueValue(</span>
<a href="#l8.2365"></a><span id="l8.2365">       GlodaIdentity.prototype.NOUN_ID, aKind + &quot;@&quot; + aValue);</span>
<a href="#l8.2366"></a><span id="l8.2366" class="difflineminus">-    </span>
<a href="#l8.2367"></a><span id="l8.2367" class="difflineplus">+</span>
<a href="#l8.2368"></a><span id="l8.2368">     let ibkv = this._selectIdentityByKindValueStatement;</span>
<a href="#l8.2369"></a><span id="l8.2369">     ibkv.bindStringParameter(0, aKind);</span>
<a href="#l8.2370"></a><span id="l8.2370">     ibkv.bindStringParameter(1, aValue);</span>
<a href="#l8.2371"></a><span id="l8.2371">     if (this._syncStep(ibkv)) {</span>
<a href="#l8.2372"></a><span id="l8.2372">       identity = this._identityFromRow(ibkv);</span>
<a href="#l8.2373"></a><span id="l8.2373">       GlodaCollectionManager.itemLoaded(identity);</span>
<a href="#l8.2374"></a><span id="l8.2374">     }</span>
<a href="#l8.2375"></a><span id="l8.2375">     ibkv.reset();</span>
<a href="#l8.2376"></a><span id="l8.2376" class="difflineminus">-    </span>
<a href="#l8.2377"></a><span id="l8.2377" class="difflineplus">+</span>
<a href="#l8.2378"></a><span id="l8.2378">     return identity;</span>
<a href="#l8.2379"></a><span id="l8.2379">   },</span>
<a href="#l8.2380"></a><span id="l8.2380"> </span>
<a href="#l8.2381"></a><span id="l8.2381">   get _selectIdentityByIDStatement() {</span>
<a href="#l8.2382"></a><span id="l8.2382">     let statement = this._createSyncStatement(</span>
<a href="#l8.2383"></a><span id="l8.2383">       &quot;SELECT * FROM identities WHERE id = ?1&quot;);</span>
<a href="#l8.2384"></a><span id="l8.2384">     this.__defineGetter__(&quot;_selectIdentityByIDStatement&quot;,</span>
<a href="#l8.2385"></a><span id="l8.2385">       function() statement);</span>
<a href="#l8.2386"></a><span id="l8.2386">     return this._selectIdentityByIDStatement;</span>
<a href="#l8.2387"></a><span id="l8.2387">   },</span>
<a href="#l8.2388"></a><span id="l8.2388"> </span>
<a href="#l8.2389"></a><span id="l8.2389">   getIdentityByID: function gloda_ds_getIdentityByID(aID) {</span>
<a href="#l8.2390"></a><span id="l8.2390">     let identity = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l8.2391"></a><span id="l8.2391">       GlodaIdentity.prototype.NOUN_ID, aID);</span>
<a href="#l8.2392"></a><span id="l8.2392" class="difflineminus">-    </span>
<a href="#l8.2393"></a><span id="l8.2393" class="difflineplus">+</span>
<a href="#l8.2394"></a><span id="l8.2394">     if (identity === null) {</span>
<a href="#l8.2395"></a><span id="l8.2395">       let sibis = this._selectIdentityByIDStatement;</span>
<a href="#l8.2396"></a><span id="l8.2396">       sibis.bindInt64Parameter(0, aID);</span>
<a href="#l8.2397"></a><span id="l8.2397">       if (this._syncStep(sibis)) {</span>
<a href="#l8.2398"></a><span id="l8.2398">         identity = this._identityFromRow(sibis);</span>
<a href="#l8.2399"></a><span id="l8.2399">         GlodaCollectionManager.itemLoaded(identity);</span>
<a href="#l8.2400"></a><span id="l8.2400">       }</span>
<a href="#l8.2401"></a><span id="l8.2401">       sibis.reset();</span>
<a href="#l8.2402"></a><span id="l8.2402">     }</span>
<a href="#l8.2403"></a><span id="l8.2403" class="difflineminus">-    </span>
<a href="#l8.2404"></a><span id="l8.2404" class="difflineplus">+</span>
<a href="#l8.2405"></a><span id="l8.2405">     return identity;</span>
<a href="#l8.2406"></a><span id="l8.2406">   },</span>
<a href="#l8.2407"></a><span id="l8.2407"> </span>
<a href="#l8.2408"></a><span id="l8.2408">   get _selectIdentityByContactIDStatement() {</span>
<a href="#l8.2409"></a><span id="l8.2409">     let statement = this._createSyncStatement(</span>
<a href="#l8.2410"></a><span id="l8.2410">       &quot;SELECT * FROM identities WHERE contactID = ?1&quot;);</span>
<a href="#l8.2411"></a><span id="l8.2411">     this.__defineGetter__(&quot;_selectIdentityByContactIDStatement&quot;,</span>
<a href="#l8.2412"></a><span id="l8.2412">       function() statement);</span>
<a href="#l8.2413"></a><span id="l8.2413">     return this._selectIdentityByContactIDStatement;</span>
<a href="#l8.2414"></a><span id="l8.2414">   },</span>
<a href="#l8.2415"></a><span id="l8.2415"> </span>
<a href="#l8.2416"></a><span id="l8.2416">   getIdentitiesByContactID: function gloda_ds_getIdentitiesByContactID(</span>
<a href="#l8.2417"></a><span id="l8.2417">       aContactID) {</span>
<a href="#l8.2418"></a><span id="l8.2418">     let sibcs = this._selectIdentityByContactIDStatement;</span>
<a href="#l8.2419"></a><span id="l8.2419" class="difflineminus">-    </span>
<a href="#l8.2420"></a><span id="l8.2420" class="difflineplus">+</span>
<a href="#l8.2421"></a><span id="l8.2421">     sibcs.bindInt64Parameter(0, aContactID);</span>
<a href="#l8.2422"></a><span id="l8.2422" class="difflineminus">-    </span>
<a href="#l8.2423"></a><span id="l8.2423" class="difflineplus">+</span>
<a href="#l8.2424"></a><span id="l8.2424">     let identities = [];</span>
<a href="#l8.2425"></a><span id="l8.2425">     while (this._syncStep(sibcs)) {</span>
<a href="#l8.2426"></a><span id="l8.2426">       identities.push(this._identityFromRow(sibcs));</span>
<a href="#l8.2427"></a><span id="l8.2427">     }</span>
<a href="#l8.2428"></a><span id="l8.2428">     sibcs.reset();</span>
<a href="#l8.2429"></a><span id="l8.2429"> </span>
<a href="#l8.2430"></a><span id="l8.2430">     if (identities.length)</span>
<a href="#l8.2431"></a><span id="l8.2431">       GlodaCollectionManager.cacheLoadUnify(GlodaIdentity.prototype.NOUN_ID,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/modules/everybody.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/modules/everybody.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -57,27 +57,32 @@ function loadModule(aModuleURI, aNSContr</span>
<a href="#l9.4"></a><span id="l9.4">   }</span>
<a href="#l9.5"></a><span id="l9.5"> </span>
<a href="#l9.6"></a><span id="l9.6">   try {</span>
<a href="#l9.7"></a><span id="l9.7">     LOG.info(&quot;... loading &quot; + aModuleURI);</span>
<a href="#l9.8"></a><span id="l9.8">     Cu.import(aModuleURI, importNS);</span>
<a href="#l9.9"></a><span id="l9.9">   }</span>
<a href="#l9.10"></a><span id="l9.10">   catch (ex) {</span>
<a href="#l9.11"></a><span id="l9.11">     LOG.error(&quot;!!! error loading &quot; + aModuleURI);</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-    LOG.error(&quot;&quot; + ex);</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+    LOG.error(&quot;(&quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;) &quot; + ex);</span>
<a href="#l9.14"></a><span id="l9.14">     return false;</span>
<a href="#l9.15"></a><span id="l9.15">   }</span>
<a href="#l9.16"></a><span id="l9.16">   LOG.info(&quot;+++ loaded &quot; + aModuleURI);</span>
<a href="#l9.17"></a><span id="l9.17"> </span>
<a href="#l9.18"></a><span id="l9.18" class="difflineminus">-  try {  </span>
<a href="#l9.19"></a><span id="l9.19" class="difflineminus">-    importNS[aNSContrib].init(strtab);</span>
<a href="#l9.20"></a><span id="l9.20" class="difflineplus">+  if (aNSContrib) {</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineplus">+    try {  </span>
<a href="#l9.22"></a><span id="l9.22" class="difflineplus">+      importNS[aNSContrib].init(strtab);</span>
<a href="#l9.23"></a><span id="l9.23" class="difflineplus">+    }</span>
<a href="#l9.24"></a><span id="l9.24" class="difflineplus">+    catch (ex) {</span>
<a href="#l9.25"></a><span id="l9.25" class="difflineplus">+      LOG.error(&quot;!!! error initializing &quot; + aModuleURI);</span>
<a href="#l9.26"></a><span id="l9.26" class="difflineplus">+      LOG.error(&quot;(&quot; + ex.fileName + &quot;:&quot; + ex.lineNumber + &quot;) &quot; + ex);</span>
<a href="#l9.27"></a><span id="l9.27" class="difflineplus">+      return false;</span>
<a href="#l9.28"></a><span id="l9.28" class="difflineplus">+    }</span>
<a href="#l9.29"></a><span id="l9.29" class="difflineplus">+    LOG.info(&quot;+++ inited &quot; + aModuleURI);</span>
<a href="#l9.30"></a><span id="l9.30">   }</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineminus">-  catch (ex) {</span>
<a href="#l9.32"></a><span id="l9.32" class="difflineminus">-    LOG.error(&quot;!!! error initializing &quot; + aModuleURI);</span>
<a href="#l9.33"></a><span id="l9.33" class="difflineminus">-    LOG.error(&quot;&quot; + ex);</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineminus">-    return false;</span>
<a href="#l9.35"></a><span id="l9.35" class="difflineminus">-  }</span>
<a href="#l9.36"></a><span id="l9.36" class="difflineminus">-  LOG.info(&quot;+++ inited &quot; + aModuleURI);</span>
<a href="#l9.37"></a><span id="l9.37">   return true;</span>
<a href="#l9.38"></a><span id="l9.38"> }</span>
<a href="#l9.39"></a><span id="l9.39"> </span>
<a href="#l9.40"></a><span id="l9.40"> loadModule(&quot;resource://gloda/modules/fundattr.js&quot;, &quot;GlodaFundAttr&quot;);</span>
<a href="#l9.41"></a><span id="l9.41"> loadModule(&quot;resource://gloda/modules/explattr.js&quot;, &quot;GlodaExplicitAttr&quot;);</span>
<a href="#l9.42"></a><span id="l9.42" class="difflineplus">+</span>
<a href="#l9.43"></a><span id="l9.43" class="difflineplus">+loadModule(&quot;resource://gloda/modules/noun_freetag.js&quot;);</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineplus">+loadModule(&quot;resource://gloda/modules/index_ab.js&quot;, &quot;GlodaABAttrs&quot;);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/modules/explattr.js</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/modules/explattr.js</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -58,17 +58,17 @@ const FA_READ = &quot;READ&quot;;</span>
<a href="#l10.4"></a><span id="l10.4">  * @namespace Explicit attribute provider.  Indexes/defines attributes that are</span>
<a href="#l10.5"></a><span id="l10.5">  *  explicitly a result of user action.  This dubiously includes marking a</span>
<a href="#l10.6"></a><span id="l10.6">  *  message as read. </span>
<a href="#l10.7"></a><span id="l10.7">  */</span>
<a href="#l10.8"></a><span id="l10.8"> var GlodaExplicitAttr = {</span>
<a href="#l10.9"></a><span id="l10.9">   providerName: &quot;gloda.explattr&quot;,</span>
<a href="#l10.10"></a><span id="l10.10">   _log: null,</span>
<a href="#l10.11"></a><span id="l10.11">   _strBundle: null,</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-  _mstTagService: null,</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+  _msgTagService: null,</span>
<a href="#l10.14"></a><span id="l10.14"> </span>
<a href="#l10.15"></a><span id="l10.15">   init: function gloda_explattr_init(aStrBundle) {</span>
<a href="#l10.16"></a><span id="l10.16">     this._log =  Log4Moz.Service.getLogger(&quot;gloda.explattr&quot;);</span>
<a href="#l10.17"></a><span id="l10.17">     this._strBundle = aStrBundle;</span>
<a href="#l10.18"></a><span id="l10.18"> </span>
<a href="#l10.19"></a><span id="l10.19">     this._msgTagService = Cc[&quot;@mozilla.org/messenger/tagservice;1&quot;].</span>
<a href="#l10.20"></a><span id="l10.20">                           getService(Ci.nsIMsgTagService);</span>
<a href="#l10.21"></a><span id="l10.21">   </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/modules/fundattr.js</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/modules/fundattr.js</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -100,98 +100,16 @@ var GlodaFundAttr = {</span>
<a href="#l11.4"></a><span id="l11.4">       bind: false,</span>
<a href="#l11.5"></a><span id="l11.5">       singular: true,</span>
<a href="#l11.6"></a><span id="l11.6">       special: Gloda.kSpecialFulltext,</span>
<a href="#l11.7"></a><span id="l11.7">       specialColumnName: &quot;subject&quot;,</span>
<a href="#l11.8"></a><span id="l11.8">       subjectNouns: [Gloda.NOUN_CONVERSATION],</span>
<a href="#l11.9"></a><span id="l11.9">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l11.10"></a><span id="l11.10">       explanation: null, // this does not merit explanation</span>
<a href="#l11.11"></a><span id="l11.11">       });</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-    </span>
<a href="#l11.13"></a><span id="l11.13" class="difflineminus">-    /* ***** Contacts ***** */</span>
<a href="#l11.14"></a><span id="l11.14" class="difflineminus">-    this._attrContactName = Gloda.defineAttribute({</span>
<a href="#l11.15"></a><span id="l11.15" class="difflineminus">-      provider: this,</span>
<a href="#l11.16"></a><span id="l11.16" class="difflineminus">-      extensionName: Gloda.BUILT_IN,</span>
<a href="#l11.17"></a><span id="l11.17" class="difflineminus">-      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l11.18"></a><span id="l11.18" class="difflineminus">-      attributeName: &quot;name&quot;,</span>
<a href="#l11.19"></a><span id="l11.19" class="difflineminus">-      bind: false,</span>
<a href="#l11.20"></a><span id="l11.20" class="difflineminus">-      singular: true,</span>
<a href="#l11.21"></a><span id="l11.21" class="difflineminus">-      special: Gloda.kSpecialString,</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineminus">-      specialColumnName: &quot;name&quot;,</span>
<a href="#l11.23"></a><span id="l11.23" class="difflineminus">-      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l11.24"></a><span id="l11.24" class="difflineminus">-      objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l11.25"></a><span id="l11.25" class="difflineminus">-      explanation: null, // name is internal, no explanation required</span>
<a href="#l11.26"></a><span id="l11.26" class="difflineminus">-      }); // tested-by: test_attributes_fundamental</span>
<a href="#l11.27"></a><span id="l11.27" class="difflineminus">-    this._attrContactPopularity = Gloda.defineAttribute({</span>
<a href="#l11.28"></a><span id="l11.28" class="difflineminus">-      provider: this,</span>
<a href="#l11.29"></a><span id="l11.29" class="difflineminus">-      extensionName: Gloda.BUILT_IN,</span>
<a href="#l11.30"></a><span id="l11.30" class="difflineminus">-      attributeType: Gloda.kAttrDerived,</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineminus">-      attributeName: &quot;popularity&quot;,</span>
<a href="#l11.32"></a><span id="l11.32" class="difflineminus">-      bind: false,</span>
<a href="#l11.33"></a><span id="l11.33" class="difflineminus">-      singular: true,</span>
<a href="#l11.34"></a><span id="l11.34" class="difflineminus">-      special: Gloda.kSpecialColumn,</span>
<a href="#l11.35"></a><span id="l11.35" class="difflineminus">-      specialColumnName: &quot;popularity&quot;,</span>
<a href="#l11.36"></a><span id="l11.36" class="difflineminus">-      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l11.37"></a><span id="l11.37" class="difflineminus">-      objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l11.38"></a><span id="l11.38" class="difflineminus">-      explanation: null, // popularity is internal, no explanation required</span>
<a href="#l11.39"></a><span id="l11.39" class="difflineminus">-      }); // not-tested</span>
<a href="#l11.40"></a><span id="l11.40" class="difflineminus">-    this._attrContactFrecency = Gloda.defineAttribute({</span>
<a href="#l11.41"></a><span id="l11.41" class="difflineminus">-      provider: this,</span>
<a href="#l11.42"></a><span id="l11.42" class="difflineminus">-      extensionName: Gloda.BUILT_IN,</span>
<a href="#l11.43"></a><span id="l11.43" class="difflineminus">-      attributeType: Gloda.kAttrDerived,</span>
<a href="#l11.44"></a><span id="l11.44" class="difflineminus">-      attributeName: &quot;frecency&quot;,</span>
<a href="#l11.45"></a><span id="l11.45" class="difflineminus">-      bind: false,</span>
<a href="#l11.46"></a><span id="l11.46" class="difflineminus">-      singular: true,</span>
<a href="#l11.47"></a><span id="l11.47" class="difflineminus">-      special: Gloda.kSpecialColumn,</span>
<a href="#l11.48"></a><span id="l11.48" class="difflineminus">-      specialColumnName: &quot;frecency&quot;,</span>
<a href="#l11.49"></a><span id="l11.49" class="difflineminus">-      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l11.50"></a><span id="l11.50" class="difflineminus">-      objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l11.51"></a><span id="l11.51" class="difflineminus">-      explanation: null, // frecency is internal, no explanation required</span>
<a href="#l11.52"></a><span id="l11.52" class="difflineminus">-      }); // not-tested</span>
<a href="#l11.53"></a><span id="l11.53" class="difflineminus">-</span>
<a href="#l11.54"></a><span id="l11.54" class="difflineminus">-    /* ***** Identities ***** */</span>
<a href="#l11.55"></a><span id="l11.55" class="difflineminus">-    this._attrIdentityContact = Gloda.defineAttribute({</span>
<a href="#l11.56"></a><span id="l11.56" class="difflineminus">-      provider: this,</span>
<a href="#l11.57"></a><span id="l11.57" class="difflineminus">-      extensionName: Gloda.BUILT_IN,</span>
<a href="#l11.58"></a><span id="l11.58" class="difflineminus">-      attributeType: Gloda.kAttrDerived,</span>
<a href="#l11.59"></a><span id="l11.59" class="difflineminus">-      attributeName: &quot;contact&quot;,</span>
<a href="#l11.60"></a><span id="l11.60" class="difflineminus">-      bind: false,</span>
<a href="#l11.61"></a><span id="l11.61" class="difflineminus">-      singular: true,</span>
<a href="#l11.62"></a><span id="l11.62" class="difflineminus">-      special: Gloda.kSpecialColumn,</span>
<a href="#l11.63"></a><span id="l11.63" class="difflineminus">-      specialColumnName: &quot;contactID&quot;,</span>
<a href="#l11.64"></a><span id="l11.64" class="difflineminus">-      subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l11.65"></a><span id="l11.65" class="difflineminus">-      objectNoun: Gloda.NOUN_CONTACT,</span>
<a href="#l11.66"></a><span id="l11.66" class="difflineminus">-      explanation: null, // popularity is internal, no explanation required</span>
<a href="#l11.67"></a><span id="l11.67" class="difflineminus">-      }); // tested-by: test_attributes_fundamental</span>
<a href="#l11.68"></a><span id="l11.68" class="difflineminus">-    this._attrIdentityKind = Gloda.defineAttribute({</span>
<a href="#l11.69"></a><span id="l11.69" class="difflineminus">-      provider: this,</span>
<a href="#l11.70"></a><span id="l11.70" class="difflineminus">-      extensionName: Gloda.BUILT_IN,</span>
<a href="#l11.71"></a><span id="l11.71" class="difflineminus">-      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l11.72"></a><span id="l11.72" class="difflineminus">-      attributeName: &quot;kind&quot;,</span>
<a href="#l11.73"></a><span id="l11.73" class="difflineminus">-      bind: false,</span>
<a href="#l11.74"></a><span id="l11.74" class="difflineminus">-      singular: true,</span>
<a href="#l11.75"></a><span id="l11.75" class="difflineminus">-      special: Gloda.kSpecialString,</span>
<a href="#l11.76"></a><span id="l11.76" class="difflineminus">-      specialColumnName: &quot;kind&quot;,</span>
<a href="#l11.77"></a><span id="l11.77" class="difflineminus">-      subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l11.78"></a><span id="l11.78" class="difflineminus">-      objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l11.79"></a><span id="l11.79" class="difflineminus">-      explanation: null, // kind is internal, no explanation required</span>
<a href="#l11.80"></a><span id="l11.80" class="difflineminus">-      }); // tested-by: test_attributes_fundamental</span>
<a href="#l11.81"></a><span id="l11.81" class="difflineminus">-    this._attrIdentityValue = Gloda.defineAttribute({</span>
<a href="#l11.82"></a><span id="l11.82" class="difflineminus">-      provider: this,</span>
<a href="#l11.83"></a><span id="l11.83" class="difflineminus">-      extensionName: Gloda.BUILT_IN,</span>
<a href="#l11.84"></a><span id="l11.84" class="difflineminus">-      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l11.85"></a><span id="l11.85" class="difflineminus">-      attributeName: &quot;value&quot;,</span>
<a href="#l11.86"></a><span id="l11.86" class="difflineminus">-      bind: false,</span>
<a href="#l11.87"></a><span id="l11.87" class="difflineminus">-      singular: true,</span>
<a href="#l11.88"></a><span id="l11.88" class="difflineminus">-      special: Gloda.kSpecialString,</span>
<a href="#l11.89"></a><span id="l11.89" class="difflineminus">-      specialColumnName: &quot;value&quot;,</span>
<a href="#l11.90"></a><span id="l11.90" class="difflineminus">-      subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l11.91"></a><span id="l11.91" class="difflineminus">-      objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l11.92"></a><span id="l11.92" class="difflineminus">-      explanation: null, // value is internal, no explanation required</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineminus">-      }); // tested-by: test_attributes_fundamental</span>
<a href="#l11.94"></a><span id="l11.94">   </span>
<a href="#l11.95"></a><span id="l11.95">     /* ***** Messages ***** */</span>
<a href="#l11.96"></a><span id="l11.96">     // folder</span>
<a href="#l11.97"></a><span id="l11.97">     this._attrFolder = Gloda.defineAttribute({</span>
<a href="#l11.98"></a><span id="l11.98">       provider: this,</span>
<a href="#l11.99"></a><span id="l11.99">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l11.100"></a><span id="l11.100">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l11.101"></a><span id="l11.101">       attributeName: &quot;folderURI&quot;,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -1,16 +1,16 @@</span>
<a href="#l12.4"></a><span id="l12.4"> /* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l12.5"></a><span id="l12.5">  *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l12.6"></a><span id="l12.6">  *</span>
<a href="#l12.7"></a><span id="l12.7">  * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l12.8"></a><span id="l12.8">  * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l12.9"></a><span id="l12.9">  * the License. You may obtain a copy of the License at</span>
<a href="#l12.10"></a><span id="l12.10">  * http://www.mozilla.org/MPL/</span>
<a href="#l12.11"></a><span id="l12.11" class="difflineminus">- * </span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+ *</span>
<a href="#l12.13"></a><span id="l12.13">  * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l12.14"></a><span id="l12.14">  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l12.15"></a><span id="l12.15">  * for the specific language governing rights and limitations under the</span>
<a href="#l12.16"></a><span id="l12.16">  * License.</span>
<a href="#l12.17"></a><span id="l12.17">  *</span>
<a href="#l12.18"></a><span id="l12.18">  * The Original Code is Thunderbird Global Database.</span>
<a href="#l12.19"></a><span id="l12.19">  *</span>
<a href="#l12.20"></a><span id="l12.20">  * The Initial Developer of the Original Code is</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineat">@@ -27,19 +27,19 @@</span>
<a href="#l12.22"></a><span id="l12.22">  * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l12.23"></a><span id="l12.23">  * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l12.24"></a><span id="l12.24">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l12.25"></a><span id="l12.25">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l12.26"></a><span id="l12.26">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l12.27"></a><span id="l12.27">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l12.28"></a><span id="l12.28">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l12.29"></a><span id="l12.29">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineminus">- * </span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+ *</span>
<a href="#l12.32"></a><span id="l12.32">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineminus">- </span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+</span>
<a href="#l12.35"></a><span id="l12.35"> EXPORTED_SYMBOLS = ['Gloda'];</span>
<a href="#l12.36"></a><span id="l12.36"> </span>
<a href="#l12.37"></a><span id="l12.37"> const Cc = Components.classes;</span>
<a href="#l12.38"></a><span id="l12.38"> const Ci = Components.interfaces;</span>
<a href="#l12.39"></a><span id="l12.39"> const Cr = Components.results;</span>
<a href="#l12.40"></a><span id="l12.40"> const Cu = Components.utils;</span>
<a href="#l12.41"></a><span id="l12.41"> </span>
<a href="#l12.42"></a><span id="l12.42"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l12.43"></a><span id="l12.43" class="difflineat">@@ -131,17 +131,17 @@ Cu.import(&quot;resource://gloda/modules/util</span>
<a href="#l12.44"></a><span id="l12.44">  *  provided by other attribute providers.  For example, the fundattr provider</span>
<a href="#l12.45"></a><span id="l12.45">  *  tells us who a message is 'from' based on the e-mail address present.</span>
<a href="#l12.46"></a><span id="l12.46">  *  However, other plugins may actually know better.  For example, the bugzilla</span>
<a href="#l12.47"></a><span id="l12.47">  *  daemon e-mails based on bug activity although the daemon gets the credit</span>
<a href="#l12.48"></a><span id="l12.48">  *  as the official sender.  A bugzilla plugin can easily extract the actual</span>
<a href="#l12.49"></a><span id="l12.49">  *  person/e-mail addressed who did something on the bug to cause the</span>
<a href="#l12.50"></a><span id="l12.50">  *  notification to be sent.  In practice, we would like that person to be</span>
<a href="#l12.51"></a><span id="l12.51">  *  the 'sender' of the bugmail.  But we can't really do that right, yet.</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineminus">- * </span>
<a href="#l12.53"></a><span id="l12.53" class="difflineplus">+ *</span>
<a href="#l12.54"></a><span id="l12.54">  * @namespace</span>
<a href="#l12.55"></a><span id="l12.55">  */</span>
<a href="#l12.56"></a><span id="l12.56"> var Gloda = {</span>
<a href="#l12.57"></a><span id="l12.57">   /**</span>
<a href="#l12.58"></a><span id="l12.58">    * Initialize logging, the datastore (SQLite database), the core nouns and</span>
<a href="#l12.59"></a><span id="l12.59">    *  attributes, and the contact and identities that belong to the presumed</span>
<a href="#l12.60"></a><span id="l12.60">    *  current user (based on accounts).</span>
<a href="#l12.61"></a><span id="l12.61">    *</span>
<a href="#l12.62"></a><span id="l12.62" class="difflineat">@@ -150,17 +150,17 @@ var Gloda = {</span>
<a href="#l12.63"></a><span id="l12.63">    *  (and initialized).</span>
<a href="#l12.64"></a><span id="l12.64">    */</span>
<a href="#l12.65"></a><span id="l12.65">   _init: function gloda_ns_init() {</span>
<a href="#l12.66"></a><span id="l12.66">     this._initLogging();</span>
<a href="#l12.67"></a><span id="l12.67">     GlodaDatastore._init();</span>
<a href="#l12.68"></a><span id="l12.68">     this._initAttributes();</span>
<a href="#l12.69"></a><span id="l12.69">     this._initMyIdentities();</span>
<a href="#l12.70"></a><span id="l12.70">   },</span>
<a href="#l12.71"></a><span id="l12.71" class="difflineminus">-  </span>
<a href="#l12.72"></a><span id="l12.72" class="difflineplus">+</span>
<a href="#l12.73"></a><span id="l12.73">   _log: null,</span>
<a href="#l12.74"></a><span id="l12.74">   /**</span>
<a href="#l12.75"></a><span id="l12.75">    * Initialize logging; the error console window gets Warning/Error, and stdout</span>
<a href="#l12.76"></a><span id="l12.76">    *  (via dump) gets everything.</span>
<a href="#l12.77"></a><span id="l12.77">    */</span>
<a href="#l12.78"></a><span id="l12.78">   _initLogging: function gloda_ns_initLogging() {</span>
<a href="#l12.79"></a><span id="l12.79">     let formatter = new Log4Moz.BasicFormatter();</span>
<a href="#l12.80"></a><span id="l12.80">     let root = Log4Moz.Service.rootLogger;</span>
<a href="#l12.81"></a><span id="l12.81" class="difflineat">@@ -168,95 +168,95 @@ var Gloda = {</span>
<a href="#l12.82"></a><span id="l12.82"> </span>
<a href="#l12.83"></a><span id="l12.83">     let capp = new Log4Moz.ConsoleAppender(formatter);</span>
<a href="#l12.84"></a><span id="l12.84">     capp.level = Log4Moz.Level.Warn;</span>
<a href="#l12.85"></a><span id="l12.85">     root.addAppender(capp);</span>
<a href="#l12.86"></a><span id="l12.86"> </span>
<a href="#l12.87"></a><span id="l12.87">     let dapp = new Log4Moz.DumpAppender(formatter);</span>
<a href="#l12.88"></a><span id="l12.88">     dapp.level = Log4Moz.Level.All;</span>
<a href="#l12.89"></a><span id="l12.89">     root.addAppender(dapp);</span>
<a href="#l12.90"></a><span id="l12.90" class="difflineminus">-    </span>
<a href="#l12.91"></a><span id="l12.91" class="difflineplus">+</span>
<a href="#l12.92"></a><span id="l12.92">     this._log = Log4Moz.Service.getLogger(&quot;gloda.NS&quot;);</span>
<a href="#l12.93"></a><span id="l12.93">     this._log.info(&quot;Logging Initialized&quot;);</span>
<a href="#l12.94"></a><span id="l12.94">   },</span>
<a href="#l12.95"></a><span id="l12.95" class="difflineminus">-  </span>
<a href="#l12.96"></a><span id="l12.96" class="difflineplus">+</span>
<a href="#l12.97"></a><span id="l12.97">   kIndexerIdle: 0,</span>
<a href="#l12.98"></a><span id="l12.98">   kIndexerIndexing: 1,</span>
<a href="#l12.99"></a><span id="l12.99">   kIndexerMoving: 2,</span>
<a href="#l12.100"></a><span id="l12.100">   kIndexerRemoving: 3,</span>
<a href="#l12.101"></a><span id="l12.101" class="difflineminus">-  </span>
<a href="#l12.102"></a><span id="l12.102" class="difflineplus">+</span>
<a href="#l12.103"></a><span id="l12.103">   /**</span>
<a href="#l12.104"></a><span id="l12.104">    * Lookup a gloda message from an nsIMsgDBHdr.</span>
<a href="#l12.105"></a><span id="l12.105">    *</span>
<a href="#l12.106"></a><span id="l12.106">    * @param aMsgHdr The header of the message you want the gloda message for.</span>
<a href="#l12.107"></a><span id="l12.107">    *</span>
<a href="#l12.108"></a><span id="l12.108">    * @return the gloda messages that corresponds to the provided nsIMsgDBHdr</span>
<a href="#l12.109"></a><span id="l12.109">    *    if one exists, null if one cannot be found.</span>
<a href="#l12.110"></a><span id="l12.110">    */</span>
<a href="#l12.111"></a><span id="l12.111">   getMessageForHeader: function gloda_ns_getMessageForHeader(aMsgHdr) {</span>
<a href="#l12.112"></a><span id="l12.112">     return GlodaDatastore.getMessageFromLocation(aMsgHdr.folder.URI,</span>
<a href="#l12.113"></a><span id="l12.113">                                                  aMsgHdr.messageKey);</span>
<a href="#l12.114"></a><span id="l12.114">   },</span>
<a href="#l12.115"></a><span id="l12.115" class="difflineminus">-  </span>
<a href="#l12.116"></a><span id="l12.116" class="difflineplus">+</span>
<a href="#l12.117"></a><span id="l12.117">   /**</span>
<a href="#l12.118"></a><span id="l12.118">    * Given one or more full mail addresses (ex: &quot;Bob Smith&quot; &lt;bob@smith.com&gt;),</span>
<a href="#l12.119"></a><span id="l12.119">    *  return a list of the identities that corresponds to each mail address,</span>
<a href="#l12.120"></a><span id="l12.120">    *  creating them as required.</span>
<a href="#l12.121"></a><span id="l12.121">    */</span>
<a href="#l12.122"></a><span id="l12.122">   getIdentitiesForFullMailAddresses:</span>
<a href="#l12.123"></a><span id="l12.123">       function gloda_ns_getIdentitiesForMailAddresses(aMailAddresses) {</span>
<a href="#l12.124"></a><span id="l12.124">     let parsed = GlodaUtils.parseMailAddresses(aMailAddresses);</span>
<a href="#l12.125"></a><span id="l12.125" class="difflineminus">-    </span>
<a href="#l12.126"></a><span id="l12.126" class="difflineplus">+</span>
<a href="#l12.127"></a><span id="l12.127">     let identities = [];</span>
<a href="#l12.128"></a><span id="l12.128">     for (let iAddress = 0; iAddress &lt; parsed.count; iAddress++) {</span>
<a href="#l12.129"></a><span id="l12.129">       let identity = GlodaDatastore.getIdentity(&quot;email&quot;,</span>
<a href="#l12.130"></a><span id="l12.130">                                                 parsed.addresses[iAddress]);</span>
<a href="#l12.131"></a><span id="l12.131" class="difflineminus">-      </span>
<a href="#l12.132"></a><span id="l12.132" class="difflineplus">+</span>
<a href="#l12.133"></a><span id="l12.133">       if (identity === null) {</span>
<a href="#l12.134"></a><span id="l12.134">         let name = parsed.names[iAddress];</span>
<a href="#l12.135"></a><span id="l12.135">         let mailAddr = parsed.addresses[iAddress];</span>
<a href="#l12.136"></a><span id="l12.136" class="difflineminus">-        </span>
<a href="#l12.137"></a><span id="l12.137" class="difflineplus">+</span>
<a href="#l12.138"></a><span id="l12.138">         // fall-back to the mail address if the name is empty</span>
<a href="#l12.139"></a><span id="l12.139">         if ((name === null) || (name == &quot;&quot;))</span>
<a href="#l12.140"></a><span id="l12.140">           name = mailAddr;</span>
<a href="#l12.141"></a><span id="l12.141" class="difflineminus">-          </span>
<a href="#l12.142"></a><span id="l12.142" class="difflineplus">+</span>
<a href="#l12.143"></a><span id="l12.143">         // we must create a contact</span>
<a href="#l12.144"></a><span id="l12.144">         let contact = GlodaDatastore.createContact(null, null, name, 0, 0);</span>
<a href="#l12.145"></a><span id="l12.145" class="difflineminus">-        </span>
<a href="#l12.146"></a><span id="l12.146" class="difflineplus">+</span>
<a href="#l12.147"></a><span id="l12.147">         // we must create the identity.  use a blank description because there's</span>
<a href="#l12.148"></a><span id="l12.148">         //  nothing to differentiate it from other identities, as this contact</span>
<a href="#l12.149"></a><span id="l12.149">         //  only has one initially (us).</span>
<a href="#l12.150"></a><span id="l12.150">         identity = GlodaDatastore.createIdentity(contact.id, contact, &quot;email&quot;,</span>
<a href="#l12.151"></a><span id="l12.151">                                                  mailAddr,</span>
<a href="#l12.152"></a><span id="l12.152">                                                  &quot;&quot;, false);</span>
<a href="#l12.153"></a><span id="l12.153">       }</span>
<a href="#l12.154"></a><span id="l12.154">       identities.push(identity);</span>
<a href="#l12.155"></a><span id="l12.155">     }</span>
<a href="#l12.156"></a><span id="l12.156" class="difflineminus">-    </span>
<a href="#l12.157"></a><span id="l12.157" class="difflineplus">+</span>
<a href="#l12.158"></a><span id="l12.158">     return identities;</span>
<a href="#l12.159"></a><span id="l12.159">   },</span>
<a href="#l12.160"></a><span id="l12.160" class="difflineminus">-  </span>
<a href="#l12.161"></a><span id="l12.161" class="difflineplus">+</span>
<a href="#l12.162"></a><span id="l12.162">   /**</span>
<a href="#l12.163"></a><span id="l12.163">    * Given a full mail address (ex: &quot;Bob Smith&quot; &lt;bob@smith.com&gt;), return the</span>
<a href="#l12.164"></a><span id="l12.164">    *  identity that corresponds to that mail address, creating it if required.</span>
<a href="#l12.165"></a><span id="l12.165">    *  (If you want the contact, it is easily retrieved via the 'contact'</span>
<a href="#l12.166"></a><span id="l12.166">    *  attribute on the identity.)</span>
<a href="#l12.167"></a><span id="l12.167">    */</span>
<a href="#l12.168"></a><span id="l12.168">   getIdentityForFullMailAddress:</span>
<a href="#l12.169"></a><span id="l12.169">       function gloda_ns_getIdentityForFullMailAddress(aMailAddress) {</span>
<a href="#l12.170"></a><span id="l12.170">     let identities = this.getIdentitiesForFullMailAddresses(aMailAddress);</span>
<a href="#l12.171"></a><span id="l12.171">     if (identities.length != 1) {</span>
<a href="#l12.172"></a><span id="l12.172">       this._log.info(&quot;Expected exactly 1 address, got &quot; + identities.length +</span>
<a href="#l12.173"></a><span id="l12.173">                      &quot; for address: &quot; + aMailAddress);</span>
<a href="#l12.174"></a><span id="l12.174">       return null;</span>
<a href="#l12.175"></a><span id="l12.175" class="difflineminus">-    }    </span>
<a href="#l12.176"></a><span id="l12.176" class="difflineminus">-    </span>
<a href="#l12.177"></a><span id="l12.177" class="difflineplus">+    }</span>
<a href="#l12.178"></a><span id="l12.178" class="difflineplus">+</span>
<a href="#l12.179"></a><span id="l12.179">     return identities[0];</span>
<a href="#l12.180"></a><span id="l12.180">   },</span>
<a href="#l12.181"></a><span id="l12.181" class="difflineminus">-  </span>
<a href="#l12.182"></a><span id="l12.182" class="difflineplus">+</span>
<a href="#l12.183"></a><span id="l12.183">   /**</span>
<a href="#l12.184"></a><span id="l12.184">    * Dictionary of the user's known identities; key is the identity id, value</span>
<a href="#l12.185"></a><span id="l12.185">    *  is the actual identity.  This is populated by _initMyIdentities based on</span>
<a href="#l12.186"></a><span id="l12.186">    *  the accounts defined.</span>
<a href="#l12.187"></a><span id="l12.187">    */</span>
<a href="#l12.188"></a><span id="l12.188">   myIdentities: {},</span>
<a href="#l12.189"></a><span id="l12.189">   /**</span>
<a href="#l12.190"></a><span id="l12.190">    * The contact corresponding to the current user.  We are assuming that only</span>
<a href="#l12.191"></a><span id="l12.191" class="difflineat">@@ -274,36 +274,36 @@ var Gloda = {</span>
<a href="#l12.192"></a><span id="l12.192">    *</span>
<a href="#l12.193"></a><span id="l12.193">    * @TODO deal with account addition/modification/removal</span>
<a href="#l12.194"></a><span id="l12.194">    * @TODO attempt to deal with multiple people using the same profile</span>
<a href="#l12.195"></a><span id="l12.195">    */</span>
<a href="#l12.196"></a><span id="l12.196">   _initMyIdentities: function gloda_ns_initMyIdentities() {</span>
<a href="#l12.197"></a><span id="l12.197">     let myContact = null;</span>
<a href="#l12.198"></a><span id="l12.198">     let myIdentities = {};</span>
<a href="#l12.199"></a><span id="l12.199">     let myEmailAddresses = {}; // process each email at most once; stored here</span>
<a href="#l12.200"></a><span id="l12.200" class="difflineminus">-    </span>
<a href="#l12.201"></a><span id="l12.201" class="difflineplus">+</span>
<a href="#l12.202"></a><span id="l12.202">     let fullName = null;</span>
<a href="#l12.203"></a><span id="l12.203">     let existingIdentities = [];</span>
<a href="#l12.204"></a><span id="l12.204">     let identitiesToCreate = [];</span>
<a href="#l12.205"></a><span id="l12.205" class="difflineminus">-  </span>
<a href="#l12.206"></a><span id="l12.206" class="difflineplus">+</span>
<a href="#l12.207"></a><span id="l12.207">     let msgAccountManager = Cc[&quot;@mozilla.org/messenger/account-manager;1&quot;].</span>
<a href="#l12.208"></a><span id="l12.208">                             getService(Ci.nsIMsgAccountManager);</span>
<a href="#l12.209"></a><span id="l12.209">     let numIdentities = msgAccountManager.allIdentities.Count();</span>
<a href="#l12.210"></a><span id="l12.210" class="difflineminus">-    </span>
<a href="#l12.211"></a><span id="l12.211" class="difflineplus">+</span>
<a href="#l12.212"></a><span id="l12.212">     // nothing to do if there are no accounts/identities.</span>
<a href="#l12.213"></a><span id="l12.213">     if (!numIdentities)</span>
<a href="#l12.214"></a><span id="l12.214">       return;</span>
<a href="#l12.215"></a><span id="l12.215" class="difflineminus">-    </span>
<a href="#l12.216"></a><span id="l12.216" class="difflineplus">+</span>
<a href="#l12.217"></a><span id="l12.217">     for (let iIdentity = 0; iIdentity &lt; numIdentities; iIdentity++) {</span>
<a href="#l12.218"></a><span id="l12.218">       let msgIdentity = msgAccountManager.allIdentities.GetElementAt(iIdentity)</span>
<a href="#l12.219"></a><span id="l12.219">                                          .QueryInterface(Ci.nsIMsgIdentity);</span>
<a href="#l12.220"></a><span id="l12.220" class="difflineminus">-      </span>
<a href="#l12.221"></a><span id="l12.221" class="difflineplus">+</span>
<a href="#l12.222"></a><span id="l12.222">       if (fullName === null)</span>
<a href="#l12.223"></a><span id="l12.223">         fullName = msgIdentity.fullName;</span>
<a href="#l12.224"></a><span id="l12.224" class="difflineminus">-        </span>
<a href="#l12.225"></a><span id="l12.225" class="difflineplus">+</span>
<a href="#l12.226"></a><span id="l12.226">       let emailAddress = msgIdentity.email;</span>
<a href="#l12.227"></a><span id="l12.227">       let replyTo = msgIdentity.replyTo;</span>
<a href="#l12.228"></a><span id="l12.228"> </span>
<a href="#l12.229"></a><span id="l12.229">       // find the identities if they exist, flag to create them if they don't</span>
<a href="#l12.230"></a><span id="l12.230">       if (emailAddress) {</span>
<a href="#l12.231"></a><span id="l12.231">         parsed = GlodaUtils.parseMailAddresses(emailAddress);</span>
<a href="#l12.232"></a><span id="l12.232">         if (!(parsed.addresses[0] in myEmailAddresses)) {</span>
<a href="#l12.233"></a><span id="l12.233">           let identity = GlodaDatastore.getIdentity(&quot;email&quot;,</span>
<a href="#l12.234"></a><span id="l12.234" class="difflineat">@@ -323,81 +323,81 @@ var Gloda = {</span>
<a href="#l12.235"></a><span id="l12.235">           if (identity)</span>
<a href="#l12.236"></a><span id="l12.236">             existingIdentities.push(identity);</span>
<a href="#l12.237"></a><span id="l12.237">           else</span>
<a href="#l12.238"></a><span id="l12.238">             identitiesToCreate.push(parsed.addresses[0]);</span>
<a href="#l12.239"></a><span id="l12.239">           myEmailAddresses[parsed.addresses[0]] = true;</span>
<a href="#l12.240"></a><span id="l12.240">         }</span>
<a href="#l12.241"></a><span id="l12.241">       }</span>
<a href="#l12.242"></a><span id="l12.242">     }</span>
<a href="#l12.243"></a><span id="l12.243" class="difflineminus">-    </span>
<a href="#l12.244"></a><span id="l12.244" class="difflineplus">+</span>
<a href="#l12.245"></a><span id="l12.245">     if (existingIdentities.length) {</span>
<a href="#l12.246"></a><span id="l12.246">       // just use the first guy's contact</span>
<a href="#l12.247"></a><span id="l12.247">       myContact = existingIdentities[0].contact;</span>
<a href="#l12.248"></a><span id="l12.248">     }</span>
<a href="#l12.249"></a><span id="l12.249">     else {</span>
<a href="#l12.250"></a><span id="l12.250">       // create a new contact</span>
<a href="#l12.251"></a><span id="l12.251">       myContact = GlodaDatastore.createContact(null, null, fullName || &quot;Me&quot;,</span>
<a href="#l12.252"></a><span id="l12.252">                                                0, 0);</span>
<a href="#l12.253"></a><span id="l12.253">     }</span>
<a href="#l12.254"></a><span id="l12.254" class="difflineminus">-    </span>
<a href="#l12.255"></a><span id="l12.255" class="difflineplus">+</span>
<a href="#l12.256"></a><span id="l12.256">     if (identitiesToCreate.length) {</span>
<a href="#l12.257"></a><span id="l12.257">       for (let iIdentity = 0; iIdentity &lt; identitiesToCreate.length;</span>
<a href="#l12.258"></a><span id="l12.258">           iIdentity++) {</span>
<a href="#l12.259"></a><span id="l12.259">         let emailAddress = identitiesToCreate[iIdentity];</span>
<a href="#l12.260"></a><span id="l12.260">         // XXX this won't always be of type &quot;email&quot; as we add new account types</span>
<a href="#l12.261"></a><span id="l12.261">         // XXX the blank string could be trying to differentiate; we do have</span>
<a href="#l12.262"></a><span id="l12.262">         //  enough info to do it.</span>
<a href="#l12.263"></a><span id="l12.263">         let identity = GlodaDatastore.createIdentity(myContact.id, myContact,</span>
<a href="#l12.264"></a><span id="l12.264">                                                      &quot;email&quot;,</span>
<a href="#l12.265"></a><span id="l12.265">                                                      emailAddress,</span>
<a href="#l12.266"></a><span id="l12.266">                                                      &quot;&quot;, false);</span>
<a href="#l12.267"></a><span id="l12.267">         existingIdentities.push(identity);</span>
<a href="#l12.268"></a><span id="l12.268">       }</span>
<a href="#l12.269"></a><span id="l12.269">     }</span>
<a href="#l12.270"></a><span id="l12.270" class="difflineminus">-    </span>
<a href="#l12.271"></a><span id="l12.271" class="difflineplus">+</span>
<a href="#l12.272"></a><span id="l12.272">     for (let iIdentity = 0; iIdentity &lt; existingIdentities.length;</span>
<a href="#l12.273"></a><span id="l12.273">         iIdentity++) {</span>
<a href="#l12.274"></a><span id="l12.274">       let identity = existingIdentities[iIdentity];</span>
<a href="#l12.275"></a><span id="l12.275">       myIdentities[identity.id] = identity;</span>
<a href="#l12.276"></a><span id="l12.276">     }</span>
<a href="#l12.277"></a><span id="l12.277" class="difflineminus">-    </span>
<a href="#l12.278"></a><span id="l12.278" class="difflineplus">+</span>
<a href="#l12.279"></a><span id="l12.279">     this.myContact = myContact;</span>
<a href="#l12.280"></a><span id="l12.280" class="difflineminus">-    this.myIdentities = myIdentities;   </span>
<a href="#l12.281"></a><span id="l12.281" class="difflineplus">+    this.myIdentities = myIdentities;</span>
<a href="#l12.282"></a><span id="l12.282">   },</span>
<a href="#l12.283"></a><span id="l12.283" class="difflineminus">-  </span>
<a href="#l12.284"></a><span id="l12.284" class="difflineplus">+</span>
<a href="#l12.285"></a><span id="l12.285">   /**</span>
<a href="#l12.286"></a><span id="l12.286">    * An attribute that is a defining characteristic of the subject.</span>
<a href="#l12.287"></a><span id="l12.287">    */</span>
<a href="#l12.288"></a><span id="l12.288">   kAttrFundamental: 0,</span>
<a href="#l12.289"></a><span id="l12.289">   /**</span>
<a href="#l12.290"></a><span id="l12.290">    * An attribute that is an optimization derived from two or more fundamental</span>
<a href="#l12.291"></a><span id="l12.291">    *  attributes and exists solely to improve database query performance.</span>
<a href="#l12.292"></a><span id="l12.292">    */</span>
<a href="#l12.293"></a><span id="l12.293">   kAttrOptimization: 1,</span>
<a href="#l12.294"></a><span id="l12.294">   /**</span>
<a href="#l12.295"></a><span id="l12.295">    * An attribute that is derived from the content of the subject.  For example,</span>
<a href="#l12.296"></a><span id="l12.296">    *  a message that references a bugzilla bug could have a &quot;derived&quot; attribute</span>
<a href="#l12.297"></a><span id="l12.297" class="difflineminus">-   *  that captures the bugzilla reference.  This is not </span>
<a href="#l12.298"></a><span id="l12.298" class="difflineplus">+   *  that captures the bugzilla reference.  This is not</span>
<a href="#l12.299"></a><span id="l12.299">    */</span>
<a href="#l12.300"></a><span id="l12.300">   kAttrDerived: 2,</span>
<a href="#l12.301"></a><span id="l12.301">   /**</span>
<a href="#l12.302"></a><span id="l12.302">    * An attribute that is the result of an explicit and intentional user action</span>
<a href="#l12.303"></a><span id="l12.303">    *  upon the subject.  For example, a tag placed on a message by a user (or</span>
<a href="#l12.304"></a><span id="l12.304">    *  at the user's request by a filter) is explicit.</span>
<a href="#l12.305"></a><span id="l12.305">    */</span>
<a href="#l12.306"></a><span id="l12.306">   kAttrExplicit: 3,</span>
<a href="#l12.307"></a><span id="l12.307">   /**</span>
<a href="#l12.308"></a><span id="l12.308">    * An attribute that is indirectly the result of a user's behaviour.  For</span>
<a href="#l12.309"></a><span id="l12.309">    *  example, if a user consults a message multiple times, we may conclude that</span>
<a href="#l12.310"></a><span id="l12.310">    *  the user finds the message interesting.  It is &quot;implied&quot;, if you will,</span>
<a href="#l12.311"></a><span id="l12.311">    *  that the message is interesting.</span>
<a href="#l12.312"></a><span id="l12.312">    */</span>
<a href="#l12.313"></a><span id="l12.313">   kAttrImplicit: 4,</span>
<a href="#l12.314"></a><span id="l12.314" class="difflineminus">-  </span>
<a href="#l12.315"></a><span id="l12.315" class="difflineplus">+</span>
<a href="#l12.316"></a><span id="l12.316">   /**</span>
<a href="#l12.317"></a><span id="l12.317">    * This attribute is not 'special'; it is stored as a (thing id, attribute id,</span>
<a href="#l12.318"></a><span id="l12.318">    *  attribute id) tuple in the database rather than on thing's row or on</span>
<a href="#l12.319"></a><span id="l12.319">    *  thing's fulltext row.  (Where &quot;thing&quot; could be a message or any other</span>
<a href="#l12.320"></a><span id="l12.320">    *  first class noun.)</span>
<a href="#l12.321"></a><span id="l12.321">    */</span>
<a href="#l12.322"></a><span id="l12.322">   kSpecialNotAtAll: 0,</span>
<a href="#l12.323"></a><span id="l12.323">   /**</span>
<a href="#l12.324"></a><span id="l12.324" class="difflineat">@@ -413,24 +413,24 @@ var Gloda = {</span>
<a href="#l12.325"></a><span id="l12.325">    */</span>
<a href="#l12.326"></a><span id="l12.326">   kSpecialString: 2,</span>
<a href="#l12.327"></a><span id="l12.327">   /**</span>
<a href="#l12.328"></a><span id="l12.328">    * This attribute is stored as a fulltext column on the fulltext table for</span>
<a href="#l12.329"></a><span id="l12.329">    *  the noun.  The attribute defintion should include this value as 'special'</span>
<a href="#l12.330"></a><span id="l12.330">    *  and the column name that stores the table as 'specialColumnName'.</span>
<a href="#l12.331"></a><span id="l12.331">    */</span>
<a href="#l12.332"></a><span id="l12.332">   kSpecialFulltext: 3,</span>
<a href="#l12.333"></a><span id="l12.333" class="difflineminus">-  </span>
<a href="#l12.334"></a><span id="l12.334" class="difflineplus">+</span>
<a href="#l12.335"></a><span id="l12.335">   /**</span>
<a href="#l12.336"></a><span id="l12.336">    * The extensionName used for the attributes defined by core gloda plugins</span>
<a href="#l12.337"></a><span id="l12.337">    *  such as fundattr.js and explattr.js.</span>
<a href="#l12.338"></a><span id="l12.338">    */</span>
<a href="#l12.339"></a><span id="l12.339">   BUILT_IN: &quot;built-in&quot;,</span>
<a href="#l12.340"></a><span id="l12.340" class="difflineminus">-  </span>
<a href="#l12.341"></a><span id="l12.341" class="difflineminus">-  </span>
<a href="#l12.342"></a><span id="l12.342" class="difflineplus">+</span>
<a href="#l12.343"></a><span id="l12.343" class="difflineplus">+</span>
<a href="#l12.344"></a><span id="l12.344">   /*</span>
<a href="#l12.345"></a><span id="l12.345">    * The following are explicit noun IDs.  While most extension-provided nouns</span>
<a href="#l12.346"></a><span id="l12.346">    *  will have dynamically allocated id's that are looked up by name, these</span>
<a href="#l12.347"></a><span id="l12.347">    *  id's can be relied upon to exist and be accessible via these</span>
<a href="#l12.348"></a><span id="l12.348">    *  pseudo-constants.  It's not really clear that we need these, although it</span>
<a href="#l12.349"></a><span id="l12.349">    *  does potentially simplify code to not have to look up all of their nouns</span>
<a href="#l12.350"></a><span id="l12.350">    *  at initialization time.</span>
<a href="#l12.351"></a><span id="l12.351">    */</span>
<a href="#l12.352"></a><span id="l12.352" class="difflineat">@@ -510,43 +510,43 @@ var Gloda = {</span>
<a href="#l12.353"></a><span id="l12.353">   NOUN_CONTACT: GlodaContact.prototype.NOUN_ID, // 103</span>
<a href="#l12.354"></a><span id="l12.354">   /**</span>
<a href="#l12.355"></a><span id="l12.355">    * A single identity of a contact, who may have one or more.  E-mail accounts,</span>
<a href="#l12.356"></a><span id="l12.356">    *  instant messaging accounts, social network site accounts, etc. are each</span>
<a href="#l12.357"></a><span id="l12.357">    *  identities.  See datamodel.js for the definition of the GlodaIdentity</span>
<a href="#l12.358"></a><span id="l12.358">    *  class.</span>
<a href="#l12.359"></a><span id="l12.359">    */</span>
<a href="#l12.360"></a><span id="l12.360">   NOUN_IDENTITY: GlodaIdentity.prototype.NOUN_ID, // 104</span>
<a href="#l12.361"></a><span id="l12.361" class="difflineminus">-  </span>
<a href="#l12.362"></a><span id="l12.362" class="difflineplus">+</span>
<a href="#l12.363"></a><span id="l12.363">   /**</span>
<a href="#l12.364"></a><span id="l12.364">    * Parameterized identities, for use in the from-me, to-me, cc-me optimization</span>
<a href="#l12.365"></a><span id="l12.365">    *  cases.  Not for reuse without some thought.  These nouns use the parameter</span>
<a href="#l12.366"></a><span id="l12.366">    *  to store the 'me' identity that we are talking about, and the value to</span>
<a href="#l12.367"></a><span id="l12.367">    *  store the identity of the other party.  So in both the from-me and to-me</span>
<a href="#l12.368"></a><span id="l12.368">    *  cases involving 'me' and 'foo@bar', the 'me' identity is always stored via</span>
<a href="#l12.369"></a><span id="l12.369">    *  the attribute parameter, and the 'foo@bar' identity is always stored as</span>
<a href="#l12.370"></a><span id="l12.370">    *  the attribute value.  See fundattr.js for more information on this, but</span>
<a href="#l12.371"></a><span id="l12.371">    *  you probably shouldn't be touching this unless you are fundattr.</span>
<a href="#l12.372"></a><span id="l12.372">    */</span>
<a href="#l12.373"></a><span id="l12.373">   NOUN_PARAM_IDENTITY: 200,</span>
<a href="#l12.374"></a><span id="l12.374" class="difflineminus">-  </span>
<a href="#l12.375"></a><span id="l12.375" class="difflineplus">+</span>
<a href="#l12.376"></a><span id="l12.376">   /** Next Noun ID to hand out, these don't need to be persisted (for now). */</span>
<a href="#l12.377"></a><span id="l12.377">   _nextNounID: 1000,</span>
<a href="#l12.378"></a><span id="l12.378"> </span>
<a href="#l12.379"></a><span id="l12.379">   /**</span>
<a href="#l12.380"></a><span id="l12.380">    * Maps noun names to noun IDs.</span>
<a href="#l12.381"></a><span id="l12.381">    */</span>
<a href="#l12.382"></a><span id="l12.382">   _nounNameToNounID: {},</span>
<a href="#l12.383"></a><span id="l12.383">   /**</span>
<a href="#l12.384"></a><span id="l12.384">    * Maps noun IDs to noun meta dictionaries.  (Noun meta dictionaries being</span>
<a href="#l12.385"></a><span id="l12.385">    *  the dictionary provided to us at the time a noun was defined, plus some</span>
<a href="#l12.386"></a><span id="l12.386">    *  additional stuff we put in there.)</span>
<a href="#l12.387"></a><span id="l12.387">    */</span>
<a href="#l12.388"></a><span id="l12.388">   _nounIDToMeta: {},</span>
<a href="#l12.389"></a><span id="l12.389" class="difflineminus">-  </span>
<a href="#l12.390"></a><span id="l12.390" class="difflineplus">+</span>
<a href="#l12.391"></a><span id="l12.391">   /**</span>
<a href="#l12.392"></a><span id="l12.392">    * Define a noun.  Takes a dictionary with the following keys/values:</span>
<a href="#l12.393"></a><span id="l12.393">    *</span>
<a href="#l12.394"></a><span id="l12.394">    * @param name The name of the noun.  This is not a display name (anything</span>
<a href="#l12.395"></a><span id="l12.395">    *     being displayed needs to be localized, after all), but simply the</span>
<a href="#l12.396"></a><span id="l12.396">    *     canonical name for debugging purposes and for people to pass to</span>
<a href="#l12.397"></a><span id="l12.397">    *     lookupNoun.  The suggested convention is lower-case-dash-delimited,</span>
<a href="#l12.398"></a><span id="l12.398">    *     with names being singular (since it's a single noun we are referring</span>
<a href="#l12.399"></a><span id="l12.399" class="difflineat">@@ -555,72 +555,77 @@ var Gloda = {</span>
<a href="#l12.400"></a><span id="l12.400">    *     will pass an instanceof test).</span>
<a href="#l12.401"></a><span id="l12.401">    * @param firstClass Is this a 'first class noun'/can it be a subject, AKA can</span>
<a href="#l12.402"></a><span id="l12.402">    *     this noun have attributes stored on it that relate it to other things?</span>
<a href="#l12.403"></a><span id="l12.403">    *     For example, a message is first-class; we store attributes of</span>
<a href="#l12.404"></a><span id="l12.404">    *     messages.  A date is not first-class now, nor is it likely to be; we</span>
<a href="#l12.405"></a><span id="l12.405">    *     will not store attributes about a date, although dates will be the</span>
<a href="#l12.406"></a><span id="l12.406">    *     objects of other subjects.  (For example: we might associate a date</span>
<a href="#l12.407"></a><span id="l12.407">    *     with a calendar event, but the date is an attribute of the calendar</span>
<a href="#l12.408"></a><span id="l12.408" class="difflineminus">-   *     event and not vice versa.) </span>
<a href="#l12.409"></a><span id="l12.409" class="difflineplus">+   *     event and not vice versa.)</span>
<a href="#l12.410"></a><span id="l12.410">    * @param usesParameter A boolean indicating whether this noun requires use</span>
<a href="#l12.411"></a><span id="l12.411">    *     of the 'parameter' BLOB storage field on the attribute bindings in the</span>
<a href="#l12.412"></a><span id="l12.412">    *     database to persist itself.  Use of parameters should be limited</span>
<a href="#l12.413"></a><span id="l12.413">    *     to a reasonable number of values (16-32 is okay, more than that is</span>
<a href="#l12.414"></a><span id="l12.414">    *     pushing it and 256 should be considered an absolute upper bound)</span>
<a href="#l12.415"></a><span id="l12.415">    *     because of the database organization.  When false, your toParamAndValue</span>
<a href="#l12.416"></a><span id="l12.416">    *     function is expected to return null for the parameter and likewise your</span>
<a href="#l12.417"></a><span id="l12.417">    *     fromParamAndValue should expect ignore and generally ignore the</span>
<a href="#l12.418"></a><span id="l12.418">    *     argument.</span>
<a href="#l12.419"></a><span id="l12.419">    * @param fromParamAndValue A function that takes a parameter value and the</span>
<a href="#l12.420"></a><span id="l12.420" class="difflineminus">-   *     object value and should return an instantiated noun instance. </span>
<a href="#l12.421"></a><span id="l12.421" class="difflineplus">+   *     object value and should return an instantiated noun instance.</span>
<a href="#l12.422"></a><span id="l12.422">    * @param toParamAndValue A function that takes an instantiated noun</span>
<a href="#l12.423"></a><span id="l12.423">    *     instance and returns a 2-element list of [parameter, value] where</span>
<a href="#l12.424"></a><span id="l12.424">    *     parameter may only be non-null if you passed a usesParameter of true.</span>
<a href="#l12.425"></a><span id="l12.425">    *     Parameter may be of any type (BLOB), and value must be numeric (pass</span>
<a href="#l12.426"></a><span id="l12.426">    *     0 if you don't need the value).</span>
<a href="#l12.427"></a><span id="l12.427">    */</span>
<a href="#l12.428"></a><span id="l12.428">   defineNoun: function gloda_ns_defineNoun(aNounMeta, aNounID) {</span>
<a href="#l12.429"></a><span id="l12.429">     this._log.info(&quot;Defining noun: &quot; + aNounMeta.name);</span>
<a href="#l12.430"></a><span id="l12.430">     if (aNounID === undefined)</span>
<a href="#l12.431"></a><span id="l12.431">       aNounID = this._nextNounID++;</span>
<a href="#l12.432"></a><span id="l12.432">     aNounMeta.id = aNounID;</span>
<a href="#l12.433"></a><span id="l12.433">     // if it has a table, you can query on it.  seems straight-forward.</span>
<a href="#l12.434"></a><span id="l12.434">     if (aNounMeta.tableName) {</span>
<a href="#l12.435"></a><span id="l12.435">       [aNounMeta.queryClass, aNounMeta.explicitQueryClass,</span>
<a href="#l12.436"></a><span id="l12.436">        aNounMeta.wildcardQueryClass] =</span>
<a href="#l12.437"></a><span id="l12.437">           GlodaQueryClassFactory(aNounMeta);</span>
<a href="#l12.438"></a><span id="l12.438" class="difflineplus">+      aNounMeta._dbMeta = {};</span>
<a href="#l12.439"></a><span id="l12.439" class="difflineplus">+      aNounMeta.class.prototype.NOUN_META = aNounMeta;</span>
<a href="#l12.440"></a><span id="l12.440">     }</span>
<a href="#l12.441"></a><span id="l12.441">     if (aNounMeta.cache) {</span>
<a href="#l12.442"></a><span id="l12.442">       let cacheCost = aNounMeta.cacheCost || 1024;</span>
<a href="#l12.443"></a><span id="l12.443">       let cacheBudget = aNounMeta.cacheBudget || 128 * 1024;</span>
<a href="#l12.444"></a><span id="l12.444">       let cacheSize = Math.floor(cacheBudget / cacheCost);</span>
<a href="#l12.445"></a><span id="l12.445">       if (cacheSize)</span>
<a href="#l12.446"></a><span id="l12.446">         GlodaCollectionManager.defineCache(aNounMeta, cacheSize);</span>
<a href="#l12.447"></a><span id="l12.447">     }</span>
<a href="#l12.448"></a><span id="l12.448" class="difflineminus">-    this._nounNameToNounID[aNounMeta.name] = aNounID; </span>
<a href="#l12.449"></a><span id="l12.449" class="difflineplus">+    this._nounNameToNounID[aNounMeta.name] = aNounID;</span>
<a href="#l12.450"></a><span id="l12.450">     this._nounIDToMeta[aNounID] = aNounMeta;</span>
<a href="#l12.451"></a><span id="l12.451">     aNounMeta.actions = [];</span>
<a href="#l12.452"></a><span id="l12.452" class="difflineplus">+    </span>
<a href="#l12.453"></a><span id="l12.453" class="difflineplus">+    this._attrProviderOrderByNoun[aNounMeta.id] = [];</span>
<a href="#l12.454"></a><span id="l12.454" class="difflineplus">+    this._attrProvidersByNoun[aNounMeta.id] = {};</span>
<a href="#l12.455"></a><span id="l12.455">   },</span>
<a href="#l12.456"></a><span id="l12.456" class="difflineminus">-  </span>
<a href="#l12.457"></a><span id="l12.457" class="difflineplus">+</span>
<a href="#l12.458"></a><span id="l12.458">   /**</span>
<a href="#l12.459"></a><span id="l12.459">    * Lookup a noun (ID) suitable for passing to defineAttribute's various</span>
<a href="#l12.460"></a><span id="l12.460">    *  noun arguments.  Throws an exception if the noun with the given name</span>
<a href="#l12.461"></a><span id="l12.461">    *  cannot be found; the assumption is that you can't live without the noun.</span>
<a href="#l12.462"></a><span id="l12.462">    */</span>
<a href="#l12.463"></a><span id="l12.463">   lookupNoun: function gloda_ns_lookupNoun(aNounName) {</span>
<a href="#l12.464"></a><span id="l12.464">     if (aNounName in this._nounNameToNounID)</span>
<a href="#l12.465"></a><span id="l12.465">       return this._nounNameToNounID[aNounName];</span>
<a href="#l12.466"></a><span id="l12.466" class="difflineminus">-    </span>
<a href="#l12.467"></a><span id="l12.467" class="difflineplus">+</span>
<a href="#l12.468"></a><span id="l12.468">     throw Error(&quot;Unable to locate noun with name '&quot; + aNounName + &quot;', but I &quot; +</span>
<a href="#l12.469"></a><span id="l12.469">                 &quot;do know about: &quot; +</span>
<a href="#l12.470"></a><span id="l12.470">                 [propName for</span>
<a href="#l12.471"></a><span id="l12.471" class="difflineminus">-                 (propName in this._nounNameToNounID)].join(&quot;, &quot;)); </span>
<a href="#l12.472"></a><span id="l12.472" class="difflineplus">+                 (propName in this._nounNameToNounID)].join(&quot;, &quot;));</span>
<a href="#l12.473"></a><span id="l12.473">   },</span>
<a href="#l12.474"></a><span id="l12.474" class="difflineminus">-  </span>
<a href="#l12.475"></a><span id="l12.475" class="difflineplus">+</span>
<a href="#l12.476"></a><span id="l12.476">   /**</span>
<a href="#l12.477"></a><span id="l12.477">    * Define an action on a noun.  During the prototype stage, this was conceived</span>
<a href="#l12.478"></a><span id="l12.478">    *  of as a way to expose all the constraints possible given a noun.  For</span>
<a href="#l12.479"></a><span id="l12.479">    *  example, if you have an identity or a contact, you could use this to</span>
<a href="#l12.480"></a><span id="l12.480">    *  see all the messages sent from/to a given contact.  It was likewise</span>
<a href="#l12.481"></a><span id="l12.481">    *  thought potentially usable for future expansion.  For example, you could</span>
<a href="#l12.482"></a><span id="l12.482">    *  also decide to send an e-mail to a contact when you have the contact</span>
<a href="#l12.483"></a><span id="l12.483">    *  instance available.</span>
<a href="#l12.484"></a><span id="l12.484" class="difflineat">@@ -653,34 +658,39 @@ var Gloda = {</span>
<a href="#l12.485"></a><span id="l12.485">    *   constraints.  Since the APV-style query mechanism is now deprecated,</span>
<a href="#l12.486"></a><span id="l12.486">    *   this signature is deprecated.  Probably the way to update this would be</span>
<a href="#l12.487"></a><span id="l12.487">    *   to pass in the query instance that constraints should be contributed to.</span>
<a href="#l12.488"></a><span id="l12.488">    */</span>
<a href="#l12.489"></a><span id="l12.489">   defineNounAction: function gloda_ns_defineNounAction(aNounID, aActionMeta) {</span>
<a href="#l12.490"></a><span id="l12.490">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l12.491"></a><span id="l12.491">     nounMeta.actions.push(aActionMeta);</span>
<a href="#l12.492"></a><span id="l12.492">   },</span>
<a href="#l12.493"></a><span id="l12.493" class="difflineminus">-  </span>
<a href="#l12.494"></a><span id="l12.494" class="difflineplus">+</span>
<a href="#l12.495"></a><span id="l12.495">   /**</span>
<a href="#l12.496"></a><span id="l12.496">    * Retrieve all of the actions (as defined using defineNounAction) for the</span>
<a href="#l12.497"></a><span id="l12.497">    *  given noun type (via noun ID) with the given action type (ex: filter).</span>
<a href="#l12.498"></a><span id="l12.498">    */</span>
<a href="#l12.499"></a><span id="l12.499">   getNounActions: function gloda_ns_getNounActions(aNounID, aActionType) {</span>
<a href="#l12.500"></a><span id="l12.500">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l12.501"></a><span id="l12.501">     if (!nounMeta)</span>
<a href="#l12.502"></a><span id="l12.502">       return [];</span>
<a href="#l12.503"></a><span id="l12.503">     return [action for each (action in nounMeta.actions)</span>
<a href="#l12.504"></a><span id="l12.504">             if (!aActionType || (action.actionType == aActionType))];</span>
<a href="#l12.505"></a><span id="l12.505">   },</span>
<a href="#l12.506"></a><span id="l12.506" class="difflineminus">-  </span>
<a href="#l12.507"></a><span id="l12.507" class="difflineplus">+</span>
<a href="#l12.508"></a><span id="l12.508">   /** Attribute providers in the sequence to process them. */</span>
<a href="#l12.509"></a><span id="l12.509" class="difflineminus">-  _attrProviderOrder: [],</span>
<a href="#l12.510"></a><span id="l12.510" class="difflineplus">+  _attrProviderOrderByNoun: {},</span>
<a href="#l12.511"></a><span id="l12.511">   /** Maps attribute providers to the list of attributes they provide */</span>
<a href="#l12.512"></a><span id="l12.512">   _attrProviders: {},</span>
<a href="#l12.513"></a><span id="l12.513" class="difflineminus">-  </span>
<a href="#l12.514"></a><span id="l12.514" class="difflineplus">+  /**</span>
<a href="#l12.515"></a><span id="l12.515" class="difflineplus">+   * Maps nouns to their attribute providers to a list of the attributes they</span>
<a href="#l12.516"></a><span id="l12.516" class="difflineplus">+   *  provide for the noun.</span>
<a href="#l12.517"></a><span id="l12.517" class="difflineplus">+   */</span>
<a href="#l12.518"></a><span id="l12.518" class="difflineplus">+  _attrProvidersByNoun: {},</span>
<a href="#l12.519"></a><span id="l12.519" class="difflineplus">+</span>
<a href="#l12.520"></a><span id="l12.520">   /**</span>
<a href="#l12.521"></a><span id="l12.521">    * Define the core nouns (that are not defined elsewhere) and a few noun</span>
<a href="#l12.522"></a><span id="l12.522">    *  actions.  Core nouns could be defined in other files, assuming dependency</span>
<a href="#l12.523"></a><span id="l12.523">    *  issues are resolved via the everybody.js mechanism or something else.</span>
<a href="#l12.524"></a><span id="l12.524">    *  Right now, noun_tag defines the tag noun.  If we broke more of these out,</span>
<a href="#l12.525"></a><span id="l12.525">    *  we would probably want to move the 'class' code from datamodel.js, the</span>
<a href="#l12.526"></a><span id="l12.526">    *  SQL table def and helper code from datastore.js (and this code) to their</span>
<a href="#l12.527"></a><span id="l12.527">    *  own noun_*.js files.  There are some trade-offs to be made, and I think</span>
<a href="#l12.528"></a><span id="l12.528" class="difflineat">@@ -767,35 +777,36 @@ var Gloda = {</span>
<a href="#l12.529"></a><span id="l12.529">           return [null, aConversation.id];</span>
<a href="#l12.530"></a><span id="l12.530">         else // assume they're just passing the id directly</span>
<a href="#l12.531"></a><span id="l12.531">           return [null, aConversation];</span>
<a href="#l12.532"></a><span id="l12.532">       }}, this.NOUN_CONVERSATION);</span>
<a href="#l12.533"></a><span id="l12.533">     this.defineNoun({</span>
<a href="#l12.534"></a><span id="l12.534">       name: &quot;message&quot;,</span>
<a href="#l12.535"></a><span id="l12.535">       class: GlodaMessage,</span>
<a href="#l12.536"></a><span id="l12.536">       firstClass: true,</span>
<a href="#l12.537"></a><span id="l12.537" class="difflineminus">-      cache: true, cacheCost: 2048, </span>
<a href="#l12.538"></a><span id="l12.538" class="difflineplus">+      cache: true, cacheCost: 2048,</span>
<a href="#l12.539"></a><span id="l12.539">       tableName: &quot;messages&quot;,</span>
<a href="#l12.540"></a><span id="l12.540">       attrTableName: &quot;messageAttributes&quot;, attrIDColumnName: &quot;messageID&quot;,</span>
<a href="#l12.541"></a><span id="l12.541">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._messageFromRow,</span>
<a href="#l12.542"></a><span id="l12.542">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l12.543"></a><span id="l12.543">         return GlodaDatastore.getMessageByID(aID);</span>
<a href="#l12.544"></a><span id="l12.544">       },</span>
<a href="#l12.545"></a><span id="l12.545">       toParamAndValue: function(aMessage) {</span>
<a href="#l12.546"></a><span id="l12.546">         if (aMessage instanceof GlodaMessage)</span>
<a href="#l12.547"></a><span id="l12.547">           return [null, aMessage.id];</span>
<a href="#l12.548"></a><span id="l12.548">         else // assume they're just passing the id directly</span>
<a href="#l12.549"></a><span id="l12.549">           return [null, aMessage];</span>
<a href="#l12.550"></a><span id="l12.550">       }}, this.NOUN_MESSAGE);</span>
<a href="#l12.551"></a><span id="l12.551">     this.defineNoun({</span>
<a href="#l12.552"></a><span id="l12.552">       name: &quot;contact&quot;,</span>
<a href="#l12.553"></a><span id="l12.553">       class: GlodaContact,</span>
<a href="#l12.554"></a><span id="l12.554" class="difflineminus">-      firstClass: false,</span>
<a href="#l12.555"></a><span id="l12.555" class="difflineplus">+      firstClass: true,</span>
<a href="#l12.556"></a><span id="l12.556">       cache: true, cacheCost: 128,</span>
<a href="#l12.557"></a><span id="l12.557">       tableName: &quot;contacts&quot;,</span>
<a href="#l12.558"></a><span id="l12.558" class="difflineplus">+      attrTableName: &quot;contactAttributes&quot;, attrIDColumnName: &quot;contactID&quot;,</span>
<a href="#l12.559"></a><span id="l12.559">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._contactFromRow,</span>
<a href="#l12.560"></a><span id="l12.560">       objUpdate: GlodaDatastore.updateContact,</span>
<a href="#l12.561"></a><span id="l12.561">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l12.562"></a><span id="l12.562">         return GlodaDatastore.getContactByID(aID);</span>
<a href="#l12.563"></a><span id="l12.563">       },</span>
<a href="#l12.564"></a><span id="l12.564">       toParamAndValue: function(aContact) {</span>
<a href="#l12.565"></a><span id="l12.565">         if (aContact instanceof GlodaContact)</span>
<a href="#l12.566"></a><span id="l12.566">           return [null, aContact.id];</span>
<a href="#l12.567"></a><span id="l12.567" class="difflineat">@@ -832,19 +843,19 @@ var Gloda = {</span>
<a href="#l12.568"></a><span id="l12.568">         return [GlodaDatastore.getIdentityByID(aParamIdentityID),</span>
<a href="#l12.569"></a><span id="l12.569">                 GlodaDatastore.getIdentityByID(aValueIdentityID)];</span>
<a href="#l12.570"></a><span id="l12.570">       },</span>
<a href="#l12.571"></a><span id="l12.571">       toParamAndValue: function(aIdentityTuple) {</span>
<a href="#l12.572"></a><span id="l12.572">         if (typeof aIdentityTuple == &quot;number&quot;)</span>
<a href="#l12.573"></a><span id="l12.573">           return aIdentityTuple;</span>
<a href="#l12.574"></a><span id="l12.574">         return [aIdentityTuple[0].id, aIdentityTuple[1].id];</span>
<a href="#l12.575"></a><span id="l12.575">       }}, this.NOUN_PARAM_IDENTITY);</span>
<a href="#l12.576"></a><span id="l12.576" class="difflineminus">-  </span>
<a href="#l12.577"></a><span id="l12.577" class="difflineplus">+</span>
<a href="#l12.578"></a><span id="l12.578">     GlodaDatastore.getAllAttributes();</span>
<a href="#l12.579"></a><span id="l12.579" class="difflineminus">-        </span>
<a href="#l12.580"></a><span id="l12.580" class="difflineplus">+</span>
<a href="#l12.581"></a><span id="l12.581">     /* boolean actions, these are parameterized by the attribute they operate</span>
<a href="#l12.582"></a><span id="l12.582">        in the context of.  They are also (not coincidentally), ugly. */</span>
<a href="#l12.583"></a><span id="l12.583">     Gloda.defineNounAction(Gloda.NOUN_BOOLEAN, {actionType: &quot;filter&quot;,</span>
<a href="#l12.584"></a><span id="l12.584">       actionTarget: Gloda.NOUN_MESSAGE,</span>
<a href="#l12.585"></a><span id="l12.585">       shortName: &quot;true&quot;,</span>
<a href="#l12.586"></a><span id="l12.586">       makeConstraint: function(aAttrDef, aIdentity) {</span>
<a href="#l12.587"></a><span id="l12.587">         return [aAttrDef, null, 1];</span>
<a href="#l12.588"></a><span id="l12.588">       },</span>
<a href="#l12.589"></a><span id="l12.589" class="difflineat">@@ -852,35 +863,35 @@ var Gloda = {</span>
<a href="#l12.590"></a><span id="l12.590">     Gloda.defineNounAction(Gloda.NOUN_BOOLEAN, {actionType: &quot;filter&quot;,</span>
<a href="#l12.591"></a><span id="l12.591">       actionTarget: Gloda.NOUN_MESSAGE,</span>
<a href="#l12.592"></a><span id="l12.592">       shortName: &quot;false&quot;,</span>
<a href="#l12.593"></a><span id="l12.593">       makeConstraint: function(aAttrDef, aIdentity) {</span>
<a href="#l12.594"></a><span id="l12.594">         return [aAttrDef, null, 0];</span>
<a href="#l12.595"></a><span id="l12.595">       },</span>
<a href="#l12.596"></a><span id="l12.596">       });</span>
<a href="#l12.597"></a><span id="l12.597">   },</span>
<a href="#l12.598"></a><span id="l12.598" class="difflineminus">-  </span>
<a href="#l12.599"></a><span id="l12.599" class="difflineplus">+</span>
<a href="#l12.600"></a><span id="l12.600">   /**</span>
<a href="#l12.601"></a><span id="l12.601">    * Create accessor functions to 'bind' an attribute to underlying normalized</span>
<a href="#l12.602"></a><span id="l12.602">    *  attribute storage, as well as creating the appropriate query object</span>
<a href="#l12.603"></a><span id="l12.603">    *  constraint helper functions.  This name is somewhat of a misnomer because</span>
<a href="#l12.604"></a><span id="l12.604">    *  special attributes are not 'bound' (because specific/non-generic per-class</span>
<a href="#l12.605"></a><span id="l12.605">    *  code provides the properties) but still depend on this method to</span>
<a href="#l12.606"></a><span id="l12.606">    *  establish their constraint helper methods.</span>
<a href="#l12.607"></a><span id="l12.607">    *</span>
<a href="#l12.608"></a><span id="l12.608">    * @XXX potentially rename to not suggest binding is required.</span>
<a href="#l12.609"></a><span id="l12.609">    */</span>
<a href="#l12.610"></a><span id="l12.610">   _bindAttribute: function gloda_ns_bindAttr(aAttr, aSubjectType, aObjectType,</span>
<a href="#l12.611"></a><span id="l12.611">                                              aSingular, aDoBind, aBindName) {</span>
<a href="#l12.612"></a><span id="l12.612">     if (!(aSubjectType in this._nounIDToMeta))</span>
<a href="#l12.613"></a><span id="l12.613">       throw Error(&quot;Invalid subject type: &quot; + aSubjectType);</span>
<a href="#l12.614"></a><span id="l12.614" class="difflineminus">-    </span>
<a href="#l12.615"></a><span id="l12.615" class="difflineplus">+</span>
<a href="#l12.616"></a><span id="l12.616">     let nounMeta = this._nounIDToMeta[aObjectType];</span>
<a href="#l12.617"></a><span id="l12.617">     let subjectNounMeta = this._nounIDToMeta[aSubjectType];</span>
<a href="#l12.618"></a><span id="l12.618" class="difflineminus">-    </span>
<a href="#l12.619"></a><span id="l12.619" class="difflineplus">+</span>
<a href="#l12.620"></a><span id="l12.620">     // -- the on-object bindings</span>
<a href="#l12.621"></a><span id="l12.621">     if (aDoBind) {</span>
<a href="#l12.622"></a><span id="l12.622">       let storageName = &quot;__&quot; + aBindName;</span>
<a href="#l12.623"></a><span id="l12.623">       let getter;</span>
<a href="#l12.624"></a><span id="l12.624">       // should we memoize the value as a getter per-instance?</span>
<a href="#l12.625"></a><span id="l12.625">       if (aSingular) {</span>
<a href="#l12.626"></a><span id="l12.626">         getter = function() {</span>
<a href="#l12.627"></a><span id="l12.627">           let val = this[storageName];</span>
<a href="#l12.628"></a><span id="l12.628" class="difflineat">@@ -911,110 +922,110 @@ var Gloda = {</span>
<a href="#l12.629"></a><span id="l12.629">           else {</span>
<a href="#l12.630"></a><span id="l12.630">             values = instances; // empty is empty</span>
<a href="#l12.631"></a><span id="l12.631">           }</span>
<a href="#l12.632"></a><span id="l12.632">           //this[storageName] = values;</span>
<a href="#l12.633"></a><span id="l12.633">           this.__defineGetter__(aBindName, function() values);</span>
<a href="#l12.634"></a><span id="l12.634">           return values;</span>
<a href="#l12.635"></a><span id="l12.635">         }</span>
<a href="#l12.636"></a><span id="l12.636">       }</span>
<a href="#l12.637"></a><span id="l12.637" class="difflineminus">-  </span>
<a href="#l12.638"></a><span id="l12.638" class="difflineplus">+</span>
<a href="#l12.639"></a><span id="l12.639">       let subjectProto = subjectNounMeta.class.prototype;</span>
<a href="#l12.640"></a><span id="l12.640">       subjectProto.__defineGetter__(aBindName, getter);</span>
<a href="#l12.641"></a><span id="l12.641">       // no setters for now; manipulation comes later, and will require the attr</span>
<a href="#l12.642"></a><span id="l12.642">       //  definer to provide the actual logic, since we need to affect reality,</span>
<a href="#l12.643"></a><span id="l12.643">       //  not just the data-store.  we may also just punt that all off onto</span>
<a href="#l12.644"></a><span id="l12.644">       //  STEEL...</span>
<a href="#l12.645"></a><span id="l12.645"> </span>
<a href="#l12.646"></a><span id="l12.646">       aAttr._boundName = aBindName;</span>
<a href="#l12.647"></a><span id="l12.647">     }</span>
<a href="#l12.648"></a><span id="l12.648" class="difflineminus">-    </span>
<a href="#l12.649"></a><span id="l12.649" class="difflineminus">-    // -- the query constraint helpers </span>
<a href="#l12.650"></a><span id="l12.650" class="difflineplus">+</span>
<a href="#l12.651"></a><span id="l12.651" class="difflineplus">+    // -- the query constraint helpers</span>
<a href="#l12.652"></a><span id="l12.652">     if (subjectNounMeta.queryClass !== undefined) {</span>
<a href="#l12.653"></a><span id="l12.653">       let constrainer = function() {</span>
<a href="#l12.654"></a><span id="l12.654">         // all the arguments provided end up being ORed together</span>
<a href="#l12.655"></a><span id="l12.655">         let our_ors = [];</span>
<a href="#l12.656"></a><span id="l12.656">         for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l12.657"></a><span id="l12.657">           let argument = arguments[iArg];</span>
<a href="#l12.658"></a><span id="l12.658">           our_ors.push([aAttr].concat(nounMeta.toParamAndValue(argument)));</span>
<a href="#l12.659"></a><span id="l12.659">         }</span>
<a href="#l12.660"></a><span id="l12.660">         // but the constraints are ANDed together</span>
<a href="#l12.661"></a><span id="l12.661">         this._constraints.push(our_ors);</span>
<a href="#l12.662"></a><span id="l12.662">         return this;</span>
<a href="#l12.663"></a><span id="l12.663">       };</span>
<a href="#l12.664"></a><span id="l12.664"> </span>
<a href="#l12.665"></a><span id="l12.665">       subjectNounMeta.queryClass.prototype[aBindName] = constrainer;</span>
<a href="#l12.666"></a><span id="l12.666" class="difflineminus">-      </span>
<a href="#l12.667"></a><span id="l12.667" class="difflineplus">+</span>
<a href="#l12.668"></a><span id="l12.668">       // - ranged value helper: fooRange</span>
<a href="#l12.669"></a><span id="l12.669">       if (nounMeta.continuous) {</span>
<a href="#l12.670"></a><span id="l12.670">         let rangedConstrainer = function() {</span>
<a href="#l12.671"></a><span id="l12.671">           // all the arguments provided end up being ORed together</span>
<a href="#l12.672"></a><span id="l12.672">           let our_ors = [];</span>
<a href="#l12.673"></a><span id="l12.673">           for (let iArg = 0; iArg &lt; arguments.length; iArg +=2 ) {</span>
<a href="#l12.674"></a><span id="l12.674">             let pv1 = nounMeta.toParamAndValue(arguments[iArg]);</span>
<a href="#l12.675"></a><span id="l12.675">             let pv2 = nounMeta.toParamAndValue(arguments[iArg+1]);</span>
<a href="#l12.676"></a><span id="l12.676">             our_ors.push([aAttr, pv1[0], pv1[1], pv2[1]]);</span>
<a href="#l12.677"></a><span id="l12.677">           }</span>
<a href="#l12.678"></a><span id="l12.678">           // but the constraints are ANDed together</span>
<a href="#l12.679"></a><span id="l12.679">           this._constraints.push(our_ors);</span>
<a href="#l12.680"></a><span id="l12.680">           return this;</span>
<a href="#l12.681"></a><span id="l12.681">         }</span>
<a href="#l12.682"></a><span id="l12.682" class="difflineminus">-        </span>
<a href="#l12.683"></a><span id="l12.683" class="difflineplus">+</span>
<a href="#l12.684"></a><span id="l12.684">         subjectNounMeta.queryClass.prototype[aBindName + &quot;Range&quot;] =</span>
<a href="#l12.685"></a><span id="l12.685">           rangedConstrainer;</span>
<a href="#l12.686"></a><span id="l12.686">       }</span>
<a href="#l12.687"></a><span id="l12.687" class="difflineminus">-      </span>
<a href="#l12.688"></a><span id="l12.688" class="difflineplus">+</span>
<a href="#l12.689"></a><span id="l12.689">       // - string LIKE helper for special on-row attributes: fooLike</span>
<a href="#l12.690"></a><span id="l12.690">       if (aAttr.special == this.kSpecialString) {</span>
<a href="#l12.691"></a><span id="l12.691">         let likeConstrainer = function() {</span>
<a href="#l12.692"></a><span id="l12.692">           let our_ors = [];</span>
<a href="#l12.693"></a><span id="l12.693">           for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l12.694"></a><span id="l12.694">             let argument = arguments[iArg];</span>
<a href="#l12.695"></a><span id="l12.695">             let this_or = [aAttr].concat(nounMeta.toParamAndValue(argument));</span>
<a href="#l12.696"></a><span id="l12.696">             // we are pushing it up to a length of 4 to signify that this is a</span>
<a href="#l12.697"></a><span id="l12.697">             //  LIKE query rather than an exact match.  this results in a</span>
<a href="#l12.698"></a><span id="l12.698">             //  similar decision process to the numeric case.</span>
<a href="#l12.699"></a><span id="l12.699">             this_or.push(&quot;LIKE&quot;);</span>
<a href="#l12.700"></a><span id="l12.700">             our_ors.push(this_or);</span>
<a href="#l12.701"></a><span id="l12.701">           }</span>
<a href="#l12.702"></a><span id="l12.702">           this._constraints.push(our_ors);</span>
<a href="#l12.703"></a><span id="l12.703">           return this;</span>
<a href="#l12.704"></a><span id="l12.704">         }</span>
<a href="#l12.705"></a><span id="l12.705" class="difflineminus">-        </span>
<a href="#l12.706"></a><span id="l12.706" class="difflineplus">+</span>
<a href="#l12.707"></a><span id="l12.707">         subjectNounMeta.queryClass.prototype[aBindName + &quot;Like&quot;] =</span>
<a href="#l12.708"></a><span id="l12.708">           likeConstrainer;</span>
<a href="#l12.709"></a><span id="l12.709">       }</span>
<a href="#l12.710"></a><span id="l12.710">     }</span>
<a href="#l12.711"></a><span id="l12.711"> </span>
<a href="#l12.712"></a><span id="l12.712">     aAttr._singular = aSingular;</span>
<a href="#l12.713"></a><span id="l12.713">   },</span>
<a href="#l12.714"></a><span id="l12.714" class="difflineminus">-  </span>
<a href="#l12.715"></a><span id="l12.715" class="difflineplus">+</span>
<a href="#l12.716"></a><span id="l12.716">   /**</span>
<a href="#l12.717"></a><span id="l12.717">    * Define an attribute and all its meta-data.  Takes a single dictionary as</span>
<a href="#l12.718"></a><span id="l12.718">    *  its argument, with the following required properties:</span>
<a href="#l12.719"></a><span id="l12.719">    *</span>
<a href="#l12.720"></a><span id="l12.720">    * @param provider The object instance providing a 'process' method.</span>
<a href="#l12.721"></a><span id="l12.721">    * @param extensionName The name of the extension providing these attributes.</span>
<a href="#l12.722"></a><span id="l12.722" class="difflineminus">-   * @param attributeType The type of attribute, one of the values from the </span>
<a href="#l12.723"></a><span id="l12.723" class="difflineplus">+   * @param attributeType The type of attribute, one of the values from the</span>
<a href="#l12.724"></a><span id="l12.724">    *     kAttr* enumeration.</span>
<a href="#l12.725"></a><span id="l12.725">    * @param attributeName The name of the attribute, which also doubles as the</span>
<a href="#l12.726"></a><span id="l12.726">    *     bound property name if you pass 'bind' a value of true.  You are</span>
<a href="#l12.727"></a><span id="l12.727">    *     responsible for avoiding collisions, which presumably will mean</span>
<a href="#l12.728"></a><span id="l12.728">    *     checking/updating a wiki page in the future, or just prefixing your</span>
<a href="#l12.729"></a><span id="l12.729">    *     attribute name with your extension name or something like that.</span>
<a href="#l12.730"></a><span id="l12.730">    * @param bind Should this attribute be 'bound' as a convenience attribute</span>
<a href="#l12.731"></a><span id="l12.731">    *     on the subject's object (true/false)?  For example, with an</span>
<a href="#l12.732"></a><span id="l12.732">    *     attributeName of &quot;foo&quot; and passing true for 'bind' with a subject noun</span>
<a href="#l12.733"></a><span id="l12.733">    *     of NOUN_MESSAGE, GlodaMessage instances will expose a &quot;foo&quot; getter</span>
<a href="#l12.734"></a><span id="l12.734">    *     that returns the value of the attribute.  If 'singular' is true, this</span>
<a href="#l12.735"></a><span id="l12.735">    *     means an instance of the object class corresponding to the noun type or</span>
<a href="#l12.736"></a><span id="l12.736">    *     null if the attribute does not exist.  If 'singular' is false, this</span>
<a href="#l12.737"></a><span id="l12.737">    *     means a list of instances of the object class corresponding to the noun</span>
<a href="#l12.738"></a><span id="l12.738">    *     type, where the list may be empty if no instances of the attribute are</span>
<a href="#l12.739"></a><span id="l12.739" class="difflineminus">-   *     present. </span>
<a href="#l12.740"></a><span id="l12.740" class="difflineplus">+   *     present.</span>
<a href="#l12.741"></a><span id="l12.741">    * @param bindName Optional override of attributeName for purposes of the</span>
<a href="#l12.742"></a><span id="l12.742">    *     binding property's name.</span>
<a href="#l12.743"></a><span id="l12.743">    * @param singular Is the attribute going to happen at most once (true),</span>
<a href="#l12.744"></a><span id="l12.744">    *     or potentially multiple times (false).  This affects whether</span>
<a href="#l12.745"></a><span id="l12.745">    *     the binding  returns a list or just a single item (which is null when</span>
<a href="#l12.746"></a><span id="l12.746">    *     the attribute is not present).</span>
<a href="#l12.747"></a><span id="l12.747">    * @param subjectNouns A list of object types (NOUNs) that this attribute can</span>
<a href="#l12.748"></a><span id="l12.748">    *     be set on.  Each element in the list should be one of the NOUN_*</span>
<a href="#l12.749"></a><span id="l12.749" class="difflineat">@@ -1045,113 +1056,120 @@ var Gloda = {</span>
<a href="#l12.750"></a><span id="l12.750">         !(&quot;explanation&quot; in aAttrDef))</span>
<a href="#l12.751"></a><span id="l12.751">       // perhaps we should have a list of required attributes, perchance with</span>
<a href="#l12.752"></a><span id="l12.752">       //  and explanation of what it holds, and use that to be friendlier?</span>
<a href="#l12.753"></a><span id="l12.753">       throw Error(&quot;You omitted a required attribute defining property, please&quot; +</span>
<a href="#l12.754"></a><span id="l12.754">                   &quot; consult the documentation as penance.&quot;)</span>
<a href="#l12.755"></a><span id="l12.755"> </span>
<a href="#l12.756"></a><span id="l12.756">     // provider tracking</span>
<a href="#l12.757"></a><span id="l12.757">     if (!(aAttrDef.provider.providerName in this._attrProviders)) {</span>
<a href="#l12.758"></a><span id="l12.758" class="difflineminus">-      this._attrProviderOrder.push(aAttrDef.provider);</span>
<a href="#l12.759"></a><span id="l12.759">       this._attrProviders[aAttrDef.provider.providerName] = [];</span>
<a href="#l12.760"></a><span id="l12.760" class="difflineminus">-    } </span>
<a href="#l12.761"></a><span id="l12.761" class="difflineminus">-    </span>
<a href="#l12.762"></a><span id="l12.762" class="difflineplus">+    }</span>
<a href="#l12.763"></a><span id="l12.763" class="difflineplus">+</span>
<a href="#l12.764"></a><span id="l12.764">     let bindName;</span>
<a href="#l12.765"></a><span id="l12.765">     if (&quot;bindName&quot; in aAttrDef)</span>
<a href="#l12.766"></a><span id="l12.766">       bindName = aAttrDef.bindName;</span>
<a href="#l12.767"></a><span id="l12.767">     else</span>
<a href="#l12.768"></a><span id="l12.768">       bindName = aAttrDef.attributeName;</span>
<a href="#l12.769"></a><span id="l12.769" class="difflineminus">-    </span>
<a href="#l12.770"></a><span id="l12.770" class="difflineplus">+</span>
<a href="#l12.771"></a><span id="l12.771">     let compoundName = aAttrDef.extensionName + &quot;:&quot; + aAttrDef.attributeName;</span>
<a href="#l12.772"></a><span id="l12.772">     let attr = null;</span>
<a href="#l12.773"></a><span id="l12.773">     if (compoundName in GlodaDatastore._attributes) {</span>
<a href="#l12.774"></a><span id="l12.774">       // the existence of the GlodaAttributeDef means that either it has</span>
<a href="#l12.775"></a><span id="l12.775">       //  already been fully defined, or has been loaded from the database but</span>
<a href="#l12.776"></a><span id="l12.776">       //  not yet 'bound' to a provider (and had important meta-info that</span>
<a href="#l12.777"></a><span id="l12.777">       //  doesn't go in the db copied over)</span>
<a href="#l12.778"></a><span id="l12.778">       attr = GlodaDatastore._attributes[compoundName];</span>
<a href="#l12.779"></a><span id="l12.779">       if (attr.provider !== null) {</span>
<a href="#l12.780"></a><span id="l12.780">         return attr;</span>
<a href="#l12.781"></a><span id="l12.781">       }</span>
<a href="#l12.782"></a><span id="l12.782" class="difflineminus">-      </span>
<a href="#l12.783"></a><span id="l12.783" class="difflineplus">+</span>
<a href="#l12.784"></a><span id="l12.784">       // we are behind the abstraction veil and can set these things</span>
<a href="#l12.785"></a><span id="l12.785">       // (these would otherwise be passed in to the GlodaAttributeDef</span>
<a href="#l12.786"></a><span id="l12.786">       //  constructor.  they are not like the HATHATHAT guys below)</span>
<a href="#l12.787"></a><span id="l12.787">       attr._provider = aAttrDef.provider;</span>
<a href="#l12.788"></a><span id="l12.788">       attr._subjectTypes = aAttrDef.subjectNouns;</span>
<a href="#l12.789"></a><span id="l12.789">       attr._objectType = aAttrDef.objectNoun;</span>
<a href="#l12.790"></a><span id="l12.790">       attr._explanationFormat = aAttrDef.explanation;</span>
<a href="#l12.791"></a><span id="l12.791">       // things after here also need to be set below the new GlodaAttributeDef</span>
<a href="#l12.792"></a><span id="l12.792">       //  clause below... HATHATHAT</span>
<a href="#l12.793"></a><span id="l12.793">       attr._special = aAttrDef.special || this.kSpecialNotAtAll;</span>
<a href="#l12.794"></a><span id="l12.794">       attr._specialColumnName = aAttrDef.specialColumnName || null;</span>
<a href="#l12.795"></a><span id="l12.795" class="difflineminus">-      </span>
<a href="#l12.796"></a><span id="l12.796" class="difflineplus">+</span>
<a href="#l12.797"></a><span id="l12.797">       for (let iSubject = 0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l12.798"></a><span id="l12.798">            iSubject++) {</span>
<a href="#l12.799"></a><span id="l12.799">         let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l12.800"></a><span id="l12.800">         this._bindAttribute(attr, subjectType, aAttrDef.objectNoun,</span>
<a href="#l12.801"></a><span id="l12.801">                             aAttrDef.singular, aAttrDef.bind, bindName);</span>
<a href="#l12.802"></a><span id="l12.802" class="difflineplus">+</span>
<a href="#l12.803"></a><span id="l12.803" class="difflineplus">+        // update the provider maps...</span>
<a href="#l12.804"></a><span id="l12.804" class="difflineplus">+        if (this._attrProviderOrderByNoun[subjectType]</span>
<a href="#l12.805"></a><span id="l12.805" class="difflineplus">+                .indexOf(aAttrDef.provider) == -1) {</span>
<a href="#l12.806"></a><span id="l12.806" class="difflineplus">+          this._attrProviderOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l12.807"></a><span id="l12.807" class="difflineplus">+          this._attrProvidersByNoun[subjectType][aAttrDef.provider] = [];</span>
<a href="#l12.808"></a><span id="l12.808" class="difflineplus">+        }</span>
<a href="#l12.809"></a><span id="l12.809" class="difflineplus">+        this._attrProvidersByNoun[subjectType][aAttrDef.provider].push(aAttrDef);</span>
<a href="#l12.810"></a><span id="l12.810">       }</span>
<a href="#l12.811"></a><span id="l12.811" class="difflineminus">-      </span>
<a href="#l12.812"></a><span id="l12.812" class="difflineplus">+</span>
<a href="#l12.813"></a><span id="l12.813">       this._attrProviders[aAttrDef.provider.providerName].push(attr);</span>
<a href="#l12.814"></a><span id="l12.814" class="difflineminus">-      return attr; </span>
<a href="#l12.815"></a><span id="l12.815" class="difflineplus">+      return attr;</span>
<a href="#l12.816"></a><span id="l12.816">     }</span>
<a href="#l12.817"></a><span id="l12.817" class="difflineminus">-    </span>
<a href="#l12.818"></a><span id="l12.818" class="difflineplus">+</span>
<a href="#l12.819"></a><span id="l12.819">     let objectNounMeta = this._nounIDToMeta[aAttrDef.objectNoun];</span>
<a href="#l12.820"></a><span id="l12.820" class="difflineminus">-    </span>
<a href="#l12.821"></a><span id="l12.821" class="difflineplus">+</span>
<a href="#l12.822"></a><span id="l12.822">     // Being here means the attribute def does not exist in the database.</span>
<a href="#l12.823"></a><span id="l12.823">     // Of course, we only want to create something in the database if the</span>
<a href="#l12.824"></a><span id="l12.824">     //  parameter is forever un-used (noun does not 'usesParameter')</span>
<a href="#l12.825"></a><span id="l12.825">     let attrID = null;</span>
<a href="#l12.826"></a><span id="l12.826">     if (!objectNounMeta.usesParameter) {</span>
<a href="#l12.827"></a><span id="l12.827">       attrID = GlodaDatastore._createAttributeDef(aAttrDef.attributeType,</span>
<a href="#l12.828"></a><span id="l12.828">                                                   aAttrDef.extensionName,</span>
<a href="#l12.829"></a><span id="l12.829">                                                   aAttrDef.attributeName,</span>
<a href="#l12.830"></a><span id="l12.830">                                                   null);</span>
<a href="#l12.831"></a><span id="l12.831">     }</span>
<a href="#l12.832"></a><span id="l12.832" class="difflineminus">-    </span>
<a href="#l12.833"></a><span id="l12.833" class="difflineplus">+</span>
<a href="#l12.834"></a><span id="l12.834">     attr = new GlodaAttributeDef(GlodaDatastore, attrID, compoundName,</span>
<a href="#l12.835"></a><span id="l12.835">                                  aAttrDef.provider, aAttrDef.attributeType,</span>
<a href="#l12.836"></a><span id="l12.836">                                  aAttrDef.extensionName, aAttrDef.attributeName,</span>
<a href="#l12.837"></a><span id="l12.837">                                  aAttrDef.subjectNouns, aAttrDef.objectNoun,</span>
<a href="#l12.838"></a><span id="l12.838">                                  aAttrDef.explanation);</span>
<a href="#l12.839"></a><span id="l12.839">     // things here match the HATHATHAT clause above.  clearly, this should also</span>
<a href="#l12.840"></a><span id="l12.840">     //  be resolved more satisfactorily.</span>
<a href="#l12.841"></a><span id="l12.841">     attr._special = aAttrDef.special || this.kSpecialNotAtAll;</span>
<a href="#l12.842"></a><span id="l12.842">     attr._specialColumnName = aAttrDef.specialColumnName || null;</span>
<a href="#l12.843"></a><span id="l12.843" class="difflineminus">-    </span>
<a href="#l12.844"></a><span id="l12.844" class="difflineplus">+</span>
<a href="#l12.845"></a><span id="l12.845">     GlodaDatastore._attributes[compoundName] = attr;</span>
<a href="#l12.846"></a><span id="l12.846"> </span>
<a href="#l12.847"></a><span id="l12.847">     for (let iSubject = 0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l12.848"></a><span id="l12.848">          iSubject++) {</span>
<a href="#l12.849"></a><span id="l12.849">       let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l12.850"></a><span id="l12.850">       this._bindAttribute(attr, subjectType, aAttrDef.objectNoun,</span>
<a href="#l12.851"></a><span id="l12.851">                           aAttrDef.singular, aAttrDef.bind, bindName);</span>
<a href="#l12.852"></a><span id="l12.852">     }</span>
<a href="#l12.853"></a><span id="l12.853"> </span>
<a href="#l12.854"></a><span id="l12.854">     this._attrProviders[aAttrDef.provider.providerName].push(attr);</span>
<a href="#l12.855"></a><span id="l12.855">     if (!objectNounMeta.usesParameter)</span>
<a href="#l12.856"></a><span id="l12.856">       GlodaDatastore._attributeIDToDef[attrID] = [attr, null];</span>
<a href="#l12.857"></a><span id="l12.857">     return attr;</span>
<a href="#l12.858"></a><span id="l12.858">   },</span>
<a href="#l12.859"></a><span id="l12.859" class="difflineminus">-  </span>
<a href="#l12.860"></a><span id="l12.860" class="difflineplus">+</span>
<a href="#l12.861"></a><span id="l12.861">   /**</span>
<a href="#l12.862"></a><span id="l12.862">    * Retrieve the attribute provided by the given extension with the given</span>
<a href="#l12.863"></a><span id="l12.863">    *  attribute name.  The original idea was that plugins would effectively</span>
<a href="#l12.864"></a><span id="l12.864">    *  name-space attributes, helping avoid collisions.  Since we are leaning</span>
<a href="#l12.865"></a><span id="l12.865">    *  towards using binding heavily, this doesn't really help, as the collisions</span>
<a href="#l12.866"></a><span id="l12.866">    *  will just occur on the attribute name instead.  Also, this can turn</span>
<a href="#l12.867"></a><span id="l12.867">    *  extensions into liars as name changes/moves to core/etc. happen.</span>
<a href="#l12.868"></a><span id="l12.868">    * @TODO consider removing the extension name argument parameter requirement</span>
<a href="#l12.869"></a><span id="l12.869">    */</span>
<a href="#l12.870"></a><span id="l12.870">   getAttrDef: function gloda_ns_getAttrDef(aPluginName, aAttrName) {</span>
<a href="#l12.871"></a><span id="l12.871">     let compoundName = aPluginName + &quot;:&quot; + aAttrName;</span>
<a href="#l12.872"></a><span id="l12.872">     return GlodaDatastore._attributes[compoundName];</span>
<a href="#l12.873"></a><span id="l12.873">   },</span>
<a href="#l12.874"></a><span id="l12.874" class="difflineminus">-  </span>
<a href="#l12.875"></a><span id="l12.875" class="difflineplus">+</span>
<a href="#l12.876"></a><span id="l12.876">   /**</span>
<a href="#l12.877"></a><span id="l12.877">    * Define a SQL table for plug-ins.  This is intended to be used by</span>
<a href="#l12.878"></a><span id="l12.878">    *  extensions/plug-ins whose storage needs exceed those provided by the</span>
<a href="#l12.879"></a><span id="l12.879">    *  attribute parameter (on the attribute definition)/attribute value (on the</span>
<a href="#l12.880"></a><span id="l12.880">    *  attribute instance) idiom.  (This includes extensions whose parameter</span>
<a href="#l12.881"></a><span id="l12.881">    *  usage would exceed acceptable cardinality.)  They can create a table</span>
<a href="#l12.882"></a><span id="l12.882">    *  to store information on their nouns, using their row id (commonly &quot;id&quot;)</span>
<a href="#l12.883"></a><span id="l12.883">    *  as the attribute value.</span>
<a href="#l12.884"></a><span id="l12.884" class="difflineat">@@ -1168,17 +1186,17 @@ var Gloda = {</span>
<a href="#l12.885"></a><span id="l12.885">    *     now.</span>
<a href="#l12.886"></a><span id="l12.886">    * @param indices A dictionary of lists of column names, where the key name</span>
<a href="#l12.887"></a><span id="l12.887">    *     becomes the index name.  Ex: {foo: [&quot;bar&quot;]} results in an index on</span>
<a href="#l12.888"></a><span id="l12.888">    *     the column &quot;bar&quot; where the index is named &quot;foo&quot;.</span>
<a href="#l12.889"></a><span id="l12.889">    */</span>
<a href="#l12.890"></a><span id="l12.890">   defineTable: function gloda_ns_defineTable(aTableDef) {</span>
<a href="#l12.891"></a><span id="l12.891">     return GlodaDatastore.createTableIfNotExists(aTableDef);</span>
<a href="#l12.892"></a><span id="l12.892">   },</span>
<a href="#l12.893"></a><span id="l12.893" class="difflineminus">-  </span>
<a href="#l12.894"></a><span id="l12.894" class="difflineplus">+</span>
<a href="#l12.895"></a><span id="l12.895">   /**</span>
<a href="#l12.896"></a><span id="l12.896">    * Create a new query instance for the given noun-type.  This provides</span>
<a href="#l12.897"></a><span id="l12.897">    *  a generic way to provide constraint-based queries of any first-class</span>
<a href="#l12.898"></a><span id="l12.898">    *  nouns supported by the system.</span>
<a href="#l12.899"></a><span id="l12.899">    *</span>
<a href="#l12.900"></a><span id="l12.900">    * The idea is that every attribute on an object can be used to express</span>
<a href="#l12.901"></a><span id="l12.901">    *  a constraint on the query object.  Constraints implicitly 'AND' together,</span>
<a href="#l12.902"></a><span id="l12.902">    *  but providing multiple arguments to a constraint function results in an</span>
<a href="#l12.903"></a><span id="l12.903" class="difflineat">@@ -1207,51 +1225,51 @@ var Gloda = {</span>
<a href="#l12.904"></a><span id="l12.904">    * There are also full-text constraint columns.  In a nutshell, their</span>
<a href="#l12.905"></a><span id="l12.905">    *  arguments are the strings that should be passed to the SQLite FTS3</span>
<a href="#l12.906"></a><span id="l12.906">    *  MATCH clause.</span>
<a href="#l12.907"></a><span id="l12.907">    */</span>
<a href="#l12.908"></a><span id="l12.908">   newQuery: function gloda_ns_newQuery(aNounID) {</span>
<a href="#l12.909"></a><span id="l12.909">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l12.910"></a><span id="l12.910">     return new nounMeta.queryClass();</span>
<a href="#l12.911"></a><span id="l12.911">   },</span>
<a href="#l12.912"></a><span id="l12.912" class="difflineminus">-  </span>
<a href="#l12.913"></a><span id="l12.913" class="difflineplus">+</span>
<a href="#l12.914"></a><span id="l12.914">   /**</span>
<a href="#l12.915"></a><span id="l12.915">    * Create a collection/query for the given noun-type that only matches the</span>
<a href="#l12.916"></a><span id="l12.916">    *  provided items.  This is to be used when you have an explicit set of items</span>
<a href="#l12.917"></a><span id="l12.917" class="difflineminus">-   *  that you would still like to receive updates for. </span>
<a href="#l12.918"></a><span id="l12.918" class="difflineplus">+   *  that you would still like to receive updates for.</span>
<a href="#l12.919"></a><span id="l12.919">    */</span>
<a href="#l12.920"></a><span id="l12.920">   explicitCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l12.921"></a><span id="l12.921">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l12.922"></a><span id="l12.922">     let collection = new GlodaCollection(nounMeta, aItems, null, null)</span>
<a href="#l12.923"></a><span id="l12.923">     let query = new nounMeta.explicitQueryClass(collection);</span>
<a href="#l12.924"></a><span id="l12.924">     collection.query = query;</span>
<a href="#l12.925"></a><span id="l12.925">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l12.926"></a><span id="l12.926">     return collection;</span>
<a href="#l12.927"></a><span id="l12.927">   },</span>
<a href="#l12.928"></a><span id="l12.928" class="difflineminus">-  </span>
<a href="#l12.929"></a><span id="l12.929" class="difflineplus">+</span>
<a href="#l12.930"></a><span id="l12.930">   /**</span>
<a href="#l12.931"></a><span id="l12.931">    * Debugging 'wildcard' collection creation support.  A wildcard collection</span>
<a href="#l12.932"></a><span id="l12.932">    *  will 'accept' any new item instances presented to the collection manager</span>
<a href="#l12.933"></a><span id="l12.933">    *  as new.  The result is that it allows you to be notified as new items</span>
<a href="#l12.934"></a><span id="l12.934">    *  as they are indexed, existing items as they are loaded from the database,</span>
<a href="#l12.935"></a><span id="l12.935">    *  etc.</span>
<a href="#l12.936"></a><span id="l12.936">    * Because the items are added to the collection without limit, this will</span>
<a href="#l12.937"></a><span id="l12.937">    *  result in a leak if you don't do something to clean up after the</span>
<a href="#l12.938"></a><span id="l12.938">    *  collection.  (Forgetting about the collection will suffice, as it is still</span>
<a href="#l12.939"></a><span id="l12.939" class="difflineminus">-   *  weakly held.) </span>
<a href="#l12.940"></a><span id="l12.940" class="difflineplus">+   *  weakly held.)</span>
<a href="#l12.941"></a><span id="l12.941">    */</span>
<a href="#l12.942"></a><span id="l12.942">   _wildcardCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l12.943"></a><span id="l12.943">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l12.944"></a><span id="l12.944">     let collection = new GlodaCollection(nounMeta, aItems, null, null)</span>
<a href="#l12.945"></a><span id="l12.945">     let query = new nounMeta.wildcardQueryClass(collection);</span>
<a href="#l12.946"></a><span id="l12.946">     collection.query = query;</span>
<a href="#l12.947"></a><span id="l12.947">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l12.948"></a><span id="l12.948">     return collection;</span>
<a href="#l12.949"></a><span id="l12.949">   },</span>
<a href="#l12.950"></a><span id="l12.950" class="difflineminus">-  </span>
<a href="#l12.951"></a><span id="l12.951" class="difflineplus">+</span>
<a href="#l12.952"></a><span id="l12.952">   /**</span>
<a href="#l12.953"></a><span id="l12.953">    * Process the given GlodaMessage, determining all the attributes it should</span>
<a href="#l12.954"></a><span id="l12.954">    *  possess.  This should not be publicly exposed here for multiple reasons.</span>
<a href="#l12.955"></a><span id="l12.955">    * What we eventually want is the ability for pluggable (non-message specific)</span>
<a href="#l12.956"></a><span id="l12.956">    *  indexers to be added to the system, and for them to register via this</span>
<a href="#l12.957"></a><span id="l12.957">    *  Gloda interface.  However, we don't want that mechanism directly exposed</span>
<a href="#l12.958"></a><span id="l12.958">    *  to user/extension code, at least in the sense that it seems like we are</span>
<a href="#l12.959"></a><span id="l12.959">    *  suggesting they should use it.</span>
<a href="#l12.960"></a><span id="l12.960" class="difflineat">@@ -1259,33 +1277,34 @@ var Gloda = {</span>
<a href="#l12.961"></a><span id="l12.961">    *  into things as a result of registering an indexing mechanism for a given</span>
<a href="#l12.962"></a><span id="l12.962">    *  noun type.</span>
<a href="#l12.963"></a><span id="l12.963">    */</span>
<a href="#l12.964"></a><span id="l12.964">   processMessage: function gloda_ns_processMessage(aMessage, aMsgHdr,</span>
<a href="#l12.965"></a><span id="l12.965">                                                    aMimeMsg, aIsNew) {</span>
<a href="#l12.966"></a><span id="l12.966">     // For now, we are ridiculously lazy and simply nuke all existing attributes</span>
<a href="#l12.967"></a><span id="l12.967">     //  before applying the new attributes.</span>
<a href="#l12.968"></a><span id="l12.968">     aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l12.969"></a><span id="l12.969" class="difflineminus">-    </span>
<a href="#l12.970"></a><span id="l12.970" class="difflineplus">+</span>
<a href="#l12.971"></a><span id="l12.971">     let allAttribs = [];</span>
<a href="#l12.972"></a><span id="l12.972" class="difflineminus">-  </span>
<a href="#l12.973"></a><span id="l12.973" class="difflineminus">-    for (let i = 0; i &lt; this._attrProviderOrder.length; i++) {</span>
<a href="#l12.974"></a><span id="l12.974" class="difflineminus">-      let attribs = this._attrProviderOrder[i].process(aMessage, aMsgHdr,</span>
<a href="#l12.975"></a><span id="l12.975" class="difflineminus">-                                                       aMimeMsg, aIsNew);</span>
<a href="#l12.976"></a><span id="l12.976" class="difflineplus">+</span>
<a href="#l12.977"></a><span id="l12.977" class="difflineplus">+    let attrProviders = this._attrProviderOrderByNoun[aMessage.NOUN_ID];</span>
<a href="#l12.978"></a><span id="l12.978" class="difflineplus">+    for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l12.979"></a><span id="l12.979" class="difflineplus">+      let attribs = attrProviders[iProvider].process(aMessage, aMsgHdr,</span>
<a href="#l12.980"></a><span id="l12.980" class="difflineplus">+                                                     aMimeMsg, aIsNew);</span>
<a href="#l12.981"></a><span id="l12.981">       allAttribs = allAttribs.concat(attribs);</span>
<a href="#l12.982"></a><span id="l12.982">     }</span>
<a href="#l12.983"></a><span id="l12.983" class="difflineminus">-    </span>
<a href="#l12.984"></a><span id="l12.984" class="difflineplus">+</span>
<a href="#l12.985"></a><span id="l12.985">     // [attribute id, value] for for the database</span>
<a href="#l12.986"></a><span id="l12.986">     let outAttribs = [];</span>
<a href="#l12.987"></a><span id="l12.987">     // [attribute def, parameter, value] for memory usage</span>
<a href="#l12.988"></a><span id="l12.988">     let memAttribs = [];</span>
<a href="#l12.989"></a><span id="l12.989" class="difflineminus">-    </span>
<a href="#l12.990"></a><span id="l12.990" class="difflineplus">+</span>
<a href="#l12.991"></a><span id="l12.991">     for (let iAttrib = 0; iAttrib &lt; allAttribs.length; iAttrib++) {</span>
<a href="#l12.992"></a><span id="l12.992">       let attribDesc = allAttribs[iAttrib];</span>
<a href="#l12.993"></a><span id="l12.993" class="difflineminus">-      </span>
<a href="#l12.994"></a><span id="l12.994" class="difflineplus">+</span>
<a href="#l12.995"></a><span id="l12.995">       // is it an (attributedef / attribute def id, value) tuple?</span>
<a href="#l12.996"></a><span id="l12.996">       if (attribDesc.length == 2) {</span>
<a href="#l12.997"></a><span id="l12.997">         // if it's already an attrib id, we can use the tuple outright</span>
<a href="#l12.998"></a><span id="l12.998">         if (typeof attribDesc[0] == &quot;number&quot;) {</span>
<a href="#l12.999"></a><span id="l12.999">           outAttribs.push(attribDesc);</span>
<a href="#l12.1000"></a><span id="l12.1000">           let [attribDef, attribParam] =</span>
<a href="#l12.1001"></a><span id="l12.1001">             GlodaDatastore._attributeIDToDef[attribDesc[0]];</span>
<a href="#l12.1002"></a><span id="l12.1002">           memAttribs.push([attribDef, attribParam, attribDesc[1]]);</span>
<a href="#l12.1003"></a><span id="l12.1003" class="difflineat">@@ -1295,37 +1314,98 @@ var Gloda = {</span>
<a href="#l12.1004"></a><span id="l12.1004">           // the parameter is null if they just pass an attribute def</span>
<a href="#l12.1005"></a><span id="l12.1005">           memAttribs.push([attribDesc[0], null, attribDesc[1]]);</span>
<a href="#l12.1006"></a><span id="l12.1006">         }</span>
<a href="#l12.1007"></a><span id="l12.1007">       }</span>
<a href="#l12.1008"></a><span id="l12.1008">       // it must be an (attrib, parameter value, attrib value) tuple</span>
<a href="#l12.1009"></a><span id="l12.1009">       else {</span>
<a href="#l12.1010"></a><span id="l12.1010">         // just store it verbatim for memory purposes</span>
<a href="#l12.1011"></a><span id="l12.1011">         memAttribs.push(attribDesc);</span>
<a href="#l12.1012"></a><span id="l12.1012" class="difflineminus">-      </span>
<a href="#l12.1013"></a><span id="l12.1013" class="difflineplus">+</span>
<a href="#l12.1014"></a><span id="l12.1014">         let attrib = attribDesc[0];</span>
<a href="#l12.1015"></a><span id="l12.1015">         let parameterValue = attribDesc[1];</span>
<a href="#l12.1016"></a><span id="l12.1016">         let attribID;</span>
<a href="#l12.1017"></a><span id="l12.1017">         if (parameterValue != null)</span>
<a href="#l12.1018"></a><span id="l12.1018">           attribID = attrib.bindParameter(parameterValue);</span>
<a href="#l12.1019"></a><span id="l12.1019">         else</span>
<a href="#l12.1020"></a><span id="l12.1020">           attribID = attrib.id;</span>
<a href="#l12.1021"></a><span id="l12.1021">         outAttribs.push([attribID, attribDesc[2]]);</span>
<a href="#l12.1022"></a><span id="l12.1022">       }</span>
<a href="#l12.1023"></a><span id="l12.1023">     }</span>
<a href="#l12.1024"></a><span id="l12.1024" class="difflineminus">-    </span>
<a href="#l12.1025"></a><span id="l12.1025" class="difflineplus">+</span>
<a href="#l12.1026"></a><span id="l12.1026">     GlodaDatastore.insertMessageAttributes(aMessage, outAttribs);</span>
<a href="#l12.1027"></a><span id="l12.1027">     aMessage._replaceAttributes(memAttribs);</span>
<a href="#l12.1028"></a><span id="l12.1028" class="difflineminus">-    </span>
<a href="#l12.1029"></a><span id="l12.1029" class="difflineplus">+</span>
<a href="#l12.1030"></a><span id="l12.1030">     if (aIsNew)</span>
<a href="#l12.1031"></a><span id="l12.1031">       GlodaCollectionManager.itemsAdded(aMessage.NOUN_ID, [aMessage]);</span>
<a href="#l12.1032"></a><span id="l12.1032">     else</span>
<a href="#l12.1033"></a><span id="l12.1033">       GlodaCollectionManager.itemsModified(aMessage.NOUN_ID, [aMessage]);</span>
<a href="#l12.1034"></a><span id="l12.1034">   },</span>
<a href="#l12.1035"></a><span id="l12.1035" class="difflineminus">-  </span>
<a href="#l12.1036"></a><span id="l12.1036" class="difflineplus">+</span>
<a href="#l12.1037"></a><span id="l12.1037" class="difflineplus">+  _processNounItem: function gloda_ns_processNounItem(aItem, aRawItem) {</span>
<a href="#l12.1038"></a><span id="l12.1038" class="difflineplus">+    // For now, we are ridiculously lazy and simply nuke all existing attributes</span>
<a href="#l12.1039"></a><span id="l12.1039" class="difflineplus">+    //  before applying the new attributes.</span>
<a href="#l12.1040"></a><span id="l12.1040" class="difflineplus">+    aItem._datastore.clearAttributes(aItem);</span>
<a href="#l12.1041"></a><span id="l12.1041" class="difflineplus">+</span>
<a href="#l12.1042"></a><span id="l12.1042" class="difflineplus">+    let allAttribs = [];</span>
<a href="#l12.1043"></a><span id="l12.1043" class="difflineplus">+</span>
<a href="#l12.1044"></a><span id="l12.1044" class="difflineplus">+    let attrProviders = this._attrProviderOrderByNoun[aItem.NOUN_ID];</span>
<a href="#l12.1045"></a><span id="l12.1045" class="difflineplus">+    for (let iProvider = 0; iProvider &lt; attrProviders.length; iProvider++) {</span>
<a href="#l12.1046"></a><span id="l12.1046" class="difflineplus">+      let attribs = attrProviders[iProvider].process(aItem, aRawItem);</span>
<a href="#l12.1047"></a><span id="l12.1047" class="difflineplus">+      allAttribs = allAttribs.concat(attribs);</span>
<a href="#l12.1048"></a><span id="l12.1048" class="difflineplus">+    }</span>
<a href="#l12.1049"></a><span id="l12.1049" class="difflineplus">+</span>
<a href="#l12.1050"></a><span id="l12.1050" class="difflineplus">+    // [attribute id, value] for for the database</span>
<a href="#l12.1051"></a><span id="l12.1051" class="difflineplus">+    let outAttribs = [];</span>
<a href="#l12.1052"></a><span id="l12.1052" class="difflineplus">+    // [attribute def, parameter, value] for memory usage</span>
<a href="#l12.1053"></a><span id="l12.1053" class="difflineplus">+    let memAttribs = [];</span>
<a href="#l12.1054"></a><span id="l12.1054" class="difflineplus">+</span>
<a href="#l12.1055"></a><span id="l12.1055" class="difflineplus">+    for (let iAttrib = 0; iAttrib &lt; allAttribs.length; iAttrib++) {</span>
<a href="#l12.1056"></a><span id="l12.1056" class="difflineplus">+      let attribDesc = allAttribs[iAttrib];</span>
<a href="#l12.1057"></a><span id="l12.1057" class="difflineplus">+</span>
<a href="#l12.1058"></a><span id="l12.1058" class="difflineplus">+      // is it an (attributedef / attribute def id, value) tuple?</span>
<a href="#l12.1059"></a><span id="l12.1059" class="difflineplus">+      if (attribDesc.length == 2) {</span>
<a href="#l12.1060"></a><span id="l12.1060" class="difflineplus">+        // if it's already an attrib id, we can use the tuple outright</span>
<a href="#l12.1061"></a><span id="l12.1061" class="difflineplus">+        if (typeof attribDesc[0] == &quot;number&quot;) {</span>
<a href="#l12.1062"></a><span id="l12.1062" class="difflineplus">+          outAttribs.push(attribDesc);</span>
<a href="#l12.1063"></a><span id="l12.1063" class="difflineplus">+          let [attribDef, attribParam] =</span>
<a href="#l12.1064"></a><span id="l12.1064" class="difflineplus">+            GlodaDatastore._attributeIDToDef[attribDesc[0]];</span>
<a href="#l12.1065"></a><span id="l12.1065" class="difflineplus">+          memAttribs.push([attribDef, attribParam, attribDesc[1]]);</span>
<a href="#l12.1066"></a><span id="l12.1066" class="difflineplus">+        }</span>
<a href="#l12.1067"></a><span id="l12.1067" class="difflineplus">+        else {</span>
<a href="#l12.1068"></a><span id="l12.1068" class="difflineplus">+          outAttribs.push([attribDesc[0].id, attribDesc[1]]);</span>
<a href="#l12.1069"></a><span id="l12.1069" class="difflineplus">+          // the parameter is null if they just pass an attribute def</span>
<a href="#l12.1070"></a><span id="l12.1070" class="difflineplus">+          memAttribs.push([attribDesc[0], null, attribDesc[1]]);</span>
<a href="#l12.1071"></a><span id="l12.1071" class="difflineplus">+        }</span>
<a href="#l12.1072"></a><span id="l12.1072" class="difflineplus">+      }</span>
<a href="#l12.1073"></a><span id="l12.1073" class="difflineplus">+      // it must be an (attrib, parameter value, attrib value) tuple</span>
<a href="#l12.1074"></a><span id="l12.1074" class="difflineplus">+      else {</span>
<a href="#l12.1075"></a><span id="l12.1075" class="difflineplus">+        // just store it verbatim for memory purposes</span>
<a href="#l12.1076"></a><span id="l12.1076" class="difflineplus">+        memAttribs.push(attribDesc);</span>
<a href="#l12.1077"></a><span id="l12.1077" class="difflineplus">+</span>
<a href="#l12.1078"></a><span id="l12.1078" class="difflineplus">+        let attrib = attribDesc[0];</span>
<a href="#l12.1079"></a><span id="l12.1079" class="difflineplus">+        let parameterValue = attribDesc[1];</span>
<a href="#l12.1080"></a><span id="l12.1080" class="difflineplus">+        let attribID;</span>
<a href="#l12.1081"></a><span id="l12.1081" class="difflineplus">+        if (parameterValue != null)</span>
<a href="#l12.1082"></a><span id="l12.1082" class="difflineplus">+          attribID = attrib.bindParameter(parameterValue);</span>
<a href="#l12.1083"></a><span id="l12.1083" class="difflineplus">+        else</span>
<a href="#l12.1084"></a><span id="l12.1084" class="difflineplus">+          attribID = attrib.id;</span>
<a href="#l12.1085"></a><span id="l12.1085" class="difflineplus">+        outAttribs.push([attribID, attribDesc[2]]);</span>
<a href="#l12.1086"></a><span id="l12.1086" class="difflineplus">+      }</span>
<a href="#l12.1087"></a><span id="l12.1087" class="difflineplus">+    }</span>
<a href="#l12.1088"></a><span id="l12.1088" class="difflineplus">+</span>
<a href="#l12.1089"></a><span id="l12.1089" class="difflineplus">+    GlodaDatastore.insertAttributes(aItem, outAttribs);</span>
<a href="#l12.1090"></a><span id="l12.1090" class="difflineplus">+    aItem._replaceAttributes(memAttribs);</span>
<a href="#l12.1091"></a><span id="l12.1091" class="difflineplus">+</span>
<a href="#l12.1092"></a><span id="l12.1092" class="difflineplus">+    if (aIsNew)</span>
<a href="#l12.1093"></a><span id="l12.1093" class="difflineplus">+      GlodaCollectionManager.itemsAdded(aItem.NOUN_ID, [aItem]);</span>
<a href="#l12.1094"></a><span id="l12.1094" class="difflineplus">+    else</span>
<a href="#l12.1095"></a><span id="l12.1095" class="difflineplus">+      GlodaCollectionManager.itemsModified(aItem.NOUN_ID, [aItem]);</span>
<a href="#l12.1096"></a><span id="l12.1096" class="difflineplus">+  },</span>
<a href="#l12.1097"></a><span id="l12.1097" class="difflineplus">+</span>
<a href="#l12.1098"></a><span id="l12.1098">   /**</span>
<a href="#l12.1099"></a><span id="l12.1099">    * Deprecated mechanism for querying for messages.  Use newQuery now,</span>
<a href="#l12.1100"></a><span id="l12.1100">    *  specifying the message noun id.  Still works for now, but not for long.</span>
<a href="#l12.1101"></a><span id="l12.1101">    */</span>
<a href="#l12.1102"></a><span id="l12.1102">   queryMessagesAPV: function gloda_ns_queryMessagesAPV(aAPVs) {</span>
<a href="#l12.1103"></a><span id="l12.1103">     return GlodaDatastore.queryMessagesAPV(aAPVs);</span>
<a href="#l12.1104"></a><span id="l12.1104">   }</span>
<a href="#l12.1105"></a><span id="l12.1105"> };</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/modules/index_ab.js</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/modules/index_ab.js</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -0,0 +1,263 @@</span>
<a href="#l13.4"></a><span id="l13.4" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l13.5"></a><span id="l13.5" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l13.6"></a><span id="l13.6" class="difflineplus">+ *</span>
<a href="#l13.7"></a><span id="l13.7" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l13.8"></a><span id="l13.8" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l13.9"></a><span id="l13.9" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l13.10"></a><span id="l13.10" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l13.11"></a><span id="l13.11" class="difflineplus">+ * </span>
<a href="#l13.12"></a><span id="l13.12" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l13.14"></a><span id="l13.14" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l13.15"></a><span id="l13.15" class="difflineplus">+ * License.</span>
<a href="#l13.16"></a><span id="l13.16" class="difflineplus">+ *</span>
<a href="#l13.17"></a><span id="l13.17" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l13.18"></a><span id="l13.18" class="difflineplus">+ *</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l13.21"></a><span id="l13.21" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l13.22"></a><span id="l13.22" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l13.23"></a><span id="l13.23" class="difflineplus">+ *</span>
<a href="#l13.24"></a><span id="l13.24" class="difflineplus">+ * Contributor(s):</span>
<a href="#l13.25"></a><span id="l13.25" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l13.26"></a><span id="l13.26" class="difflineplus">+ *</span>
<a href="#l13.27"></a><span id="l13.27" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l13.28"></a><span id="l13.28" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l13.29"></a><span id="l13.29" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l13.30"></a><span id="l13.30" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l13.31"></a><span id="l13.31" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l13.32"></a><span id="l13.32" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l13.33"></a><span id="l13.33" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l13.34"></a><span id="l13.34" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l13.35"></a><span id="l13.35" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l13.36"></a><span id="l13.36" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l13.37"></a><span id="l13.37" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l13.38"></a><span id="l13.38" class="difflineplus">+ * </span>
<a href="#l13.39"></a><span id="l13.39" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l13.40"></a><span id="l13.40" class="difflineplus">+</span>
<a href="#l13.41"></a><span id="l13.41" class="difflineplus">+EXPORTED_SYMBOLS = ['GlodaABIndexer', 'GlodaABAttrs'];</span>
<a href="#l13.42"></a><span id="l13.42" class="difflineplus">+</span>
<a href="#l13.43"></a><span id="l13.43" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l13.44"></a><span id="l13.44" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l13.45"></a><span id="l13.45" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l13.46"></a><span id="l13.46" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l13.47"></a><span id="l13.47" class="difflineplus">+</span>
<a href="#l13.48"></a><span id="l13.48" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l13.49"></a><span id="l13.49" class="difflineplus">+</span>
<a href="#l13.50"></a><span id="l13.50" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l13.51"></a><span id="l13.51" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/datastore.js&quot;);</span>
<a href="#l13.52"></a><span id="l13.52" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l13.53"></a><span id="l13.53" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/collection.js&quot;);</span>
<a href="#l13.54"></a><span id="l13.54" class="difflineplus">+</span>
<a href="#l13.55"></a><span id="l13.55" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/indexer.js&quot;);</span>
<a href="#l13.56"></a><span id="l13.56" class="difflineplus">+</span>
<a href="#l13.57"></a><span id="l13.57" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/noun_freetag.js&quot;);</span>
<a href="#l13.58"></a><span id="l13.58" class="difflineplus">+</span>
<a href="#l13.59"></a><span id="l13.59" class="difflineplus">+</span>
<a href="#l13.60"></a><span id="l13.60" class="difflineplus">+var GlodaABIndexer = {</span>
<a href="#l13.61"></a><span id="l13.61" class="difflineplus">+  _log: null,</span>
<a href="#l13.62"></a><span id="l13.62" class="difflineplus">+</span>
<a href="#l13.63"></a><span id="l13.63" class="difflineplus">+  name: &quot;ab_indexer&quot;,</span>
<a href="#l13.64"></a><span id="l13.64" class="difflineplus">+  enable: function() {</span>
<a href="#l13.65"></a><span id="l13.65" class="difflineplus">+    if (this._log == null)</span>
<a href="#l13.66"></a><span id="l13.66" class="difflineplus">+      this._log =  Log4Moz.Service.getLogger(&quot;gloda.ab_indexer&quot;);</span>
<a href="#l13.67"></a><span id="l13.67" class="difflineplus">+  </span>
<a href="#l13.68"></a><span id="l13.68" class="difflineplus">+    let abManager = Cc[&quot;@mozilla.org/abmanager;1&quot;].getService(Ci.nsIAbManager);</span>
<a href="#l13.69"></a><span id="l13.69" class="difflineplus">+    abManager.addAddressBookListener(this, Ci.nsIAbListener.itemChanged);</span>
<a href="#l13.70"></a><span id="l13.70" class="difflineplus">+  },</span>
<a href="#l13.71"></a><span id="l13.71" class="difflineplus">+  </span>
<a href="#l13.72"></a><span id="l13.72" class="difflineplus">+  disable: function() {</span>
<a href="#l13.73"></a><span id="l13.73" class="difflineplus">+    let abManager = Cc[&quot;@mozilla.org/abmanager;1&quot;].getService(Ci.nsIAbManager);</span>
<a href="#l13.74"></a><span id="l13.74" class="difflineplus">+    abManager.removeAddressBookListener(this);</span>
<a href="#l13.75"></a><span id="l13.75" class="difflineplus">+  },</span>
<a href="#l13.76"></a><span id="l13.76" class="difflineplus">+</span>
<a href="#l13.77"></a><span id="l13.77" class="difflineplus">+  get workers() {</span>
<a href="#l13.78"></a><span id="l13.78" class="difflineplus">+    return [[&quot;ab-index&quot;, this._worker_index]];</span>
<a href="#l13.79"></a><span id="l13.79" class="difflineplus">+  },</span>
<a href="#l13.80"></a><span id="l13.80" class="difflineplus">+  </span>
<a href="#l13.81"></a><span id="l13.81" class="difflineplus">+  _worker_index: function(aJob) {</span>
<a href="#l13.82"></a><span id="l13.82" class="difflineplus">+    yield GlodaIndexer.kWorkDone;</span>
<a href="#l13.83"></a><span id="l13.83" class="difflineplus">+  },</span>
<a href="#l13.84"></a><span id="l13.84" class="difflineplus">+  </span>
<a href="#l13.85"></a><span id="l13.85" class="difflineplus">+  initialSweep: function() {</span>
<a href="#l13.86"></a><span id="l13.86" class="difflineplus">+  },</span>
<a href="#l13.87"></a><span id="l13.87" class="difflineplus">+  </span>
<a href="#l13.88"></a><span id="l13.88" class="difflineplus">+  /* ------ nsIAbListener ------ */</span>
<a href="#l13.89"></a><span id="l13.89" class="difflineplus">+  onItemAdded: function ab_indexer_onItemAdded(aParentDir, aItem) {</span>
<a href="#l13.90"></a><span id="l13.90" class="difflineplus">+  },</span>
<a href="#l13.91"></a><span id="l13.91" class="difflineplus">+  onItemRemoved: function ab_indexer_onItemRemoved(aParentDir, aItem) {</span>
<a href="#l13.92"></a><span id="l13.92" class="difflineplus">+  },</span>
<a href="#l13.93"></a><span id="l13.93" class="difflineplus">+  onItemPropertyChanged: function ab_indexer_onItemPropertyChanged(aItem,</span>
<a href="#l13.94"></a><span id="l13.94" class="difflineplus">+      aProperty, aOldValue, aNewValue) {</span>
<a href="#l13.95"></a><span id="l13.95" class="difflineplus">+    if (aProperty == null &amp;&amp; aItem instanceof Ci.nsIAbCard) {</span>
<a href="#l13.96"></a><span id="l13.96" class="difflineplus">+      this._log.debug(&quot;Received Card Change Notification&quot;);</span>
<a href="#l13.97"></a><span id="l13.97" class="difflineplus">+      let card = aItem; // instanceof already QueryInterface'd for us.</span>
<a href="#l13.98"></a><span id="l13.98" class="difflineplus">+      let identity = GlodaDatastore.getIdentity(&quot;email&quot;, card.primaryEmail);</span>
<a href="#l13.99"></a><span id="l13.99" class="difflineplus">+      if (identity) {</span>
<a href="#l13.100"></a><span id="l13.100" class="difflineplus">+        this._log.debug(&quot;Found identity, processing card.&quot;);</span>
<a href="#l13.101"></a><span id="l13.101" class="difflineplus">+        Gloda._processNounItem(identity.contact, card);</span>
<a href="#l13.102"></a><span id="l13.102" class="difflineplus">+        this._log.debug(&quot;Done processing card.&quot;);</span>
<a href="#l13.103"></a><span id="l13.103" class="difflineplus">+      }</span>
<a href="#l13.104"></a><span id="l13.104" class="difflineplus">+    }</span>
<a href="#l13.105"></a><span id="l13.105" class="difflineplus">+  }</span>
<a href="#l13.106"></a><span id="l13.106" class="difflineplus">+};</span>
<a href="#l13.107"></a><span id="l13.107" class="difflineplus">+GlodaIndexer.registerIndexer(GlodaABIndexer);</span>
<a href="#l13.108"></a><span id="l13.108" class="difflineplus">+</span>
<a href="#l13.109"></a><span id="l13.109" class="difflineplus">+var GlodaABAttrs = {</span>
<a href="#l13.110"></a><span id="l13.110" class="difflineplus">+  providerName: &quot;gloda.ab_attr&quot;,</span>
<a href="#l13.111"></a><span id="l13.111" class="difflineplus">+  _log: null,</span>
<a href="#l13.112"></a><span id="l13.112" class="difflineplus">+  _strBundle: null,</span>
<a href="#l13.113"></a><span id="l13.113" class="difflineplus">+</span>
<a href="#l13.114"></a><span id="l13.114" class="difflineplus">+  init: function(aStrBundle) {</span>
<a href="#l13.115"></a><span id="l13.115" class="difflineplus">+    this._log =  Log4Moz.Service.getLogger(&quot;gloda.abattrs&quot;);</span>
<a href="#l13.116"></a><span id="l13.116" class="difflineplus">+    this._strBundle = aStrBundle;</span>
<a href="#l13.117"></a><span id="l13.117" class="difflineplus">+    </span>
<a href="#l13.118"></a><span id="l13.118" class="difflineplus">+    try {</span>
<a href="#l13.119"></a><span id="l13.119" class="difflineplus">+      this.defineAttributes();</span>
<a href="#l13.120"></a><span id="l13.120" class="difflineplus">+    }</span>
<a href="#l13.121"></a><span id="l13.121" class="difflineplus">+    catch (ex) {</span>
<a href="#l13.122"></a><span id="l13.122" class="difflineplus">+      this._log.error(&quot;Error in init: &quot; + ex);</span>
<a href="#l13.123"></a><span id="l13.123" class="difflineplus">+      throw ex;</span>
<a href="#l13.124"></a><span id="l13.124" class="difflineplus">+    }</span>
<a href="#l13.125"></a><span id="l13.125" class="difflineplus">+  },</span>
<a href="#l13.126"></a><span id="l13.126" class="difflineplus">+  </span>
<a href="#l13.127"></a><span id="l13.127" class="difflineplus">+  defineAttributes: function() {</span>
<a href="#l13.128"></a><span id="l13.128" class="difflineplus">+    /* ***** Contacts ***** */</span>
<a href="#l13.129"></a><span id="l13.129" class="difflineplus">+    this._attrContactName = Gloda.defineAttribute({</span>
<a href="#l13.130"></a><span id="l13.130" class="difflineplus">+      provider: this,</span>
<a href="#l13.131"></a><span id="l13.131" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l13.132"></a><span id="l13.132" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l13.133"></a><span id="l13.133" class="difflineplus">+      attributeName: &quot;name&quot;,</span>
<a href="#l13.134"></a><span id="l13.134" class="difflineplus">+      bind: false,</span>
<a href="#l13.135"></a><span id="l13.135" class="difflineplus">+      singular: true,</span>
<a href="#l13.136"></a><span id="l13.136" class="difflineplus">+      special: Gloda.kSpecialString,</span>
<a href="#l13.137"></a><span id="l13.137" class="difflineplus">+      specialColumnName: &quot;name&quot;,</span>
<a href="#l13.138"></a><span id="l13.138" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l13.139"></a><span id="l13.139" class="difflineplus">+      objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l13.140"></a><span id="l13.140" class="difflineplus">+      explanation: null, // name is internal, no explanation required</span>
<a href="#l13.141"></a><span id="l13.141" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l13.142"></a><span id="l13.142" class="difflineplus">+    this._attrContactPopularity = Gloda.defineAttribute({</span>
<a href="#l13.143"></a><span id="l13.143" class="difflineplus">+      provider: this,</span>
<a href="#l13.144"></a><span id="l13.144" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l13.145"></a><span id="l13.145" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l13.146"></a><span id="l13.146" class="difflineplus">+      attributeName: &quot;popularity&quot;,</span>
<a href="#l13.147"></a><span id="l13.147" class="difflineplus">+      bind: false,</span>
<a href="#l13.148"></a><span id="l13.148" class="difflineplus">+      singular: true,</span>
<a href="#l13.149"></a><span id="l13.149" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l13.150"></a><span id="l13.150" class="difflineplus">+      specialColumnName: &quot;popularity&quot;,</span>
<a href="#l13.151"></a><span id="l13.151" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l13.152"></a><span id="l13.152" class="difflineplus">+      objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l13.153"></a><span id="l13.153" class="difflineplus">+      explanation: null, // popularity is internal, no explanation required</span>
<a href="#l13.154"></a><span id="l13.154" class="difflineplus">+      }); // not-tested</span>
<a href="#l13.155"></a><span id="l13.155" class="difflineplus">+    this._attrContactFrecency = Gloda.defineAttribute({</span>
<a href="#l13.156"></a><span id="l13.156" class="difflineplus">+      provider: this,</span>
<a href="#l13.157"></a><span id="l13.157" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l13.158"></a><span id="l13.158" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l13.159"></a><span id="l13.159" class="difflineplus">+      attributeName: &quot;frecency&quot;,</span>
<a href="#l13.160"></a><span id="l13.160" class="difflineplus">+      bind: false,</span>
<a href="#l13.161"></a><span id="l13.161" class="difflineplus">+      singular: true,</span>
<a href="#l13.162"></a><span id="l13.162" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l13.163"></a><span id="l13.163" class="difflineplus">+      specialColumnName: &quot;frecency&quot;,</span>
<a href="#l13.164"></a><span id="l13.164" class="difflineplus">+      subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l13.165"></a><span id="l13.165" class="difflineplus">+      objectNoun: Gloda.NOUN_NUMBER,</span>
<a href="#l13.166"></a><span id="l13.166" class="difflineplus">+      explanation: null, // frecency is internal, no explanation required</span>
<a href="#l13.167"></a><span id="l13.167" class="difflineplus">+      }); // not-tested</span>
<a href="#l13.168"></a><span id="l13.168" class="difflineplus">+</span>
<a href="#l13.169"></a><span id="l13.169" class="difflineplus">+    /* ***** Identities ***** */</span>
<a href="#l13.170"></a><span id="l13.170" class="difflineplus">+    this._attrIdentityContact = Gloda.defineAttribute({</span>
<a href="#l13.171"></a><span id="l13.171" class="difflineplus">+      provider: this,</span>
<a href="#l13.172"></a><span id="l13.172" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l13.173"></a><span id="l13.173" class="difflineplus">+      attributeType: Gloda.kAttrDerived,</span>
<a href="#l13.174"></a><span id="l13.174" class="difflineplus">+      attributeName: &quot;contact&quot;,</span>
<a href="#l13.175"></a><span id="l13.175" class="difflineplus">+      bind: false,</span>
<a href="#l13.176"></a><span id="l13.176" class="difflineplus">+      singular: true,</span>
<a href="#l13.177"></a><span id="l13.177" class="difflineplus">+      special: Gloda.kSpecialColumn,</span>
<a href="#l13.178"></a><span id="l13.178" class="difflineplus">+      specialColumnName: &quot;contactID&quot;,</span>
<a href="#l13.179"></a><span id="l13.179" class="difflineplus">+      subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l13.180"></a><span id="l13.180" class="difflineplus">+      objectNoun: Gloda.NOUN_CONTACT,</span>
<a href="#l13.181"></a><span id="l13.181" class="difflineplus">+      explanation: null, // popularity is internal, no explanation required</span>
<a href="#l13.182"></a><span id="l13.182" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l13.183"></a><span id="l13.183" class="difflineplus">+    this._attrIdentityKind = Gloda.defineAttribute({</span>
<a href="#l13.184"></a><span id="l13.184" class="difflineplus">+      provider: this,</span>
<a href="#l13.185"></a><span id="l13.185" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l13.186"></a><span id="l13.186" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l13.187"></a><span id="l13.187" class="difflineplus">+      attributeName: &quot;kind&quot;,</span>
<a href="#l13.188"></a><span id="l13.188" class="difflineplus">+      bind: false,</span>
<a href="#l13.189"></a><span id="l13.189" class="difflineplus">+      singular: true,</span>
<a href="#l13.190"></a><span id="l13.190" class="difflineplus">+      special: Gloda.kSpecialString,</span>
<a href="#l13.191"></a><span id="l13.191" class="difflineplus">+      specialColumnName: &quot;kind&quot;,</span>
<a href="#l13.192"></a><span id="l13.192" class="difflineplus">+      subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l13.193"></a><span id="l13.193" class="difflineplus">+      objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l13.194"></a><span id="l13.194" class="difflineplus">+      explanation: null, // kind is internal, no explanation required</span>
<a href="#l13.195"></a><span id="l13.195" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l13.196"></a><span id="l13.196" class="difflineplus">+    this._attrIdentityValue = Gloda.defineAttribute({</span>
<a href="#l13.197"></a><span id="l13.197" class="difflineplus">+      provider: this,</span>
<a href="#l13.198"></a><span id="l13.198" class="difflineplus">+      extensionName: Gloda.BUILT_IN,</span>
<a href="#l13.199"></a><span id="l13.199" class="difflineplus">+      attributeType: Gloda.kAttrFundamental,</span>
<a href="#l13.200"></a><span id="l13.200" class="difflineplus">+      attributeName: &quot;value&quot;,</span>
<a href="#l13.201"></a><span id="l13.201" class="difflineplus">+      bind: false,</span>
<a href="#l13.202"></a><span id="l13.202" class="difflineplus">+      singular: true,</span>
<a href="#l13.203"></a><span id="l13.203" class="difflineplus">+      special: Gloda.kSpecialString,</span>
<a href="#l13.204"></a><span id="l13.204" class="difflineplus">+      specialColumnName: &quot;value&quot;,</span>
<a href="#l13.205"></a><span id="l13.205" class="difflineplus">+      subjectNouns: [Gloda.NOUN_IDENTITY],</span>
<a href="#l13.206"></a><span id="l13.206" class="difflineplus">+      objectNoun: Gloda.NOUN_STRING,</span>
<a href="#l13.207"></a><span id="l13.207" class="difflineplus">+      explanation: null, // value is internal, no explanation required</span>
<a href="#l13.208"></a><span id="l13.208" class="difflineplus">+      }); // tested-by: test_attributes_fundamental</span>
<a href="#l13.209"></a><span id="l13.209" class="difflineplus">+</span>
<a href="#l13.210"></a><span id="l13.210" class="difflineplus">+    /* ***** Contact Meta ***** */</span>
<a href="#l13.211"></a><span id="l13.211" class="difflineplus">+    // Freeform tags; not explicit like thunderbird's fundamental tags.</span>
<a href="#l13.212"></a><span id="l13.212" class="difflineplus">+    //  we differentiate for now because of fundamental implementation</span>
<a href="#l13.213"></a><span id="l13.213" class="difflineplus">+    //  differences.</span>
<a href="#l13.214"></a><span id="l13.214" class="difflineplus">+    this._attrFreeTag = Gloda.defineAttribute({</span>
<a href="#l13.215"></a><span id="l13.215" class="difflineplus">+                        provider: this,</span>
<a href="#l13.216"></a><span id="l13.216" class="difflineplus">+                        extensionName: Gloda.BUILT_IN,</span>
<a href="#l13.217"></a><span id="l13.217" class="difflineplus">+                        attributeType: Gloda.kAttrExplicit,</span>
<a href="#l13.218"></a><span id="l13.218" class="difflineplus">+                        attributeName: &quot;freetag&quot;,</span>
<a href="#l13.219"></a><span id="l13.219" class="difflineplus">+                        bind: true,</span>
<a href="#l13.220"></a><span id="l13.220" class="difflineplus">+                        bindName: &quot;freeTags&quot;,</span>
<a href="#l13.221"></a><span id="l13.221" class="difflineplus">+                        singular: false,</span>
<a href="#l13.222"></a><span id="l13.222" class="difflineplus">+                        subjectNouns: [Gloda.NOUN_CONTACT],</span>
<a href="#l13.223"></a><span id="l13.223" class="difflineplus">+                        objectNoun: Gloda.lookupNoun(&quot;freetag&quot;),</span>
<a href="#l13.224"></a><span id="l13.224" class="difflineplus">+                        parameterNoun: null,</span>
<a href="#l13.225"></a><span id="l13.225" class="difflineplus">+                        explanation: null,</span>
<a href="#l13.226"></a><span id="l13.226" class="difflineplus">+                        }); // not-tested</span>
<a href="#l13.227"></a><span id="l13.227" class="difflineplus">+    // we need to find any existing bound freetag attributes, and use them to</span>
<a href="#l13.228"></a><span id="l13.228" class="difflineplus">+    //  populate to FreeTagNoun's understanding</span>
<a href="#l13.229"></a><span id="l13.229" class="difflineplus">+    for (let freeTagName in this._attrFreeTag._bindings) {</span>
<a href="#l13.230"></a><span id="l13.230" class="difflineplus">+      FreeTagNoun.getFreeTag(freeTagName);</span>
<a href="#l13.231"></a><span id="l13.231" class="difflineplus">+    }</span>
<a href="#l13.232"></a><span id="l13.232" class="difflineplus">+  },</span>
<a href="#l13.233"></a><span id="l13.233" class="difflineplus">+  </span>
<a href="#l13.234"></a><span id="l13.234" class="difflineplus">+  process: function(aContact, aCard) {</span>
<a href="#l13.235"></a><span id="l13.235" class="difflineplus">+    if (aContact.NOUN_ID != Gloda.NOUN_CONTACT) {</span>
<a href="#l13.236"></a><span id="l13.236" class="difflineplus">+      this._log.warning(&quot;Somehow got a non-contact: &quot; + aContact);</span>
<a href="#l13.237"></a><span id="l13.237" class="difflineplus">+      return [];</span>
<a href="#l13.238"></a><span id="l13.238" class="difflineplus">+    }</span>
<a href="#l13.239"></a><span id="l13.239" class="difflineplus">+  </span>
<a href="#l13.240"></a><span id="l13.240" class="difflineplus">+    this._log.debug(&quot;Processing a contact and card.&quot;);</span>
<a href="#l13.241"></a><span id="l13.241" class="difflineplus">+    let attribs = [];</span>
<a href="#l13.242"></a><span id="l13.242" class="difflineplus">+    </span>
<a href="#l13.243"></a><span id="l13.243" class="difflineplus">+    let tags = null;</span>
<a href="#l13.244"></a><span id="l13.244" class="difflineplus">+    try {</span>
<a href="#l13.245"></a><span id="l13.245" class="difflineplus">+      tags = aCard.getProperty(&quot;tags&quot;, null);</span>
<a href="#l13.246"></a><span id="l13.246" class="difflineplus">+    } catch (ex) {</span>
<a href="#l13.247"></a><span id="l13.247" class="difflineplus">+      this._log.error(&quot;Problem accessing property: &quot; + ex);</span>
<a href="#l13.248"></a><span id="l13.248" class="difflineplus">+    }</span>
<a href="#l13.249"></a><span id="l13.249" class="difflineplus">+    if (tags) {</span>
<a href="#l13.250"></a><span id="l13.250" class="difflineplus">+      this._log.debug(&quot;Found tags: &quot; + tags);</span>
<a href="#l13.251"></a><span id="l13.251" class="difflineplus">+      for each (let tagName in tags.split(&quot;,&quot;)) {</span>
<a href="#l13.252"></a><span id="l13.252" class="difflineplus">+        tagName = tagName.trim();</span>
<a href="#l13.253"></a><span id="l13.253" class="difflineplus">+        // return attrib, param, value; we know the param to use because we know</span>
<a href="#l13.254"></a><span id="l13.254" class="difflineplus">+        //  how FreeTagNoun works, but this is a candidate for refactoring.</span>
<a href="#l13.255"></a><span id="l13.255" class="difflineplus">+        if (tagName) {</span>
<a href="#l13.256"></a><span id="l13.256" class="difflineplus">+          FreeTagNoun.getFreeTag(tagName); // cause the tag to be known</span>
<a href="#l13.257"></a><span id="l13.257" class="difflineplus">+          attribs.push([this._attrFreeTag, tagName, null]);</span>
<a href="#l13.258"></a><span id="l13.258" class="difflineplus">+        }</span>
<a href="#l13.259"></a><span id="l13.259" class="difflineplus">+      }</span>
<a href="#l13.260"></a><span id="l13.260" class="difflineplus">+    }</span>
<a href="#l13.261"></a><span id="l13.261" class="difflineplus">+    </span>
<a href="#l13.262"></a><span id="l13.262" class="difflineplus">+    this._log.debug(&quot;Returning attributes: &quot; + attribs);</span>
<a href="#l13.263"></a><span id="l13.263" class="difflineplus">+    </span>
<a href="#l13.264"></a><span id="l13.264" class="difflineplus">+    return attribs;</span>
<a href="#l13.265"></a><span id="l13.265" class="difflineplus">+  }</span>
<a href="#l13.266"></a><span id="l13.266" class="difflineplus">+};</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -301,16 +301,39 @@ var GlodaIndexer = {</span>
<a href="#l14.4"></a><span id="l14.4">     // if the datastore can't stop immediately, it will call the provided</span>
<a href="#l14.5"></a><span id="l14.5">     //  callback.</span>
<a href="#l14.6"></a><span id="l14.6">     return GlodaDatastore.shutdown(function () {</span>
<a href="#l14.7"></a><span id="l14.7">       if (aUrlListener)</span>
<a href="#l14.8"></a><span id="l14.8">         aUrlListener.OnStopRunningUrl(null, Cr.NS_OK);</span>
<a href="#l14.9"></a><span id="l14.9">     });</span>
<a href="#l14.10"></a><span id="l14.10">   },</span>
<a href="#l14.11"></a><span id="l14.11">   </span>
<a href="#l14.12"></a><span id="l14.12" class="difflineplus">+  _otherIndexers: [],</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+  registerIndexer: function gloda_index_registerIndexer(aIndexer) {</span>
<a href="#l14.14"></a><span id="l14.14" class="difflineplus">+    this._log.info(&quot;Registering indexer: &quot; + aIndexer.name);</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineplus">+    this._otherIndexers.push(aIndexer);</span>
<a href="#l14.16"></a><span id="l14.16" class="difflineplus">+    </span>
<a href="#l14.17"></a><span id="l14.17" class="difflineplus">+    try {</span>
<a href="#l14.18"></a><span id="l14.18" class="difflineplus">+      for each (let [workerCode, workerFunc] in aIndexer.workers) {</span>
<a href="#l14.19"></a><span id="l14.19" class="difflineplus">+        this._otherIndexerWorkers[workerCode] = [aIndexer, workerFunc];</span>
<a href="#l14.20"></a><span id="l14.20" class="difflineplus">+      }</span>
<a href="#l14.21"></a><span id="l14.21" class="difflineplus">+    }</span>
<a href="#l14.22"></a><span id="l14.22" class="difflineplus">+    catch (ex) {</span>
<a href="#l14.23"></a><span id="l14.23" class="difflineplus">+      this._log.warning(&quot;Helper indexer threw exception on worker enum.&quot;);</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineplus">+    }</span>
<a href="#l14.25"></a><span id="l14.25" class="difflineplus">+    </span>
<a href="#l14.26"></a><span id="l14.26" class="difflineplus">+    if (this._enabled) {</span>
<a href="#l14.27"></a><span id="l14.27" class="difflineplus">+      try {</span>
<a href="#l14.28"></a><span id="l14.28" class="difflineplus">+        aIndexer.enable();</span>
<a href="#l14.29"></a><span id="l14.29" class="difflineplus">+      } catch (ex) {</span>
<a href="#l14.30"></a><span id="l14.30" class="difflineplus">+        this._log.warning(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l14.31"></a><span id="l14.31" class="difflineplus">+      }</span>
<a href="#l14.32"></a><span id="l14.32" class="difflineplus">+    }</span>
<a href="#l14.33"></a><span id="l14.33" class="difflineplus">+  },</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineplus">+  </span>
<a href="#l14.35"></a><span id="l14.35">   /**</span>
<a href="#l14.36"></a><span id="l14.36">    * Are we enabled, read: are we processing change events?</span>
<a href="#l14.37"></a><span id="l14.37">    */</span>
<a href="#l14.38"></a><span id="l14.38">   _enabled: false,</span>
<a href="#l14.39"></a><span id="l14.39">   get enabled() { return this._enabled; },</span>
<a href="#l14.40"></a><span id="l14.40">   set enabled(aEnable) {</span>
<a href="#l14.41"></a><span id="l14.41">     if (!this._enabled &amp;&amp; aEnable) {</span>
<a href="#l14.42"></a><span id="l14.42">       // register for:</span>
<a href="#l14.43"></a><span id="l14.43" class="difflineat">@@ -340,23 +363,39 @@ var GlodaIndexer = {</span>
<a href="#l14.44"></a><span id="l14.44">       let notificationService =</span>
<a href="#l14.45"></a><span id="l14.45">         Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l14.46"></a><span id="l14.46">         getService(Ci.nsIMsgFolderNotificationService);</span>
<a href="#l14.47"></a><span id="l14.47">       notificationService.addListener(this._msgFolderListener,</span>
<a href="#l14.48"></a><span id="l14.48">                                       Ci.nsIMsgFolderNotificationService.all);</span>
<a href="#l14.49"></a><span id="l14.49">       </span>
<a href="#l14.50"></a><span id="l14.50">       this._enabled = true;</span>
<a href="#l14.51"></a><span id="l14.51">       </span>
<a href="#l14.52"></a><span id="l14.52" class="difflineplus">+      for each (let indexer in this._otherIndexers) {</span>
<a href="#l14.53"></a><span id="l14.53" class="difflineplus">+        try {</span>
<a href="#l14.54"></a><span id="l14.54" class="difflineplus">+          indexer.enable();</span>
<a href="#l14.55"></a><span id="l14.55" class="difflineplus">+        } catch (ex) {</span>
<a href="#l14.56"></a><span id="l14.56" class="difflineplus">+          this._log.warning(&quot;Helper indexer threw exception on enable: &quot; + ex);</span>
<a href="#l14.57"></a><span id="l14.57" class="difflineplus">+        }</span>
<a href="#l14.58"></a><span id="l14.58" class="difflineplus">+      }</span>
<a href="#l14.59"></a><span id="l14.59" class="difflineplus">+      </span>
<a href="#l14.60"></a><span id="l14.60">       // if we have an accumulated desire to index things, kick it off again.</span>
<a href="#l14.61"></a><span id="l14.61">       if (this._indexingDesired) {</span>
<a href="#l14.62"></a><span id="l14.62">         this._indexingDesired = false; // it's edge-triggered for now</span>
<a href="#l14.63"></a><span id="l14.63">         this.indexing = true;</span>
<a href="#l14.64"></a><span id="l14.64">       }</span>
<a href="#l14.65"></a><span id="l14.65">     }</span>
<a href="#l14.66"></a><span id="l14.66">     else if (this._enabled &amp;&amp; !aEnable) {</span>
<a href="#l14.67"></a><span id="l14.67" class="difflineplus">+      for each (let indexer in this._otherIndexers) {</span>
<a href="#l14.68"></a><span id="l14.68" class="difflineplus">+        try {</span>
<a href="#l14.69"></a><span id="l14.69" class="difflineplus">+          indexer.disable();</span>
<a href="#l14.70"></a><span id="l14.70" class="difflineplus">+        } catch (ex) {</span>
<a href="#l14.71"></a><span id="l14.71" class="difflineplus">+          this._log.warning(&quot;Helper indexer threw exception on disable: &quot; + ex);</span>
<a href="#l14.72"></a><span id="l14.72" class="difflineplus">+        }</span>
<a href="#l14.73"></a><span id="l14.73" class="difflineplus">+      }</span>
<a href="#l14.74"></a><span id="l14.74" class="difflineplus">+</span>
<a href="#l14.75"></a><span id="l14.75">       // remove observer; no more events to observe!</span>
<a href="#l14.76"></a><span id="l14.76">       let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l14.77"></a><span id="l14.77">                               getService(Ci.nsIObserverService);</span>
<a href="#l14.78"></a><span id="l14.78">       observerService.removeObserver(this, &quot;network:offline-status-changed&quot;);</span>
<a href="#l14.79"></a><span id="l14.79">       observerService.removeObserver(this._shutdownTask, &quot;msg-shutdown&quot;, false);</span>
<a href="#l14.80"></a><span id="l14.80">   </span>
<a href="#l14.81"></a><span id="l14.81">       // remove idle</span>
<a href="#l14.82"></a><span id="l14.82">       let idleService = Cc[&quot;@mozilla.org/widget/idleservice;1&quot;].</span>
<a href="#l14.83"></a><span id="l14.83" class="difflineat">@@ -436,16 +475,17 @@ var GlodaIndexer = {</span>
<a href="#l14.84"></a><span id="l14.84">         this._log.info(&quot;+++ Indexing Queue Processing Resuming&quot;);</span>
<a href="#l14.85"></a><span id="l14.85">         this._indexingActive = true;</span>
<a href="#l14.86"></a><span id="l14.86">         this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l14.87"></a><span id="l14.87">                                      this._indexInterval,</span>
<a href="#l14.88"></a><span id="l14.88">                                      Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l14.89"></a><span id="l14.89">     }</span>
<a href="#l14.90"></a><span id="l14.90">   },</span>
<a href="#l14.91"></a><span id="l14.91"> </span>
<a href="#l14.92"></a><span id="l14.92" class="difflineplus">+  _initialSweepPerformed: false,</span>
<a href="#l14.93"></a><span id="l14.93">   _indexingSweepActive: false,</span>
<a href="#l14.94"></a><span id="l14.94">   /**</span>
<a href="#l14.95"></a><span id="l14.95">    * Indicate that an indexing sweep is desired.  We kick-off an indexing</span>
<a href="#l14.96"></a><span id="l14.96">    *  sweep at start-up and whenever we receive an event-based notification</span>
<a href="#l14.97"></a><span id="l14.97">    *  that we either can't process as an event or that we normally handle</span>
<a href="#l14.98"></a><span id="l14.98">    *  during the sweep pass anyways.</span>
<a href="#l14.99"></a><span id="l14.99">    */</span>
<a href="#l14.100"></a><span id="l14.100">   set indexingSweepNeeded(aNeeded) {</span>
<a href="#l14.101"></a><span id="l14.101" class="difflineat">@@ -917,16 +957,17 @@ var GlodaIndexer = {</span>
<a href="#l14.102"></a><span id="l14.102">     // try and get a job if we don't have one for the sake of the notification</span>
<a href="#l14.103"></a><span id="l14.103">     if (this.indexing &amp;&amp; (this._actualWorker === null))</span>
<a href="#l14.104"></a><span id="l14.104">       this._hireJobWorker();</span>
<a href="#l14.105"></a><span id="l14.105">     this._notifyListeners();</span>
<a href="#l14.106"></a><span id="l14.106">     </span>
<a href="#l14.107"></a><span id="l14.107">     yield this.kWorkDone;</span>
<a href="#l14.108"></a><span id="l14.108">   },</span>
<a href="#l14.109"></a><span id="l14.109"> </span>
<a href="#l14.110"></a><span id="l14.110" class="difflineplus">+  _otherIndexerWorkers: {},</span>
<a href="#l14.111"></a><span id="l14.111">   /**</span>
<a href="#l14.112"></a><span id="l14.112">    * Perform the initialization step and return a generator if there is any</span>
<a href="#l14.113"></a><span id="l14.113">    *  steady-state processing to be had.</span>
<a href="#l14.114"></a><span id="l14.114">    */</span>
<a href="#l14.115"></a><span id="l14.115">   _hireJobWorker: function gloda_index_hireJobWorker() {</span>
<a href="#l14.116"></a><span id="l14.116">     if (this._indexQueue.length == 0) {</span>
<a href="#l14.117"></a><span id="l14.117">       this._log.info(&quot;--- Done indexing, disabling timer renewal.&quot;);</span>
<a href="#l14.118"></a><span id="l14.118">       </span>
<a href="#l14.119"></a><span id="l14.119" class="difflineat">@@ -963,16 +1004,23 @@ var GlodaIndexer = {</span>
<a href="#l14.120"></a><span id="l14.120">                   </span>
<a href="#l14.121"></a><span id="l14.121">       this._actualWorker = this._worker_messageIndex(job);</span>
<a href="#l14.122"></a><span id="l14.122">     }</span>
<a href="#l14.123"></a><span id="l14.123">     else if (job.jobType == &quot;delete&quot;) {</span>
<a href="#l14.124"></a><span id="l14.124">       // we'll count the block processing as a cost of 1...</span>
<a href="#l14.125"></a><span id="l14.125">       job.goal = 1;</span>
<a href="#l14.126"></a><span id="l14.126">       this._actualWorker = this._worker_processDeletes(job);</span>
<a href="#l14.127"></a><span id="l14.127">     }</span>
<a href="#l14.128"></a><span id="l14.128" class="difflineplus">+    else if (job.jobType in this._otherIndexerWorkers) {</span>
<a href="#l14.129"></a><span id="l14.129" class="difflineplus">+      let [indexer, workerFunc] = this._otherIndexerWorkers[job.jobType];</span>
<a href="#l14.130"></a><span id="l14.130" class="difflineplus">+      this._actualWorker = workerFunc.call(indexer, job);</span>
<a href="#l14.131"></a><span id="l14.131" class="difflineplus">+    }</span>
<a href="#l14.132"></a><span id="l14.132" class="difflineplus">+    else {</span>
<a href="#l14.133"></a><span id="l14.133" class="difflineplus">+      this._log.warning(&quot;Unknown job type: &quot; + job.jobType);</span>
<a href="#l14.134"></a><span id="l14.134" class="difflineplus">+    }</span>
<a href="#l14.135"></a><span id="l14.135">     </span>
<a href="#l14.136"></a><span id="l14.136">     return true;</span>
<a href="#l14.137"></a><span id="l14.137">   },</span>
<a href="#l14.138"></a><span id="l14.138"> </span>
<a href="#l14.139"></a><span id="l14.139">   /**</span>
<a href="#l14.140"></a><span id="l14.140">    * Performs the folder sweep, locating folders that should be indexed, and</span>
<a href="#l14.141"></a><span id="l14.141">    *  creating a folder indexing job for them, and rescheduling itself for</span>
<a href="#l14.142"></a><span id="l14.142">    *  execution after that job is completed.  Once it indexes all the folders,</span>
<a href="#l14.143"></a><span id="l14.143" class="difflineat">@@ -1055,16 +1103,34 @@ var GlodaIndexer = {</span>
<a href="#l14.144"></a><span id="l14.144">     </span>
<a href="#l14.145"></a><span id="l14.145">     // consider deletion</span>
<a href="#l14.146"></a><span id="l14.146">     if (this.pendingDeletion || this.pendingDeletion === null) {</span>
<a href="#l14.147"></a><span id="l14.147">       this._indexingJobGoal++;</span>
<a href="#l14.148"></a><span id="l14.148">       this._indexQueue.push(new IndexingJob(&quot;delete&quot;, 0, null));</span>
<a href="#l14.149"></a><span id="l14.149">       // no need to set this.indexing to true, it must be true if we are here.</span>
<a href="#l14.150"></a><span id="l14.150">     }</span>
<a href="#l14.151"></a><span id="l14.151">     </span>
<a href="#l14.152"></a><span id="l14.152" class="difflineplus">+    // if this is our first sweep, give the other indexers a chance to do their</span>
<a href="#l14.153"></a><span id="l14.153" class="difflineplus">+    //  own initial sweep.  it's on them to schedule their own job if they have</span>
<a href="#l14.154"></a><span id="l14.154" class="difflineplus">+    //  a lot to do, but if they only have a little to do, they can get away</span>
<a href="#l14.155"></a><span id="l14.155" class="difflineplus">+    //  with it, as we yield a sync after each one.</span>
<a href="#l14.156"></a><span id="l14.156" class="difflineplus">+    if (!this._initialSweepPerformed) {</span>
<a href="#l14.157"></a><span id="l14.157" class="difflineplus">+      for each (let indexer in this._otherIndexers) {</span>
<a href="#l14.158"></a><span id="l14.158" class="difflineplus">+        try {</span>
<a href="#l14.159"></a><span id="l14.159" class="difflineplus">+          indexer.initialSweep();</span>
<a href="#l14.160"></a><span id="l14.160" class="difflineplus">+        }</span>
<a href="#l14.161"></a><span id="l14.161" class="difflineplus">+        catch (ex) {</span>
<a href="#l14.162"></a><span id="l14.162" class="difflineplus">+          this._log.warning(&quot;Helper indexer threw exception on initial sweep:&quot; +</span>
<a href="#l14.163"></a><span id="l14.163" class="difflineplus">+                            ex);</span>
<a href="#l14.164"></a><span id="l14.164" class="difflineplus">+        }</span>
<a href="#l14.165"></a><span id="l14.165" class="difflineplus">+        yield this.kWorkSync;</span>
<a href="#l14.166"></a><span id="l14.166" class="difflineplus">+      }</span>
<a href="#l14.167"></a><span id="l14.167" class="difflineplus">+      this._initialSweepPerformed = true;</span>
<a href="#l14.168"></a><span id="l14.168" class="difflineplus">+    }</span>
<a href="#l14.169"></a><span id="l14.169" class="difflineplus">+    </span>
<a href="#l14.170"></a><span id="l14.170">     // we don't have any more work to do...</span>
<a href="#l14.171"></a><span id="l14.171">     this._indexingSweepActive = false;</span>
<a href="#l14.172"></a><span id="l14.172">     yield this.kWorkDone;</span>
<a href="#l14.173"></a><span id="l14.173">   },</span>
<a href="#l14.174"></a><span id="l14.174"> </span>
<a href="#l14.175"></a><span id="l14.175">   /**</span>
<a href="#l14.176"></a><span id="l14.176">    * Index the contents of a folder.</span>
<a href="#l14.177"></a><span id="l14.177">    */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1">new file mode 100644</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineminus">--- /dev/null</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineplus">+++ b/modules/noun_freetag.js</span>
<a href="#l15.4"></a><span id="l15.4" class="difflineat">@@ -0,0 +1,97 @@</span>
<a href="#l15.5"></a><span id="l15.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l15.6"></a><span id="l15.6" class="difflineplus">+ *   Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l15.7"></a><span id="l15.7" class="difflineplus">+ *</span>
<a href="#l15.8"></a><span id="l15.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l15.9"></a><span id="l15.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l15.10"></a><span id="l15.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l15.11"></a><span id="l15.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l15.12"></a><span id="l15.12" class="difflineplus">+ * </span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l15.14"></a><span id="l15.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l15.15"></a><span id="l15.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l15.16"></a><span id="l15.16" class="difflineplus">+ * License.</span>
<a href="#l15.17"></a><span id="l15.17" class="difflineplus">+ *</span>
<a href="#l15.18"></a><span id="l15.18" class="difflineplus">+ * The Original Code is Thunderbird Global Database.</span>
<a href="#l15.19"></a><span id="l15.19" class="difflineplus">+ *</span>
<a href="#l15.20"></a><span id="l15.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l15.21"></a><span id="l15.21" class="difflineplus">+ * Mozilla Messaging, Inc.</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2008</span>
<a href="#l15.23"></a><span id="l15.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l15.24"></a><span id="l15.24" class="difflineplus">+ *</span>
<a href="#l15.25"></a><span id="l15.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l15.26"></a><span id="l15.26" class="difflineplus">+ *   Andrew Sutherland &lt;asutherland@asutherland.org&gt;</span>
<a href="#l15.27"></a><span id="l15.27" class="difflineplus">+ *</span>
<a href="#l15.28"></a><span id="l15.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l15.29"></a><span id="l15.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l15.30"></a><span id="l15.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l15.33"></a><span id="l15.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l15.34"></a><span id="l15.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l15.35"></a><span id="l15.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l15.36"></a><span id="l15.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l15.37"></a><span id="l15.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l15.38"></a><span id="l15.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l15.39"></a><span id="l15.39" class="difflineplus">+ * </span>
<a href="#l15.40"></a><span id="l15.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l15.41"></a><span id="l15.41" class="difflineplus">+</span>
<a href="#l15.42"></a><span id="l15.42" class="difflineplus">+EXPORTED_SYMBOLS = ['FreeTag', 'FreeTagNoun'];</span>
<a href="#l15.43"></a><span id="l15.43" class="difflineplus">+</span>
<a href="#l15.44"></a><span id="l15.44" class="difflineplus">+const Cc = Components.classes;</span>
<a href="#l15.45"></a><span id="l15.45" class="difflineplus">+const Ci = Components.interfaces;</span>
<a href="#l15.46"></a><span id="l15.46" class="difflineplus">+const Cr = Components.results;</span>
<a href="#l15.47"></a><span id="l15.47" class="difflineplus">+const Cu = Components.utils;</span>
<a href="#l15.48"></a><span id="l15.48" class="difflineplus">+</span>
<a href="#l15.49"></a><span id="l15.49" class="difflineplus">+Cu.import(&quot;resource://gloda/modules/gloda.js&quot;);</span>
<a href="#l15.50"></a><span id="l15.50" class="difflineplus">+</span>
<a href="#l15.51"></a><span id="l15.51" class="difflineplus">+function FreeTag(aTagName) {</span>
<a href="#l15.52"></a><span id="l15.52" class="difflineplus">+  this.name = aTagName;</span>
<a href="#l15.53"></a><span id="l15.53" class="difflineplus">+}</span>
<a href="#l15.54"></a><span id="l15.54" class="difflineplus">+</span>
<a href="#l15.55"></a><span id="l15.55" class="difflineplus">+FreeTag.prototype = {</span>
<a href="#l15.56"></a><span id="l15.56" class="difflineplus">+  toString: function () {</span>
<a href="#l15.57"></a><span id="l15.57" class="difflineplus">+    return this.name;</span>
<a href="#l15.58"></a><span id="l15.58" class="difflineplus">+  }</span>
<a href="#l15.59"></a><span id="l15.59" class="difflineplus">+};</span>
<a href="#l15.60"></a><span id="l15.60" class="difflineplus">+</span>
<a href="#l15.61"></a><span id="l15.61" class="difflineplus">+/**</span>
<a href="#l15.62"></a><span id="l15.62" class="difflineplus">+ * @namespace Tag noun provider.  Since the tag unique value is stored as a</span>
<a href="#l15.63"></a><span id="l15.63" class="difflineplus">+ *  parameter, we are an odd case and semantically confused.</span>
<a href="#l15.64"></a><span id="l15.64" class="difflineplus">+ */</span>
<a href="#l15.65"></a><span id="l15.65" class="difflineplus">+var FreeTagNoun = {</span>
<a href="#l15.66"></a><span id="l15.66" class="difflineplus">+  name: &quot;freetag&quot;,</span>
<a href="#l15.67"></a><span id="l15.67" class="difflineplus">+  class: FreeTag,</span>
<a href="#l15.68"></a><span id="l15.68" class="difflineplus">+  firstClass: false,</span>
<a href="#l15.69"></a><span id="l15.69" class="difflineplus">+  </span>
<a href="#l15.70"></a><span id="l15.70" class="difflineplus">+  _listeners: [],</span>
<a href="#l15.71"></a><span id="l15.71" class="difflineplus">+  addListener: function(aListener) {</span>
<a href="#l15.72"></a><span id="l15.72" class="difflineplus">+    this._listeners.push(aListener);</span>
<a href="#l15.73"></a><span id="l15.73" class="difflineplus">+  },</span>
<a href="#l15.74"></a><span id="l15.74" class="difflineplus">+  removeListener: function(aListener) {</span>
<a href="#l15.75"></a><span id="l15.75" class="difflineplus">+    let index = this._listeners.indexOf(aListener);</span>
<a href="#l15.76"></a><span id="l15.76" class="difflineplus">+    if (index &gt;=0)</span>
<a href="#l15.77"></a><span id="l15.77" class="difflineplus">+      this._listeners.splice(index, 1);</span>
<a href="#l15.78"></a><span id="l15.78" class="difflineplus">+  },</span>
<a href="#l15.79"></a><span id="l15.79" class="difflineplus">+  </span>
<a href="#l15.80"></a><span id="l15.80" class="difflineplus">+  knownFreeTags: {},</span>
<a href="#l15.81"></a><span id="l15.81" class="difflineplus">+  getFreeTag: function(aTagName) {</span>
<a href="#l15.82"></a><span id="l15.82" class="difflineplus">+    let tag = this.knownFreeTags[aTagName];</span>
<a href="#l15.83"></a><span id="l15.83" class="difflineplus">+    if (!tag) {</span>
<a href="#l15.84"></a><span id="l15.84" class="difflineplus">+      tag = this.knownFreeTags[aTagName] = new FreeTag(aTagName);</span>
<a href="#l15.85"></a><span id="l15.85" class="difflineplus">+      for each (let listener in this._listeners)</span>
<a href="#l15.86"></a><span id="l15.86" class="difflineplus">+        listener.onFreeTagAdded(tag);</span>
<a href="#l15.87"></a><span id="l15.87" class="difflineplus">+    }</span>
<a href="#l15.88"></a><span id="l15.88" class="difflineplus">+    return tag;</span>
<a href="#l15.89"></a><span id="l15.89" class="difflineplus">+  },</span>
<a href="#l15.90"></a><span id="l15.90" class="difflineplus">+</span>
<a href="#l15.91"></a><span id="l15.91" class="difflineplus">+  toParamAndValue: function gloda_noun_tag_toParamAndValue(aTag) {</span>
<a href="#l15.92"></a><span id="l15.92" class="difflineplus">+    return [aTag.name, null];</span>
<a href="#l15.93"></a><span id="l15.93" class="difflineplus">+  },</span>
<a href="#l15.94"></a><span id="l15.94" class="difflineplus">+  </span>
<a href="#l15.95"></a><span id="l15.95" class="difflineplus">+  fromParamAndValue: function gloda_noun_tag_fromParameterValue(aTagName,</span>
<a href="#l15.96"></a><span id="l15.96" class="difflineplus">+                                                                aIgnored) {</span>
<a href="#l15.97"></a><span id="l15.97" class="difflineplus">+    return this.getFreeTag(aTagName);</span>
<a href="#l15.98"></a><span id="l15.98" class="difflineplus">+  },</span>
<a href="#l15.99"></a><span id="l15.99" class="difflineplus">+};</span>
<a href="#l15.100"></a><span id="l15.100" class="difflineplus">+</span>
<a href="#l15.101"></a><span id="l15.101" class="difflineplus">+Gloda.defineNoun(FreeTagNoun);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/modules/query.js</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/modules/query.js</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -63,16 +63,18 @@ function GlodaQueryClass() {</span>
<a href="#l16.4"></a><span id="l16.4">   this._owner = null;</span>
<a href="#l16.5"></a><span id="l16.5">   // our personal chain of and-ing.</span>
<a href="#l16.6"></a><span id="l16.6">   this._constraints = [];</span>
<a href="#l16.7"></a><span id="l16.7">   // the other instances we union with</span>
<a href="#l16.8"></a><span id="l16.8">   this._unions = [];</span>
<a href="#l16.9"></a><span id="l16.9"> }</span>
<a href="#l16.10"></a><span id="l16.10"> </span>
<a href="#l16.11"></a><span id="l16.11"> GlodaQueryClass.prototype = {</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineplus">+  WILDCARD: {},</span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+  </span>
<a href="#l16.14"></a><span id="l16.14">   or: function gloda_query_or() {</span>
<a href="#l16.15"></a><span id="l16.15">     let owner = this._owner || this;</span>
<a href="#l16.16"></a><span id="l16.16">     let orQuery = new this._queryClass();</span>
<a href="#l16.17"></a><span id="l16.17">     orQuery._owner = owner;</span>
<a href="#l16.18"></a><span id="l16.18">     owner._unions.push(orQuery);</span>
<a href="#l16.19"></a><span id="l16.19">     return orQuery;</span>
<a href="#l16.20"></a><span id="l16.20">   },</span>
<a href="#l16.21"></a><span id="l16.21">   </span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

