<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 933:eb07537051591a8ed2254f56804f20f64e2f7d8a</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ eb07537051591a8ed2254f56804f20f64e2f7d8a" />
<meta property="og:url" content="/comm-central/rev/eb07537051591a8ed2254f56804f20f64e2f7d8a" />
<meta property="og:description" content="Add concept of 'unique value' as an alternate lookup mechanism for" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / eb07537051591a8ed2254f56804f20f64e2f7d8a 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/eb07537051591a8ed2254f56804f20f64e2f7d8a">shortlog</a> |
<a href="/comm-central/log/eb07537051591a8ed2254f56804f20f64e2f7d8a">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/eb07537051591a8ed2254f56804f20f64e2f7d8a">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/eb07537051591a8ed2254f56804f20f64e2f7d8a">files</a> |
changeset |
<a href="/comm-central/raw-rev/eb07537051591a8ed2254f56804f20f64e2f7d8a">raw</a>  | <a href="/comm-central/archive/eb07537051591a8ed2254f56804f20f64e2f7d8a.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
Add concept of 'unique value' as an alternate lookup mechanism for
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Sat, 20 Sep 2008 23:36:26 -0700</td></tr>

<tr>
 <td>changeset 933</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/eb07537051591a8ed2254f56804f20f64e2f7d8a">eb07537051591a8ed2254f56804f20f64e2f7d8a</a></td>
</tr>



<tr>
<td>parent 932</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/9082e6d74f2d06a0a0556585ec78174fbe276cc0">9082e6d74f2d06a0a0556585ec78174fbe276cc0</a>
</td>
</tr>

<tr>
<td>child 934</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/13592e09f549e323eab7719286d45b36d2f99148">13592e09f549e323eab7719286d45b36d2f99148</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=eb07537051591a8ed2254f56804f20f64e2f7d8a">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">Add concept of 'unique value' as an alternate lookup mechanism for
collections.  This allows us to avoid creation of duplicate identities due
to the lookup currently being synchronous and the insert being async.  It
does assume the cache/collections are sufficient though.  We probably need
some concept of locking the objects into memory until their transaction is
committed.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/collection.js">file</a> |
<a href="/comm-central/annotate/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/collection.js">comparison</a> |
<a href="/comm-central/log/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/eb07537051591a8ed2254f56804f20f64e2f7d8a/modules/gloda.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -128,16 +128,48 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4">         if (cache)</span>
<a href="#l1.5"></a><span id="l1.5">           cache.add([item]);</span>
<a href="#l1.6"></a><span id="l1.6">         return item;</span>
<a href="#l1.7"></a><span id="l1.7">       }</span>
<a href="#l1.8"></a><span id="l1.8">     }</span>
<a href="#l1.9"></a><span id="l1.9">     </span>
<a href="#l1.10"></a><span id="l1.10">     return null;</span>
<a href="#l1.11"></a><span id="l1.11">   },</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  /**</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+   * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l1.15"></a><span id="l1.15" class="difflineplus">+   *  given id.  Counts as a cache hit if found.  (And if it was't in a cache,</span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+   *  but rather a collection, it is added to the cache.)</span>
<a href="#l1.17"></a><span id="l1.17" class="difflineplus">+   */</span>
<a href="#l1.18"></a><span id="l1.18" class="difflineplus">+  cacheLookupOneByUniqueValue:</span>
<a href="#l1.19"></a><span id="l1.19" class="difflineplus">+      function gloda_colm_cacheLookupOneByUniqueValue(aNounID, aUniqueValue,</span>
<a href="#l1.20"></a><span id="l1.20" class="difflineplus">+                                                      aDoCache) {</span>
<a href="#l1.21"></a><span id="l1.21" class="difflineplus">+    let cache = this._cachesByNoun[aNounID];</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineplus">+    </span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+    if (cache) {</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineplus">+      if (aUniqueValue in cache._uniqueValueMap) {</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineplus">+        let item = cache._uniqueValueMap[aUniqueValue];</span>
<a href="#l1.26"></a><span id="l1.26" class="difflineplus">+        return cache.hit(item);</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+      }</span>
<a href="#l1.28"></a><span id="l1.28" class="difflineplus">+    }</span>
<a href="#l1.29"></a><span id="l1.29" class="difflineplus">+    </span>
<a href="#l1.30"></a><span id="l1.30" class="difflineplus">+    if (aDoCache === false)</span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+      cache = null;</span>
<a href="#l1.32"></a><span id="l1.32" class="difflineplus">+  </span>
<a href="#l1.33"></a><span id="l1.33" class="difflineplus">+    for each (let collection in this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineplus">+      if (aUniqueValue in collection._uniqueValueMap) {</span>
<a href="#l1.35"></a><span id="l1.35" class="difflineplus">+        let item = collection._uniqueValueMap[aUniqueValue];</span>
<a href="#l1.36"></a><span id="l1.36" class="difflineplus">+        if (cache)</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineplus">+          cache.add([item]);</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+        return item;</span>
<a href="#l1.39"></a><span id="l1.39" class="difflineplus">+      }</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineplus">+    }</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+    </span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+    return null;</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+  },</span>
<a href="#l1.44"></a><span id="l1.44">   </span>
<a href="#l1.45"></a><span id="l1.45">   /**</span>
<a href="#l1.46"></a><span id="l1.46">    * Checks whether the provided item with the given id is actually a duplicate</span>
<a href="#l1.47"></a><span id="l1.47">    *  of an instance that already exists in the cache/a collection.  If it is,</span>
<a href="#l1.48"></a><span id="l1.48">    *  the pre-existing instance is returned and counts as a cache hit.  If it</span>
<a href="#l1.49"></a><span id="l1.49">    *  is not, the passed-in instance is added to the cache and returned.</span>
<a href="#l1.50"></a><span id="l1.50">    */</span>
<a href="#l1.51"></a><span id="l1.51">   cacheLoadUnifyOne: function gloda_colm_cacheLoadUnifyOne(aItem) {</span>
<a href="#l1.52"></a><span id="l1.52" class="difflineat">@@ -339,21 +371,38 @@ GlodaCollectionManager = new GlodaCollec</span>
<a href="#l1.53"></a><span id="l1.53"> /**</span>
<a href="#l1.54"></a><span id="l1.54">  * A GlodaCollection is intended to be a current view of the set of first-class</span>
<a href="#l1.55"></a><span id="l1.55">  *  nouns meeting a given query.  Assuming a listener is present, events are</span>
<a href="#l1.56"></a><span id="l1.56">  *  generated when new objects meet the query, existing objects no longer meet</span>
<a href="#l1.57"></a><span id="l1.57">  *  the query, or existing objects have experienced a change in attributes that</span>
<a href="#l1.58"></a><span id="l1.58">  *  does not affect their ability to be present (but the listener may care about</span>
<a href="#l1.59"></a><span id="l1.59">  *  because it is exposing those attributes). </span>
<a href="#l1.60"></a><span id="l1.60">  */</span>
<a href="#l1.61"></a><span id="l1.61" class="difflineminus">-function GlodaCollection(aItems, aQuery, aListener) {</span>
<a href="#l1.62"></a><span id="l1.62" class="difflineplus">+function GlodaCollection(aNounMeta, aItems, aQuery, aListener) {</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineplus">+  // if aNounMeta is null, we are just being invoked for subclassing</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+  if (aNounMeta === undefined)</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+    return;</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+</span>
<a href="#l1.67"></a><span id="l1.67" class="difflineplus">+  this._nounMeta = aNounMeta;</span>
<a href="#l1.68"></a><span id="l1.68" class="difflineplus">+  // should we also maintain a unique value mapping...</span>
<a href="#l1.69"></a><span id="l1.69" class="difflineplus">+  if (this._nounMeta.usesUniqueValue)</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineplus">+    this._uniqueValueMap = {};</span>
<a href="#l1.71"></a><span id="l1.71" class="difflineplus">+</span>
<a href="#l1.72"></a><span id="l1.72">   this.items = aItems || [];</span>
<a href="#l1.73"></a><span id="l1.73">   this._idMap = {};</span>
<a href="#l1.74"></a><span id="l1.74" class="difflineminus">-  for each (let item in this.items) {</span>
<a href="#l1.75"></a><span id="l1.75" class="difflineminus">-    this._idMap[item.id] = item;</span>
<a href="#l1.76"></a><span id="l1.76" class="difflineplus">+  if (this._uniqueValueMap) {</span>
<a href="#l1.77"></a><span id="l1.77" class="difflineplus">+    for each (let item in this.items) {</span>
<a href="#l1.78"></a><span id="l1.78" class="difflineplus">+      this._idMap[item.id] = item;</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineplus">+      this._uniqueValueMap[item.uniqueValue] = item;</span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+    }</span>
<a href="#l1.81"></a><span id="l1.81" class="difflineplus">+  }</span>
<a href="#l1.82"></a><span id="l1.82" class="difflineplus">+  else {</span>
<a href="#l1.83"></a><span id="l1.83" class="difflineplus">+    for each (let item in this.items) {</span>
<a href="#l1.84"></a><span id="l1.84" class="difflineplus">+      this._idMap[item.id] = item;</span>
<a href="#l1.85"></a><span id="l1.85" class="difflineplus">+    }</span>
<a href="#l1.86"></a><span id="l1.86">   }</span>
<a href="#l1.87"></a><span id="l1.87">   </span>
<a href="#l1.88"></a><span id="l1.88">   this.query = aQuery || null;</span>
<a href="#l1.89"></a><span id="l1.89">   this._listener = aListener || null;</span>
<a href="#l1.90"></a><span id="l1.90"> }</span>
<a href="#l1.91"></a><span id="l1.91">  </span>
<a href="#l1.92"></a><span id="l1.92"> GlodaCollection.prototype = {</span>
<a href="#l1.93"></a><span id="l1.93">   get listener() { return this._listener; },</span>
<a href="#l1.94"></a><span id="l1.94" class="difflineat">@@ -362,40 +411,59 @@ GlodaCollection.prototype = {</span>
<a href="#l1.95"></a><span id="l1.95">   /**</span>
<a href="#l1.96"></a><span id="l1.96">    * Clear the contents of this collection.  This only makes sense for explicit</span>
<a href="#l1.97"></a><span id="l1.97">    *  collections or wildcard collections.  (Actual query-based collections</span>
<a href="#l1.98"></a><span id="l1.98">    *  should represent the state of the query, so unless we're going to delete</span>
<a href="#l1.99"></a><span id="l1.99">    *  all the items, clearing the collection would violate that constraint.)</span>
<a href="#l1.100"></a><span id="l1.100">    */</span>
<a href="#l1.101"></a><span id="l1.101">   clear: function gloda_coll_clear() {</span>
<a href="#l1.102"></a><span id="l1.102">     this._idMap = {};</span>
<a href="#l1.103"></a><span id="l1.103" class="difflineplus">+    if (this._uniqueValueMap)</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineplus">+      this._uniqueValueMap = {};</span>
<a href="#l1.105"></a><span id="l1.105">     this.items = [];</span>
<a href="#l1.106"></a><span id="l1.106">   },</span>
<a href="#l1.107"></a><span id="l1.107"> </span>
<a href="#l1.108"></a><span id="l1.108">   _onItemsAdded: function gloda_coll_onItemsAdded(aItems) {</span>
<a href="#l1.109"></a><span id="l1.109">     this.items.push.apply(this.items, aItems);</span>
<a href="#l1.110"></a><span id="l1.110" class="difflineminus">-    for each (item in aItems) {</span>
<a href="#l1.111"></a><span id="l1.111" class="difflineminus">-      this._idMap[item.id] = item;</span>
<a href="#l1.112"></a><span id="l1.112" class="difflineplus">+    if (this._uniqueValueMap) {</span>
<a href="#l1.113"></a><span id="l1.113" class="difflineplus">+      for each (let item in this.items) {</span>
<a href="#l1.114"></a><span id="l1.114" class="difflineplus">+        this._idMap[item.id] = item;</span>
<a href="#l1.115"></a><span id="l1.115" class="difflineplus">+        this._uniqueValueMap[item.uniqueValue] = item;</span>
<a href="#l1.116"></a><span id="l1.116" class="difflineplus">+      }</span>
<a href="#l1.117"></a><span id="l1.117" class="difflineplus">+    }</span>
<a href="#l1.118"></a><span id="l1.118" class="difflineplus">+    else {</span>
<a href="#l1.119"></a><span id="l1.119" class="difflineplus">+      for each (let item in this.items) {</span>
<a href="#l1.120"></a><span id="l1.120" class="difflineplus">+        this._idMap[item.id] = item;</span>
<a href="#l1.121"></a><span id="l1.121" class="difflineplus">+      }</span>
<a href="#l1.122"></a><span id="l1.122">     }</span>
<a href="#l1.123"></a><span id="l1.123">     if (this._listener)</span>
<a href="#l1.124"></a><span id="l1.124">       this._listener.onItemsAdded(aItems);</span>
<a href="#l1.125"></a><span id="l1.125">   },</span>
<a href="#l1.126"></a><span id="l1.126">   </span>
<a href="#l1.127"></a><span id="l1.127">   _onItemsModified: function gloda_coll_onItemsModified(aItems) {</span>
<a href="#l1.128"></a><span id="l1.128">     if (this._listener)</span>
<a href="#l1.129"></a><span id="l1.129">       this._listener.onItemsModified(aItems);</span>
<a href="#l1.130"></a><span id="l1.130">   },</span>
<a href="#l1.131"></a><span id="l1.131">   </span>
<a href="#l1.132"></a><span id="l1.132" class="difflineplus">+  /**</span>
<a href="#l1.133"></a><span id="l1.133" class="difflineplus">+   * Given a list of items that definitely no longer belong in this collection,</span>
<a href="#l1.134"></a><span id="l1.134" class="difflineplus">+   *  remove them from the collection and notify the listener.  The 'tricky'</span>
<a href="#l1.135"></a><span id="l1.135" class="difflineplus">+   *  part is that we need to remove the deleted items from our list of items.</span>
<a href="#l1.136"></a><span id="l1.136" class="difflineplus">+   */</span>
<a href="#l1.137"></a><span id="l1.137">   _onItemsRemoved: function gloda_coll_onItemsRemoved(aItems) {</span>
<a href="#l1.138"></a><span id="l1.138">     // we want to avoid the O(n^2) deletion performance case, and deletion</span>
<a href="#l1.139"></a><span id="l1.139">     //  should be rare enough that the extra cost of building the deletion map</span>
<a href="#l1.140"></a><span id="l1.140">     //  should never be a real problem.</span>
<a href="#l1.141"></a><span id="l1.141">     let deleteMap = {};</span>
<a href="#l1.142"></a><span id="l1.142" class="difflineplus">+    // build the delete map while also nuking from our id map/unique value map</span>
<a href="#l1.143"></a><span id="l1.143">     for each (let item in aItems) {</span>
<a href="#l1.144"></a><span id="l1.144">       deleteMap[item.id] = true;</span>
<a href="#l1.145"></a><span id="l1.145" class="difflineplus">+      delete this._idMap[item.id];</span>
<a href="#l1.146"></a><span id="l1.146" class="difflineplus">+      if (this._uniqueValueMap)</span>
<a href="#l1.147"></a><span id="l1.147" class="difflineplus">+        delete this._uniqueValueMap[item.uniqueValue];</span>
<a href="#l1.148"></a><span id="l1.148">     }</span>
<a href="#l1.149"></a><span id="l1.149">     let items = this.items;</span>
<a href="#l1.150"></a><span id="l1.150">     // in-place filter.  probably needless optimization.</span>
<a href="#l1.151"></a><span id="l1.151">     let iWrite=0;</span>
<a href="#l1.152"></a><span id="l1.152">     for (let iRead=0; iRead &lt; items.length; iRead++) {</span>
<a href="#l1.153"></a><span id="l1.153">       let item = items[iRead];</span>
<a href="#l1.154"></a><span id="l1.154">       if (!(item.id in deleteMap))</span>
<a href="#l1.155"></a><span id="l1.155">         items[iWrite++] = item;</span>
<a href="#l1.156"></a><span id="l1.156" class="difflineat">@@ -409,19 +477,17 @@ GlodaCollection.prototype = {</span>
<a href="#l1.157"></a><span id="l1.157"> </span>
<a href="#l1.158"></a><span id="l1.158"> /**</span>
<a href="#l1.159"></a><span id="l1.159">  * A LRU-discard cache.  We use a doubly linked-list for the eviction</span>
<a href="#l1.160"></a><span id="l1.160">  *  tracking.  Since we require that there is at most one LRU-discard cache per</span>
<a href="#l1.161"></a><span id="l1.161">  *  noun class, we simplify our lives by adding our own attributes to the</span>
<a href="#l1.162"></a><span id="l1.162">  *  cached objects.</span>
<a href="#l1.163"></a><span id="l1.163">  */</span>
<a href="#l1.164"></a><span id="l1.164"> function GlodaLRUCacheCollection(aNounMeta, aCacheSize) {</span>
<a href="#l1.165"></a><span id="l1.165" class="difflineminus">-  GlodaCollection.call(this, null, null, null);</span>
<a href="#l1.166"></a><span id="l1.166" class="difflineminus">-  </span>
<a href="#l1.167"></a><span id="l1.167" class="difflineminus">-  this._nounMeta = aNounMeta;</span>
<a href="#l1.168"></a><span id="l1.168" class="difflineplus">+  GlodaCollection.call(this, aNounMeta, null, null, null);</span>
<a href="#l1.169"></a><span id="l1.169">   </span>
<a href="#l1.170"></a><span id="l1.170">   this._head = null; // aka oldest!</span>
<a href="#l1.171"></a><span id="l1.171">   this._tail = null; // aka newest!</span>
<a href="#l1.172"></a><span id="l1.172">   this._size = 0;</span>
<a href="#l1.173"></a><span id="l1.173">   // let's keep things sane, and simplify our logic a little...</span>
<a href="#l1.174"></a><span id="l1.174">   if (aCacheSize &lt; 32)</span>
<a href="#l1.175"></a><span id="l1.175">     aCacheSize = 32;</span>
<a href="#l1.176"></a><span id="l1.176">   this._maxCacheSize = aCacheSize;</span>
<a href="#l1.177"></a><span id="l1.177" class="difflineat">@@ -431,16 +497,18 @@ GlodaLRUCacheCollection.prototype = new </span>
<a href="#l1.178"></a><span id="l1.178"> GlodaLRUCacheCollection.prototype.add = function cache_add(aItems) {</span>
<a href="#l1.179"></a><span id="l1.179">   for each (let item in aItems) {</span>
<a href="#l1.180"></a><span id="l1.180">     if (item.id in this._idMap) {</span>
<a href="#l1.181"></a><span id="l1.181">       // DEBUGME so, we're dealing with this, but it shouldn't happen.  need</span>
<a href="#l1.182"></a><span id="l1.182">       //  trace-debuggage.</span>
<a href="#l1.183"></a><span id="l1.183">       continue;</span>
<a href="#l1.184"></a><span id="l1.184">     }</span>
<a href="#l1.185"></a><span id="l1.185">     this._idMap[item.id] = item;</span>
<a href="#l1.186"></a><span id="l1.186" class="difflineplus">+    if (this._uniqueValueMap)</span>
<a href="#l1.187"></a><span id="l1.187" class="difflineplus">+      this._uniqueValueMap[item.uniqueValue] = item;</span>
<a href="#l1.188"></a><span id="l1.188">     </span>
<a href="#l1.189"></a><span id="l1.189">     item._lruPrev = this._tail;</span>
<a href="#l1.190"></a><span id="l1.190">     // we do have to make sure that we will set _head the first time we insert</span>
<a href="#l1.191"></a><span id="l1.191">     //  something</span>
<a href="#l1.192"></a><span id="l1.192">     if (this._tail !== null)</span>
<a href="#l1.193"></a><span id="l1.193">       this._tail._lruNext = item;</span>
<a href="#l1.194"></a><span id="l1.194">     else</span>
<a href="#l1.195"></a><span id="l1.195">       this._head = item;</span>
<a href="#l1.196"></a><span id="l1.196" class="difflineat">@@ -458,16 +526,18 @@ GlodaLRUCacheCollection.prototype.add = </span>
<a href="#l1.197"></a><span id="l1.197">     this._head = item._lruNext;</span>
<a href="#l1.198"></a><span id="l1.198">     this._head._lruPrev = null;</span>
<a href="#l1.199"></a><span id="l1.199">     // (because we are nice, we will delete the properties...)</span>
<a href="#l1.200"></a><span id="l1.200">     delete item._lruNext;</span>
<a href="#l1.201"></a><span id="l1.201">     delete item._lruPrev;</span>
<a href="#l1.202"></a><span id="l1.202">     </span>
<a href="#l1.203"></a><span id="l1.203">     // nuke from our id map</span>
<a href="#l1.204"></a><span id="l1.204">     delete this._idMap[item.id];</span>
<a href="#l1.205"></a><span id="l1.205" class="difflineplus">+    if (this._uniqueValueMap)</span>
<a href="#l1.206"></a><span id="l1.206" class="difflineplus">+      delete this._uniqueValueMap[item.uniqueValue];</span>
<a href="#l1.207"></a><span id="l1.207">     </span>
<a href="#l1.208"></a><span id="l1.208">     // flush dirty items to disk (they may not have this attribute, in which</span>
<a href="#l1.209"></a><span id="l1.209">     //  case, this returns false, which is fine.)</span>
<a href="#l1.210"></a><span id="l1.210">     if (item.dirty) {</span>
<a href="#l1.211"></a><span id="l1.211">       this._nounMeta.objUpdate.call(this._nounMeta.datastore, item);</span>
<a href="#l1.212"></a><span id="l1.212">       delete item.dirty;</span>
<a href="#l1.213"></a><span id="l1.213">     }</span>
<a href="#l1.214"></a><span id="l1.214">     </span>
<a href="#l1.215"></a><span id="l1.215" class="difflineat">@@ -510,16 +580,18 @@ GlodaLRUCacheCollection.prototype.delete</span>
<a href="#l1.216"></a><span id="l1.216">     this._tail = aItem._lruPrev;</span>
<a href="#l1.217"></a><span id="l1.217"> </span>
<a href="#l1.218"></a><span id="l1.218">   // (because we are nice, we will delete the properties...)</span>
<a href="#l1.219"></a><span id="l1.219">   delete aItem._lruNext;</span>
<a href="#l1.220"></a><span id="l1.220">   delete aItem._lruPrev;</span>
<a href="#l1.221"></a><span id="l1.221">     </span>
<a href="#l1.222"></a><span id="l1.222">   // nuke from our id map</span>
<a href="#l1.223"></a><span id="l1.223">   delete this._idMap[aItem.id];</span>
<a href="#l1.224"></a><span id="l1.224" class="difflineplus">+  if (this._uniqueValueMap)</span>
<a href="#l1.225"></a><span id="l1.225" class="difflineplus">+    delete this._uniqueValueMap[aItem.uniqueValue];</span>
<a href="#l1.226"></a><span id="l1.226">   </span>
<a href="#l1.227"></a><span id="l1.227">   this._size--;</span>
<a href="#l1.228"></a><span id="l1.228"> }</span>
<a href="#l1.229"></a><span id="l1.229"> </span>
<a href="#l1.230"></a><span id="l1.230"> /**</span>
<a href="#l1.231"></a><span id="l1.231">  * If any of the cached items are dirty, commit them, and make them no longer</span>
<a href="#l1.232"></a><span id="l1.232">  *  dirty.</span>
<a href="#l1.233"></a><span id="l1.233">  */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -462,16 +462,20 @@ GlodaIdentity.prototype = {</span>
<a href="#l2.4"></a><span id="l2.4">   NOUN_ID: 104,</span>
<a href="#l2.5"></a><span id="l2.5">   get id() { return this._id; },</span>
<a href="#l2.6"></a><span id="l2.6">   get contactID() { return this._contactID; }, </span>
<a href="#l2.7"></a><span id="l2.7">   get kind() { return this._kind; },</span>
<a href="#l2.8"></a><span id="l2.8">   get value() { return this._value; },</span>
<a href="#l2.9"></a><span id="l2.9">   get description() { return this._description; },</span>
<a href="#l2.10"></a><span id="l2.10">   get isRelay() { return this._isRelay; },</span>
<a href="#l2.11"></a><span id="l2.11">   </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+  get uniqueValue() {</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+    return this._kind + &quot;@&quot; + this._value;</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+  },</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+  </span>
<a href="#l2.16"></a><span id="l2.16">   get contact() {</span>
<a href="#l2.17"></a><span id="l2.17">     if (this._contact === null)</span>
<a href="#l2.18"></a><span id="l2.18">       this._contact = this._datastore.getContactByID(this._contactID);</span>
<a href="#l2.19"></a><span id="l2.19">     return this._contact;</span>
<a href="#l2.20"></a><span id="l2.20">   },</span>
<a href="#l2.21"></a><span id="l2.21">   </span>
<a href="#l2.22"></a><span id="l2.22">   toString: function gloda_identity_toString() {</span>
<a href="#l2.23"></a><span id="l2.23">     return this._value;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -2045,23 +2045,23 @@ let GlodaDatastore = {</span>
<a href="#l3.4"></a><span id="l3.4">       statement.finalize();</span>
<a href="#l3.5"></a><span id="l3.5">       </span>
<a href="#l3.6"></a><span id="l3.6">       // have the collection manager attempt to replace the instances we just</span>
<a href="#l3.7"></a><span id="l3.7">       //  created with pre-existing instances.  if the instance didn't exist,</span>
<a href="#l3.8"></a><span id="l3.8">       //  cache the newly observed ones.  We are trading off wastes here; we don't</span>
<a href="#l3.9"></a><span id="l3.9">       //  want to have to ask the collection manager about every row, and we don't</span>
<a href="#l3.10"></a><span id="l3.10">       //  want to invent some alternate row storage.</span>
<a href="#l3.11"></a><span id="l3.11">       GlodaCollectionManager.cacheLoadUnify(nounMeta.id, items);</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-      collection = new GlodaCollection(items, aQuery, aListener);</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+      collection = new GlodaCollection(nounMeta, items, aQuery, aListener);</span>
<a href="#l3.14"></a><span id="l3.14">       </span>
<a href="#l3.15"></a><span id="l3.15">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l3.16"></a><span id="l3.16">     }</span>
<a href="#l3.17"></a><span id="l3.17">     else { // async!</span>
<a href="#l3.18"></a><span id="l3.18">       let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l3.19"></a><span id="l3.19" class="difflineminus">-      let collection = new GlodaCollection([], aQuery, aListener);    </span>
<a href="#l3.20"></a><span id="l3.20" class="difflineplus">+      let collection = new GlodaCollection(nounMeta, [], aQuery, aListener);    </span>
<a href="#l3.21"></a><span id="l3.21">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l3.22"></a><span id="l3.22"> </span>
<a href="#l3.23"></a><span id="l3.23">       statement.executeAsync(new QueryFromQueryCallback(statement, nounMeta,</span>
<a href="#l3.24"></a><span id="l3.24">         collection));</span>
<a href="#l3.25"></a><span id="l3.25">       statement.finalize();</span>
<a href="#l3.26"></a><span id="l3.26">     }</span>
<a href="#l3.27"></a><span id="l3.27">     return collection;</span>
<a href="#l3.28"></a><span id="l3.28">   },</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineat">@@ -2276,27 +2276,29 @@ let GlodaDatastore = {</span>
<a href="#l3.30"></a><span id="l3.30">       &quot;SELECT * FROM identities WHERE kind = ?1 AND value = ?2&quot;);</span>
<a href="#l3.31"></a><span id="l3.31">     this.__defineGetter__(&quot;_selectIdentityByKindValueStatement&quot;,</span>
<a href="#l3.32"></a><span id="l3.32">       function() statement);</span>
<a href="#l3.33"></a><span id="l3.33">     return this._selectIdentityByKindValueStatement;</span>
<a href="#l3.34"></a><span id="l3.34">   },</span>
<a href="#l3.35"></a><span id="l3.35"> </span>
<a href="#l3.36"></a><span id="l3.36">   /** Lookup an identity by kind and value.  Ex: (email, foo@bar.com) */</span>
<a href="#l3.37"></a><span id="l3.37">   getIdentity: function gloda_ds_getIdentity(aKind, aValue) {</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineminus">-    let identity = null;</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+    let identity = GlodaCollectionManager.cacheLookupOneByUniqueValue(</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+      GlodaIdentity.prototype.NOUN_ID, aKind + &quot;@&quot; + aValue);</span>
<a href="#l3.41"></a><span id="l3.41">     </span>
<a href="#l3.42"></a><span id="l3.42">     let ibkv = this._selectIdentityByKindValueStatement;</span>
<a href="#l3.43"></a><span id="l3.43">     ibkv.bindStringParameter(0, aKind);</span>
<a href="#l3.44"></a><span id="l3.44">     ibkv.bindStringParameter(1, aValue);</span>
<a href="#l3.45"></a><span id="l3.45">     if (this._syncStep(ibkv)) {</span>
<a href="#l3.46"></a><span id="l3.46">       identity = this._identityFromRow(ibkv);</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineplus">+      GlodaCollectionManager.itemLoaded(identity);</span>
<a href="#l3.48"></a><span id="l3.48">     }</span>
<a href="#l3.49"></a><span id="l3.49">     ibkv.reset();</span>
<a href="#l3.50"></a><span id="l3.50">     </span>
<a href="#l3.51"></a><span id="l3.51" class="difflineminus">-    return identity &amp;&amp; GlodaCollectionManager.cacheLoadUnifyOne(identity);</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+    return identity;</span>
<a href="#l3.53"></a><span id="l3.53">   },</span>
<a href="#l3.54"></a><span id="l3.54"> </span>
<a href="#l3.55"></a><span id="l3.55">   get _selectIdentityByIDStatement() {</span>
<a href="#l3.56"></a><span id="l3.56">     let statement = this._createSyncStatement(</span>
<a href="#l3.57"></a><span id="l3.57">       &quot;SELECT * FROM identities WHERE id = ?1&quot;);</span>
<a href="#l3.58"></a><span id="l3.58">     this.__defineGetter__(&quot;_selectIdentityByIDStatement&quot;,</span>
<a href="#l3.59"></a><span id="l3.59">       function() statement);</span>
<a href="#l3.60"></a><span id="l3.60">     return this._selectIdentityByIDStatement;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -796,16 +796,17 @@ let Gloda = {</span>
<a href="#l4.4"></a><span id="l4.4">         else // assume they're just passing the id directly</span>
<a href="#l4.5"></a><span id="l4.5">           return [null, aContact];</span>
<a href="#l4.6"></a><span id="l4.6">       }}, this.NOUN_CONTACT);</span>
<a href="#l4.7"></a><span id="l4.7">     this.defineNoun({</span>
<a href="#l4.8"></a><span id="l4.8">       name: &quot;identity&quot;,</span>
<a href="#l4.9"></a><span id="l4.9">       class: GlodaIdentity,</span>
<a href="#l4.10"></a><span id="l4.10">       firstClass: false,</span>
<a href="#l4.11"></a><span id="l4.11">       cache: true, cacheCost: 128,</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineplus">+      usesUniqueValue: true,</span>
<a href="#l4.13"></a><span id="l4.13">       tableName: &quot;identities&quot;,</span>
<a href="#l4.14"></a><span id="l4.14">       datastore: GlodaDatastore, objFromRow: GlodaDatastore._identityFromRow,</span>
<a href="#l4.15"></a><span id="l4.15">       fromParamAndValue: function(aParam, aID) {</span>
<a href="#l4.16"></a><span id="l4.16">         return GlodaDatastore.getIdentityByID(aID);</span>
<a href="#l4.17"></a><span id="l4.17">       },</span>
<a href="#l4.18"></a><span id="l4.18">       toParamAndValue: function(aIdentity) {</span>
<a href="#l4.19"></a><span id="l4.19">         if (aIdentity instanceof GlodaIdentity)</span>
<a href="#l4.20"></a><span id="l4.20">           return [null, aIdentity.id];</span>
<a href="#l4.21"></a><span id="l4.21" class="difflineat">@@ -1208,17 +1209,17 @@ let Gloda = {</span>
<a href="#l4.22"></a><span id="l4.22">   </span>
<a href="#l4.23"></a><span id="l4.23">   /**</span>
<a href="#l4.24"></a><span id="l4.24">    * Create a collection/query for the given noun-type that only matches the</span>
<a href="#l4.25"></a><span id="l4.25">    *  provided items.  This is to be used when you have an explicit set of items</span>
<a href="#l4.26"></a><span id="l4.26">    *  that you would still like to receive updates for. </span>
<a href="#l4.27"></a><span id="l4.27">    */</span>
<a href="#l4.28"></a><span id="l4.28">   explicitCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l4.29"></a><span id="l4.29">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l4.30"></a><span id="l4.30" class="difflineminus">-    let collection = new GlodaCollection(aItems, null, null)</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+    let collection = new GlodaCollection(nounMeta, aItems, null, null)</span>
<a href="#l4.32"></a><span id="l4.32">     let query = new nounMeta.explicitQueryClass(collection);</span>
<a href="#l4.33"></a><span id="l4.33">     collection.query = query;</span>
<a href="#l4.34"></a><span id="l4.34">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l4.35"></a><span id="l4.35">     return collection;</span>
<a href="#l4.36"></a><span id="l4.36">   },</span>
<a href="#l4.37"></a><span id="l4.37">   </span>
<a href="#l4.38"></a><span id="l4.38">   /**</span>
<a href="#l4.39"></a><span id="l4.39">    * Debugging 'wildcard' collection creation support.  A wildcard collection</span>
<a href="#l4.40"></a><span id="l4.40" class="difflineat">@@ -1228,17 +1229,17 @@ let Gloda = {</span>
<a href="#l4.41"></a><span id="l4.41">    *  etc.</span>
<a href="#l4.42"></a><span id="l4.42">    * Because the items are added to the collection without limit, this will</span>
<a href="#l4.43"></a><span id="l4.43">    *  result in a leak if you don't do something to clean up after the</span>
<a href="#l4.44"></a><span id="l4.44">    *  collection.  (Forgetting about the collection will suffice, as it is still</span>
<a href="#l4.45"></a><span id="l4.45">    *  weakly held.) </span>
<a href="#l4.46"></a><span id="l4.46">    */</span>
<a href="#l4.47"></a><span id="l4.47">   _wildcardCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l4.48"></a><span id="l4.48">     let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l4.49"></a><span id="l4.49" class="difflineminus">-    let collection = new GlodaCollection(aItems, null, null)</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineplus">+    let collection = new GlodaCollection(nounMeta, aItems, null, null)</span>
<a href="#l4.51"></a><span id="l4.51">     let query = new nounMeta.wildcardQueryClass(collection);</span>
<a href="#l4.52"></a><span id="l4.52">     collection.query = query;</span>
<a href="#l4.53"></a><span id="l4.53">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l4.54"></a><span id="l4.54">     return collection;</span>
<a href="#l4.55"></a><span id="l4.55">   },</span>
<a href="#l4.56"></a><span id="l4.56">   </span>
<a href="#l4.57"></a><span id="l4.57">   /**</span>
<a href="#l4.58"></a><span id="l4.58">    * Process the given GlodaMessage, determining all the attributes it should</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

