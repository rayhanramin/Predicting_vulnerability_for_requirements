<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 7798:e545b6accf995657ca270f4666ae9aebabbc0cf4</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ e545b6accf995657ca270f4666ae9aebabbc0cf4" />
<meta property="og:url" content="/comm-central/rev/e545b6accf995657ca270f4666ae9aebabbc0cf4" />
<meta property="og:description" content="fetch imap hdrs in chunks, newest headers first, r=neil, bug 464126" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / e545b6accf995657ca270f4666ae9aebabbc0cf4 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/e545b6accf995657ca270f4666ae9aebabbc0cf4">shortlog</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/e545b6accf995657ca270f4666ae9aebabbc0cf4">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4">files</a> |
changeset |
<a href="/comm-central/raw-rev/e545b6accf995657ca270f4666ae9aebabbc0cf4">raw</a>  | <a href="/comm-central/archive/e545b6accf995657ca270f4666ae9aebabbc0cf4.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
fetch imap hdrs in chunks, newest headers first, r=neil, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=464126">bug 464126</a>
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#68;&#97;&#118;&#105;&#100;&#32;&#66;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#32;&#60;&#98;&#105;&#101;&#110;&#118;&#101;&#110;&#117;&#64;&#110;&#118;&#101;&#110;&#116;&#117;&#114;&#101;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Sat, 21 May 2011 11:45:03 -0700</td></tr>

<tr>
 <td>changeset 7798</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/e545b6accf995657ca270f4666ae9aebabbc0cf4">e545b6accf995657ca270f4666ae9aebabbc0cf4</a></td>
</tr>



<tr>
<td>parent 7797</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/802908081687e4a188bd331390716b84e8da04a2">802908081687e4a188bd331390716b84e8da04a2</a>
</td>
</tr>

<tr>
<td>child 7799</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/3d6a55d85b66154af903f93858c1036a2d8395f5">3d6a55d85b66154af903f93858c1036a2d8395f5</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=e545b6accf995657ca270f4666ae9aebabbc0cf4">5990</a></td></tr>
<tr><td>push user</td><td>bienvenu@nventure.com</td></tr>
<tr><td>push date</td><td class="date age">Sat, 21 May 2011 18:44:59 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@e545b6accf99 [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=e545b6accf995657ca270f4666ae9aebabbc0cf4">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=e545b6accf995657ca270f4666ae9aebabbc0cf4&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=e545b6accf995657ca270f4666ae9aebabbc0cf4&newProject=comm-central&newRevision=e545b6accf995657ca270f4666ae9aebabbc0cf4&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=e545b6accf995657ca270f4666ae9aebabbc0cf4&newProject=comm-central&newRevision=e545b6accf995657ca270f4666ae9aebabbc0cf4&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=e545b6accf995657ca270f4666ae9aebabbc0cf4&newProject=comm-central&newRevision=e545b6accf995657ca270f4666ae9aebabbc0cf4&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28neil%29&revcount=50">neil</a>, <a href="/comm-central/log?rev=reviewer%28bug%29&revcount=50">bug</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=464126">464126</a></td></tr>




</table></div>

<div class="page_body description">fetch imap hdrs in chunks, newest headers first, r=neil, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=464126">bug 464126</a></div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapMailFolderSink.idl">mailnews/imap/public/nsIImapMailFolderSink.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapMailFolderSink.idl">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapMailFolderSink.idl">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapMailFolderSink.idl">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapMailFolderSink.idl">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapMailFolderSink.idl">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapProtocol.idl">mailnews/imap/public/nsIImapProtocol.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapProtocol.idl">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapProtocol.idl">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapProtocol.idl">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapProtocol.idl">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapProtocol.idl">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapServerSink.idl">mailnews/imap/public/nsIImapServerSink.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapServerSink.idl">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapServerSink.idl">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapServerSink.idl">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapServerSink.idl">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapServerSink.idl">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapUrl.idl">mailnews/imap/public/nsIImapUrl.idl</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapUrl.idl">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapUrl.idl">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapUrl.idl">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapUrl.idl">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/public/nsIImapUrl.idl">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapIncomingServer.cpp">mailnews/imap/src/nsImapIncomingServer.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapIncomingServer.cpp">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapIncomingServer.cpp">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapIncomingServer.cpp">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapIncomingServer.cpp">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapIncomingServer.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.cpp">mailnews/imap/src/nsImapMailFolder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.cpp">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.cpp">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.cpp">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.cpp">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.h">mailnews/imap/src/nsImapMailFolder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.h">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.h">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.h">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.h">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapMailFolder.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.cpp">mailnews/imap/src/nsImapProtocol.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.cpp">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.cpp">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.cpp">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.cpp">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.h">mailnews/imap/src/nsImapProtocol.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.h">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.h">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.h">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.h">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapProtocol.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.cpp">mailnews/imap/src/nsImapUrl.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.cpp">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.cpp">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.cpp">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.cpp">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.h">mailnews/imap/src/nsImapUrl.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.h">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.h">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.h">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.h">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/src/nsImapUrl.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/test_imapHdrChunking.js">mailnews/imap/test/unit/test_imapHdrChunking.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/test_imapHdrChunking.js">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/test_imapHdrChunking.js">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/test_imapHdrChunking.js">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/test_imapHdrChunking.js">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/test_imapHdrChunking.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/xpcshell.ini">mailnews/imap/test/unit/xpcshell.ini</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/xpcshell.ini">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/xpcshell.ini">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/xpcshell.ini">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/xpcshell.ini">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/imap/test/unit/xpcshell.ini">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/mailnews.js">mailnews/mailnews.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/mailnews.js">file</a> |
<a href="/comm-central/annotate/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/mailnews.js">annotate</a> |
<a href="/comm-central/diff/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/mailnews.js">diff</a> |
<a href="/comm-central/comparison/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/mailnews.js">comparison</a> |
<a href="/comm-central/log/e545b6accf995657ca270f4666ae9aebabbc0cf4/mailnews/mailnews.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/imap/public/nsIImapMailFolderSink.idl</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/imap/public/nsIImapMailFolderSink.idl</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -59,17 +59,17 @@ interface ImapOnlineCopyStateType</span>
<a href="#l1.4"></a><span id="l1.4">    const long kFailedDelete = 4;</span>
<a href="#l1.5"></a><span id="l1.5">    const long kReadyForAppendData = 5;</span>
<a href="#l1.6"></a><span id="l1.6">    const long kFailedAppend = 6;</span>
<a href="#l1.7"></a><span id="l1.7">    const long kInterruptedState = 7;</span>
<a href="#l1.8"></a><span id="l1.8">    const long kFailedCopy = 8;</span>
<a href="#l1.9"></a><span id="l1.9">    const long kFailedMove = 9;</span>
<a href="#l1.10"></a><span id="l1.10"> };</span>
<a href="#l1.11"></a><span id="l1.11"> </span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-[scriptable, uuid(531d4a3a-4921-4b7d-a46d-c66be8bec781)]</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+[scriptable, uuid(e16c3399-285a-4e1b-8940-c3352200aa9c)]</span>
<a href="#l1.14"></a><span id="l1.14"> interface nsIImapMailFolderSink : nsISupports {</span>
<a href="#l1.15"></a><span id="l1.15">   attribute boolean folderNeedsACLListed;</span>
<a href="#l1.16"></a><span id="l1.16">   attribute boolean folderNeedsSubscribing;</span>
<a href="#l1.17"></a><span id="l1.17">   attribute boolean folderNeedsAdded;</span>
<a href="#l1.18"></a><span id="l1.18">   attribute unsigned long aclFlags;</span>
<a href="#l1.19"></a><span id="l1.19">   attribute long uidValidity;</span>
<a href="#l1.20"></a><span id="l1.20">   /**</span>
<a href="#l1.21"></a><span id="l1.21">    * Whether we have asked the server for this folder's quota information.</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineat">@@ -82,36 +82,49 @@ interface nsIImapMailFolderSink : nsISup</span>
<a href="#l1.23"></a><span id="l1.23">    * @param aFolderQuotaRoot    The IMAP quota root for this folder, </span>
<a href="#l1.24"></a><span id="l1.24">    *                            as returned by the GETQUOTAROOT IMAP command.</span>
<a href="#l1.25"></a><span id="l1.25">    * @param aFolderQuotaUsedKB  Used space, in KB, on this folder's quota root.</span>
<a href="#l1.26"></a><span id="l1.26">    * @param aFolderQuotaMaxKB   Size, in KB, of this folder's quota root.</span>
<a href="#l1.27"></a><span id="l1.27">    **/</span>
<a href="#l1.28"></a><span id="l1.28">   void setFolderQuotaData(in ACString aFolderQuotaRoot, in unsigned long aFolderQuotaUsedKB, </span>
<a href="#l1.29"></a><span id="l1.29">                           in unsigned long aFolderQuotaMaxKB);</span>
<a href="#l1.30"></a><span id="l1.30"> </span>
<a href="#l1.31"></a><span id="l1.31" class="difflineplus">+  /// Should we download all the rfc822 headers of messages, instead of subset.</span>
<a href="#l1.32"></a><span id="l1.32">   readonly attribute boolean shouldDownloadAllHeaders;</span>
<a href="#l1.33"></a><span id="l1.33">   string GetOnlineDelimiter();</span>
<a href="#l1.34"></a><span id="l1.34">   void OnNewIdleMessages();</span>
<a href="#l1.35"></a><span id="l1.35">   // Tell mail master about the newly selected mailbox</span>
<a href="#l1.36"></a><span id="l1.36">   void UpdateImapMailboxInfo(in nsIImapProtocol aProtocol,</span>
<a href="#l1.37"></a><span id="l1.37" class="difflineminus">-                                   in nsIMailboxSpec aSpec);</span>
<a href="#l1.38"></a><span id="l1.38" class="difflineplus">+                             in nsIMailboxSpec aSpec);</span>
<a href="#l1.39"></a><span id="l1.39">   void UpdateImapMailboxStatus(in nsIImapProtocol aProtocol,</span>
<a href="#l1.40"></a><span id="l1.40" class="difflineminus">-                                     in nsIMailboxSpec aSpec);</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineplus">+                               in nsIMailboxSpec aSpec);</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+  /**</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+   * Used when downloading headers in chunks.</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+   * @param aSpec Mailbox spec of folder we're downloading headers for.</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineplus">+   * @returns true if more to download, false otherwise.</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+   * @returns total count of headers to download (across all chunks)</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+   * @returns an array of msg keys to download, array size is this chunk's size</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+   */</span>
<a href="#l1.49"></a><span id="l1.49" class="difflineplus">+  void getMsgHdrsToDownload(out boolean aMore, out long aTotalCount,</span>
<a href="#l1.50"></a><span id="l1.50" class="difflineplus">+                            out unsigned long aCount,</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineplus">+                            [retval, array, size_is(aCount)] out nsMsgKey aKeys);</span>
<a href="#l1.52"></a><span id="l1.52">   void parseMsgHdrs(in nsIImapProtocol aProtocol, in nsIImapHeaderXferInfo aHdrXferInfo);</span>
<a href="#l1.53"></a><span id="l1.53">   void AbortHeaderParseStream(in nsIImapProtocol aProtocol) ;</span>
<a href="#l1.54"></a><span id="l1.54">   </span>
<a href="#l1.55"></a><span id="l1.55">   void OnlineCopyCompleted(in nsIImapProtocol aProtocol, in ImapOnlineCopyState aCopyState);</span>
<a href="#l1.56"></a><span id="l1.56">   void StartMessage(in nsIMsgMailNewsUrl aUrl);</span>
<a href="#l1.57"></a><span id="l1.57">   void EndMessage(in nsIMsgMailNewsUrl aUrl, in nsMsgKey uidOfMessage);</span>
<a href="#l1.58"></a><span id="l1.58"> </span>
<a href="#l1.59"></a><span id="l1.59">   void NotifySearchHit(in nsIMsgMailNewsUrl aUrl, in string hitLine);</span>
<a href="#l1.60"></a><span id="l1.60"> </span>
<a href="#l1.61"></a><span id="l1.61">   void copyNextStreamMessage(in boolean copySucceeded, in nsISupports copyState);</span>
<a href="#l1.62"></a><span id="l1.62">   void closeMockChannel(in nsIImapMockChannel aChannel);</span>
<a href="#l1.63"></a><span id="l1.63" class="difflineminus">-  void setUrlState(in nsIImapProtocol aProtocol, in nsIMsgMailNewsUrl aUrl, in boolean isRunning, in nsresult status);</span>
<a href="#l1.64"></a><span id="l1.64" class="difflineplus">+  void setUrlState(in nsIImapProtocol aProtocol, in nsIMsgMailNewsUrl aUrl,</span>
<a href="#l1.65"></a><span id="l1.65" class="difflineplus">+                   in boolean isRunning, in boolean aSuspend,</span>
<a href="#l1.66"></a><span id="l1.66" class="difflineplus">+                   in nsresult status);</span>
<a href="#l1.67"></a><span id="l1.67">   void releaseUrlCacheEntry(in nsIMsgMailNewsUrl aUrl);</span>
<a href="#l1.68"></a><span id="l1.68"> </span>
<a href="#l1.69"></a><span id="l1.69">   void headerFetchCompleted(in nsIImapProtocol aProtocol);</span>
<a href="#l1.70"></a><span id="l1.70">   void setBiffStateAndUpdate(in long biffState);</span>
<a href="#l1.71"></a><span id="l1.71">   void progressStatus(in nsIImapProtocol aProtocol, in unsigned long aMsgId, in wstring extraInfo);</span>
<a href="#l1.72"></a><span id="l1.72">   void percentProgress(in nsIImapProtocol aProtocol, in wstring aMessage, </span>
<a href="#l1.73"></a><span id="l1.73">                        in long long aCurrentProgress, in long long aMaxProgressProgressInfo);</span>
<a href="#l1.74"></a><span id="l1.74"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/imap/public/nsIImapProtocol.idl</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/imap/public/nsIImapProtocol.idl</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -43,17 +43,17 @@ interface nsIURI;</span>
<a href="#l2.4"></a><span id="l2.4"> interface nsIImapUrl;</span>
<a href="#l2.5"></a><span id="l2.5"> interface nsIEventTarget;</span>
<a href="#l2.6"></a><span id="l2.6"> interface nsIImapProtocol;</span>
<a href="#l2.7"></a><span id="l2.7"> interface nsIImapIncomingServer;</span>
<a href="#l2.8"></a><span id="l2.8"> interface nsIMsgFolder;</span>
<a href="#l2.9"></a><span id="l2.9"> interface nsIImapHostSessionList;</span>
<a href="#l2.10"></a><span id="l2.10"> interface nsIMsgWindow;</span>
<a href="#l2.11"></a><span id="l2.11"> </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-[scriptable, uuid(49816377-9319-48f8-8c90-7efadff8e628)]</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+[scriptable, uuid(1c3bbfa9-69f7-4716-8986-2dba10cefb09)]</span>
<a href="#l2.14"></a><span id="l2.14"> interface nsIImapProtocol : nsISupports {</span>
<a href="#l2.15"></a><span id="l2.15">   void LoadImapUrl(in nsIURI aUrl, in nsISupports aConsumer);</span>
<a href="#l2.16"></a><span id="l2.16"> </span>
<a href="#l2.17"></a><span id="l2.17">   /**</span>
<a href="#l2.18"></a><span id="l2.18">    * IsBusy returns true if the connection is currently processing a url</span>
<a href="#l2.19"></a><span id="l2.19">    * and false otherwise.</span>
<a href="#l2.20"></a><span id="l2.20">    */</span>
<a href="#l2.21"></a><span id="l2.21">   void IsBusy(out boolean aIsConnectionBusy,</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -71,17 +71,16 @@ interface nsIImapProtocol : nsISupports </span>
<a href="#l2.23"></a><span id="l2.23">   /**</span>
<a href="#l2.24"></a><span id="l2.24">    * Right now, initialize requires the event queue of the UI thread,</span>
<a href="#l2.25"></a><span id="l2.25">    * or more importantly the event queue of the consumer of the imap</span>
<a href="#l2.26"></a><span id="l2.26">    * protocol data. The protocol also needs a host session list.</span>
<a href="#l2.27"></a><span id="l2.27">    */</span>
<a href="#l2.28"></a><span id="l2.28">   void Initialize(in nsIImapHostSessionList aHostSessionList, in nsIImapIncomingServer aServer,</span>
<a href="#l2.29"></a><span id="l2.29">                   in nsIEventTarget aSinkEventTarget);</span>
<a href="#l2.30"></a><span id="l2.30"> </span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-  void NotifyHdrsToDownload(out unsigned long keys, in unsigned long keyCount);</span>
<a href="#l2.32"></a><span id="l2.32">   void NotifyBodysToDownload(out unsigned long keys, in unsigned long count);</span>
<a href="#l2.33"></a><span id="l2.33">   // methods to get data from the imap parser flag state.</span>
<a href="#l2.34"></a><span id="l2.34">   void GetFlagsForUID(in unsigned long uid, out boolean foundIt, out unsigned short flags, out string customFlags);</span>
<a href="#l2.35"></a><span id="l2.35">   void GetSupportedUserFlags(out unsigned short flags);</span>
<a href="#l2.36"></a><span id="l2.36"> </span>
<a href="#l2.37"></a><span id="l2.37">   void GetRunningImapURL(out nsIImapUrl aImapUrl);</span>
<a href="#l2.38"></a><span id="l2.38"> </span>
<a href="#l2.39"></a><span id="l2.39">   void GetRunningUrl(out nsIURI aUrl);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/imap/public/nsIImapServerSink.idl</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/imap/public/nsIImapServerSink.idl</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -43,17 +43,17 @@ interface nsIMsgMailNewsUrl;</span>
<a href="#l3.4"></a><span id="l3.4"> interface nsIImapProtocol;</span>
<a href="#l3.5"></a><span id="l3.5"> interface nsIImapUrl;</span>
<a href="#l3.6"></a><span id="l3.6"> interface nsIImapMockChannel;</span>
<a href="#l3.7"></a><span id="l3.7"> </span>
<a href="#l3.8"></a><span id="l3.8"> /**</span>
<a href="#l3.9"></a><span id="l3.9">  * nsIImapServerSink is designed to be used as a proxy to the application's UI</span>
<a href="#l3.10"></a><span id="l3.10">  * thread from the running IMAP threads.</span>
<a href="#l3.11"></a><span id="l3.11">  */</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-[scriptable, uuid(596cbacd-53d2-468e-9ea3-fe2512cb3997)]</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+[scriptable, uuid(24136ca7-0000-4731-8d5f-fc0908aa7c75)]</span>
<a href="#l3.14"></a><span id="l3.14"> interface nsIImapServerSink : nsISupports {</span>
<a href="#l3.15"></a><span id="l3.15">   /**</span>
<a href="#l3.16"></a><span id="l3.16">    * Check if the given folder path is a possible IMAP mailbox.</span>
<a href="#l3.17"></a><span id="l3.17">    * @param folderPath folder path to check</span>
<a href="#l3.18"></a><span id="l3.18">    * @param hierarchyDelimiter IMAP hierarchy delimiter in canonical format,</span>
<a href="#l3.19"></a><span id="l3.19">    *                           i.e., hierarchy delimiter has been replaced</span>
<a href="#l3.20"></a><span id="l3.20">    *                           with '/'</span>
<a href="#l3.21"></a><span id="l3.21">    * @param boxFlags IMAP folder flags (for subscription, namespaces etc.)</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineat">@@ -81,16 +81,25 @@ interface nsIImapServerSink : nsISupport</span>
<a href="#l3.23"></a><span id="l3.23">    * Prepare to retry the given URL.</span>
<a href="#l3.24"></a><span id="l3.24">    * @param imapUrl the url we're going to retry</span>
<a href="#l3.25"></a><span id="l3.25">    * @return channel to associate with the url. We return this because access</span>
<a href="#l3.26"></a><span id="l3.26">    *         to the channel should only happen on the ui thread.</span>
<a href="#l3.27"></a><span id="l3.27">    */</span>
<a href="#l3.28"></a><span id="l3.28">   nsIImapMockChannel prepareToRetryUrl(in nsIImapUrl imapUrl);</span>
<a href="#l3.29"></a><span id="l3.29"> </span>
<a href="#l3.30"></a><span id="l3.30">   /**</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+   * Suspend the url. This puts it at the end of the queue. If the queue is</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+   * empty, the url will get resumed immediately. Currently, the plan is</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineplus">+   * do this when we have to download a lot of headers in chunks, though we</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineplus">+   * could find other uses for it.</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineplus">+   * @param imapUrl url to suspend</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineplus">+   */</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineplus">+  void suspendUrl(in nsIImapUrl aImapUrl);</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+  /**</span>
<a href="#l3.40"></a><span id="l3.40">    * Retry the given URL.</span>
<a href="#l3.41"></a><span id="l3.41">    * @param imapUrl url to retry</span>
<a href="#l3.42"></a><span id="l3.42">    * @param channel the channel to associate with the url</span>
<a href="#l3.43"></a><span id="l3.43">    */</span>
<a href="#l3.44"></a><span id="l3.44">   void retryUrl(in nsIImapUrl imapUrl, in nsIImapMockChannel channel);</span>
<a href="#l3.45"></a><span id="l3.45"> </span>
<a href="#l3.46"></a><span id="l3.46">   /**</span>
<a href="#l3.47"></a><span id="l3.47">    * If previous URL failed, this gives server chance to abort URLs with same</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/mailnews/imap/public/nsIImapUrl.idl</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/mailnews/imap/public/nsIImapUrl.idl</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -55,17 +55,17 @@ typedef long nsImapContentModifiedType;</span>
<a href="#l4.4"></a><span id="l4.4"> interface nsImapContentModifiedTypes</span>
<a href="#l4.5"></a><span id="l4.5"> {</span>
<a href="#l4.6"></a><span id="l4.6">   const long IMAP_CONTENT_NOT_MODIFIED = 0;</span>
<a href="#l4.7"></a><span id="l4.7">   const long IMAP_CONTENT_MODIFIED_VIEW_INLINE = 1;</span>
<a href="#l4.8"></a><span id="l4.8">   const long IMAP_CONTENT_MODIFIED_VIEW_AS_LINKS = 2;</span>
<a href="#l4.9"></a><span id="l4.9">   const long IMAP_CONTENT_FORCE_CONTENT_NOT_MODIFIED = 3;</span>
<a href="#l4.10"></a><span id="l4.10"> } ;</span>
<a href="#l4.11"></a><span id="l4.11"> </span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-[scriptable, uuid(efd92a5f-a4fe-4093-ac9c-d23fae3950cd)]</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+[scriptable, uuid(fe2a8f9e-2886-4146-9896-27fff660c69f)]</span>
<a href="#l4.14"></a><span id="l4.14"> interface nsIImapUrl : nsISupports</span>
<a href="#l4.15"></a><span id="l4.15"> {</span>
<a href="#l4.16"></a><span id="l4.16">   ///////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.17"></a><span id="l4.17">   // Getters and Setters for the imap specific event sinks to bind to to the url</span>
<a href="#l4.18"></a><span id="l4.18">   ///////////////////////////////////////////////////////////////////////////////</span>
<a href="#l4.19"></a><span id="l4.19">   attribute nsIImapMailFolderSink imapMailFolderSink;</span>
<a href="#l4.20"></a><span id="l4.20">   attribute nsIImapMessageSink imapMessageSink;</span>
<a href="#l4.21"></a><span id="l4.21">   attribute nsIImapServerSink imapServerSink;</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineat">@@ -126,16 +126,24 @@ interface nsIImapUrl : nsISupports</span>
<a href="#l4.23"></a><span id="l4.23">    * this to true. Currently, nsIMsgMessageService.streamMessage does this.</span>
<a href="#l4.24"></a><span id="l4.24">    */</span>
<a href="#l4.25"></a><span id="l4.25">   attribute boolean localFetchOnly;</span>
<a href="#l4.26"></a><span id="l4.26"> </span>
<a href="#l4.27"></a><span id="l4.27">   /// Server disconnected first time so we're retrying.</span>
<a href="#l4.28"></a><span id="l4.28">   attribute boolean rerunningUrl;</span>
<a href="#l4.29"></a><span id="l4.29"> </span>
<a href="#l4.30"></a><span id="l4.30">   /**</span>
<a href="#l4.31"></a><span id="l4.31" class="difflineplus">+   * Do we have more headers to download? This is set when we decide to</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineplus">+   * download newest headers first, followed by older headers in a subsequent</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+   * run of the url, which allows other urls to run against the folder in the</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+   * meantime.</span>
<a href="#l4.35"></a><span id="l4.35" class="difflineplus">+   */</span>
<a href="#l4.36"></a><span id="l4.36" class="difflineplus">+  attribute boolean moreHeadersToDownload;</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineplus">+</span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+  /**</span>
<a href="#l4.39"></a><span id="l4.39">    * @{</span>
<a href="#l4.40"></a><span id="l4.40">    * This is used to tell the runner of the url more about the status of</span>
<a href="#l4.41"></a><span id="l4.41">    * the command, beyond whether it was successful or not. For example,</span>
<a href="#l4.42"></a><span id="l4.42">    * subtracting flags from a UID that doesn't exist isn't an error</span>
<a href="#l4.43"></a><span id="l4.43">    * (the server returns OK), but the backend code may want to know about it.</span>
<a href="#l4.44"></a><span id="l4.44">    */</span>
<a href="#l4.45"></a><span id="l4.45">   attribute long extraStatus;</span>
<a href="#l4.46"></a><span id="l4.46"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapIncomingServer.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -461,16 +461,28 @@ nsImapIncomingServer::PrepareToRetryUrl(</span>
<a href="#l5.4"></a><span id="l5.4"> {</span>
<a href="#l5.5"></a><span id="l5.5">   NS_ENSURE_ARG_POINTER(aChannel);</span>
<a href="#l5.6"></a><span id="l5.6">   NS_ENSURE_ARG_POINTER(aImapUrl);</span>
<a href="#l5.7"></a><span id="l5.7">   // maybe there's more we could do here, but this is all we need now.</span>
<a href="#l5.8"></a><span id="l5.8">   return aImapUrl-&gt;GetMockChannel(aChannel);</span>
<a href="#l5.9"></a><span id="l5.9"> }</span>
<a href="#l5.10"></a><span id="l5.10"> </span>
<a href="#l5.11"></a><span id="l5.11"> NS_IMETHODIMP</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineplus">+nsImapIncomingServer::SuspendUrl(nsIImapUrl *aImapUrl)</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+{</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aImapUrl);</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+  nsImapProtocol::LogImapUrl(&quot;suspending url&quot;, aImapUrl);</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+  PR_CEnterMonitor(this);</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+  m_urlQueue.AppendObject(aImapUrl);</span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+  m_urlConsumers.AppendElement(nsnull);</span>
<a href="#l5.19"></a><span id="l5.19" class="difflineplus">+  PR_CExitMonitor(this);</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineplus">+  return NS_OK;</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineplus">+}</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineplus">+</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l5.24"></a><span id="l5.24"> nsImapIncomingServer::RetryUrl(nsIImapUrl *aImapUrl, nsIImapMockChannel *aChannel)</span>
<a href="#l5.25"></a><span id="l5.25"> {</span>
<a href="#l5.26"></a><span id="l5.26">   nsresult rv;</span>
<a href="#l5.27"></a><span id="l5.27">   // Get current thread envent queue</span>
<a href="#l5.28"></a><span id="l5.28">   aImapUrl-&gt;SetMockChannel(aChannel);</span>
<a href="#l5.29"></a><span id="l5.29">   nsCOMPtr &lt;nsIImapProtocol&gt; protocolInstance;</span>
<a href="#l5.30"></a><span id="l5.30">   nsImapProtocol::LogImapUrl(&quot;creating protocol instance to retry queued url&quot;, aImapUrl);</span>
<a href="#l5.31"></a><span id="l5.31">   nsCOMPtr&lt;nsIThread&gt; thread(do_GetCurrentThread());</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.cpp</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -2706,17 +2706,16 @@ NS_IMETHODIMP nsImapMailFolder::UpdateIm</span>
<a href="#l6.4"></a><span id="l6.4">   if (!mDatabase)</span>
<a href="#l6.5"></a><span id="l6.5">     GetDatabase();</span>
<a href="#l6.6"></a><span id="l6.6"> </span>
<a href="#l6.7"></a><span id="l6.7">   PRBool folderSelected;</span>
<a href="#l6.8"></a><span id="l6.8">   rv = aSpec-&gt;GetFolderSelected(&amp;folderSelected);</span>
<a href="#l6.9"></a><span id="l6.9">   NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l6.10"></a><span id="l6.10">   nsTArray&lt;nsMsgKey&gt; existingKeys;</span>
<a href="#l6.11"></a><span id="l6.11">   nsTArray&lt;nsMsgKey&gt; keysToDelete;</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-  nsTArray&lt;nsMsgKey&gt; keysToFetch;</span>
<a href="#l6.13"></a><span id="l6.13">   PRUint32 numNewUnread;</span>
<a href="#l6.14"></a><span id="l6.14">   nsCOMPtr&lt;nsIDBFolderInfo&gt; dbFolderInfo;</span>
<a href="#l6.15"></a><span id="l6.15">   PRInt32 imapUIDValidity = 0;</span>
<a href="#l6.16"></a><span id="l6.16">   if (mDatabase)</span>
<a href="#l6.17"></a><span id="l6.17">   {</span>
<a href="#l6.18"></a><span id="l6.18">     rv = mDatabase-&gt;GetDBFolderInfo(getter_AddRefs(dbFolderInfo));</span>
<a href="#l6.19"></a><span id="l6.19">     if (NS_SUCCEEDED(rv) &amp;&amp; dbFolderInfo)</span>
<a href="#l6.20"></a><span id="l6.20">     {</span>
<a href="#l6.21"></a><span id="l6.21" class="difflineat">@@ -2822,33 +2821,34 @@ NS_IMETHODIMP nsImapMailFolder::UpdateIm</span>
<a href="#l6.22"></a><span id="l6.22">     // delete all my msgs, the keys are bogus now</span>
<a href="#l6.23"></a><span id="l6.23">     // add every message in this folder</span>
<a href="#l6.24"></a><span id="l6.24">     existingKeys.Clear();</span>
<a href="#l6.25"></a><span id="l6.25">     //      keysToDelete.CopyArray(&amp;existingKeys);</span>
<a href="#l6.26"></a><span id="l6.26"> </span>
<a href="#l6.27"></a><span id="l6.27">     if (flagState)</span>
<a href="#l6.28"></a><span id="l6.28">     {</span>
<a href="#l6.29"></a><span id="l6.29">       nsTArray&lt;nsMsgKey&gt; no_existingKeys;</span>
<a href="#l6.30"></a><span id="l6.30" class="difflineminus">-      FindKeysToAdd(no_existingKeys, keysToFetch, numNewUnread, flagState);</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineplus">+      FindKeysToAdd(no_existingKeys, m_keysToFetch, numNewUnread, flagState);</span>
<a href="#l6.32"></a><span id="l6.32">     }</span>
<a href="#l6.33"></a><span id="l6.33">     if (NS_FAILED(rv))</span>
<a href="#l6.34"></a><span id="l6.34">       pathFile-&gt;Remove(PR_FALSE);</span>
<a href="#l6.35"></a><span id="l6.35"> </span>
<a href="#l6.36"></a><span id="l6.36">   }</span>
<a href="#l6.37"></a><span id="l6.37">   else if (!flagState /*&amp;&amp; !NET_IsOffline() */) // if there are no messages on the server</span>
<a href="#l6.38"></a><span id="l6.38">     keysToDelete = existingKeys;</span>
<a href="#l6.39"></a><span id="l6.39">   else /* if ( !NET_IsOffline()) */</span>
<a href="#l6.40"></a><span id="l6.40">   {</span>
<a href="#l6.41"></a><span id="l6.41">     PRUint32 boxFlags;</span>
<a href="#l6.42"></a><span id="l6.42">     aSpec-&gt;GetBox_flags(&amp;boxFlags);</span>
<a href="#l6.43"></a><span id="l6.43">     FindKeysToDelete(existingKeys, keysToDelete, flagState, boxFlags);</span>
<a href="#l6.44"></a><span id="l6.44">     // if this is the result of an expunge then don't grab headers</span>
<a href="#l6.45"></a><span id="l6.45">     if (!(boxFlags &amp; kJustExpunged))</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineminus">-      FindKeysToAdd(existingKeys, keysToFetch, numNewUnread, flagState);</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineminus">-  }</span>
<a href="#l6.48"></a><span id="l6.48" class="difflineplus">+      FindKeysToAdd(existingKeys, m_keysToFetch, numNewUnread, flagState);</span>
<a href="#l6.49"></a><span id="l6.49" class="difflineplus">+  }</span>
<a href="#l6.50"></a><span id="l6.50" class="difflineplus">+  m_totalKeysToFetch = m_keysToFetch.Length();</span>
<a href="#l6.51"></a><span id="l6.51">   if (!keysToDelete.IsEmpty() &amp;&amp; mDatabase)</span>
<a href="#l6.52"></a><span id="l6.52">   {</span>
<a href="#l6.53"></a><span id="l6.53">     nsCOMPtr&lt;nsIMutableArray&gt; hdrsToDelete(do_CreateInstance(NS_ARRAY_CONTRACTID));</span>
<a href="#l6.54"></a><span id="l6.54">     MsgGetHeadersFromKeys(mDatabase, keysToDelete, hdrsToDelete);</span>
<a href="#l6.55"></a><span id="l6.55">     // Notify nsIMsgFolderListeners of a mass delete, but only if we actually have headers</span>
<a href="#l6.56"></a><span id="l6.56">     PRUint32 numHdrs;</span>
<a href="#l6.57"></a><span id="l6.57">     hdrsToDelete-&gt;GetLength(&amp;numHdrs);</span>
<a href="#l6.58"></a><span id="l6.58">     if (numHdrs)</span>
<a href="#l6.59"></a><span id="l6.59" class="difflineat">@@ -2877,26 +2877,23 @@ NS_IMETHODIMP nsImapMailFolder::UpdateIm</span>
<a href="#l6.60"></a><span id="l6.60">     // We must ensure that the server knows that we are performing biff.</span>
<a href="#l6.61"></a><span id="l6.61">     // Otherwise the stand-alone biff won't fire.</span>
<a href="#l6.62"></a><span id="l6.62">     nsCOMPtr&lt;nsIMsgIncomingServer&gt; server;</span>
<a href="#l6.63"></a><span id="l6.63">     if (NS_SUCCEEDED(GetServer(getter_AddRefs(server))) &amp;&amp; server)</span>
<a href="#l6.64"></a><span id="l6.64">       server-&gt;SetPerformingBiff(PR_TRUE);</span>
<a href="#l6.65"></a><span id="l6.65">      SetNumNewMessages(numNewUnread);</span>
<a href="#l6.66"></a><span id="l6.66">   }</span>
<a href="#l6.67"></a><span id="l6.67">   SyncFlags(flagState);</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineminus">-  if (mDatabase &amp;&amp; mNumUnreadMessages + keysToFetch.Length() &gt; numUnreadFromServer)</span>
<a href="#l6.69"></a><span id="l6.69" class="difflineplus">+  if (mDatabase &amp;&amp; mNumUnreadMessages + m_keysToFetch.Length() &gt; numUnreadFromServer)</span>
<a href="#l6.70"></a><span id="l6.70">     mDatabase-&gt;SyncCounts();</span>
<a href="#l6.71"></a><span id="l6.71"> </span>
<a href="#l6.72"></a><span id="l6.72" class="difflineminus">-  if (!keysToFetch.IsEmpty())</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineminus">-    PrepareToAddHeadersToMailDB(aProtocol, keysToFetch, aSpec);</span>
<a href="#l6.74"></a><span id="l6.74" class="difflineplus">+  if (!m_keysToFetch.IsEmpty() &amp;&amp; aProtocol)</span>
<a href="#l6.75"></a><span id="l6.75" class="difflineplus">+    PrepareToAddHeadersToMailDB(aProtocol);</span>
<a href="#l6.76"></a><span id="l6.76">   else</span>
<a href="#l6.77"></a><span id="l6.77">   {</span>
<a href="#l6.78"></a><span id="l6.78" class="difflineminus">-    // let the imap libnet module know that we don't need headers</span>
<a href="#l6.79"></a><span id="l6.79" class="difflineminus">-    if (aProtocol)</span>
<a href="#l6.80"></a><span id="l6.80" class="difflineminus">-      aProtocol-&gt;NotifyHdrsToDownload(nsnull, 0);</span>
<a href="#l6.81"></a><span id="l6.81">     PRBool gettingNewMessages;</span>
<a href="#l6.82"></a><span id="l6.82">     GetGettingNewMessages(&amp;gettingNewMessages);</span>
<a href="#l6.83"></a><span id="l6.83">     if (gettingNewMessages)</span>
<a href="#l6.84"></a><span id="l6.84">       ProgressStatus(aProtocol, IMAP_NO_NEW_MESSAGES, nsnull);</span>
<a href="#l6.85"></a><span id="l6.85">     SetPerformingBiff(PR_FALSE);</span>
<a href="#l6.86"></a><span id="l6.86">   }</span>
<a href="#l6.87"></a><span id="l6.87">   aSpec-&gt;GetNumMessages(&amp;m_numServerTotalMessages);</span>
<a href="#l6.88"></a><span id="l6.88">   aSpec-&gt;GetNumUnseenMessages(&amp;m_numServerUnseenMessages);</span>
<a href="#l6.89"></a><span id="l6.89" class="difflineat">@@ -4347,35 +4344,73 @@ void nsImapMailFolder::FindKeysToAdd(con</span>
<a href="#l6.90"></a><span id="l6.90">         keysToFetch.AppendElement(uidOfMessage);</span>
<a href="#l6.91"></a><span id="l6.91">         if (! (flags &amp; kImapMsgSeenFlag))</span>
<a href="#l6.92"></a><span id="l6.92">           numNewUnread++;</span>
<a href="#l6.93"></a><span id="l6.93">       }</span>
<a href="#l6.94"></a><span id="l6.94">     }</span>
<a href="#l6.95"></a><span id="l6.95">   }</span>
<a href="#l6.96"></a><span id="l6.96"> }</span>
<a href="#l6.97"></a><span id="l6.97"> </span>
<a href="#l6.98"></a><span id="l6.98" class="difflineminus">-void nsImapMailFolder::PrepareToAddHeadersToMailDB(nsIImapProtocol* aProtocol, const nsTArray&lt;nsMsgKey&gt; &amp;keysToFetch,</span>
<a href="#l6.99"></a><span id="l6.99" class="difflineminus">-                                                nsIMailboxSpec *boxSpec)</span>
<a href="#l6.100"></a><span id="l6.100" class="difflineminus">-{</span>
<a href="#l6.101"></a><span id="l6.101" class="difflineminus">-  PRUint32 *theKeys = (PRUint32 *) PR_Malloc( keysToFetch.Length() * sizeof(PRUint32) );</span>
<a href="#l6.102"></a><span id="l6.102" class="difflineminus">-  if (theKeys)</span>
<a href="#l6.103"></a><span id="l6.103" class="difflineminus">-  {</span>
<a href="#l6.104"></a><span id="l6.104" class="difflineminus">-    PRUint32 total = keysToFetch.Length();</span>
<a href="#l6.105"></a><span id="l6.105" class="difflineminus">-    for (PRUint32 keyIndex=0; keyIndex &lt; total; keyIndex++)</span>
<a href="#l6.106"></a><span id="l6.106" class="difflineminus">-      theKeys[keyIndex] = keysToFetch[keyIndex];</span>
<a href="#l6.107"></a><span id="l6.107" class="difflineminus">-    // tell the imap thread which hdrs to download</span>
<a href="#l6.108"></a><span id="l6.108" class="difflineminus">-    if (aProtocol)</span>
<a href="#l6.109"></a><span id="l6.109" class="difflineminus">-    {</span>
<a href="#l6.110"></a><span id="l6.110" class="difflineminus">-      aProtocol-&gt;NotifyHdrsToDownload(theKeys, total /*keysToFetch.Length() */);</span>
<a href="#l6.111"></a><span id="l6.111" class="difflineminus">-      // now, tell it we don't need any bodies.</span>
<a href="#l6.112"></a><span id="l6.112" class="difflineminus">-      aProtocol-&gt;NotifyBodysToDownload(nsnull, 0);</span>
<a href="#l6.113"></a><span id="l6.113" class="difflineminus">-    }</span>
<a href="#l6.114"></a><span id="l6.114" class="difflineminus">-  }</span>
<a href="#l6.115"></a><span id="l6.115" class="difflineminus">-  else if (aProtocol)</span>
<a href="#l6.116"></a><span id="l6.116" class="difflineminus">-    aProtocol-&gt;NotifyHdrsToDownload(nsnull, 0);</span>
<a href="#l6.117"></a><span id="l6.117" class="difflineplus">+NS_IMETHODIMP nsImapMailFolder::GetMsgHdrsToDownload(PRBool *aMoreToDownload,</span>
<a href="#l6.118"></a><span id="l6.118" class="difflineplus">+                                                     PRInt32 *aTotalCount,</span>
<a href="#l6.119"></a><span id="l6.119" class="difflineplus">+                                                     PRUint32 *aLength,</span>
<a href="#l6.120"></a><span id="l6.120" class="difflineplus">+                                                     nsMsgKey **aKeys)</span>
<a href="#l6.121"></a><span id="l6.121" class="difflineplus">+{</span>
<a href="#l6.122"></a><span id="l6.122" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aMoreToDownload);</span>
<a href="#l6.123"></a><span id="l6.123" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aTotalCount);</span>
<a href="#l6.124"></a><span id="l6.124" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aLength);</span>
<a href="#l6.125"></a><span id="l6.125" class="difflineplus">+  NS_ENSURE_ARG_POINTER(aKeys);</span>
<a href="#l6.126"></a><span id="l6.126" class="difflineplus">+</span>
<a href="#l6.127"></a><span id="l6.127" class="difflineplus">+  *aMoreToDownload = PR_FALSE;</span>
<a href="#l6.128"></a><span id="l6.128" class="difflineplus">+  *aTotalCount = m_totalKeysToFetch;</span>
<a href="#l6.129"></a><span id="l6.129" class="difflineplus">+  if (m_keysToFetch.IsEmpty())</span>
<a href="#l6.130"></a><span id="l6.130" class="difflineplus">+  {</span>
<a href="#l6.131"></a><span id="l6.131" class="difflineplus">+    *aLength = 0;</span>
<a href="#l6.132"></a><span id="l6.132" class="difflineplus">+    return NS_OK;</span>
<a href="#l6.133"></a><span id="l6.133" class="difflineplus">+  }</span>
<a href="#l6.134"></a><span id="l6.134" class="difflineplus">+</span>
<a href="#l6.135"></a><span id="l6.135" class="difflineplus">+  // if folder isn't open in a window, no reason to limit the number of headers</span>
<a href="#l6.136"></a><span id="l6.136" class="difflineplus">+  // we download.</span>
<a href="#l6.137"></a><span id="l6.137" class="difflineplus">+  nsCOMPtr&lt;nsIMsgMailSession&gt; session = do_GetService(NS_MSGMAILSESSION_CONTRACTID);</span>
<a href="#l6.138"></a><span id="l6.138" class="difflineplus">+  PRBool folderOpen = PR_FALSE;</span>
<a href="#l6.139"></a><span id="l6.139" class="difflineplus">+  if (session)</span>
<a href="#l6.140"></a><span id="l6.140" class="difflineplus">+    session-&gt;IsFolderOpenInWindow(this, &amp;folderOpen);</span>
<a href="#l6.141"></a><span id="l6.141" class="difflineplus">+</span>
<a href="#l6.142"></a><span id="l6.142" class="difflineplus">+  PRInt32 hdrChunkSize = 200;</span>
<a href="#l6.143"></a><span id="l6.143" class="difflineplus">+  if (folderOpen)</span>
<a href="#l6.144"></a><span id="l6.144" class="difflineplus">+  {</span>
<a href="#l6.145"></a><span id="l6.145" class="difflineplus">+    nsresult rv;</span>
<a href="#l6.146"></a><span id="l6.146" class="difflineplus">+    nsCOMPtr&lt;nsIPrefBranch&gt; prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID, &amp;rv));</span>
<a href="#l6.147"></a><span id="l6.147" class="difflineplus">+    NS_ENSURE_SUCCESS(rv, rv);</span>
<a href="#l6.148"></a><span id="l6.148" class="difflineplus">+    if (prefBranch)</span>
<a href="#l6.149"></a><span id="l6.149" class="difflineplus">+      prefBranch-&gt;GetIntPref(&quot;mail.imap.hdr_chunk_size&quot;, &amp;hdrChunkSize);</span>
<a href="#l6.150"></a><span id="l6.150" class="difflineplus">+  }</span>
<a href="#l6.151"></a><span id="l6.151" class="difflineplus">+  PRInt32 numKeysToFetch = m_keysToFetch.Length();</span>
<a href="#l6.152"></a><span id="l6.152" class="difflineplus">+  PRInt32 startIndex = 0;</span>
<a href="#l6.153"></a><span id="l6.153" class="difflineplus">+  if (folderOpen &amp;&amp; hdrChunkSize &gt; 0 &amp;&amp; m_keysToFetch.Length() &gt; hdrChunkSize)</span>
<a href="#l6.154"></a><span id="l6.154" class="difflineplus">+  {</span>
<a href="#l6.155"></a><span id="l6.155" class="difflineplus">+    numKeysToFetch = hdrChunkSize;</span>
<a href="#l6.156"></a><span id="l6.156" class="difflineplus">+    *aMoreToDownload = PR_TRUE;</span>
<a href="#l6.157"></a><span id="l6.157" class="difflineplus">+    startIndex = m_keysToFetch.Length() - hdrChunkSize;</span>
<a href="#l6.158"></a><span id="l6.158" class="difflineplus">+  }</span>
<a href="#l6.159"></a><span id="l6.159" class="difflineplus">+  *aKeys = (nsMsgKey *) nsMemory::Clone(&amp;m_keysToFetch[startIndex],</span>
<a href="#l6.160"></a><span id="l6.160" class="difflineplus">+                                       numKeysToFetch * sizeof(nsMsgKey));</span>
<a href="#l6.161"></a><span id="l6.161" class="difflineplus">+  NS_ENSURE_TRUE(*aKeys, NS_ERROR_OUT_OF_MEMORY);</span>
<a href="#l6.162"></a><span id="l6.162" class="difflineplus">+  // Remove these for the incremental header download case, so that</span>
<a href="#l6.163"></a><span id="l6.163" class="difflineplus">+  // we know we don't have to download them again.</span>
<a href="#l6.164"></a><span id="l6.164" class="difflineplus">+  m_keysToFetch.RemoveElementsAt(startIndex, numKeysToFetch);</span>
<a href="#l6.165"></a><span id="l6.165" class="difflineplus">+  *aLength = numKeysToFetch;</span>
<a href="#l6.166"></a><span id="l6.166" class="difflineplus">+</span>
<a href="#l6.167"></a><span id="l6.167" class="difflineplus">+  return NS_OK;</span>
<a href="#l6.168"></a><span id="l6.168" class="difflineplus">+}</span>
<a href="#l6.169"></a><span id="l6.169" class="difflineplus">+</span>
<a href="#l6.170"></a><span id="l6.170" class="difflineplus">+void nsImapMailFolder::PrepareToAddHeadersToMailDB(nsIImapProtocol* aProtocol)</span>
<a href="#l6.171"></a><span id="l6.171" class="difflineplus">+{</span>
<a href="#l6.172"></a><span id="l6.172" class="difflineplus">+  // now, tell it we don't need any bodies.</span>
<a href="#l6.173"></a><span id="l6.173" class="difflineplus">+  aProtocol-&gt;NotifyBodysToDownload(nsnull, 0);</span>
<a href="#l6.174"></a><span id="l6.174"> }</span>
<a href="#l6.175"></a><span id="l6.175"> </span>
<a href="#l6.176"></a><span id="l6.176"> void nsImapMailFolder::TweakHeaderFlags(nsIImapProtocol* aProtocol, nsIMsgDBHdr *tweakMe)</span>
<a href="#l6.177"></a><span id="l6.177"> {</span>
<a href="#l6.178"></a><span id="l6.178">   if (mDatabase &amp;&amp; aProtocol &amp;&amp; tweakMe)</span>
<a href="#l6.179"></a><span id="l6.179">   {</span>
<a href="#l6.180"></a><span id="l6.180">     tweakMe-&gt;SetMessageKey(m_curMsgUid);</span>
<a href="#l6.181"></a><span id="l6.181">     tweakMe-&gt;SetMessageSize(m_nextMessageByteLength);</span>
<a href="#l6.182"></a><span id="l6.182" class="difflineat">@@ -6753,16 +6788,17 @@ nsImapMailFolder::CopyNextStreamMessage(</span>
<a href="#l6.183"></a><span id="l6.183"> </span>
<a href="#l6.184"></a><span id="l6.184">   return rv;</span>
<a href="#l6.185"></a><span id="l6.185"> }</span>
<a href="#l6.186"></a><span id="l6.186"> </span>
<a href="#l6.187"></a><span id="l6.187"> NS_IMETHODIMP</span>
<a href="#l6.188"></a><span id="l6.188"> nsImapMailFolder::SetUrlState(nsIImapProtocol* aProtocol,</span>
<a href="#l6.189"></a><span id="l6.189">                               nsIMsgMailNewsUrl* aUrl,</span>
<a href="#l6.190"></a><span id="l6.190">                               PRBool isRunning,</span>
<a href="#l6.191"></a><span id="l6.191" class="difflineplus">+                              PRBool aSuspend,</span>
<a href="#l6.192"></a><span id="l6.192">                               nsresult statusCode)</span>
<a href="#l6.193"></a><span id="l6.193"> {</span>
<a href="#l6.194"></a><span id="l6.194">   if (!isRunning)</span>
<a href="#l6.195"></a><span id="l6.195">   {</span>
<a href="#l6.196"></a><span id="l6.196">     ProgressStatus(aProtocol, IMAP_DONE, nsnull);</span>
<a href="#l6.197"></a><span id="l6.197">     m_urlRunning = PR_FALSE;</span>
<a href="#l6.198"></a><span id="l6.198">     // if no protocol, then we're reading from the mem or disk cache</span>
<a href="#l6.199"></a><span id="l6.199">     // and we don't want to end the offline download just yet.</span>
<a href="#l6.200"></a><span id="l6.200" class="difflineat">@@ -6782,17 +6818,17 @@ nsImapMailFolder::SetUrlState(nsIImapPro</span>
<a href="#l6.201"></a><span id="l6.201">       imapUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l6.202"></a><span id="l6.202">       // if the server doesn't support copyUID, then SetCopyResponseUid won't</span>
<a href="#l6.203"></a><span id="l6.203">       // get called, so we need to clear m_pendingOfflineMoves when the online</span>
<a href="#l6.204"></a><span id="l6.204">       // move operation has finished.</span>
<a href="#l6.205"></a><span id="l6.205">       if (imapAction == nsIImapUrl::nsImapOnlineMove)</span>
<a href="#l6.206"></a><span id="l6.206">         m_pendingOfflineMoves.Clear();</span>
<a href="#l6.207"></a><span id="l6.207">     }</span>
<a href="#l6.208"></a><span id="l6.208">   }</span>
<a href="#l6.209"></a><span id="l6.209" class="difflineminus">-  if (aUrl)</span>
<a href="#l6.210"></a><span id="l6.210" class="difflineplus">+  if (aUrl &amp;&amp; !aSuspend)</span>
<a href="#l6.211"></a><span id="l6.211">       return aUrl-&gt;SetUrlState(isRunning, statusCode);</span>
<a href="#l6.212"></a><span id="l6.212">   return statusCode;</span>
<a href="#l6.213"></a><span id="l6.213"> }</span>
<a href="#l6.214"></a><span id="l6.214"> </span>
<a href="#l6.215"></a><span id="l6.215"> // used when copying from local mail folder, or other imap server)</span>
<a href="#l6.216"></a><span id="l6.216"> nsresult</span>
<a href="#l6.217"></a><span id="l6.217"> nsImapMailFolder::CopyMessagesWithStream(nsIMsgFolder* srcFolder,</span>
<a href="#l6.218"></a><span id="l6.218">                                 nsIArray* messages,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/mailnews/imap/src/nsImapMailFolder.h</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapMailFolder.h</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -359,19 +359,17 @@ public:</span>
<a href="#l7.4"></a><span id="l7.4"> protected:</span>
<a href="#l7.5"></a><span id="l7.5">   // Helper methods</span>
<a href="#l7.6"></a><span id="l7.6"> </span>
<a href="#l7.7"></a><span id="l7.7">   virtual nsresult CreateChildFromURI(const nsCString &amp;uri, nsIMsgFolder **folder);</span>
<a href="#l7.8"></a><span id="l7.8">   void FindKeysToAdd(const nsTArray&lt;nsMsgKey&gt; &amp;existingKeys, nsTArray&lt;nsMsgKey&gt;</span>
<a href="#l7.9"></a><span id="l7.9">     &amp;keysToFetch, PRUint32 &amp;numNewUnread, nsIImapFlagAndUidState *flagState);</span>
<a href="#l7.10"></a><span id="l7.10">   void FindKeysToDelete(const nsTArray&lt;nsMsgKey&gt; &amp;existingKeys, nsTArray&lt;nsMsgKey&gt;</span>
<a href="#l7.11"></a><span id="l7.11">     &amp;keysToFetch, nsIImapFlagAndUidState *flagState, PRUint32 boxFlags);</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-  void PrepareToAddHeadersToMailDB(nsIImapProtocol* aProtocol, const</span>
<a href="#l7.13"></a><span id="l7.13" class="difflineminus">-    nsTArray&lt;nsMsgKey&gt; &amp;keysToFetch,</span>
<a href="#l7.14"></a><span id="l7.14" class="difflineminus">-    nsIMailboxSpec *boxSpec);</span>
<a href="#l7.15"></a><span id="l7.15" class="difflineplus">+  void PrepareToAddHeadersToMailDB(nsIImapProtocol* aProtocol);</span>
<a href="#l7.16"></a><span id="l7.16">   void TweakHeaderFlags(nsIImapProtocol* aProtocol, nsIMsgDBHdr *tweakMe);</span>
<a href="#l7.17"></a><span id="l7.17"> </span>
<a href="#l7.18"></a><span id="l7.18">   nsresult SyncFlags(nsIImapFlagAndUidState *flagState);</span>
<a href="#l7.19"></a><span id="l7.19">   nsresult HandleCustomFlags(nsMsgKey uidOfMessage, nsIMsgDBHdr *dbHdr,</span>
<a href="#l7.20"></a><span id="l7.20">                              PRUint16 userFlags, nsCString&amp; keywords);</span>
<a href="#l7.21"></a><span id="l7.21">   nsresult NotifyMessageFlagsFromHdr(nsIMsgDBHdr *dbHdr, nsMsgKey msgKey, PRUint32 flags);</span>
<a href="#l7.22"></a><span id="l7.22"> </span>
<a href="#l7.23"></a><span id="l7.23">   nsresult SetupHeaderParseStream(PRUint32 size, const nsACString&amp; content_type, nsIMailboxSpec *boxSpec);</span>
<a href="#l7.24"></a><span id="l7.24" class="difflineat">@@ -445,22 +443,21 @@ protected:</span>
<a href="#l7.25"></a><span id="l7.25">   nsresult CopyOfflineMsgBody(nsIMsgFolder *srcFolder, nsIMsgDBHdr *destHdr,</span>
<a href="#l7.26"></a><span id="l7.26">                               nsIMsgDBHdr *origHdr, nsIInputStream *inputStream,</span>
<a href="#l7.27"></a><span id="l7.27">                               nsIOutputStream *outputStream);</span>
<a href="#l7.28"></a><span id="l7.28"> </span>
<a href="#l7.29"></a><span id="l7.29">   void GetTrashFolderName(nsAString &amp;aFolderName);</span>
<a href="#l7.30"></a><span id="l7.30">   PRBool ShowPreviewText();</span>
<a href="#l7.31"></a><span id="l7.31"> </span>
<a href="#l7.32"></a><span id="l7.32">   // Pseudo-Offline operation playback timer</span>
<a href="#l7.33"></a><span id="l7.33" class="difflineminus">-  static </span>
<a href="#l7.34"></a><span id="l7.34" class="difflineminus">-  void PlaybackTimerCallback(nsITimer *aTimer, void *aClosure);</span>
<a href="#l7.35"></a><span id="l7.35" class="difflineminus">-  </span>
<a href="#l7.36"></a><span id="l7.36" class="difflineplus">+  static void PlaybackTimerCallback(nsITimer *aTimer, void *aClosure);</span>
<a href="#l7.37"></a><span id="l7.37" class="difflineplus">+</span>
<a href="#l7.38"></a><span id="l7.38">   nsresult CreatePlaybackTimer();</span>
<a href="#l7.39"></a><span id="l7.39" class="difflineminus">-  </span>
<a href="#l7.40"></a><span id="l7.40" class="difflineminus">-  // Allocate and initialize associated auto-sync state object </span>
<a href="#l7.41"></a><span id="l7.41" class="difflineplus">+</span>
<a href="#l7.42"></a><span id="l7.42" class="difflineplus">+  // Allocate and initialize associated auto-sync state object.</span>
<a href="#l7.43"></a><span id="l7.43">   void InitAutoSyncState();</span>
<a href="#l7.44"></a><span id="l7.44"> </span>
<a href="#l7.45"></a><span id="l7.45">   PRBool m_initialized;</span>
<a href="#l7.46"></a><span id="l7.46">   PRBool m_haveDiscoveredAllFolders;</span>
<a href="#l7.47"></a><span id="l7.47">   nsCOMPtr&lt;nsIMsgParseMailMsgState&gt; m_msgParser;</span>
<a href="#l7.48"></a><span id="l7.48">   nsCOMPtr&lt;nsIMsgFilterList&gt; m_filterList;</span>
<a href="#l7.49"></a><span id="l7.49">   nsCOMPtr&lt;nsIMsgFilterPlugin&gt; m_filterPlugin;  // XXX should be a list</span>
<a href="#l7.50"></a><span id="l7.50">   // used with filter plugins to know when we've finished classifying and can playback moves</span>
<a href="#l7.51"></a><span id="l7.51" class="difflineat">@@ -472,28 +469,28 @@ protected:</span>
<a href="#l7.52"></a><span id="l7.52">   /// the junk destination folder</span>
<a href="#l7.53"></a><span id="l7.53">   nsCOMPtr&lt;nsIMsgFolder&gt; mSpamFolder;</span>
<a href="#l7.54"></a><span id="l7.54">   nsMsgKey m_curMsgUid;</span>
<a href="#l7.55"></a><span id="l7.55">   PRUint32 m_uidValidity;</span>
<a href="#l7.56"></a><span id="l7.56"> </span>
<a href="#l7.57"></a><span id="l7.57">   // These three vars are used to store counts from STATUS or SELECT command</span>
<a href="#l7.58"></a><span id="l7.58">   // They include deleted messages, so they can differ from the generic</span>
<a href="#l7.59"></a><span id="l7.59">   // folder total and unread counts.</span>
<a href="#l7.60"></a><span id="l7.60" class="difflineminus">-  PRInt32 m_numServerRecentMessages; </span>
<a href="#l7.61"></a><span id="l7.61" class="difflineplus">+  PRInt32 m_numServerRecentMessages;</span>
<a href="#l7.62"></a><span id="l7.62">   PRInt32 m_numServerUnseenMessages;</span>
<a href="#l7.63"></a><span id="l7.63">   PRInt32 m_numServerTotalMessages;</span>
<a href="#l7.64"></a><span id="l7.64">   // if server supports UIDNEXT, we store it here.</span>
<a href="#l7.65"></a><span id="l7.65">   PRInt32 m_nextUID;</span>
<a href="#l7.66"></a><span id="l7.66"> </span>
<a href="#l7.67"></a><span id="l7.67">   PRInt32  m_nextMessageByteLength;</span>
<a href="#l7.68"></a><span id="l7.68">   nsCOMPtr&lt;nsIThread&gt; m_thread;</span>
<a href="#l7.69"></a><span id="l7.69">   nsCOMPtr&lt;nsIUrlListener&gt; m_urlListener;</span>
<a href="#l7.70"></a><span id="l7.70">   PRBool m_urlRunning;</span>
<a href="#l7.71"></a><span id="l7.71"> </span>
<a href="#l7.72"></a><span id="l7.72" class="difflineminus">-  // *** jt - undo move/copy trasaction support</span>
<a href="#l7.73"></a><span id="l7.73" class="difflineplus">+  // undo move/copy transaction support</span>
<a href="#l7.74"></a><span id="l7.74">   nsRefPtr&lt;nsMsgTxn&gt; m_pendingUndoTxn;</span>
<a href="#l7.75"></a><span id="l7.75">   nsCOMPtr&lt;nsImapMailCopyState&gt; m_copyState;</span>
<a href="#l7.76"></a><span id="l7.76">   char m_hierarchyDelimiter;</span>
<a href="#l7.77"></a><span id="l7.77">   PRInt32 m_boxFlags;</span>
<a href="#l7.78"></a><span id="l7.78">   nsCString m_onlineFolderName;</span>
<a href="#l7.79"></a><span id="l7.79">   nsCString m_ownerUserName;  // username of the &quot;other user,&quot; as in</span>
<a href="#l7.80"></a><span id="l7.80">   // &quot;Other Users' Mailboxes&quot;</span>
<a href="#l7.81"></a><span id="l7.81"> </span>
<a href="#l7.82"></a><span id="l7.82" class="difflineat">@@ -517,25 +514,29 @@ protected:</span>
<a href="#l7.83"></a><span id="l7.83">   nsMsgIMAPFolderACL *m_folderACL;</span>
<a href="#l7.84"></a><span id="l7.84">   PRUint32     m_aclFlags;</span>
<a href="#l7.85"></a><span id="l7.85">   PRUint32     m_supportedUserFlags;</span>
<a href="#l7.86"></a><span id="l7.86"> </span>
<a href="#l7.87"></a><span id="l7.87">   // offline imap support</span>
<a href="#l7.88"></a><span id="l7.88">   PRBool m_downloadingFolderForOfflineUse;</span>
<a href="#l7.89"></a><span id="l7.89">   PRBool m_filterListRequiresBody;</span>
<a href="#l7.90"></a><span id="l7.90"> </span>
<a href="#l7.91"></a><span id="l7.91" class="difflineminus">-  // auto-sync (preemptive download) support</span>
<a href="#l7.92"></a><span id="l7.92" class="difflineplus">+  // auto-sync (automatic message download) support</span>
<a href="#l7.93"></a><span id="l7.93">   nsRefPtr&lt;nsAutoSyncState&gt; m_autoSyncStateObj;</span>
<a href="#l7.94"></a><span id="l7.94"> </span>
<a href="#l7.95"></a><span id="l7.95">   // Quota support</span>
<a href="#l7.96"></a><span id="l7.96">   nsCString m_folderQuotaRoot;</span>
<a href="#l7.97"></a><span id="l7.97">   PRUint32 m_folderQuotaUsedKB;</span>
<a href="#l7.98"></a><span id="l7.98">   PRUint32 m_folderQuotaMaxKB;</span>
<a href="#l7.99"></a><span id="l7.99"> </span>
<a href="#l7.100"></a><span id="l7.100">   // Pseudo-Offline Playback support</span>
<a href="#l7.101"></a><span id="l7.101">   nsPlaybackRequest *m_pendingPlaybackReq;</span>
<a href="#l7.102"></a><span id="l7.102">   nsCOMPtr&lt;nsITimer&gt; m_playbackTimer;</span>
<a href="#l7.103"></a><span id="l7.103">   nsTArray&lt;nsRefPtr&lt;nsImapMoveCopyMsgTxn&gt; &gt; m_pendingOfflineMoves;</span>
<a href="#l7.104"></a><span id="l7.104">   // hash table of mapping between messageids and message keys</span>
<a href="#l7.105"></a><span id="l7.105">   // for pseudo hdrs.</span>
<a href="#l7.106"></a><span id="l7.106">   nsDataHashtable&lt;nsCStringHashKey, nsMsgKey&gt; m_pseudoHdrs;</span>
<a href="#l7.107"></a><span id="l7.107" class="difflineplus">+</span>
<a href="#l7.108"></a><span id="l7.108" class="difflineplus">+  nsTArray&lt;nsMsgKey&gt; m_keysToFetch;</span>
<a href="#l7.109"></a><span id="l7.109" class="difflineplus">+  PRUint32 m_totalKeysToFetch;</span>
<a href="#l7.110"></a><span id="l7.110" class="difflineplus">+</span>
<a href="#l7.111"></a><span id="l7.111"> };</span>
<a href="#l7.112"></a><span id="l7.112"> #endif</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.cpp</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -386,17 +386,16 @@ nsresult nsImapProtocol::GlobalInitializ</span>
<a href="#l8.4"></a><span id="l8.4"> nsImapProtocol::nsImapProtocol() : nsMsgProtocol(nsnull),</span>
<a href="#l8.5"></a><span id="l8.5">     mLock(&quot;nsImapProtocol.mLock&quot;),</span>
<a href="#l8.6"></a><span id="l8.6">     m_dataAvailableMonitor(&quot;imapDataAvailable&quot;),</span>
<a href="#l8.7"></a><span id="l8.7">     m_urlReadyToRunMonitor(&quot;imapUrlReadyToRun&quot;),</span>
<a href="#l8.8"></a><span id="l8.8">     m_pseudoInterruptMonitor(&quot;imapPseudoInterrupt&quot;),</span>
<a href="#l8.9"></a><span id="l8.9">     m_dataMemberMonitor(&quot;imapDataMember&quot;),</span>
<a href="#l8.10"></a><span id="l8.10">     m_threadDeathMonitor(&quot;imapThreadDeath&quot;),</span>
<a href="#l8.11"></a><span id="l8.11">     m_waitForBodyIdsMonitor(&quot;imapWaitForBodyIds&quot;),</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-    m_fetchMsgListMonitor(&quot;imapFetchMsgList&quot;),</span>
<a href="#l8.13"></a><span id="l8.13">     m_fetchBodyListMonitor(&quot;imapFetchBodyList&quot;),</span>
<a href="#l8.14"></a><span id="l8.14">     m_passwordReadyMonitor(&quot;imapPasswordReady&quot;),</span>
<a href="#l8.15"></a><span id="l8.15">     m_parser(*this)</span>
<a href="#l8.16"></a><span id="l8.16"> {</span>
<a href="#l8.17"></a><span id="l8.17">   m_urlInProgress = PR_FALSE;</span>
<a href="#l8.18"></a><span id="l8.18">   m_idle = PR_FALSE;</span>
<a href="#l8.19"></a><span id="l8.19">   m_retryUrlOnError = PR_FALSE;</span>
<a href="#l8.20"></a><span id="l8.20">   m_useIdle = PR_TRUE; // by default, use it</span>
<a href="#l8.21"></a><span id="l8.21" class="difflineat">@@ -462,17 +461,16 @@ nsImapProtocol::nsImapProtocol() : nsMsg</span>
<a href="#l8.22"></a><span id="l8.22">   m_fetchByChunks = PR_TRUE;</span>
<a href="#l8.23"></a><span id="l8.23">   m_sendID = PR_TRUE;</span>
<a href="#l8.24"></a><span id="l8.24">   m_chunkSize = 0;</span>
<a href="#l8.25"></a><span id="l8.25">   m_chunkThreshold = 0;</span>
<a href="#l8.26"></a><span id="l8.26">   m_fromHeaderSeen = PR_FALSE;</span>
<a href="#l8.27"></a><span id="l8.27">   m_closeNeededBeforeSelect = PR_FALSE;</span>
<a href="#l8.28"></a><span id="l8.28">   m_needNoop = PR_FALSE;</span>
<a href="#l8.29"></a><span id="l8.29">   m_noopCount = 0;</span>
<a href="#l8.30"></a><span id="l8.30" class="difflineminus">-  m_fetchMsgListIsNew = PR_FALSE;</span>
<a href="#l8.31"></a><span id="l8.31">   m_fetchBodyListIsNew = PR_FALSE;</span>
<a href="#l8.32"></a><span id="l8.32">   m_flagChangeCount = 0;</span>
<a href="#l8.33"></a><span id="l8.33">   m_lastCheckTime = PR_Now();</span>
<a href="#l8.34"></a><span id="l8.34"> </span>
<a href="#l8.35"></a><span id="l8.35">   m_checkForNewMailDownloadsHeaders = PR_TRUE;  // this should be on by default</span>
<a href="#l8.36"></a><span id="l8.36">   m_hierarchyNameState = kNoOperationInProgress;</span>
<a href="#l8.37"></a><span id="l8.37">   m_discoveryStatus = eContinue;</span>
<a href="#l8.38"></a><span id="l8.38"> </span>
<a href="#l8.39"></a><span id="l8.39" class="difflineat">@@ -1612,17 +1610,18 @@ PRBool nsImapProtocol::ProcessCurrentURL</span>
<a href="#l8.40"></a><span id="l8.40">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailnewsurl = do_QueryInterface(m_runningUrl, &amp;rv);</span>
<a href="#l8.41"></a><span id="l8.41">   nsCAutoString urlSpec;</span>
<a href="#l8.42"></a><span id="l8.42">   mailnewsurl-&gt;GetSpec(urlSpec);</span>
<a href="#l8.43"></a><span id="l8.43">   Log(&quot;ProcessCurrentURL&quot;, urlSpec.get(), (validUrl) ? &quot; = currentUrl\n&quot; : &quot; is not valid\n&quot;);</span>
<a href="#l8.44"></a><span id="l8.44">   if (!validUrl)</span>
<a href="#l8.45"></a><span id="l8.45">     return PR_FALSE;</span>
<a href="#l8.46"></a><span id="l8.46"> </span>
<a href="#l8.47"></a><span id="l8.47">   if (NS_SUCCEEDED(rv) &amp;&amp; mailnewsurl &amp;&amp; m_imapMailFolderSink &amp;&amp; !rerunningUrl)</span>
<a href="#l8.48"></a><span id="l8.48" class="difflineminus">-    m_imapMailFolderSink-&gt;SetUrlState(this, mailnewsurl, PR_TRUE, NS_OK);</span>
<a href="#l8.49"></a><span id="l8.49" class="difflineplus">+    m_imapMailFolderSink-&gt;SetUrlState(this, mailnewsurl, PR_TRUE, PR_FALSE,</span>
<a href="#l8.50"></a><span id="l8.50" class="difflineplus">+                                      NS_OK);</span>
<a href="#l8.51"></a><span id="l8.51"> </span>
<a href="#l8.52"></a><span id="l8.52">   // if we are set up as a channel, we should notify our channel listener that we are starting...</span>
<a href="#l8.53"></a><span id="l8.53">   // so pass in ourself as the channel and not the underlying socket or file channel the protocol</span>
<a href="#l8.54"></a><span id="l8.54">   // happens to be using</span>
<a href="#l8.55"></a><span id="l8.55">   if (m_channelListener) // ### not sure we want to do this if rerunning url...</span>
<a href="#l8.56"></a><span id="l8.56">   {</span>
<a href="#l8.57"></a><span id="l8.57">     nsCOMPtr&lt;nsIRequest&gt; request = do_QueryInterface(m_mockChannel);</span>
<a href="#l8.58"></a><span id="l8.58">     m_channelListener-&gt;OnStartRequest(request, m_channelContext);</span>
<a href="#l8.59"></a><span id="l8.59" class="difflineat">@@ -1768,26 +1767,29 @@ PRBool nsImapProtocol::ProcessCurrentURL</span>
<a href="#l8.60"></a><span id="l8.60">       nsCOMPtr&lt;nsIRequest&gt; request = do_QueryInterface(m_mockChannel);</span>
<a href="#l8.61"></a><span id="l8.61">       NS_ASSERTION(request, &quot;no request&quot;);</span>
<a href="#l8.62"></a><span id="l8.62">       if (request) {</span>
<a href="#l8.63"></a><span id="l8.63">         nsresult status;</span>
<a href="#l8.64"></a><span id="l8.64">         request-&gt;GetStatus(&amp;status);</span>
<a href="#l8.65"></a><span id="l8.65">         rv = m_channelListener-&gt;OnStopRequest(request, m_channelContext, status);</span>
<a href="#l8.66"></a><span id="l8.66">       }</span>
<a href="#l8.67"></a><span id="l8.67">   }</span>
<a href="#l8.68"></a><span id="l8.68" class="difflineplus">+  PRBool suspendUrl = PR_FALSE;</span>
<a href="#l8.69"></a><span id="l8.69" class="difflineplus">+  m_runningUrl-&gt;GetMoreHeadersToDownload(&amp;suspendUrl);</span>
<a href="#l8.70"></a><span id="l8.70">   if (mailnewsurl &amp;&amp; m_imapMailFolderSink)</span>
<a href="#l8.71"></a><span id="l8.71">   {</span>
<a href="#l8.72"></a><span id="l8.72">     if (logonFailed)</span>
<a href="#l8.73"></a><span id="l8.73">       rv = NS_ERROR_FAILURE;</span>
<a href="#l8.74"></a><span id="l8.74">     else if (GetServerStateParser().CommandFailed())</span>
<a href="#l8.75"></a><span id="l8.75">       rv = NS_MSG_ERROR_IMAP_COMMAND_FAILED;</span>
<a href="#l8.76"></a><span id="l8.76">     else</span>
<a href="#l8.77"></a><span id="l8.77">       rv = GetConnectionStatus();</span>
<a href="#l8.78"></a><span id="l8.78">     // we are done with this url.</span>
<a href="#l8.79"></a><span id="l8.79" class="difflineminus">-    m_imapMailFolderSink-&gt;SetUrlState(this, mailnewsurl, PR_FALSE, rv);</span>
<a href="#l8.80"></a><span id="l8.80" class="difflineplus">+    m_imapMailFolderSink-&gt;SetUrlState(this, mailnewsurl, PR_FALSE, suspendUrl,</span>
<a href="#l8.81"></a><span id="l8.81" class="difflineplus">+                                      rv);</span>
<a href="#l8.82"></a><span id="l8.82">      // doom the cache entry</span>
<a href="#l8.83"></a><span id="l8.83">     if (NS_FAILED(rv) &amp;&amp; DeathSignalReceived() &amp;&amp; m_mockChannel)</span>
<a href="#l8.84"></a><span id="l8.84">       DoomCacheEntry(mailnewsurl);</span>
<a href="#l8.85"></a><span id="l8.85">   }</span>
<a href="#l8.86"></a><span id="l8.86">   else</span>
<a href="#l8.87"></a><span id="l8.87">     NS_ERROR(&quot;missing url or sink&quot;);</span>
<a href="#l8.88"></a><span id="l8.88"> </span>
<a href="#l8.89"></a><span id="l8.89">   // disable timeouts before caching connection.</span>
<a href="#l8.90"></a><span id="l8.90" class="difflineat">@@ -1798,16 +1800,18 @@ PRBool nsImapProtocol::ProcessCurrentURL</span>
<a href="#l8.91"></a><span id="l8.91"> </span>
<a href="#l8.92"></a><span id="l8.92">   nsCOMPtr &lt;nsISupports&gt; copyState;</span>
<a href="#l8.93"></a><span id="l8.93">   if (m_runningUrl)</span>
<a href="#l8.94"></a><span id="l8.94">     m_runningUrl-&gt;GetCopyState(getter_AddRefs(copyState));</span>
<a href="#l8.95"></a><span id="l8.95">   // this is so hokey...we MUST clear any local references to the url</span>
<a href="#l8.96"></a><span id="l8.96">   // BEFORE calling ReleaseUrlState</span>
<a href="#l8.97"></a><span id="l8.97">   mailnewsurl = nsnull;</span>
<a href="#l8.98"></a><span id="l8.98"> </span>
<a href="#l8.99"></a><span id="l8.99" class="difflineplus">+  if (suspendUrl)</span>
<a href="#l8.100"></a><span id="l8.100" class="difflineplus">+    m_imapServerSink-&gt;SuspendUrl(m_runningUrl);</span>
<a href="#l8.101"></a><span id="l8.101">   // save the imap folder sink since we need it to do the CopyNextStreamMessage</span>
<a href="#l8.102"></a><span id="l8.102">   nsCOMPtr&lt;nsIImapMailFolderSink&gt; imapMailFolderSink = m_imapMailFolderSink;</span>
<a href="#l8.103"></a><span id="l8.103">   // release the url as we are done with it...</span>
<a href="#l8.104"></a><span id="l8.104">   ReleaseUrlState(PR_FALSE);</span>
<a href="#l8.105"></a><span id="l8.105">   ResetProgressInfo();</span>
<a href="#l8.106"></a><span id="l8.106"> </span>
<a href="#l8.107"></a><span id="l8.107">   ClearFlag(IMAP_CLEAN_UP_URL_STATE);</span>
<a href="#l8.108"></a><span id="l8.108"> </span>
<a href="#l8.109"></a><span id="l8.109" class="difflineat">@@ -2016,18 +2020,18 @@ public:</span>
<a href="#l8.110"></a><span id="l8.110">   {</span>
<a href="#l8.111"></a><span id="l8.111">     if (mUrl)</span>
<a href="#l8.112"></a><span id="l8.112">     {</span>
<a href="#l8.113"></a><span id="l8.113">       nsCOMPtr&lt;nsIMsgFolder&gt; folder;</span>
<a href="#l8.114"></a><span id="l8.114">       mUrl-&gt;GetFolder(getter_AddRefs(folder));</span>
<a href="#l8.115"></a><span id="l8.115">       NS_ENSURE_TRUE(folder, NS_OK);</span>
<a href="#l8.116"></a><span id="l8.116">       nsCOMPtr&lt;nsIImapMailFolderSink&gt; folderSink(do_QueryInterface(folder));</span>
<a href="#l8.117"></a><span id="l8.117">       // This causes the url listener to get OnStart and Stop notifications.</span>
<a href="#l8.118"></a><span id="l8.118" class="difflineminus">-      folderSink-&gt;SetUrlState(mProtocol, mUrl, PR_TRUE, NS_OK);</span>
<a href="#l8.119"></a><span id="l8.119" class="difflineminus">-      folderSink-&gt;SetUrlState(mProtocol, mUrl, PR_FALSE, NS_OK);</span>
<a href="#l8.120"></a><span id="l8.120" class="difflineplus">+      folderSink-&gt;SetUrlState(mProtocol, mUrl, PR_TRUE, PR_FALSE, NS_OK);</span>
<a href="#l8.121"></a><span id="l8.121" class="difflineplus">+      folderSink-&gt;SetUrlState(mProtocol, mUrl, PR_FALSE, PR_FALSE, NS_OK);</span>
<a href="#l8.122"></a><span id="l8.122">     }</span>
<a href="#l8.123"></a><span id="l8.123">     return NS_OK;</span>
<a href="#l8.124"></a><span id="l8.124">   }</span>
<a href="#l8.125"></a><span id="l8.125"> </span>
<a href="#l8.126"></a><span id="l8.126"> private:</span>
<a href="#l8.127"></a><span id="l8.127">   nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mUrl;</span>
<a href="#l8.128"></a><span id="l8.128">   nsCOMPtr&lt;nsIImapProtocol&gt; mProtocol;</span>
<a href="#l8.129"></a><span id="l8.129"> };</span>
<a href="#l8.130"></a><span id="l8.130" class="difflineat">@@ -2384,34 +2388,34 @@ void nsImapProtocol::IncrementCommandTag</span>
<a href="#l8.131"></a><span id="l8.131"> const char *nsImapProtocol::GetServerCommandTag()</span>
<a href="#l8.132"></a><span id="l8.132"> {</span>
<a href="#l8.133"></a><span id="l8.133">     return m_currentServerCommandTag;</span>
<a href="#l8.134"></a><span id="l8.134"> }</span>
<a href="#l8.135"></a><span id="l8.135"> </span>
<a href="#l8.136"></a><span id="l8.136"> void nsImapProtocol::ProcessSelectedStateURL()</span>
<a href="#l8.137"></a><span id="l8.137"> {</span>
<a href="#l8.138"></a><span id="l8.138">   nsCString mailboxName;</span>
<a href="#l8.139"></a><span id="l8.139" class="difflineminus">-  PRBool          bMessageIdsAreUids = PR_TRUE;</span>
<a href="#l8.140"></a><span id="l8.140" class="difflineplus">+  PRBool bMessageIdsAreUids = PR_TRUE;</span>
<a href="#l8.141"></a><span id="l8.141" class="difflineplus">+  PRBool moreHeadersToDownload;</span>
<a href="#l8.142"></a><span id="l8.142">   imapMessageFlagsType  msgFlags = 0;</span>
<a href="#l8.143"></a><span id="l8.143">   nsCString       urlHost;</span>
<a href="#l8.144"></a><span id="l8.144"> </span>
<a href="#l8.145"></a><span id="l8.145">   // this can't fail, can it?</span>
<a href="#l8.146"></a><span id="l8.146">   nsresult res;</span>
<a href="#l8.147"></a><span id="l8.147">   res = m_runningUrl-&gt;GetImapAction(&amp;m_imapAction);</span>
<a href="#l8.148"></a><span id="l8.148">   m_runningUrl-&gt;MessageIdsAreUids(&amp;bMessageIdsAreUids);</span>
<a href="#l8.149"></a><span id="l8.149">   m_runningUrl-&gt;GetMsgFlags(&amp;msgFlags);</span>
<a href="#l8.150"></a><span id="l8.150" class="difflineplus">+  m_runningUrl-&gt;GetMoreHeadersToDownload(&amp;moreHeadersToDownload);</span>
<a href="#l8.151"></a><span id="l8.151"> </span>
<a href="#l8.152"></a><span id="l8.152">   res = CreateServerSourceFolderPathString(getter_Copies(mailboxName));</span>
<a href="#l8.153"></a><span id="l8.153">   if (NS_FAILED(res))</span>
<a href="#l8.154"></a><span id="l8.154">     Log(&quot;ProcessSelectedStateURL&quot;, nsnull, &quot;error getting source folder path string&quot;);</span>
<a href="#l8.155"></a><span id="l8.155"> </span>
<a href="#l8.156"></a><span id="l8.156">   if (NS_SUCCEEDED(res) &amp;&amp; !DeathSignalReceived())</span>
<a href="#l8.157"></a><span id="l8.157">   {</span>
<a href="#l8.158"></a><span id="l8.158" class="difflineminus">-    // OK, code here used to check explicitly for multiple connections to the inbox,</span>
<a href="#l8.159"></a><span id="l8.159" class="difflineminus">-    // but the connection pool stuff should handle this now.</span>
<a href="#l8.160"></a><span id="l8.160">     PRBool selectIssued = PR_FALSE;</span>
<a href="#l8.161"></a><span id="l8.161">     if (GetServerStateParser().GetIMAPstate() == nsImapServerResponseParser::kFolderSelected)</span>
<a href="#l8.162"></a><span id="l8.162">     {</span>
<a href="#l8.163"></a><span id="l8.163">       if (GetServerStateParser().GetSelectedMailboxName() &amp;&amp;</span>
<a href="#l8.164"></a><span id="l8.164">         PL_strcmp(GetServerStateParser().GetSelectedMailboxName(),</span>
<a href="#l8.165"></a><span id="l8.165">         mailboxName.get()))</span>
<a href="#l8.166"></a><span id="l8.166">       {       // we are selected in another folder</span>
<a href="#l8.167"></a><span id="l8.167">         if (m_closeNeededBeforeSelect)</span>
<a href="#l8.168"></a><span id="l8.168" class="difflineat">@@ -2423,16 +2427,34 @@ void nsImapProtocol::ProcessSelectedStat</span>
<a href="#l8.169"></a><span id="l8.169">           SelectMailbox(mailboxName.get());</span>
<a href="#l8.170"></a><span id="l8.170">         }</span>
<a href="#l8.171"></a><span id="l8.171">       }</span>
<a href="#l8.172"></a><span id="l8.172">       else if (!GetServerStateParser().GetSelectedMailboxName())</span>
<a href="#l8.173"></a><span id="l8.173">       {       // why are we in the selected state with no box name?</span>
<a href="#l8.174"></a><span id="l8.174">         SelectMailbox(mailboxName.get());</span>
<a href="#l8.175"></a><span id="l8.175">         selectIssued = PR_TRUE;</span>
<a href="#l8.176"></a><span id="l8.176">       }</span>
<a href="#l8.177"></a><span id="l8.177" class="difflineplus">+      else if (moreHeadersToDownload &amp;&amp; m_imapMailFolderSink) // we need to fetch older headers</span>
<a href="#l8.178"></a><span id="l8.178" class="difflineplus">+      {</span>
<a href="#l8.179"></a><span id="l8.179" class="difflineplus">+        nsMsgKey *msgIdList = nsnull;</span>
<a href="#l8.180"></a><span id="l8.180" class="difflineplus">+        PRUint32 msgCount = 0;</span>
<a href="#l8.181"></a><span id="l8.181" class="difflineplus">+        PRBool more;</span>
<a href="#l8.182"></a><span id="l8.182" class="difflineplus">+        m_imapMailFolderSink-&gt;GetMsgHdrsToDownload(&amp;more, &amp;m_progressCount,</span>
<a href="#l8.183"></a><span id="l8.183" class="difflineplus">+                                                   &amp;msgCount, &amp;msgIdList);</span>
<a href="#l8.184"></a><span id="l8.184" class="difflineplus">+        if (msgIdList)</span>
<a href="#l8.185"></a><span id="l8.185" class="difflineplus">+        {</span>
<a href="#l8.186"></a><span id="l8.186" class="difflineplus">+          FolderHeaderDump(msgIdList, msgCount);</span>
<a href="#l8.187"></a><span id="l8.187" class="difflineplus">+          NS_Free(msgIdList);</span>
<a href="#l8.188"></a><span id="l8.188" class="difflineplus">+          m_runningUrl-&gt;SetMoreHeadersToDownload(more);</span>
<a href="#l8.189"></a><span id="l8.189" class="difflineplus">+          // We're going to be re-running this url.</span>
<a href="#l8.190"></a><span id="l8.190" class="difflineplus">+          if (more)</span>
<a href="#l8.191"></a><span id="l8.191" class="difflineplus">+            m_runningUrl-&gt;SetRerunningUrl(PR_TRUE);</span>
<a href="#l8.192"></a><span id="l8.192" class="difflineplus">+        }</span>
<a href="#l8.193"></a><span id="l8.193" class="difflineplus">+        HeaderFetchCompleted();</span>
<a href="#l8.194"></a><span id="l8.194" class="difflineplus">+      }</span>
<a href="#l8.195"></a><span id="l8.195">       else</span>
<a href="#l8.196"></a><span id="l8.196">       {</span>
<a href="#l8.197"></a><span id="l8.197">         // get new message counts, if any, from server</span>
<a href="#l8.198"></a><span id="l8.198">         if (m_needNoop)</span>
<a href="#l8.199"></a><span id="l8.199">         {</span>
<a href="#l8.200"></a><span id="l8.200">           m_noopCount++;</span>
<a href="#l8.201"></a><span id="l8.201">           if ((gPromoteNoopToCheckCount &gt; 0 &amp;&amp; (m_noopCount % gPromoteNoopToCheckCount) == 0) ||</span>
<a href="#l8.202"></a><span id="l8.202">             CheckNeeded())</span>
<a href="#l8.203"></a><span id="l8.203" class="difflineat">@@ -2499,21 +2521,20 @@ void nsImapProtocol::ProcessSelectedStat</span>
<a href="#l8.204"></a><span id="l8.204">         }</span>
<a href="#l8.205"></a><span id="l8.205">         if (m_imapAction == nsIImapUrl::nsImapExpungeFolder || m_imapAction == nsIImapUrl::nsImapDeleteMsg ||</span>
<a href="#l8.206"></a><span id="l8.206">           m_imapAction == nsIImapUrl::nsImapDeleteAllMsgs)</span>
<a href="#l8.207"></a><span id="l8.207">           return;</span>
<a href="#l8.208"></a><span id="l8.208">       }</span>
<a href="#l8.209"></a><span id="l8.209">       switch (m_imapAction)</span>
<a href="#l8.210"></a><span id="l8.210">       {</span>
<a href="#l8.211"></a><span id="l8.211">       case nsIImapUrl::nsImapLiteSelectFolder:</span>
<a href="#l8.212"></a><span id="l8.212" class="difflineminus">-        if (GetServerStateParser().LastCommandSuccessful() &amp;&amp; m_imapMailFolderSink)</span>
<a href="#l8.213"></a><span id="l8.213" class="difflineplus">+        if (GetServerStateParser().LastCommandSuccessful() &amp;&amp;</span>
<a href="#l8.214"></a><span id="l8.214" class="difflineplus">+            m_imapMailFolderSink &amp;&amp; !moreHeadersToDownload)</span>
<a href="#l8.215"></a><span id="l8.215">         {</span>
<a href="#l8.216"></a><span id="l8.216">           m_imapMailFolderSink-&gt;SetUidValidity(GetServerStateParser().FolderUID());</span>
<a href="#l8.217"></a><span id="l8.217" class="difflineminus">-</span>
<a href="#l8.218"></a><span id="l8.218" class="difflineminus">-          // need to update the mailbox count - is this a good place?</span>
<a href="#l8.219"></a><span id="l8.219">           ProcessMailboxUpdate(PR_FALSE); // handle uidvalidity change</span>
<a href="#l8.220"></a><span id="l8.220">         }</span>
<a href="#l8.221"></a><span id="l8.221">         break;</span>
<a href="#l8.222"></a><span id="l8.222">       case nsIImapUrl::nsImapSaveMessageToDisk:</span>
<a href="#l8.223"></a><span id="l8.223">       case nsIImapUrl::nsImapMsgFetch:</span>
<a href="#l8.224"></a><span id="l8.224">       case nsIImapUrl::nsImapMsgFetchPeek:</span>
<a href="#l8.225"></a><span id="l8.225">       case nsIImapUrl::nsImapMsgDownloadForOffline:</span>
<a href="#l8.226"></a><span id="l8.226">       case nsIImapUrl::nsImapMsgPreview:</span>
<a href="#l8.227"></a><span id="l8.227" class="difflineat">@@ -2539,18 +2560,18 @@ void nsImapProtocol::ProcessSelectedStat</span>
<a href="#l8.228"></a><span id="l8.228">               ? kBodyStart : kEveryThingRFC822Peek);</span>
<a href="#l8.229"></a><span id="l8.229">             if (m_imapAction == nsIImapUrl::nsImapMsgPreview)</span>
<a href="#l8.230"></a><span id="l8.230">               HeaderFetchCompleted();</span>
<a href="#l8.231"></a><span id="l8.231">             SetProgressString(0);</span>
<a href="#l8.232"></a><span id="l8.232">           }</span>
<a href="#l8.233"></a><span id="l8.233">           else</span>
<a href="#l8.234"></a><span id="l8.234">           {</span>
<a href="#l8.235"></a><span id="l8.235">             // A single message ID</span>
<a href="#l8.236"></a><span id="l8.236" class="difflineminus">-		    nsIMAPeFetchFields whatToFetch = kEveryThingRFC822;</span>
<a href="#l8.237"></a><span id="l8.237" class="difflineminus">-	        if(m_imapAction == nsIImapUrl::nsImapMsgFetchPeek)</span>
<a href="#l8.238"></a><span id="l8.238" class="difflineplus">+            nsIMAPeFetchFields whatToFetch = kEveryThingRFC822;</span>
<a href="#l8.239"></a><span id="l8.239" class="difflineplus">+            if(m_imapAction == nsIImapUrl::nsImapMsgFetchPeek)</span>
<a href="#l8.240"></a><span id="l8.240">               whatToFetch = kEveryThingRFC822Peek;</span>
<a href="#l8.241"></a><span id="l8.241"> </span>
<a href="#l8.242"></a><span id="l8.242">             // First, let's see if we're requesting a specific MIME part</span>
<a href="#l8.243"></a><span id="l8.243">             char *imappart = nsnull;</span>
<a href="#l8.244"></a><span id="l8.244">             m_runningUrl-&gt;GetImapPartToFetch(&amp;imappart);</span>
<a href="#l8.245"></a><span id="l8.245">             if (imappart)</span>
<a href="#l8.246"></a><span id="l8.246">             {</span>
<a href="#l8.247"></a><span id="l8.247">               if (bMessageIdsAreUids)</span>
<a href="#l8.248"></a><span id="l8.248" class="difflineat">@@ -2685,17 +2706,18 @@ void nsImapProtocol::ProcessSelectedStat</span>
<a href="#l8.249"></a><span id="l8.249">           }</span>
<a href="#l8.250"></a><span id="l8.250">         }</span>
<a href="#l8.251"></a><span id="l8.251">         break;</span>
<a href="#l8.252"></a><span id="l8.252">       case nsIImapUrl::nsImapExpungeFolder:</span>
<a href="#l8.253"></a><span id="l8.253">         Expunge();</span>
<a href="#l8.254"></a><span id="l8.254">         // note fall through to next cases.</span>
<a href="#l8.255"></a><span id="l8.255">       case nsIImapUrl::nsImapSelectFolder:</span>
<a href="#l8.256"></a><span id="l8.256">       case nsIImapUrl::nsImapSelectNoopFolder:</span>
<a href="#l8.257"></a><span id="l8.257" class="difflineminus">-        ProcessMailboxUpdate(PR_TRUE);</span>
<a href="#l8.258"></a><span id="l8.258" class="difflineplus">+        if (!moreHeadersToDownload)</span>
<a href="#l8.259"></a><span id="l8.259" class="difflineplus">+          ProcessMailboxUpdate(PR_TRUE);</span>
<a href="#l8.260"></a><span id="l8.260">         break;</span>
<a href="#l8.261"></a><span id="l8.261">       case nsIImapUrl::nsImapMsgHeader:</span>
<a href="#l8.262"></a><span id="l8.262">         {</span>
<a href="#l8.263"></a><span id="l8.263">           nsCString messageIds;</span>
<a href="#l8.264"></a><span id="l8.264">           m_runningUrl-&gt;GetListOfMessageIds(messageIds);</span>
<a href="#l8.265"></a><span id="l8.265"> </span>
<a href="#l8.266"></a><span id="l8.266">           FetchMessage(messageIds,</span>
<a href="#l8.267"></a><span id="l8.267">             kHeadersRFC822andUid);</span>
<a href="#l8.268"></a><span id="l8.268" class="difflineat">@@ -4128,48 +4150,54 @@ void nsImapProtocol::ProcessMailboxUpdat</span>
<a href="#l8.269"></a><span id="l8.269">     nsImapAction imapAction;</span>
<a href="#l8.270"></a><span id="l8.270">     nsresult res = m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l8.271"></a><span id="l8.271">     if (NS_SUCCEEDED(res) &amp;&amp; imapAction == nsIImapUrl::nsImapLiteSelectFolder)</span>
<a href="#l8.272"></a><span id="l8.272">       return;</span>
<a href="#l8.273"></a><span id="l8.273">   }</span>
<a href="#l8.274"></a><span id="l8.274"> </span>
<a href="#l8.275"></a><span id="l8.275">   PRBool entered_waitForBodyIdsMonitor = PR_FALSE;</span>
<a href="#l8.276"></a><span id="l8.276"> </span>
<a href="#l8.277"></a><span id="l8.277" class="difflineplus">+  PRUint32 *msgIdList = nsnull;</span>
<a href="#l8.278"></a><span id="l8.278" class="difflineplus">+  PRUint32 msgCount = 0;</span>
<a href="#l8.279"></a><span id="l8.279" class="difflineplus">+</span>
<a href="#l8.280"></a><span id="l8.280">   nsImapMailboxSpec *new_spec = GetServerStateParser().CreateCurrentMailboxSpec();</span>
<a href="#l8.281"></a><span id="l8.281">   if (new_spec &amp;&amp; !DeathSignalReceived())</span>
<a href="#l8.282"></a><span id="l8.282">   {</span>
<a href="#l8.283"></a><span id="l8.283" class="difflineminus">-    if (!DeathSignalReceived())</span>
<a href="#l8.284"></a><span id="l8.284" class="difflineminus">-    {</span>
<a href="#l8.285"></a><span id="l8.285" class="difflineminus">-      nsImapAction imapAction;</span>
<a href="#l8.286"></a><span id="l8.286" class="difflineminus">-      nsresult res = m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l8.287"></a><span id="l8.287" class="difflineminus">-      if (NS_SUCCEEDED(res) &amp;&amp; imapAction == nsIImapUrl::nsImapExpungeFolder)</span>
<a href="#l8.288"></a><span id="l8.288" class="difflineminus">-        new_spec-&gt;mBoxFlags |= kJustExpunged;</span>
<a href="#l8.289"></a><span id="l8.289" class="difflineminus">-      m_waitForBodyIdsMonitor.Enter();</span>
<a href="#l8.290"></a><span id="l8.290" class="difflineminus">-      entered_waitForBodyIdsMonitor = PR_TRUE;</span>
<a href="#l8.291"></a><span id="l8.291" class="difflineminus">-      UpdatedMailboxSpec(new_spec);</span>
<a href="#l8.292"></a><span id="l8.292" class="difflineplus">+    nsImapAction imapAction;</span>
<a href="#l8.293"></a><span id="l8.293" class="difflineplus">+    nsresult res = m_runningUrl-&gt;GetImapAction(&amp;imapAction);</span>
<a href="#l8.294"></a><span id="l8.294" class="difflineplus">+    if (NS_SUCCEEDED(res) &amp;&amp; imapAction == nsIImapUrl::nsImapExpungeFolder)</span>
<a href="#l8.295"></a><span id="l8.295" class="difflineplus">+      new_spec-&gt;mBoxFlags |= kJustExpunged;</span>
<a href="#l8.296"></a><span id="l8.296" class="difflineplus">+    m_waitForBodyIdsMonitor.Enter();</span>
<a href="#l8.297"></a><span id="l8.297" class="difflineplus">+    entered_waitForBodyIdsMonitor = PR_TRUE;</span>
<a href="#l8.298"></a><span id="l8.298" class="difflineplus">+</span>
<a href="#l8.299"></a><span id="l8.299" class="difflineplus">+    if (m_imapMailFolderSink)</span>
<a href="#l8.300"></a><span id="l8.300" class="difflineplus">+    {</span>
<a href="#l8.301"></a><span id="l8.301" class="difflineplus">+      PRBool more;</span>
<a href="#l8.302"></a><span id="l8.302" class="difflineplus">+      m_imapMailFolderSink-&gt;UpdateImapMailboxInfo(this, new_spec);</span>
<a href="#l8.303"></a><span id="l8.303" class="difflineplus">+      m_imapMailFolderSink-&gt;GetMsgHdrsToDownload(&amp;more, &amp;m_progressCount,</span>
<a href="#l8.304"></a><span id="l8.304" class="difflineplus">+                                                 &amp;msgCount, &amp;msgIdList);</span>
<a href="#l8.305"></a><span id="l8.305" class="difflineplus">+      m_progressIndex = 0;</span>
<a href="#l8.306"></a><span id="l8.306" class="difflineplus">+      m_runningUrl-&gt;SetMoreHeadersToDownload(more);</span>
<a href="#l8.307"></a><span id="l8.307" class="difflineplus">+      // We're going to be re-running this url if there are more headers.</span>
<a href="#l8.308"></a><span id="l8.308" class="difflineplus">+      if (more)</span>
<a href="#l8.309"></a><span id="l8.309" class="difflineplus">+        m_runningUrl-&gt;SetRerunningUrl(PR_TRUE);</span>
<a href="#l8.310"></a><span id="l8.310">     }</span>
<a href="#l8.311"></a><span id="l8.311">   }</span>
<a href="#l8.312"></a><span id="l8.312">   else if (!new_spec)</span>
<a href="#l8.313"></a><span id="l8.313">     HandleMemoryFailure();</span>
<a href="#l8.314"></a><span id="l8.314"> </span>
<a href="#l8.315"></a><span id="l8.315" class="difflineminus">-  // Block until libmsg decides whether to download headers or not.</span>
<a href="#l8.316"></a><span id="l8.316" class="difflineminus">-  PRUint32 *msgIdList = nsnull;</span>
<a href="#l8.317"></a><span id="l8.317" class="difflineminus">-  PRUint32 msgCount = 0;</span>
<a href="#l8.318"></a><span id="l8.318" class="difflineminus">-</span>
<a href="#l8.319"></a><span id="l8.319">   if (!DeathSignalReceived())</span>
<a href="#l8.320"></a><span id="l8.320">   {</span>
<a href="#l8.321"></a><span id="l8.321" class="difflineminus">-    WaitForPotentialListOfMsgsToFetch(&amp;msgIdList, msgCount);</span>
<a href="#l8.322"></a><span id="l8.322" class="difflineminus">-</span>
<a href="#l8.323"></a><span id="l8.323">     if (entered_waitForBodyIdsMonitor)</span>
<a href="#l8.324"></a><span id="l8.324">       m_waitForBodyIdsMonitor.Exit();</span>
<a href="#l8.325"></a><span id="l8.325"> </span>
<a href="#l8.326"></a><span id="l8.326">     if (msgIdList &amp;&amp; !DeathSignalReceived() &amp;&amp; GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l8.327"></a><span id="l8.327">     {</span>
<a href="#l8.328"></a><span id="l8.328">       FolderHeaderDump(msgIdList, msgCount);</span>
<a href="#l8.329"></a><span id="l8.329" class="difflineminus">-      PR_Free( msgIdList);</span>
<a href="#l8.330"></a><span id="l8.330" class="difflineplus">+      NS_Free( msgIdList);</span>
<a href="#l8.331"></a><span id="l8.331">     }</span>
<a href="#l8.332"></a><span id="l8.332">     HeaderFetchCompleted();</span>
<a href="#l8.333"></a><span id="l8.333">       // this might be bogus, how are we going to do pane notification and stuff when we fetch bodies without</span>
<a href="#l8.334"></a><span id="l8.334">       // headers!</span>
<a href="#l8.335"></a><span id="l8.335">   }</span>
<a href="#l8.336"></a><span id="l8.336">   else if (entered_waitForBodyIdsMonitor) // need to exit this monitor if death signal received</span>
<a href="#l8.337"></a><span id="l8.337">     m_waitForBodyIdsMonitor.Exit();</span>
<a href="#l8.338"></a><span id="l8.338"> </span>
<a href="#l8.339"></a><span id="l8.339" class="difflineat">@@ -4179,32 +4207,28 @@ void nsImapProtocol::ProcessMailboxUpdat</span>
<a href="#l8.340"></a><span id="l8.340">     WaitForPotentialListOfBodysToFetch(&amp;msgIdList, msgCount);</span>
<a href="#l8.341"></a><span id="l8.341">     if ( msgCount &amp;&amp; !DeathSignalReceived() &amp;&amp; GetServerStateParser().LastCommandSuccessful())</span>
<a href="#l8.342"></a><span id="l8.342">     {</span>
<a href="#l8.343"></a><span id="l8.343">       // Tell the url that it should store the msg fetch results offline,</span>
<a href="#l8.344"></a><span id="l8.344">       // while we're dumping the messages, and then restore the setting.</span>
<a href="#l8.345"></a><span id="l8.345">       PRBool wasStoringOffline;</span>
<a href="#l8.346"></a><span id="l8.346">       m_runningUrl-&gt;GetStoreResultsOffline(&amp;wasStoringOffline);</span>
<a href="#l8.347"></a><span id="l8.347">       m_runningUrl-&gt;SetStoreResultsOffline(PR_TRUE);</span>
<a href="#l8.348"></a><span id="l8.348" class="difflineplus">+      m_progressIndex = 0;</span>
<a href="#l8.349"></a><span id="l8.349" class="difflineplus">+      m_progressCount = msgCount;</span>
<a href="#l8.350"></a><span id="l8.350">       FolderMsgDump(msgIdList, msgCount, kEveryThingRFC822Peek);</span>
<a href="#l8.351"></a><span id="l8.351">       m_runningUrl-&gt;SetStoreResultsOffline(wasStoringOffline);</span>
<a href="#l8.352"></a><span id="l8.352">     }</span>
<a href="#l8.353"></a><span id="l8.353">   }</span>
<a href="#l8.354"></a><span id="l8.354">   if (DeathSignalReceived())</span>
<a href="#l8.355"></a><span id="l8.355">     GetServerStateParser().ResetFlagInfo();</span>
<a href="#l8.356"></a><span id="l8.356"> </span>
<a href="#l8.357"></a><span id="l8.357">   NS_IF_RELEASE(new_spec);</span>
<a href="#l8.358"></a><span id="l8.358"> }</span>
<a href="#l8.359"></a><span id="l8.359"> </span>
<a href="#l8.360"></a><span id="l8.360" class="difflineminus">-void nsImapProtocol::UpdatedMailboxSpec(nsImapMailboxSpec *aSpec)</span>
<a href="#l8.361"></a><span id="l8.361" class="difflineminus">-{</span>
<a href="#l8.362"></a><span id="l8.362" class="difflineminus">-  if (m_imapMailFolderSink)</span>
<a href="#l8.363"></a><span id="l8.363" class="difflineminus">-    m_imapMailFolderSink-&gt;UpdateImapMailboxInfo(this, aSpec);</span>
<a href="#l8.364"></a><span id="l8.364" class="difflineminus">-}</span>
<a href="#l8.365"></a><span id="l8.365" class="difflineminus">-</span>
<a href="#l8.366"></a><span id="l8.366"> void nsImapProtocol::FolderHeaderDump(PRUint32 *msgUids, PRUint32 msgCount)</span>
<a href="#l8.367"></a><span id="l8.367"> {</span>
<a href="#l8.368"></a><span id="l8.368">   FolderMsgDump(msgUids, msgCount, kHeadersRFC822andUid);</span>
<a href="#l8.369"></a><span id="l8.369"> }</span>
<a href="#l8.370"></a><span id="l8.370"> </span>
<a href="#l8.371"></a><span id="l8.371"> void nsImapProtocol::FolderMsgDump(PRUint32 *msgUids, PRUint32 msgCount, nsIMAPeFetchFields fields)</span>
<a href="#l8.372"></a><span id="l8.372"> {</span>
<a href="#l8.373"></a><span id="l8.373">   // lets worry about this progress stuff later.</span>
<a href="#l8.374"></a><span id="l8.374" class="difflineat">@@ -4215,62 +4239,34 @@ void nsImapProtocol::FolderMsgDump(PRUin</span>
<a href="#l8.375"></a><span id="l8.375">   case kFlags:</span>
<a href="#l8.376"></a><span id="l8.376">     SetProgressString(IMAP_RECEIVING_MESSAGE_FLAGS_OF);</span>
<a href="#l8.377"></a><span id="l8.377">     break;</span>
<a href="#l8.378"></a><span id="l8.378">   default:</span>
<a href="#l8.379"></a><span id="l8.379">     SetProgressString(IMAP_FOLDER_RECEIVING_MESSAGE_OF);</span>
<a href="#l8.380"></a><span id="l8.380">     break;</span>
<a href="#l8.381"></a><span id="l8.381">   }</span>
<a href="#l8.382"></a><span id="l8.382"> </span>
<a href="#l8.383"></a><span id="l8.383" class="difflineminus">-  m_progressIndex = 0;</span>
<a href="#l8.384"></a><span id="l8.384" class="difflineminus">-  m_progressCount = msgCount;</span>
<a href="#l8.385"></a><span id="l8.385">   FolderMsgDumpLoop(msgUids, msgCount, fields);</span>
<a href="#l8.386"></a><span id="l8.386"> </span>
<a href="#l8.387"></a><span id="l8.387">   SetProgressString(0);</span>
<a href="#l8.388"></a><span id="l8.388"> }</span>
<a href="#l8.389"></a><span id="l8.389"> </span>
<a href="#l8.390"></a><span id="l8.390" class="difflineminus">-void nsImapProtocol::WaitForPotentialListOfMsgsToFetch(PRUint32 **msgIdList, PRUint32 &amp;msgCount)</span>
<a href="#l8.391"></a><span id="l8.391" class="difflineminus">-{</span>
<a href="#l8.392"></a><span id="l8.392" class="difflineminus">-  PRIntervalTime sleepTime = kImapSleepTime;</span>
<a href="#l8.393"></a><span id="l8.393" class="difflineminus">-</span>
<a href="#l8.394"></a><span id="l8.394" class="difflineminus">-  ReentrantMonitorAutoEnter fetchListMon(m_fetchMsgListMonitor);</span>
<a href="#l8.395"></a><span id="l8.395" class="difflineminus">-  while(!m_fetchMsgListIsNew &amp;&amp; !DeathSignalReceived())</span>
<a href="#l8.396"></a><span id="l8.396" class="difflineminus">-    fetchListMon.Wait(sleepTime);</span>
<a href="#l8.397"></a><span id="l8.397" class="difflineminus">-  m_fetchMsgListIsNew = PR_FALSE;</span>
<a href="#l8.398"></a><span id="l8.398" class="difflineminus">-</span>
<a href="#l8.399"></a><span id="l8.399" class="difflineminus">-  *msgIdList = m_fetchMsgIdList;</span>
<a href="#l8.400"></a><span id="l8.400" class="difflineminus">-  msgCount   = m_fetchCount;</span>
<a href="#l8.401"></a><span id="l8.401" class="difflineminus">-}</span>
<a href="#l8.402"></a><span id="l8.402" class="difflineminus">-</span>
<a href="#l8.403"></a><span id="l8.403"> void nsImapProtocol::WaitForPotentialListOfBodysToFetch(PRUint32 **msgIdList, PRUint32 &amp;msgCount)</span>
<a href="#l8.404"></a><span id="l8.404"> {</span>
<a href="#l8.405"></a><span id="l8.405">   PRIntervalTime sleepTime = kImapSleepTime;</span>
<a href="#l8.406"></a><span id="l8.406"> </span>
<a href="#l8.407"></a><span id="l8.407" class="difflineminus">-  ReentrantMonitorAutoEnter fetchListMon(m_fetchMsgListMonitor);</span>
<a href="#l8.408"></a><span id="l8.408" class="difflineplus">+  ReentrantMonitorAutoEnter fetchListMon(m_fetchBodyListMonitor);</span>
<a href="#l8.409"></a><span id="l8.409">   while(!m_fetchBodyListIsNew &amp;&amp; !DeathSignalReceived())</span>
<a href="#l8.410"></a><span id="l8.410">     fetchListMon.Wait(sleepTime);</span>
<a href="#l8.411"></a><span id="l8.411">   m_fetchBodyListIsNew = PR_FALSE;</span>
<a href="#l8.412"></a><span id="l8.412"> </span>
<a href="#l8.413"></a><span id="l8.413">   *msgIdList = m_fetchBodyIdList;</span>
<a href="#l8.414"></a><span id="l8.414">   msgCount   = m_fetchBodyCount;</span>
<a href="#l8.415"></a><span id="l8.415"> }</span>
<a href="#l8.416"></a><span id="l8.416"> </span>
<a href="#l8.417"></a><span id="l8.417" class="difflineminus">-// libmsg uses this to notify a running imap url about the message headers it should</span>
<a href="#l8.418"></a><span id="l8.418" class="difflineminus">-// download while opening a folder. Generally, the imap thread will be blocked</span>
<a href="#l8.419"></a><span id="l8.419" class="difflineminus">-// in WaitForPotentialListOfMsgsToFetch waiting for this notification.</span>
<a href="#l8.420"></a><span id="l8.420" class="difflineminus">-NS_IMETHODIMP nsImapProtocol::NotifyHdrsToDownload(PRUint32 *keys, PRUint32 keyCount)</span>
<a href="#l8.421"></a><span id="l8.421" class="difflineminus">-{</span>
<a href="#l8.422"></a><span id="l8.422" class="difflineminus">-  ReentrantMonitorAutoEnter fetchListMon(m_fetchMsgListMonitor);</span>
<a href="#l8.423"></a><span id="l8.423" class="difflineminus">-  m_fetchMsgIdList = keys;</span>
<a href="#l8.424"></a><span id="l8.424" class="difflineminus">-  m_fetchCount    = keyCount;</span>
<a href="#l8.425"></a><span id="l8.425" class="difflineminus">-  m_fetchMsgListIsNew = PR_TRUE;</span>
<a href="#l8.426"></a><span id="l8.426" class="difflineminus">-  fetchListMon.Notify();</span>
<a href="#l8.427"></a><span id="l8.427" class="difflineminus">-  return NS_OK;</span>
<a href="#l8.428"></a><span id="l8.428" class="difflineminus">-}</span>
<a href="#l8.429"></a><span id="l8.429" class="difflineminus">-</span>
<a href="#l8.430"></a><span id="l8.430"> // libmsg uses this to notify a running imap url about message bodies it should download.</span>
<a href="#l8.431"></a><span id="l8.431"> // why not just have libmsg explicitly download the message bodies?</span>
<a href="#l8.432"></a><span id="l8.432"> NS_IMETHODIMP nsImapProtocol::NotifyBodysToDownload(PRUint32 *keys, PRUint32 keyCount)</span>
<a href="#l8.433"></a><span id="l8.433"> {</span>
<a href="#l8.434"></a><span id="l8.434">   ReentrantMonitorAutoEnter fetchListMon(m_fetchBodyListMonitor);</span>
<a href="#l8.435"></a><span id="l8.435">   PR_FREEIF(m_fetchBodyIdList);</span>
<a href="#l8.436"></a><span id="l8.436">   m_fetchBodyIdList = (PRUint32 *) PR_MALLOC(keyCount * sizeof(PRUint32));</span>
<a href="#l8.437"></a><span id="l8.437">   if (m_fetchBodyIdList)</span>
<a href="#l8.438"></a><span id="l8.438" class="difflineat">@@ -4377,28 +4373,24 @@ void nsImapProtocol::PeriodicBiff()</span>
<a href="#l8.439"></a><span id="l8.439"> }</span>
<a href="#l8.440"></a><span id="l8.440"> </span>
<a href="#l8.441"></a><span id="l8.441"> void nsImapProtocol::SendSetBiffIndicatorEvent(nsMsgBiffState newState)</span>
<a href="#l8.442"></a><span id="l8.442"> {</span>
<a href="#l8.443"></a><span id="l8.443">     if (m_imapMailFolderSink)</span>
<a href="#l8.444"></a><span id="l8.444">       m_imapMailFolderSink-&gt;SetBiffStateAndUpdate(newState);</span>
<a href="#l8.445"></a><span id="l8.445"> }</span>
<a href="#l8.446"></a><span id="l8.446"> </span>
<a href="#l8.447"></a><span id="l8.447" class="difflineminus">-</span>
<a href="#l8.448"></a><span id="l8.448" class="difflineminus">-</span>
<a href="#l8.449"></a><span id="l8.449"> // We get called to see if there is mail waiting for us at the server, even if it may have been</span>
<a href="#l8.450"></a><span id="l8.450"> // read elsewhere. We just want to know if we should download headers or not.</span>
<a href="#l8.451"></a><span id="l8.451"> </span>
<a href="#l8.452"></a><span id="l8.452"> PRBool nsImapProtocol::CheckNewMail()</span>
<a href="#l8.453"></a><span id="l8.453"> {</span>
<a href="#l8.454"></a><span id="l8.454">   return m_checkForNewMailDownloadsHeaders;</span>
<a href="#l8.455"></a><span id="l8.455"> }</span>
<a href="#l8.456"></a><span id="l8.456"> </span>
<a href="#l8.457"></a><span id="l8.457" class="difflineminus">-</span>
<a href="#l8.458"></a><span id="l8.458" class="difflineminus">-</span>
<a href="#l8.459"></a><span id="l8.459"> /* static */ void nsImapProtocol::LogImapUrl(const char *logMsg, nsIImapUrl *imapUrl)</span>
<a href="#l8.460"></a><span id="l8.460"> {</span>
<a href="#l8.461"></a><span id="l8.461">   // nsImapProtocol is not always constructed before this static method is called</span>
<a href="#l8.462"></a><span id="l8.462">   if (!IMAP)</span>
<a href="#l8.463"></a><span id="l8.463">     IMAP = PR_NewLogModule(&quot;IMAP&quot;);</span>
<a href="#l8.464"></a><span id="l8.464"> </span>
<a href="#l8.465"></a><span id="l8.465">   if (PR_LOG_TEST(IMAP, PR_LOG_ALWAYS))</span>
<a href="#l8.466"></a><span id="l8.466">   {</span>
<a href="#l8.467"></a><span id="l8.467" class="difflineat">@@ -5340,37 +5332,18 @@ nsImapProtocol::HandleMemoryFailure()</span>
<a href="#l8.468"></a><span id="l8.468">     // **** jefft fix me!!!!!! ******</span>
<a href="#l8.469"></a><span id="l8.469">     // m_imapThreadIsRunning = PR_FALSE;</span>
<a href="#l8.470"></a><span id="l8.470">     // SetConnectionStatus(-1);</span>
<a href="#l8.471"></a><span id="l8.471">     PR_CExitMonitor(this);</span>
<a href="#l8.472"></a><span id="l8.472"> }</span>
<a href="#l8.473"></a><span id="l8.473"> </span>
<a href="#l8.474"></a><span id="l8.474"> void nsImapProtocol::HandleCurrentUrlError()</span>
<a href="#l8.475"></a><span id="l8.475"> {</span>
<a href="#l8.476"></a><span id="l8.476" class="difflineminus">-#ifdef UNREADY_CODE</span>
<a href="#l8.477"></a><span id="l8.477" class="difflineminus">-  if (fCurrentUrl-&gt;GetIMAPurlType() == TIMAPUrl::kSelectFolder)</span>
<a href="#l8.478"></a><span id="l8.478" class="difflineminus">-  {</span>
<a href="#l8.479"></a><span id="l8.479" class="difflineminus">-    // let the front end know the select failed so they</span>
<a href="#l8.480"></a><span id="l8.480" class="difflineminus">-    // don't leave the view without a database.</span>
<a href="#l8.481"></a><span id="l8.481" class="difflineminus">-    nsImapMailboxSpec *notSelectedSpec = new nsImapMailboxSpec;</span>
<a href="#l8.482"></a><span id="l8.482" class="difflineminus">-    if (notSelectedSpec)</span>
<a href="#l8.483"></a><span id="l8.483" class="difflineminus">-    {</span>
<a href="#l8.484"></a><span id="l8.484" class="difflineminus">-      NS_ADDREF(notSelectedSpec);</span>
<a href="#l8.485"></a><span id="l8.485" class="difflineminus">-      notSelectedSpec-&gt;mAllocatedPathName = fCurrentUrl-&gt;CreateCanonicalSourceFolderPathString();</span>
<a href="#l8.486"></a><span id="l8.486" class="difflineminus">-      notSelectedSpec-&gt;mHostName = fCurrentUrl-&gt;GetUrlHost();</span>
<a href="#l8.487"></a><span id="l8.487" class="difflineminus">-      notSelectedSpec-&gt;mFolderSelected = PR_FALSE;</span>
<a href="#l8.488"></a><span id="l8.488" class="difflineminus">-      notSelectedSpec-&gt;mFlagState = nsnull;</span>
<a href="#l8.489"></a><span id="l8.489" class="difflineminus">-      notSelectedSpec-&gt;mOnlineVerified = PR_FALSE;</span>
<a href="#l8.490"></a><span id="l8.490" class="difflineminus">-      UpdatedMailboxSpec(notSelectedSpec);</span>
<a href="#l8.491"></a><span id="l8.491" class="difflineminus">-    }</span>
<a href="#l8.492"></a><span id="l8.492" class="difflineminus">-  }</span>
<a href="#l8.493"></a><span id="l8.493" class="difflineminus">-  else</span>
<a href="#l8.494"></a><span id="l8.494" class="difflineminus">-#endif</span>
<a href="#l8.495"></a><span id="l8.495" class="difflineminus">-    // this is to handle a move/copy failing, especially because the user</span>
<a href="#l8.496"></a><span id="l8.496" class="difflineminus">-    // cancelled the password prompt.</span>
<a href="#l8.497"></a><span id="l8.497" class="difflineplus">+  // This is to handle a move/copy failing, especially because the user</span>
<a href="#l8.498"></a><span id="l8.498" class="difflineplus">+  // cancelled the password prompt.</span>
<a href="#l8.499"></a><span id="l8.499">   nsresult res;</span>
<a href="#l8.500"></a><span id="l8.500">   res = m_runningUrl-&gt;GetImapAction(&amp;m_imapAction);</span>
<a href="#l8.501"></a><span id="l8.501">     if (m_imapAction == nsIImapUrl::nsImapOfflineToOnlineMove || m_imapAction == nsIImapUrl::nsImapAppendMsgFromFile</span>
<a href="#l8.502"></a><span id="l8.502">       || m_imapAction == nsIImapUrl::nsImapAppendDraftFromFile)</span>
<a href="#l8.503"></a><span id="l8.503">   {</span>
<a href="#l8.504"></a><span id="l8.504">     if (m_imapMailFolderSink)</span>
<a href="#l8.505"></a><span id="l8.505">       m_imapMailFolderSink-&gt;OnlineCopyCompleted(this, ImapOnlineCopyStateType::kFailedCopy);</span>
<a href="#l8.506"></a><span id="l8.506">   }</span>
<a href="#l8.507"></a><span id="l8.507" class="difflineat">@@ -8735,17 +8708,17 @@ nsresult nsImapMockChannel::NotifyStartE</span>
<a href="#l8.508"></a><span id="l8.508">   if (imapUrl)</span>
<a href="#l8.509"></a><span id="l8.509">   {</span>
<a href="#l8.510"></a><span id="l8.510">     nsCOMPtr&lt;nsIImapMailFolderSink&gt; folderSink;</span>
<a href="#l8.511"></a><span id="l8.511">     rv = imapUrl-&gt;GetImapMailFolderSink(getter_AddRefs(folderSink));</span>
<a href="#l8.512"></a><span id="l8.512">     if (folderSink)</span>
<a href="#l8.513"></a><span id="l8.513">     {</span>
<a href="#l8.514"></a><span id="l8.514">       nsCOMPtr&lt;nsIMsgMailNewsUrl&gt; mailUrl = do_QueryInterface(m_url);</span>
<a href="#l8.515"></a><span id="l8.515">       rv = folderSink-&gt;SetUrlState(nsnull /* we don't know the protocol */,</span>
<a href="#l8.516"></a><span id="l8.516" class="difflineminus">-                                   mailUrl, start, m_cancelStatus);</span>
<a href="#l8.517"></a><span id="l8.517" class="difflineplus">+                                   mailUrl, start, PR_FALSE, m_cancelStatus);</span>
<a href="#l8.518"></a><span id="l8.518"> </span>
<a href="#l8.519"></a><span id="l8.519">       // Required for killing ImapProtocol thread</span>
<a href="#l8.520"></a><span id="l8.520">       if (m_cancelStatus != NS_OK &amp;&amp; imapProtocol)</span>
<a href="#l8.521"></a><span id="l8.521">         imapProtocol-&gt;TellThreadToDie(PR_FALSE);</span>
<a href="#l8.522"></a><span id="l8.522">     }</span>
<a href="#l8.523"></a><span id="l8.523">   }</span>
<a href="#l8.524"></a><span id="l8.524">   return rv;</span>
<a href="#l8.525"></a><span id="l8.525"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapProtocol.h</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -389,17 +389,16 @@ private:</span>
<a href="#l9.4"></a><span id="l9.4">   typedef mozilla::Monitor ReentrantMonitor;</span>
<a href="#l9.5"></a><span id="l9.5"> #endif</span>
<a href="#l9.6"></a><span id="l9.6">   ReentrantMonitor m_dataAvailableMonitor;   // used to notify the arrival of data from the server</span>
<a href="#l9.7"></a><span id="l9.7">   ReentrantMonitor m_urlReadyToRunMonitor;   // used to notify the arrival of a new url to be processed</span>
<a href="#l9.8"></a><span id="l9.8">   ReentrantMonitor m_pseudoInterruptMonitor;</span>
<a href="#l9.9"></a><span id="l9.9">   ReentrantMonitor m_dataMemberMonitor;</span>
<a href="#l9.10"></a><span id="l9.10">   ReentrantMonitor m_threadDeathMonitor;</span>
<a href="#l9.11"></a><span id="l9.11">   ReentrantMonitor m_waitForBodyIdsMonitor;</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-  ReentrantMonitor m_fetchMsgListMonitor;</span>
<a href="#l9.13"></a><span id="l9.13">   ReentrantMonitor m_fetchBodyListMonitor;</span>
<a href="#l9.14"></a><span id="l9.14">   ReentrantMonitor m_passwordReadyMonitor;</span>
<a href="#l9.15"></a><span id="l9.15">   mozilla::Mutex mLock;</span>
<a href="#l9.16"></a><span id="l9.16">   // If we get an async password prompt, this is where the UI thread</span>
<a href="#l9.17"></a><span id="l9.17">   // stores the password, before notifying the imap thread of the password</span>
<a href="#l9.18"></a><span id="l9.18">   // via the m_passwordReadyMonitor.</span>
<a href="#l9.19"></a><span id="l9.19">   nsCString m_password;</span>
<a href="#l9.20"></a><span id="l9.20">   // Set to the result of nsImapServer::PromptPassword</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineat">@@ -434,36 +433,31 @@ private:</span>
<a href="#l9.22"></a><span id="l9.22">   virtual void ParseIMAPandCheckForNewMail(const char* commandString =</span>
<a href="#l9.23"></a><span id="l9.23">     nsnull, PRBool ignoreBadNOResponses = PR_FALSE);</span>
<a href="#l9.24"></a><span id="l9.24">   // biff</span>
<a href="#l9.25"></a><span id="l9.25">   void  PeriodicBiff();</span>
<a href="#l9.26"></a><span id="l9.26">   void  SendSetBiffIndicatorEvent(nsMsgBiffState newState);</span>
<a href="#l9.27"></a><span id="l9.27">   PRBool  CheckNewMail();</span>
<a href="#l9.28"></a><span id="l9.28"> </span>
<a href="#l9.29"></a><span id="l9.29">   // folder opening and listing header functions</span>
<a href="#l9.30"></a><span id="l9.30" class="difflineminus">-  void UpdatedMailboxSpec(nsImapMailboxSpec *aSpec);</span>
<a href="#l9.31"></a><span id="l9.31">   void FolderHeaderDump(PRUint32 *msgUids, PRUint32 msgCount);</span>
<a href="#l9.32"></a><span id="l9.32">   void FolderMsgDump(PRUint32 *msgUids, PRUint32 msgCount, nsIMAPeFetchFields fields);</span>
<a href="#l9.33"></a><span id="l9.33">   void FolderMsgDumpLoop(PRUint32 *msgUids, PRUint32 msgCount, nsIMAPeFetchFields fields);</span>
<a href="#l9.34"></a><span id="l9.34" class="difflineminus">-  void WaitForPotentialListOfMsgsToFetch(PRUint32 **msgIdList, PRUint32 &amp;msgCount);</span>
<a href="#l9.35"></a><span id="l9.35">   void WaitForPotentialListOfBodysToFetch(PRUint32 **msgIdList, PRUint32 &amp;msgCount);</span>
<a href="#l9.36"></a><span id="l9.36">   void HeaderFetchCompleted();</span>
<a href="#l9.37"></a><span id="l9.37">   void UploadMessageFromFile(nsIFile* file, const char* mailboxName, PRTime date,</span>
<a href="#l9.38"></a><span id="l9.38">     imapMessageFlagsType flags, nsCString &amp;keywords);</span>
<a href="#l9.39"></a><span id="l9.39"> </span>
<a href="#l9.40"></a><span id="l9.40">   // mailbox name utilities.</span>
<a href="#l9.41"></a><span id="l9.41">   void CreateEscapedMailboxName(const char *rawName, nsCString &amp;escapedName);</span>
<a href="#l9.42"></a><span id="l9.42">   void SetupMessageFlagsString(nsCString &amp; flagString,</span>
<a href="#l9.43"></a><span id="l9.43">     imapMessageFlagsType flags,</span>
<a href="#l9.44"></a><span id="l9.44">     PRUint16 userFlags);</span>
<a href="#l9.45"></a><span id="l9.45"> </span>
<a href="#l9.46"></a><span id="l9.46" class="difflineminus">-  // header listing data</span>
<a href="#l9.47"></a><span id="l9.47" class="difflineminus">-  PRBool    m_fetchMsgListIsNew;</span>
<a href="#l9.48"></a><span id="l9.48" class="difflineminus">-  PRUint32  m_fetchCount;</span>
<a href="#l9.49"></a><span id="l9.49" class="difflineminus">-  PRUint32  *m_fetchMsgIdList;</span>
<a href="#l9.50"></a><span id="l9.50" class="difflineplus">+  // body fetching listing data</span>
<a href="#l9.51"></a><span id="l9.51">   PRBool    m_fetchBodyListIsNew;</span>
<a href="#l9.52"></a><span id="l9.52">   PRUint32  m_fetchBodyCount;</span>
<a href="#l9.53"></a><span id="l9.53">   PRUint32  *m_fetchBodyIdList;</span>
<a href="#l9.54"></a><span id="l9.54"> </span>
<a href="#l9.55"></a><span id="l9.55">   // initialization function given a new url and transport layer</span>
<a href="#l9.56"></a><span id="l9.56">   nsresult  SetupWithUrl(nsIURI * aURL, nsISupports* aConsumer);</span>
<a href="#l9.57"></a><span id="l9.57">   void ReleaseUrlState(PRBool rerunningUrl); // release any state that is stored on a per action basis.</span>
<a href="#l9.58"></a><span id="l9.58">   /**</span>
<a href="#l9.59"></a><span id="l9.59" class="difflineat">@@ -771,21 +765,21 @@ protected:</span>
<a href="#l9.60"></a><span id="l9.60"> </span>
<a href="#l9.61"></a><span id="l9.61"> // This class contains the name of a mailbox and whether or not</span>
<a href="#l9.62"></a><span id="l9.62"> // its children have been listed.</span>
<a href="#l9.63"></a><span id="l9.63"> class nsIMAPMailboxInfo</span>
<a href="#l9.64"></a><span id="l9.64"> {</span>
<a href="#l9.65"></a><span id="l9.65"> public:</span>
<a href="#l9.66"></a><span id="l9.66">   nsIMAPMailboxInfo(const nsACString &amp;aName, char aDelimiter);</span>
<a href="#l9.67"></a><span id="l9.67">   virtual ~nsIMAPMailboxInfo();</span>
<a href="#l9.68"></a><span id="l9.68" class="difflineminus">-  </span>
<a href="#l9.69"></a><span id="l9.69" class="difflineplus">+</span>
<a href="#l9.70"></a><span id="l9.70">   void   SetChildrenListed(PRBool childrenListed);</span>
<a href="#l9.71"></a><span id="l9.71">   PRBool GetChildrenListed();</span>
<a href="#l9.72"></a><span id="l9.72">   const  nsACString&amp; GetMailboxName();</span>
<a href="#l9.73"></a><span id="l9.73">   char   GetDelimiter();</span>
<a href="#l9.74"></a><span id="l9.74" class="difflineminus">-  </span>
<a href="#l9.75"></a><span id="l9.75" class="difflineplus">+</span>
<a href="#l9.76"></a><span id="l9.76"> protected:</span>
<a href="#l9.77"></a><span id="l9.77">   nsCString mMailboxName;</span>
<a href="#l9.78"></a><span id="l9.78">   PRBool   mChildrenListed;</span>
<a href="#l9.79"></a><span id="l9.79">   char     mDelimiter;</span>
<a href="#l9.80"></a><span id="l9.80"> };</span>
<a href="#l9.81"></a><span id="l9.81"> </span>
<a href="#l9.82"></a><span id="l9.82"> #endif  // nsImapProtocol_h___</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/mailnews/imap/src/nsImapUrl.cpp</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapUrl.cpp</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -81,16 +81,17 @@ nsImapUrl::nsImapUrl() : mLock(&quot;nsImapUr</span>
<a href="#l10.4"></a><span id="l10.4">   m_mimePartSelectorDetected = PR_FALSE;</span>
<a href="#l10.5"></a><span id="l10.5">   m_allowContentChange = PR_TRUE;  // assume we can do MPOD.</span>
<a href="#l10.6"></a><span id="l10.6">   m_fetchPartsOnDemand = PR_FALSE; // but assume we're not doing it :-)</span>
<a href="#l10.7"></a><span id="l10.7">   m_msgLoadingFromCache = PR_FALSE;</span>
<a href="#l10.8"></a><span id="l10.8">   m_storeResultsOffline = PR_FALSE;</span>
<a href="#l10.9"></a><span id="l10.9">   m_storeOfflineOnFallback = PR_FALSE;</span>
<a href="#l10.10"></a><span id="l10.10">   m_localFetchOnly = PR_FALSE;</span>
<a href="#l10.11"></a><span id="l10.11">   m_rerunningUrl = PR_FALSE;</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineplus">+  m_moreHeadersToDownload = PR_FALSE;</span>
<a href="#l10.13"></a><span id="l10.13">   m_externalLinkUrl = PR_TRUE; // we'll start this at true, and set it false in nsImapService::CreateStartOfImapUrl</span>
<a href="#l10.14"></a><span id="l10.14">   m_contentModified = IMAP_CONTENT_NOT_MODIFIED;</span>
<a href="#l10.15"></a><span id="l10.15">   m_validUrl = PR_TRUE;  // assume the best.</span>
<a href="#l10.16"></a><span id="l10.16">   m_flags = 0;</span>
<a href="#l10.17"></a><span id="l10.17">   m_extraStatus = ImapStatusNone;</span>
<a href="#l10.18"></a><span id="l10.18">   m_onlineSubDirSeparator = '/';</span>
<a href="#l10.19"></a><span id="l10.19"> </span>
<a href="#l10.20"></a><span id="l10.20">   // ** jt - the following are not ref counted</span>
<a href="#l10.21"></a><span id="l10.21" class="difflineat">@@ -1252,16 +1253,17 @@ NS_IMETHODIMP nsImapUrl::GetUri(char** a</span>
<a href="#l10.22"></a><span id="l10.22"> </span>
<a href="#l10.23"></a><span id="l10.23"> NS_IMPL_GETSET(nsImapUrl, AddDummyEnvelope, PRBool, m_addDummyEnvelope)</span>
<a href="#l10.24"></a><span id="l10.24"> NS_IMPL_GETSET(nsImapUrl, CanonicalLineEnding, PRBool, m_canonicalLineEnding)</span>
<a href="#l10.25"></a><span id="l10.25"> NS_IMPL_GETTER(nsImapUrl::GetMsgLoadingFromCache, PRBool, m_msgLoadingFromCache)</span>
<a href="#l10.26"></a><span id="l10.26"> NS_IMPL_GETSET(nsImapUrl, LocalFetchOnly, PRBool, m_localFetchOnly)</span>
<a href="#l10.27"></a><span id="l10.27"> NS_IMPL_GETSET(nsImapUrl, ExternalLinkUrl, PRBool, m_externalLinkUrl)</span>
<a href="#l10.28"></a><span id="l10.28"> NS_IMPL_GETSET(nsImapUrl, RerunningUrl, PRBool, m_rerunningUrl)</span>
<a href="#l10.29"></a><span id="l10.29"> NS_IMPL_GETSET(nsImapUrl, ValidUrl, PRBool, m_validUrl)</span>
<a href="#l10.30"></a><span id="l10.30" class="difflineplus">+NS_IMPL_GETSET(nsImapUrl, MoreHeadersToDownload, PRBool, m_moreHeadersToDownload)</span>
<a href="#l10.31"></a><span id="l10.31"> </span>
<a href="#l10.32"></a><span id="l10.32"> NS_IMETHODIMP nsImapUrl::SetMsgLoadingFromCache(PRBool loadingFromCache)</span>
<a href="#l10.33"></a><span id="l10.33"> {</span>
<a href="#l10.34"></a><span id="l10.34">   nsresult rv = NS_OK;</span>
<a href="#l10.35"></a><span id="l10.35">   m_msgLoadingFromCache = loadingFromCache;</span>
<a href="#l10.36"></a><span id="l10.36">   return rv;</span>
<a href="#l10.37"></a><span id="l10.37"> }</span>
<a href="#l10.38"></a><span id="l10.38"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/mailnews/imap/src/nsImapUrl.h</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/mailnews/imap/src/nsImapUrl.h</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -123,16 +123,17 @@ protected:</span>
<a href="#l11.4"></a><span id="l11.4">   PRPackedBool m_fetchPartsOnDemand; // if PR_TRUE, we should fetch leave parts on server.</span>
<a href="#l11.5"></a><span id="l11.5">   PRPackedBool m_msgLoadingFromCache; // if PR_TRUE, we might need to mark read on server</span>
<a href="#l11.6"></a><span id="l11.6">   PRPackedBool m_externalLinkUrl; // if PR_TRUE, we're running this url because the user</span>
<a href="#l11.7"></a><span id="l11.7">   // True if the fetch results should be put in the offline store.</span>
<a href="#l11.8"></a><span id="l11.8">   PRPackedBool m_storeResultsOffline;</span>
<a href="#l11.9"></a><span id="l11.9">   PRPackedBool m_storeOfflineOnFallback;</span>
<a href="#l11.10"></a><span id="l11.10">   PRPackedBool m_localFetchOnly;</span>
<a href="#l11.11"></a><span id="l11.11">   PRPackedBool m_rerunningUrl; // first attempt running this failed with connection error; retrying</span>
<a href="#l11.12"></a><span id="l11.12" class="difflineplus">+  PRPackedBool m_moreHeadersToDownload;</span>
<a href="#l11.13"></a><span id="l11.13">   nsImapContentModifiedType  m_contentModified;</span>
<a href="#l11.14"></a><span id="l11.14"> </span>
<a href="#l11.15"></a><span id="l11.15">   PRInt32    m_extraStatus;</span>
<a href="#l11.16"></a><span id="l11.16"> </span>
<a href="#l11.17"></a><span id="l11.17">   nsCString  m_userName;</span>
<a href="#l11.18"></a><span id="l11.18">   nsCString  m_serverKey;</span>
<a href="#l11.19"></a><span id="l11.19">   // event sinks</span>
<a href="#l11.20"></a><span id="l11.20">   imapMessageFlagsType  m_flags;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1">new file mode 100644</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineminus">--- /dev/null</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineplus">+++ b/mailnews/imap/test/unit/test_imapHdrChunking.js</span>
<a href="#l12.4"></a><span id="l12.4" class="difflineat">@@ -0,0 +1,171 @@</span>
<a href="#l12.5"></a><span id="l12.5" class="difflineplus">+/* ***** BEGIN LICENSE BLOCK *****</span>
<a href="#l12.6"></a><span id="l12.6" class="difflineplus">+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1</span>
<a href="#l12.7"></a><span id="l12.7" class="difflineplus">+ *</span>
<a href="#l12.8"></a><span id="l12.8" class="difflineplus">+ * The contents of this file are subject to the Mozilla Public License Version</span>
<a href="#l12.9"></a><span id="l12.9" class="difflineplus">+ * 1.1 (the &quot;License&quot;); you may not use this file except in compliance with</span>
<a href="#l12.10"></a><span id="l12.10" class="difflineplus">+ * the License. You may obtain a copy of the License at</span>
<a href="#l12.11"></a><span id="l12.11" class="difflineplus">+ * http://www.mozilla.org/MPL/</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineplus">+ *</span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+ * Software distributed under the License is distributed on an &quot;AS IS&quot; basis,</span>
<a href="#l12.14"></a><span id="l12.14" class="difflineplus">+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License</span>
<a href="#l12.15"></a><span id="l12.15" class="difflineplus">+ * for the specific language governing rights and limitations under the</span>
<a href="#l12.16"></a><span id="l12.16" class="difflineplus">+ * License.</span>
<a href="#l12.17"></a><span id="l12.17" class="difflineplus">+ *</span>
<a href="#l12.18"></a><span id="l12.18" class="difflineplus">+ * The Original Code is mozilla.org code.</span>
<a href="#l12.19"></a><span id="l12.19" class="difflineplus">+ *</span>
<a href="#l12.20"></a><span id="l12.20" class="difflineplus">+ * The Initial Developer of the Original Code is</span>
<a href="#l12.21"></a><span id="l12.21" class="difflineplus">+ *   The Mozilla Foundation</span>
<a href="#l12.22"></a><span id="l12.22" class="difflineplus">+ * Portions created by the Initial Developer are Copyright (C) 2011</span>
<a href="#l12.23"></a><span id="l12.23" class="difflineplus">+ * the Initial Developer. All Rights Reserved.</span>
<a href="#l12.24"></a><span id="l12.24" class="difflineplus">+ *</span>
<a href="#l12.25"></a><span id="l12.25" class="difflineplus">+ * Contributor(s):</span>
<a href="#l12.26"></a><span id="l12.26" class="difflineplus">+ * David Bienvenu &lt;bienvenu@mozilla.com&gt;</span>
<a href="#l12.27"></a><span id="l12.27" class="difflineplus">+ *</span>
<a href="#l12.28"></a><span id="l12.28" class="difflineplus">+ * Alternatively, the contents of this file may be used under the terms of</span>
<a href="#l12.29"></a><span id="l12.29" class="difflineplus">+ * either the GNU General Public License Version 2 or later (the &quot;GPL&quot;), or</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineplus">+ * the GNU Lesser General Public License Version 2.1 or later (the &quot;LGPL&quot;),</span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+ * in which case the provisions of the GPL or the LGPL are applicable instead</span>
<a href="#l12.32"></a><span id="l12.32" class="difflineplus">+ * of those above. If you wish to allow use of your version of this file only</span>
<a href="#l12.33"></a><span id="l12.33" class="difflineplus">+ * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l12.34"></a><span id="l12.34" class="difflineplus">+ * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l12.35"></a><span id="l12.35" class="difflineplus">+ * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l12.36"></a><span id="l12.36" class="difflineplus">+ * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l12.37"></a><span id="l12.37" class="difflineplus">+ * the provisions above, a recipient may use your version of this file under</span>
<a href="#l12.38"></a><span id="l12.38" class="difflineplus">+ * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l12.39"></a><span id="l12.39" class="difflineplus">+ *</span>
<a href="#l12.40"></a><span id="l12.40" class="difflineplus">+ * ***** END LICENSE BLOCK ***** */</span>
<a href="#l12.41"></a><span id="l12.41" class="difflineplus">+</span>
<a href="#l12.42"></a><span id="l12.42" class="difflineplus">+/*</span>
<a href="#l12.43"></a><span id="l12.43" class="difflineplus">+ * Tests imap msg header download chunking</span>
<a href="#l12.44"></a><span id="l12.44" class="difflineplus">+ */</span>
<a href="#l12.45"></a><span id="l12.45" class="difflineplus">+</span>
<a href="#l12.46"></a><span id="l12.46" class="difflineplus">+load(&quot;../../../resources/logHelper.js&quot;);</span>
<a href="#l12.47"></a><span id="l12.47" class="difflineplus">+load(&quot;../../../resources/mailTestUtils.js&quot;);</span>
<a href="#l12.48"></a><span id="l12.48" class="difflineplus">+load(&quot;../../../resources/asyncTestUtils.js&quot;);</span>
<a href="#l12.49"></a><span id="l12.49" class="difflineplus">+load(&quot;../../../resources/messageGenerator.js&quot;);</span>
<a href="#l12.50"></a><span id="l12.50" class="difflineplus">+</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineplus">+Components.utils.import(&quot;resource://gre/modules/Services.jsm&quot;);</span>
<a href="#l12.52"></a><span id="l12.52" class="difflineplus">+Components.utils.import(&quot;resource:///modules/mailServices.js&quot;);</span>
<a href="#l12.53"></a><span id="l12.53" class="difflineplus">+// javascript mime emitter functions</span>
<a href="#l12.54"></a><span id="l12.54" class="difflineplus">+</span>
<a href="#l12.55"></a><span id="l12.55" class="difflineplus">+// IMAP pump</span>
<a href="#l12.56"></a><span id="l12.56" class="difflineplus">+load(&quot;../../../resources/IMAPpump.js&quot;);</span>
<a href="#l12.57"></a><span id="l12.57" class="difflineplus">+</span>
<a href="#l12.58"></a><span id="l12.58" class="difflineplus">+setupIMAPPump();</span>
<a href="#l12.59"></a><span id="l12.59" class="difflineplus">+</span>
<a href="#l12.60"></a><span id="l12.60" class="difflineplus">+// Dummy message window so we can say the inbox is open in a window.</span>
<a href="#l12.61"></a><span id="l12.61" class="difflineplus">+var dummyMsgWindow =</span>
<a href="#l12.62"></a><span id="l12.62" class="difflineplus">+{</span>
<a href="#l12.63"></a><span id="l12.63" class="difflineplus">+  openFolder : gIMAPInbox,</span>
<a href="#l12.64"></a><span id="l12.64" class="difflineplus">+  QueryInterface: XPCOMUtils.generateQI([Ci.nsIMsgWindow,</span>
<a href="#l12.65"></a><span id="l12.65" class="difflineplus">+                                         Ci.nsISupportsWeakReference])</span>
<a href="#l12.66"></a><span id="l12.66" class="difflineplus">+};</span>
<a href="#l12.67"></a><span id="l12.67" class="difflineplus">+</span>
<a href="#l12.68"></a><span id="l12.68" class="difflineplus">+var mfnListener =</span>
<a href="#l12.69"></a><span id="l12.69" class="difflineplus">+{</span>
<a href="#l12.70"></a><span id="l12.70" class="difflineplus">+  _msgStreamed: false,</span>
<a href="#l12.71"></a><span id="l12.71" class="difflineplus">+  msgAdded: function msgAdded(aMsg)</span>
<a href="#l12.72"></a><span id="l12.72" class="difflineplus">+  {</span>
<a href="#l12.73"></a><span id="l12.73" class="difflineplus">+    if (!this._msgStreamed) {</span>
<a href="#l12.74"></a><span id="l12.74" class="difflineplus">+      // Try to fetch the message with UID 8. This will be the first header </span>
<a href="#l12.75"></a><span id="l12.75" class="difflineplus">+      // downloaded iff we fetch the newest hdrs first.</span>
<a href="#l12.76"></a><span id="l12.76" class="difflineplus">+      let messenger = Cc[&quot;@mozilla.org/messenger;1&quot;].createInstance(Ci.nsIMessenger);</span>
<a href="#l12.77"></a><span id="l12.77" class="difflineplus">+      let msgURI = gIMAPInbox.getUriForMsg(aMsg);</span>
<a href="#l12.78"></a><span id="l12.78" class="difflineplus">+      do_check_eq(aMsg.messageKey, 8);</span>
<a href="#l12.79"></a><span id="l12.79" class="difflineplus">+      let msgServ = messenger.messageServiceFromURI(msgURI);</span>
<a href="#l12.80"></a><span id="l12.80" class="difflineplus">+      msgServ.streamMessage(msgURI, gStreamListener, null, null, false, &quot;&quot;, false);</span>
<a href="#l12.81"></a><span id="l12.81" class="difflineplus">+      this._msgStreamed = true;</span>
<a href="#l12.82"></a><span id="l12.82" class="difflineplus">+    }</span>
<a href="#l12.83"></a><span id="l12.83" class="difflineplus">+  }</span>
<a href="#l12.84"></a><span id="l12.84" class="difflineplus">+};</span>
<a href="#l12.85"></a><span id="l12.85" class="difflineplus">+</span>
<a href="#l12.86"></a><span id="l12.86" class="difflineplus">+gStreamListener = {</span>
<a href="#l12.87"></a><span id="l12.87" class="difflineplus">+  QueryInterface : XPCOMUtils.generateQI([Ci.nsIStreamListener]),</span>
<a href="#l12.88"></a><span id="l12.88" class="difflineplus">+  _stream : null,</span>
<a href="#l12.89"></a><span id="l12.89" class="difflineplus">+  _gotStartRequest : false,</span>
<a href="#l12.90"></a><span id="l12.90" class="difflineplus">+  onStartRequest : function (aRequest, aContext) {</span>
<a href="#l12.91"></a><span id="l12.91" class="difflineplus">+    this._gotStartRequest = true;</span>
<a href="#l12.92"></a><span id="l12.92" class="difflineplus">+  },</span>
<a href="#l12.93"></a><span id="l12.93" class="difflineplus">+  onStopRequest : function (aRequest, aContext, aStatusCode) {</span>
<a href="#l12.94"></a><span id="l12.94" class="difflineplus">+    async_driver();</span>
<a href="#l12.95"></a><span id="l12.95" class="difflineplus">+  },</span>
<a href="#l12.96"></a><span id="l12.96" class="difflineplus">+  onDataAvailable : function (aRequest, aContext, aInputStream, aOff, aCount) {</span>
<a href="#l12.97"></a><span id="l12.97" class="difflineplus">+    if (this._stream == null) {</span>
<a href="#l12.98"></a><span id="l12.98" class="difflineplus">+      this._stream = Cc[&quot;@mozilla.org/scriptableinputstream;1&quot;].createInstance(Ci.nsIScriptableInputStream);</span>
<a href="#l12.99"></a><span id="l12.99" class="difflineplus">+      this._stream.init(aInputStream);</span>
<a href="#l12.100"></a><span id="l12.100" class="difflineplus">+    }</span>
<a href="#l12.101"></a><span id="l12.101" class="difflineplus">+    this._data += this._stream.read(aCount);</span>
<a href="#l12.102"></a><span id="l12.102" class="difflineplus">+  },</span>
<a href="#l12.103"></a><span id="l12.103" class="difflineplus">+};</span>
<a href="#l12.104"></a><span id="l12.104" class="difflineplus">+</span>
<a href="#l12.105"></a><span id="l12.105" class="difflineplus">+</span>
<a href="#l12.106"></a><span id="l12.106" class="difflineplus">+var tests = [</span>
<a href="#l12.107"></a><span id="l12.107" class="difflineplus">+  uploadImapMessages,</span>
<a href="#l12.108"></a><span id="l12.108" class="difflineplus">+  testMessageFetched,</span>
<a href="#l12.109"></a><span id="l12.109" class="difflineplus">+  testHdrsDownloaded,</span>
<a href="#l12.110"></a><span id="l12.110" class="difflineplus">+  endTest</span>
<a href="#l12.111"></a><span id="l12.111" class="difflineplus">+]</span>
<a href="#l12.112"></a><span id="l12.112" class="difflineplus">+</span>
<a href="#l12.113"></a><span id="l12.113" class="difflineplus">+// upload messages to the imap fake server Inbox</span>
<a href="#l12.114"></a><span id="l12.114" class="difflineplus">+function uploadImapMessages()</span>
<a href="#l12.115"></a><span id="l12.115" class="difflineplus">+{</span>
<a href="#l12.116"></a><span id="l12.116" class="difflineplus">+  // make 10 messges</span>
<a href="#l12.117"></a><span id="l12.117" class="difflineplus">+  let messageGenerator = new MessageGenerator();</span>
<a href="#l12.118"></a><span id="l12.118" class="difflineplus">+  let scenarioFactory = new MessageScenarioFactory(messageGenerator);</span>
<a href="#l12.119"></a><span id="l12.119" class="difflineplus">+</span>
<a href="#l12.120"></a><span id="l12.120" class="difflineplus">+  // build up a list of messages</span>
<a href="#l12.121"></a><span id="l12.121" class="difflineplus">+  let messages = [];</span>
<a href="#l12.122"></a><span id="l12.122" class="difflineplus">+  messages = messages.concat(scenarioFactory.directReply(10));</span>
<a href="#l12.123"></a><span id="l12.123" class="difflineplus">+</span>
<a href="#l12.124"></a><span id="l12.124" class="difflineplus">+  // Add 10 messages with uids 1-10.</span>
<a href="#l12.125"></a><span id="l12.125" class="difflineplus">+  let imapInbox = gIMAPDaemon.getMailbox(&quot;INBOX&quot;)</span>
<a href="#l12.126"></a><span id="l12.126" class="difflineplus">+  // Create the imapMessages and store them on the mailbox</span>
<a href="#l12.127"></a><span id="l12.127" class="difflineplus">+  messages.forEach(function (message)</span>
<a href="#l12.128"></a><span id="l12.128" class="difflineplus">+  {</span>
<a href="#l12.129"></a><span id="l12.129" class="difflineplus">+    let dataUri = Services.io.newURI(&quot;data:text/plain;base64,&quot; +</span>
<a href="#l12.130"></a><span id="l12.130" class="difflineplus">+                                      btoa(message.toMessageString()),</span>
<a href="#l12.131"></a><span id="l12.131" class="difflineplus">+                                     null, null);</span>
<a href="#l12.132"></a><span id="l12.132" class="difflineplus">+    imapInbox.addMessage(new imapMessage(dataUri.spec, imapInbox.uidnext++, []));</span>
<a href="#l12.133"></a><span id="l12.133" class="difflineplus">+  });</span>
<a href="#l12.134"></a><span id="l12.134" class="difflineplus">+  gIMAPInbox.updateFolderWithListener(null, asyncUrlListener);</span>
<a href="#l12.135"></a><span id="l12.135" class="difflineplus">+  yield false;</span>
<a href="#l12.136"></a><span id="l12.136" class="difflineplus">+}</span>
<a href="#l12.137"></a><span id="l12.137" class="difflineplus">+</span>
<a href="#l12.138"></a><span id="l12.138" class="difflineplus">+function testMessageFetched() {</span>
<a href="#l12.139"></a><span id="l12.139" class="difflineplus">+  // If we're really chunking, then the message fetch should have started before</span>
<a href="#l12.140"></a><span id="l12.140" class="difflineplus">+  // we finished the updateFolder URL.</span>
<a href="#l12.141"></a><span id="l12.141" class="difflineplus">+  do_check_true(gStreamListener._gotStartRequest);</span>
<a href="#l12.142"></a><span id="l12.142" class="difflineplus">+  // Should have only downloaded first chunk of headers when message</span>
<a href="#l12.143"></a><span id="l12.143" class="difflineplus">+  // has finished streaming.</span>
<a href="#l12.144"></a><span id="l12.144" class="difflineplus">+  do_check_eq(gIMAPInbox.msgDatabase.dBFolderInfo.numMessages, 3);</span>
<a href="#l12.145"></a><span id="l12.145" class="difflineplus">+  yield false;</span>
<a href="#l12.146"></a><span id="l12.146" class="difflineplus">+}</span>
<a href="#l12.147"></a><span id="l12.147" class="difflineplus">+</span>
<a href="#l12.148"></a><span id="l12.148" class="difflineplus">+function testHdrsDownloaded() {</span>
<a href="#l12.149"></a><span id="l12.149" class="difflineplus">+  // Make sure we got all 10 headers.</span>
<a href="#l12.150"></a><span id="l12.150" class="difflineplus">+  do_check_eq(gIMAPInbox.msgDatabase.dBFolderInfo.numMessages, 10);</span>
<a href="#l12.151"></a><span id="l12.151" class="difflineplus">+  yield true;</span>
<a href="#l12.152"></a><span id="l12.152" class="difflineplus">+}</span>
<a href="#l12.153"></a><span id="l12.153" class="difflineplus">+</span>
<a href="#l12.154"></a><span id="l12.154" class="difflineplus">+// Cleanup</span>
<a href="#l12.155"></a><span id="l12.155" class="difflineplus">+function endTest() {</span>
<a href="#l12.156"></a><span id="l12.156" class="difflineplus">+  teardownIMAPPump();</span>
<a href="#l12.157"></a><span id="l12.157" class="difflineplus">+}</span>
<a href="#l12.158"></a><span id="l12.158" class="difflineplus">+</span>
<a href="#l12.159"></a><span id="l12.159" class="difflineplus">+function run_test()</span>
<a href="#l12.160"></a><span id="l12.160" class="difflineplus">+{</span>
<a href="#l12.161"></a><span id="l12.161" class="difflineplus">+  // We need to register the dummyMsgWindow so that we'll think the</span>
<a href="#l12.162"></a><span id="l12.162" class="difflineplus">+  // Inbox is open in a folder and fetch headers in chunks.</span>
<a href="#l12.163"></a><span id="l12.163" class="difflineplus">+  MailServices.mailSession.AddMsgWindow(dummyMsgWindow);</span>
<a href="#l12.164"></a><span id="l12.164" class="difflineplus">+  MailServices.mfn.addListener(mfnListener, MailServices.mfn.msgAdded);</span>
<a href="#l12.165"></a><span id="l12.165" class="difflineplus">+</span>
<a href="#l12.166"></a><span id="l12.166" class="difflineplus">+  // Set chunk size to 3, so we'll have to chain 4 requests to get</span>
<a href="#l12.167"></a><span id="l12.167" class="difflineplus">+  // 10 headers.</span>
<a href="#l12.168"></a><span id="l12.168" class="difflineplus">+  Services.prefs.setIntPref(&quot;mail.imap.hdr_chunk_size&quot;, 3);</span>
<a href="#l12.169"></a><span id="l12.169" class="difflineplus">+  // Turn off offline sync to avoid complications in verifying that we can</span>
<a href="#l12.170"></a><span id="l12.170" class="difflineplus">+  // run a url after the first header chunk.</span>
<a href="#l12.171"></a><span id="l12.171" class="difflineplus">+  Services.prefs.setBoolPref(&quot;mail.server.server1.autosync_offline_stores&quot;, false);</span>
<a href="#l12.172"></a><span id="l12.172" class="difflineplus">+</span>
<a href="#l12.173"></a><span id="l12.173" class="difflineplus">+  async_run_tests(tests);</span>
<a href="#l12.174"></a><span id="l12.174" class="difflineplus">+}</span>
<a href="#l12.175"></a><span id="l12.175" class="difflineplus">+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/mailnews/imap/test/unit/xpcshell.ini</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/mailnews/imap/test/unit/xpcshell.ini</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -14,16 +14,17 @@ tail = tail_imap.js</span>
<a href="#l13.4"></a><span id="l13.4"> [test_imapAttachmentSaves.js]</span>
<a href="#l13.5"></a><span id="l13.5"> [test_imapAuthMethods.js]</span>
<a href="#l13.6"></a><span id="l13.6"> [test_imapAutoSync.js]</span>
<a href="#l13.7"></a><span id="l13.7"> [test_imapContentLength.js]</span>
<a href="#l13.8"></a><span id="l13.8"> [test_imapCopyTimeout.js]</span>
<a href="#l13.9"></a><span id="l13.9"> [test_imapFilterActions.js]</span>
<a href="#l13.10"></a><span id="l13.10"> [test_imapFlagChange.js]</span>
<a href="#l13.11"></a><span id="l13.11"> [test_imapFolderCopy.js]</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineplus">+[test_imapHdrChunking.js]</span>
<a href="#l13.13"></a><span id="l13.13"> [test_imapHighWater.js]</span>
<a href="#l13.14"></a><span id="l13.14"> [test_imapID.js]</span>
<a href="#l13.15"></a><span id="l13.15"> [test_imapMove.js]</span>
<a href="#l13.16"></a><span id="l13.16"> [test_imapPasswordFailure.js]</span>
<a href="#l13.17"></a><span id="l13.17"> [test_imapProtocols.js]</span>
<a href="#l13.18"></a><span id="l13.18"> [test_imapStatusCloseDBs.js]</span>
<a href="#l13.19"></a><span id="l13.19"> [test_imapStoreMsgOffline.js]</span>
<a href="#l13.20"></a><span id="l13.20"> [test_imapUndo.js]</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/mailnews/mailnews.js</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/mailnews/mailnews.js</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -119,16 +119,18 @@ pref(&quot;mail.imap.hide_unused_namespaces&quot;,</span>
<a href="#l14.4"></a><span id="l14.4"> pref(&quot;mail.imap.auto_unsubscribe_from_noselect_folders&quot;,    true);</span>
<a href="#l14.5"></a><span id="l14.5"> pref(&quot;mail.imap.mime_parts_on_demand&quot;,      true);</span>
<a href="#l14.6"></a><span id="l14.6"> pref(&quot;mail.imap.mime_parts_on_demand_threshold&quot;, 30000);</span>
<a href="#l14.7"></a><span id="l14.7"> pref(&quot;mail.imap.use_literal_plus&quot;,          true);</span>
<a href="#l14.8"></a><span id="l14.8"> pref(&quot;mail.imap.expunge_after_delete&quot;,      false);</span>
<a href="#l14.9"></a><span id="l14.9"> pref(&quot;mail.imap.check_deleted_before_expunge&quot;, false);</span>
<a href="#l14.10"></a><span id="l14.10"> pref(&quot;mail.imap.expunge_option&quot;,            0);</span>
<a href="#l14.11"></a><span id="l14.11"> pref(&quot;mail.imap.expunge_threshold_number&quot;,  20);</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineplus">+pref(&quot;mail.imap.hdr_chunk_size&quot;, 200);</span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+</span>
<a href="#l14.14"></a><span id="l14.14"> // if true, we assume that a user access a folder in the other users namespace</span>
<a href="#l14.15"></a><span id="l14.15"> // is acting as a delegate for that folder, and wishes to use the other users</span>
<a href="#l14.16"></a><span id="l14.16"> // identity when acting on messages in other users folders.</span>
<a href="#l14.17"></a><span id="l14.17"> pref(&quot;mail.imap.delegateOtherUsersFolders&quot;, false);</span>
<a href="#l14.18"></a><span id="l14.18"> pref(&quot;mail.thread_without_re&quot;,              false); // if false, only thread by subject if Re:</span>
<a href="#l14.19"></a><span id="l14.19"> pref(&quot;mail.strict_threading&quot;,               true);  // if true, don't thread by subject at all</span>
<a href="#l14.20"></a><span id="l14.20"> pref(&quot;mail.correct_threading&quot;,              true);  // if true, makes sure threading works correctly always (see bug 181446)</span>
<a href="#l14.21"></a><span id="l14.21"> pref(&quot;mail.pop3.deleteFromServerOnMove&quot;,    false);</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

