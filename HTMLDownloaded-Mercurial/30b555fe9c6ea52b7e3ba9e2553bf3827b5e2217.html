<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 23365:30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217" />
<meta property="og:url" content="/comm-central/rev/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217" />
<meta property="og:description" content="Bug 1399756 - remove trailing spaces in db (Mork). rs=white-space-only" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217">shortlog</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217">files</a> |
changeset |
<a href="/comm-central/raw-rev/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217">raw</a>  | <a href="/comm-central/archive/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399756">Bug 1399756</a> - remove trailing spaces in db (Mork). rs=white-space-only
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#114;&#103;&#32;&#75;&#32;&#60;&#106;&#111;&#114;&#103;&#107;&#64;&#106;&#111;&#114;&#103;&#107;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Sat, 24 Feb 2018 09:55:44 +0100</td></tr>

<tr>
 <td>changeset 23365</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217">30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217</a></td>
</tr>



<tr>
<td>parent 23364</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/1558f598599efcf64ed39457e9d124d66415106c">1558f598599efcf64ed39457e9d124d66415106c</a>
</td>
</tr>

<tr>
<td>child 23366</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/48e30a34372b031e067af5d5b3f5e19ec64cbb46">48e30a34372b031e067af5d5b3f5e19ec64cbb46</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217">14119</a></td></tr>
<tr><td>push user</td><td>mozilla@jorgk.com</td></tr>
<tr><td>push date</td><td class="date age">Sat, 24 Feb 2018 08:56:11 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@30b555fe9c6e [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217&newProject=comm-central&newRevision=30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217&newProject=comm-central&newRevision=30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217&newProject=comm-central&newRevision=30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28white-space-only%29&revcount=50">white-space-only</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399756">1399756</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399756">Bug 1399756</a> - remove trailing spaces in db (Mork). rs=white-space-only
[skip-blame]</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/public/mdb.h">db/mork/public/mdb.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/public/mdb.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/public/mdb.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/public/mdb.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/public/mdb.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/public/mdb.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/mork.h">db/mork/src/mork.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/mork.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/mork.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/mork.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/mork.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/mork.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.cpp">db/mork/src/morkArray.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.h">db/mork/src/morkArray.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkArray.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.cpp">db/mork/src/morkAtom.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.h">db/mork/src/morkAtom.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtom.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.cpp">db/mork/src/morkAtomMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.h">db/mork/src/morkAtomMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomMap.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.cpp">db/mork/src/morkAtomSpace.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.h">db/mork/src/morkAtomSpace.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkAtomSpace.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.cpp">db/mork/src/morkBead.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.h">db/mork/src/morkBead.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBead.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.cpp">db/mork/src/morkBlob.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.h">db/mork/src/morkBlob.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBlob.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.cpp">db/mork/src/morkBuilder.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.h">db/mork/src/morkBuilder.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkBuilder.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.cpp">db/mork/src/morkCell.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.h">db/mork/src/morkCell.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCell.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.cpp">db/mork/src/morkCellObject.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.h">db/mork/src/morkCellObject.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCellObject.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.cpp">db/mork/src/morkCh.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.h">db/mork/src/morkCh.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCh.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.cpp">db/mork/src/morkConfig.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.h">db/mork/src/morkConfig.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkConfig.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.cpp">db/mork/src/morkCursor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.h">db/mork/src/morkCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkCursor.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.cpp">db/mork/src/morkDeque.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.h">db/mork/src/morkDeque.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkDeque.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.cpp">db/mork/src/morkEnv.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.h">db/mork/src/morkEnv.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkEnv.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.cpp">db/mork/src/morkFactory.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.h">db/mork/src/morkFactory.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFactory.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.cpp">db/mork/src/morkFile.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.h">db/mork/src/morkFile.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkFile.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.cpp">db/mork/src/morkHandle.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.h">db/mork/src/morkHandle.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkHandle.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.cpp">db/mork/src/morkIntMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.h">db/mork/src/morkIntMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkIntMap.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.cpp">db/mork/src/morkMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.h">db/mork/src/morkMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkMap.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.cpp">db/mork/src/morkNode.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.h">db/mork/src/morkNode.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNode.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.cpp">db/mork/src/morkNodeMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.h">db/mork/src/morkNodeMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkNodeMap.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.cpp">db/mork/src/morkObject.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.h">db/mork/src/morkObject.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkObject.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.cpp">db/mork/src/morkParser.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.h">db/mork/src/morkParser.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkParser.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.cpp">db/mork/src/morkPool.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.h">db/mork/src/morkPool.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPool.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.cpp">db/mork/src/morkPortTableCursor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.h">db/mork/src/morkPortTableCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkPortTableCursor.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.cpp">db/mork/src/morkProbeMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.h">db/mork/src/morkProbeMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkProbeMap.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkQuickSort.h">db/mork/src/morkQuickSort.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkQuickSort.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkQuickSort.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkQuickSort.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkQuickSort.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkQuickSort.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.cpp">db/mork/src/morkRow.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.h">db/mork/src/morkRow.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRow.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.cpp">db/mork/src/morkRowCellCursor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.h">db/mork/src/morkRowCellCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowCellCursor.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.cpp">db/mork/src/morkRowMap.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.h">db/mork/src/morkRowMap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowMap.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.cpp">db/mork/src/morkRowObject.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.h">db/mork/src/morkRowObject.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowObject.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.cpp">db/mork/src/morkRowSpace.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.h">db/mork/src/morkRowSpace.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkRowSpace.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.cpp">db/mork/src/morkSearchRowCursor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.h">db/mork/src/morkSearchRowCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSearchRowCursor.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.cpp">db/mork/src/morkSink.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.h">db/mork/src/morkSink.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSink.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.cpp">db/mork/src/morkSpace.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.h">db/mork/src/morkSpace.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkSpace.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.cpp">db/mork/src/morkStore.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.h">db/mork/src/morkStore.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStore.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.cpp">db/mork/src/morkStream.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.h">db/mork/src/morkStream.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkStream.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.cpp">db/mork/src/morkTable.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.h">db/mork/src/morkTable.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTable.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.cpp">db/mork/src/morkTableRowCursor.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.h">db/mork/src/morkTableRowCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkTableRowCursor.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.cpp">db/mork/src/morkThumb.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.cpp">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.h">db/mork/src/morkThumb.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkThumb.h">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkUniqRowCursor.h">db/mork/src/morkUniqRowCursor.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkUniqRowCursor.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkUniqRowCursor.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkUniqRowCursor.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkUniqRowCursor.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkUniqRowCursor.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.cpp">db/mork/src/morkWriter.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.h">db/mork/src/morkWriter.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkWriter.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.cpp">db/mork/src/morkYarn.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.h">db/mork/src/morkYarn.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkYarn.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.cpp">db/mork/src/morkZone.cpp</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.cpp">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.cpp">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.cpp">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.cpp">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.cpp">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.h">db/mork/src/morkZone.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/morkZone.h">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/orkinHeap.h">db/mork/src/orkinHeap.h</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/orkinHeap.h">file</a> |
<a href="/comm-central/annotate/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/orkinHeap.h">annotate</a> |
<a href="/comm-central/diff/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/orkinHeap.h">diff</a> |
<a href="/comm-central/comparison/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/orkinHeap.h">comparison</a> |
<a href="/comm-central/log/30b555fe9c6ea52b7e3ba9e2553bf3827b5e2217/db/mork/src/orkinHeap.h">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/db/mork/public/mdb.h</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/db/mork/public/mdb.h</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -82,19 +82,19 @@ typedef mdb_u4 mdb_percent; // 0..100, w</span>
<a href="#l1.4"></a><span id="l1.4"> typedef mdb_u1 mdb_priority; // 0..9, for a total of ten different values</span>
<a href="#l1.5"></a><span id="l1.5"> </span>
<a href="#l1.6"></a><span id="l1.6"> // sequence position is signed; negative is useful to mean &quot;before first&quot;:</span>
<a href="#l1.7"></a><span id="l1.7"> typedef mdb_i4 mdb_pos; // signed zero-based ordinal collection position</span>
<a href="#l1.8"></a><span id="l1.8"> </span>
<a href="#l1.9"></a><span id="l1.9"> #define mdbPos_kBeforeFirst ((mdb_pos) -1) /* any negative is before zero */</span>
<a href="#l1.10"></a><span id="l1.10"> </span>
<a href="#l1.11"></a><span id="l1.11"> // order is also signed, so we can use three states for comparison order:</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-typedef mdb_i4 mdb_order; // neg:lessthan, zero:equalto, pos:greaterthan </span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+typedef mdb_i4 mdb_order; // neg:lessthan, zero:equalto, pos:greaterthan</span>
<a href="#l1.14"></a><span id="l1.14"> </span>
<a href="#l1.15"></a><span id="l1.15" class="difflineminus">-typedef mdb_order (* mdbAny_Order)(const void* inA, const void* inB, </span>
<a href="#l1.16"></a><span id="l1.16" class="difflineplus">+typedef mdb_order (* mdbAny_Order)(const void* inA, const void* inB,</span>
<a href="#l1.17"></a><span id="l1.17">   const void* inClosure);</span>
<a href="#l1.18"></a><span id="l1.18"> </span>
<a href="#l1.19"></a><span id="l1.19"> // } %%%%% end scalar typedefs %%%%%</span>
<a href="#l1.20"></a><span id="l1.20"> </span>
<a href="#l1.21"></a><span id="l1.21"> // { %%%%% begin C structs %%%%%</span>
<a href="#l1.22"></a><span id="l1.22"> </span>
<a href="#l1.23"></a><span id="l1.23"> #ifndef mdbScopeStringSet_typedef</span>
<a href="#l1.24"></a><span id="l1.24"> typedef struct mdbScopeStringSet mdbScopeStringSet;</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineat">@@ -107,23 +107,23 @@ typedef struct mdbScopeStringSet mdbScop</span>
<a href="#l1.26"></a><span id="l1.26"> **| (We use strings and not tokens because we cannot know the tokens for any</span>
<a href="#l1.27"></a><span id="l1.27"> **| particular db without having first opened the db.)  The goal is to inform</span>
<a href="#l1.28"></a><span id="l1.28"> **| a db runtime that scopes not appearing in this list can be given relatively</span>
<a href="#l1.29"></a><span id="l1.29"> **| short shrift in runtime representation, with the expectation that other</span>
<a href="#l1.30"></a><span id="l1.30"> **| scopes will not actually be used.  However, a db should still be prepared</span>
<a href="#l1.31"></a><span id="l1.31"> **| to handle accessing row scopes not in this list, rather than raising errors.</span>
<a href="#l1.32"></a><span id="l1.32"> **| But it could be quite expensive to access a row scope not on the list.</span>
<a href="#l1.33"></a><span id="l1.33"> **| Note a zero count for the string set means no such string set is being</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineminus">-**| specified, and that a db should handle all row scopes efficiently. </span>
<a href="#l1.35"></a><span id="l1.35" class="difflineplus">+**| specified, and that a db should handle all row scopes efficiently.</span>
<a href="#l1.36"></a><span id="l1.36"> **| (It does NOT mean an app plans to use no content whatsoever.)</span>
<a href="#l1.37"></a><span id="l1.37"> |*/</span>
<a href="#l1.38"></a><span id="l1.38"> #ifndef mdbScopeStringSet_struct</span>
<a href="#l1.39"></a><span id="l1.39"> #define mdbScopeStringSet_struct 1</span>
<a href="#l1.40"></a><span id="l1.40"> struct mdbScopeStringSet { // vector of scopes for use in db opening policy</span>
<a href="#l1.41"></a><span id="l1.41" class="difflineminus">-  // when mScopeStringSet_Count is zero, this means no scope constraints </span>
<a href="#l1.42"></a><span id="l1.42" class="difflineplus">+  // when mScopeStringSet_Count is zero, this means no scope constraints</span>
<a href="#l1.43"></a><span id="l1.43">   mdb_count     mScopeStringSet_Count;    // number of strings in vector below</span>
<a href="#l1.44"></a><span id="l1.44">   const char**  mScopeStringSet_Strings;  // null-ended ascii scope strings</span>
<a href="#l1.45"></a><span id="l1.45"> };</span>
<a href="#l1.46"></a><span id="l1.46"> #endif /*mdbScopeStringSet_struct*/</span>
<a href="#l1.47"></a><span id="l1.47"> </span>
<a href="#l1.48"></a><span id="l1.48"> #ifndef mdbOpenPolicy_typedef</span>
<a href="#l1.49"></a><span id="l1.49"> typedef struct mdbOpenPolicy mdbOpenPolicy;</span>
<a href="#l1.50"></a><span id="l1.50"> #define mdbOpenPolicy_typedef 1</span>
<a href="#l1.51"></a><span id="l1.51" class="difflineat">@@ -295,17 +295,17 @@ typedef void (* mdbYarn_mGrow)(mdbYarn* </span>
<a href="#l1.52"></a><span id="l1.52"> **| mime type charset designation.  If and when mdbYarn is used for</span>
<a href="#l1.53"></a><span id="l1.53"> **| other purposes away from the mdb interface, folks can use another</span>
<a href="#l1.54"></a><span id="l1.54"> **| convention system for encoding content formats.  However, in all</span>
<a href="#l1.55"></a><span id="l1.55"> **| contexts is it useful to maintain the convention that Form==0</span>
<a href="#l1.56"></a><span id="l1.56"> **| implies Buf contains US-ASCII iso-8859-1 Latin1 string content.</span>
<a href="#l1.57"></a><span id="l1.57"> **|</span>
<a href="#l1.58"></a><span id="l1.58"> **|| mYarn_Grow: either a mdbYarn_mGrow method, or else nil.  When</span>
<a href="#l1.59"></a><span id="l1.59"> **| a mdbYarn_mGrow method is provided, this method can be used to</span>
<a href="#l1.60"></a><span id="l1.60" class="difflineminus">-**| request a yarn buf size increase.  A caller who constructs the </span>
<a href="#l1.61"></a><span id="l1.61" class="difflineplus">+**| request a yarn buf size increase.  A caller who constructs the</span>
<a href="#l1.62"></a><span id="l1.62"> **| original mdbYarn instance decides whether a grow method is necessary</span>
<a href="#l1.63"></a><span id="l1.63"> **| or desirable, and uses only grow methods suitable for the buffering</span>
<a href="#l1.64"></a><span id="l1.64"> **| nature of a specific mdbYarn instance.  (For example, Buf might be a</span>
<a href="#l1.65"></a><span id="l1.65"> **| staticly allocated string space which switches to something heap-based</span>
<a href="#l1.66"></a><span id="l1.66"> **| when grown, and subsequent calls to grow the yarn must distinguish the</span>
<a href="#l1.67"></a><span id="l1.67"> **| original static string from heap allocated space, etc.) Note that the</span>
<a href="#l1.68"></a><span id="l1.68"> **| method stored in mYarn_Grow can change, and this might be a common way</span>
<a href="#l1.69"></a><span id="l1.69"> **| to track memory managent changes in policy for mYarn_Buf.</span>
<a href="#l1.70"></a><span id="l1.70" class="difflineat">@@ -314,17 +314,17 @@ typedef void (* mdbYarn_mGrow)(mdbYarn* </span>
<a href="#l1.71"></a><span id="l1.71"> #define mdbYarn_struct 1</span>
<a href="#l1.72"></a><span id="l1.72"> struct mdbYarn { // buffer with caller space allocation semantics</span>
<a href="#l1.73"></a><span id="l1.73">   void*         mYarn_Buf;   // space for holding any binary content</span>
<a href="#l1.74"></a><span id="l1.74">   mdb_fill      mYarn_Fill;  // logical content in Buf in bytes</span>
<a href="#l1.75"></a><span id="l1.75">   mdb_size      mYarn_Size;  // physical size of Buf in bytes</span>
<a href="#l1.76"></a><span id="l1.76">   mdb_more      mYarn_More;  // more available bytes if Buf is bigger</span>
<a href="#l1.77"></a><span id="l1.77">   mdb_cscode    mYarn_Form;  // charset format encoding</span>
<a href="#l1.78"></a><span id="l1.78">   mdbYarn_mGrow mYarn_Grow;  // optional method to grow mYarn_Buf</span>
<a href="#l1.79"></a><span id="l1.79" class="difflineminus">-  </span>
<a href="#l1.80"></a><span id="l1.80" class="difflineplus">+</span>
<a href="#l1.81"></a><span id="l1.81">   // Subclasses might add further slots after mYarn_Grow in order to</span>
<a href="#l1.82"></a><span id="l1.82">   // maintain bookkeeping needs, such as state info about mYarn_Buf.</span>
<a href="#l1.83"></a><span id="l1.83"> };</span>
<a href="#l1.84"></a><span id="l1.84"> #endif /*mdbYarn_struct*/</span>
<a href="#l1.85"></a><span id="l1.85"> </span>
<a href="#l1.86"></a><span id="l1.86"> // } %%%%% end C structs %%%%%</span>
<a href="#l1.87"></a><span id="l1.87"> </span>
<a href="#l1.88"></a><span id="l1.88"> // { %%%%% begin class forward defines %%%%%</span>
<a href="#l1.89"></a><span id="l1.89" class="difflineat">@@ -378,35 +378,35 @@ public:</span>
<a href="#l1.90"></a><span id="l1.90"> // { ===== begin nsIMdbObject methods =====</span>
<a href="#l1.91"></a><span id="l1.91"> </span>
<a href="#l1.92"></a><span id="l1.92">   // { ----- begin attribute methods -----</span>
<a href="#l1.93"></a><span id="l1.93">   NS_IMETHOD IsFrozenMdbObject(nsIMdbEnv* ev, mdb_bool* outIsReadonly) = 0;</span>
<a href="#l1.94"></a><span id="l1.94">   // same as nsIMdbPort::GetIsPortReadonly() when this object is inside a port.</span>
<a href="#l1.95"></a><span id="l1.95">   // } ----- end attribute methods -----</span>
<a href="#l1.96"></a><span id="l1.96"> </span>
<a href="#l1.97"></a><span id="l1.97">   // { ----- begin factory methods -----</span>
<a href="#l1.98"></a><span id="l1.98" class="difflineminus">-  NS_IMETHOD GetMdbFactory(nsIMdbEnv* ev, nsIMdbFactory** acqFactory) = 0; </span>
<a href="#l1.99"></a><span id="l1.99" class="difflineplus">+  NS_IMETHOD GetMdbFactory(nsIMdbEnv* ev, nsIMdbFactory** acqFactory) = 0;</span>
<a href="#l1.100"></a><span id="l1.100">   // } ----- end factory methods -----</span>
<a href="#l1.101"></a><span id="l1.101"> </span>
<a href="#l1.102"></a><span id="l1.102">   // { ----- begin ref counting for well-behaved cyclic graphs -----</span>
<a href="#l1.103"></a><span id="l1.103">   NS_IMETHOD GetWeakRefCount(nsIMdbEnv* ev, // weak refs</span>
<a href="#l1.104"></a><span id="l1.104" class="difflineminus">-    mdb_count* outCount) = 0;  </span>
<a href="#l1.105"></a><span id="l1.105" class="difflineplus">+    mdb_count* outCount) = 0;</span>
<a href="#l1.106"></a><span id="l1.106">   NS_IMETHOD GetStrongRefCount(nsIMdbEnv* ev, // strong refs</span>
<a href="#l1.107"></a><span id="l1.107">     mdb_count* outCount) = 0;</span>
<a href="#l1.108"></a><span id="l1.108"> </span>
<a href="#l1.109"></a><span id="l1.109">   NS_IMETHOD AddWeakRef(nsIMdbEnv* ev) = 0;</span>
<a href="#l1.110"></a><span id="l1.110">   NS_IMETHOD_(mork_uses) AddStrongRef(nsIMdbEnv* ev) = 0;</span>
<a href="#l1.111"></a><span id="l1.111"> </span>
<a href="#l1.112"></a><span id="l1.112">   NS_IMETHOD CutWeakRef(nsIMdbEnv* ev) = 0;</span>
<a href="#l1.113"></a><span id="l1.113">   NS_IMETHOD CutStrongRef(nsIMdbEnv* ev) = 0;</span>
<a href="#l1.114"></a><span id="l1.114" class="difflineminus">-  </span>
<a href="#l1.115"></a><span id="l1.115" class="difflineplus">+</span>
<a href="#l1.116"></a><span id="l1.116">   NS_IMETHOD CloseMdbObject(nsIMdbEnv* ev) = 0; // called at strong refs zero</span>
<a href="#l1.117"></a><span id="l1.117">   NS_IMETHOD IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen) = 0;</span>
<a href="#l1.118"></a><span id="l1.118">   // } ----- end ref counting -----</span>
<a href="#l1.119"></a><span id="l1.119" class="difflineminus">-  </span>
<a href="#l1.120"></a><span id="l1.120" class="difflineplus">+</span>
<a href="#l1.121"></a><span id="l1.121"> // } ===== end nsIMdbObject methods =====</span>
<a href="#l1.122"></a><span id="l1.122"> };</span>
<a href="#l1.123"></a><span id="l1.123"> </span>
<a href="#l1.124"></a><span id="l1.124"> NS_DEFINE_STATIC_IID_ACCESSOR(nsIMdbObject, NS_IMDBOBJECT_IID)</span>
<a href="#l1.125"></a><span id="l1.125"> </span>
<a href="#l1.126"></a><span id="l1.126"> /*| nsIMdbErrorHook: a base class for clients of this API to subclass, in order</span>
<a href="#l1.127"></a><span id="l1.127"> **| to provide a callback installable in nsIMdbEnv for error notifications. If</span>
<a href="#l1.128"></a><span id="l1.128"> **| apps that subclass nsIMdbErrorHook wish to maintain a reference to the env</span>
<a href="#l1.129"></a><span id="l1.129" class="difflineat">@@ -433,62 +433,62 @@ public:</span>
<a href="#l1.130"></a><span id="l1.130"> // } ===== end warning methods =====</span>
<a href="#l1.131"></a><span id="l1.131"> </span>
<a href="#l1.132"></a><span id="l1.132"> // { ===== begin abort hint methods =====</span>
<a href="#l1.133"></a><span id="l1.133">   NS_IMETHOD OnAbortHintString(nsIMdbEnv* ev, const char* inAscii) = 0;</span>
<a href="#l1.134"></a><span id="l1.134">   NS_IMETHOD OnAbortHintYarn(nsIMdbEnv* ev, const mdbYarn* inYarn) = 0;</span>
<a href="#l1.135"></a><span id="l1.135"> // } ===== end abort hint methods =====</span>
<a href="#l1.136"></a><span id="l1.136"> };</span>
<a href="#l1.137"></a><span id="l1.137"> </span>
<a href="#l1.138"></a><span id="l1.138" class="difflineminus">-/*| nsIMdbHeap: abstract memory allocation interface. </span>
<a href="#l1.139"></a><span id="l1.139" class="difflineplus">+/*| nsIMdbHeap: abstract memory allocation interface.</span>
<a href="#l1.140"></a><span id="l1.140"> **|</span>
<a href="#l1.141"></a><span id="l1.141"> **|| Alloc: return a block at least inSize bytes in size with alignment</span>
<a href="#l1.142"></a><span id="l1.142"> **| suitable for any native type (such as long integers).  When no such</span>
<a href="#l1.143"></a><span id="l1.143"> **| block can be allocated, failure is indicated by a null address in</span>
<a href="#l1.144"></a><span id="l1.144"> **| addition to reporting an error in the environment.</span>
<a href="#l1.145"></a><span id="l1.145"> **|</span>
<a href="#l1.146"></a><span id="l1.146"> **|| Free: deallocate a block allocated or resized earlier by the same</span>
<a href="#l1.147"></a><span id="l1.147"> **| heap instance.  If the inBlock parameter is nil, the heap should do</span>
<a href="#l1.148"></a><span id="l1.148"> **| nothing (and crashing is strongly discouraged).</span>
<a href="#l1.149"></a><span id="l1.149"> |*/</span>
<a href="#l1.150"></a><span id="l1.150"> class nsIMdbHeap { // caller-supplied memory management interface</span>
<a href="#l1.151"></a><span id="l1.151"> public:</span>
<a href="#l1.152"></a><span id="l1.152"> // { ===== begin nsIMdbHeap methods =====</span>
<a href="#l1.153"></a><span id="l1.153">   NS_IMETHOD Alloc(nsIMdbEnv* ev, // allocate a piece of memory</span>
<a href="#l1.154"></a><span id="l1.154" class="difflineminus">-    mdb_size inSize,        // requested byte size of new memory block </span>
<a href="#l1.155"></a><span id="l1.155" class="difflineplus">+    mdb_size inSize,        // requested byte size of new memory block</span>
<a href="#l1.156"></a><span id="l1.156">     void** outBlock) = 0;   // memory block of inSize bytes, or nil</span>
<a href="#l1.157"></a><span id="l1.157" class="difflineminus">-    </span>
<a href="#l1.158"></a><span id="l1.158" class="difflineplus">+</span>
<a href="#l1.159"></a><span id="l1.159">   NS_IMETHOD Free(nsIMdbEnv* ev, // free block from Alloc or Resize()</span>
<a href="#l1.160"></a><span id="l1.160">     void* ioBlock) = 0;     // block to be destroyed/deallocated</span>
<a href="#l1.161"></a><span id="l1.161"> </span>
<a href="#l1.162"></a><span id="l1.162">   virtual size_t GetUsedSize() = 0;</span>
<a href="#l1.163"></a><span id="l1.163"> </span>
<a href="#l1.164"></a><span id="l1.164">   virtual ~nsIMdbHeap() {};</span>
<a href="#l1.165"></a><span id="l1.165"> // } ===== end nsIMdbHeap methods =====</span>
<a href="#l1.166"></a><span id="l1.166"> };</span>
<a href="#l1.167"></a><span id="l1.167"> </span>
<a href="#l1.168"></a><span id="l1.168" class="difflineminus">-/*| nsIMdbCPlusHeap: Alloc() with global ::new(), Free() with global ::delete(). </span>
<a href="#l1.169"></a><span id="l1.169" class="difflineplus">+/*| nsIMdbCPlusHeap: Alloc() with global ::new(), Free() with global ::delete().</span>
<a href="#l1.170"></a><span id="l1.170"> **| Resize() is done by ::new() followed by ::delete().</span>
<a href="#l1.171"></a><span id="l1.171"> |*/</span>
<a href="#l1.172"></a><span id="l1.172"> class nsIMdbCPlusHeap { // caller-supplied memory management interface</span>
<a href="#l1.173"></a><span id="l1.173"> public:</span>
<a href="#l1.174"></a><span id="l1.174"> // { ===== begin nsIMdbHeap methods =====</span>
<a href="#l1.175"></a><span id="l1.175">   NS_IMETHOD Alloc(nsIMdbEnv* ev, // allocate a piece of memory</span>
<a href="#l1.176"></a><span id="l1.176" class="difflineminus">-    mdb_size inSize,   // requested size of new memory block </span>
<a href="#l1.177"></a><span id="l1.177" class="difflineplus">+    mdb_size inSize,   // requested size of new memory block</span>
<a href="#l1.178"></a><span id="l1.178">     void** outBlock);  // memory block of inSize bytes, or nil</span>
<a href="#l1.179"></a><span id="l1.179" class="difflineminus">-    </span>
<a href="#l1.180"></a><span id="l1.180" class="difflineplus">+</span>
<a href="#l1.181"></a><span id="l1.181">   NS_IMETHOD Free(nsIMdbEnv* ev, // free block allocated earlier by Alloc()</span>
<a href="#l1.182"></a><span id="l1.182">     void* inBlock);</span>
<a href="#l1.183"></a><span id="l1.183" class="difflineminus">-    </span>
<a href="#l1.184"></a><span id="l1.184" class="difflineplus">+</span>
<a href="#l1.185"></a><span id="l1.185">   NS_IMETHOD HeapAddStrongRef(nsIMdbEnv* ev);</span>
<a href="#l1.186"></a><span id="l1.186">   NS_IMETHOD HeapCutStrongRef(nsIMdbEnv* ev);</span>
<a href="#l1.187"></a><span id="l1.187"> // } ===== end nsIMdbHeap methods =====</span>
<a href="#l1.188"></a><span id="l1.188"> };</span>
<a href="#l1.189"></a><span id="l1.189"> </span>
<a href="#l1.190"></a><span id="l1.190" class="difflineminus">-/*| nsIMdbThumb: </span>
<a href="#l1.191"></a><span id="l1.191" class="difflineplus">+/*| nsIMdbThumb:</span>
<a href="#l1.192"></a><span id="l1.192"> |*/</span>
<a href="#l1.193"></a><span id="l1.193"> </span>
<a href="#l1.194"></a><span id="l1.194"> </span>
<a href="#l1.195"></a><span id="l1.195"> #define NS_IMDBTHUMB_IID_STR &quot;6d3ad7c1-a809-4e74-8577-49fa9a4562fa&quot;</span>
<a href="#l1.196"></a><span id="l1.196"> </span>
<a href="#l1.197"></a><span id="l1.197"> #define NS_IMDBTHUMB_IID \</span>
<a href="#l1.198"></a><span id="l1.198"> {0x6d3ad7c1, 0xa809, 0x4e74, \</span>
<a href="#l1.199"></a><span id="l1.199"> { 0x85, 0x77, 0x49, 0xfa, 0x9a, 0x45, 0x62, 0xfa}}</span>
<a href="#l1.200"></a><span id="l1.200" class="difflineat">@@ -500,24 +500,24 @@ public:</span>
<a href="#l1.201"></a><span id="l1.201"> </span>
<a href="#l1.202"></a><span id="l1.202"> // { ===== begin nsIMdbThumb methods =====</span>
<a href="#l1.203"></a><span id="l1.203">   NS_IMETHOD GetProgress(nsIMdbEnv* ev,</span>
<a href="#l1.204"></a><span id="l1.204">     mdb_count* outTotal,    // total somethings to do in operation</span>
<a href="#l1.205"></a><span id="l1.205">     mdb_count* outCurrent,  // subportion of total completed so far</span>
<a href="#l1.206"></a><span id="l1.206">     mdb_bool* outDone,      // is operation finished?</span>
<a href="#l1.207"></a><span id="l1.207">     mdb_bool* outBroken     // is operation irreparably dead and broken?</span>
<a href="#l1.208"></a><span id="l1.208">   ) = 0;</span>
<a href="#l1.209"></a><span id="l1.209" class="difflineminus">-  </span>
<a href="#l1.210"></a><span id="l1.210" class="difflineplus">+</span>
<a href="#l1.211"></a><span id="l1.211">   NS_IMETHOD DoMore(nsIMdbEnv* ev,</span>
<a href="#l1.212"></a><span id="l1.212">     mdb_count* outTotal,    // total somethings to do in operation</span>
<a href="#l1.213"></a><span id="l1.213">     mdb_count* outCurrent,  // subportion of total completed so far</span>
<a href="#l1.214"></a><span id="l1.214">     mdb_bool* outDone,      // is operation finished?</span>
<a href="#l1.215"></a><span id="l1.215">     mdb_bool* outBroken     // is operation irreparably dead and broken?</span>
<a href="#l1.216"></a><span id="l1.216">   ) = 0;</span>
<a href="#l1.217"></a><span id="l1.217" class="difflineminus">-  </span>
<a href="#l1.218"></a><span id="l1.218" class="difflineplus">+</span>
<a href="#l1.219"></a><span id="l1.219">   NS_IMETHOD CancelAndBreakThumb( // cancel pending operation</span>
<a href="#l1.220"></a><span id="l1.220">     nsIMdbEnv* ev) = 0;</span>
<a href="#l1.221"></a><span id="l1.221"> // } ===== end nsIMdbThumb methods =====</span>
<a href="#l1.222"></a><span id="l1.222"> };</span>
<a href="#l1.223"></a><span id="l1.223"> </span>
<a href="#l1.224"></a><span id="l1.224"> NS_DEFINE_STATIC_IID_ACCESSOR(nsIMdbThumb, NS_IMDBTHUMB_IID)</span>
<a href="#l1.225"></a><span id="l1.225"> </span>
<a href="#l1.226"></a><span id="l1.226"> /*| nsIMdbEnv: a context parameter used when calling most abstract db methods.</span>
<a href="#l1.227"></a><span id="l1.227" class="difflineat">@@ -526,17 +526,17 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsIMdbThum</span>
<a href="#l1.228"></a><span id="l1.228"> **| the implementation behind the abstract db interface.  An environment acts</span>
<a href="#l1.229"></a><span id="l1.229"> **| like a session object for a given calling thread, and callers should use</span>
<a href="#l1.230"></a><span id="l1.230"> **| at least one different nsIMdbEnv instance for each thread calling the API.</span>
<a href="#l1.231"></a><span id="l1.231"> **| While the database implementation might not be threaded, it is highly</span>
<a href="#l1.232"></a><span id="l1.232"> **| desirable that the db be thread-safe if calling threads use distinct</span>
<a href="#l1.233"></a><span id="l1.233"> **| instances of nsIMdbEnv.  Callers can stop at one nsIMdbEnv per thread, or they</span>
<a href="#l1.234"></a><span id="l1.234"> **| might decide to make on nsIMdbEnv instance for every nsIMdbPort opened, so that</span>
<a href="#l1.235"></a><span id="l1.235"> **| error information is segregated by database instance.  Callers create</span>
<a href="#l1.236"></a><span id="l1.236" class="difflineminus">-**| instances of nsIMdbEnv by calling the MakeEnv() method in nsIMdbFactory. </span>
<a href="#l1.237"></a><span id="l1.237" class="difflineplus">+**| instances of nsIMdbEnv by calling the MakeEnv() method in nsIMdbFactory.</span>
<a href="#l1.238"></a><span id="l1.238"> **|</span>
<a href="#l1.239"></a><span id="l1.239"> **|| tracing: an environment might support some kind of tracing, and this</span>
<a href="#l1.240"></a><span id="l1.240"> **| boolean attribute permits such activity to be enabled or disabled.</span>
<a href="#l1.241"></a><span id="l1.241"> **|</span>
<a href="#l1.242"></a><span id="l1.242"> **|| errors: when a call to the abstract db interface returns, a caller might</span>
<a href="#l1.243"></a><span id="l1.243"> **| check the number of outstanding errors to see whether the operation did</span>
<a href="#l1.244"></a><span id="l1.244"> **| actually succeed. Each nsIMdbEnv should have all its errors cleared by a</span>
<a href="#l1.245"></a><span id="l1.245"> **| call to ClearErrors() before making each call to the abstract db API,</span>
<a href="#l1.246"></a><span id="l1.246" class="difflineat">@@ -562,35 +562,35 @@ public:</span>
<a href="#l1.247"></a><span id="l1.247">   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMDBENV_IID)</span>
<a href="#l1.248"></a><span id="l1.248"> // { ===== begin nsIMdbEnv methods =====</span>
<a href="#l1.249"></a><span id="l1.249"> </span>
<a href="#l1.250"></a><span id="l1.250">   // { ----- begin attribute methods -----</span>
<a href="#l1.251"></a><span id="l1.251">   NS_IMETHOD GetErrorCount(mdb_count* outCount,</span>
<a href="#l1.252"></a><span id="l1.252">     mdb_bool* outShouldAbort) = 0;</span>
<a href="#l1.253"></a><span id="l1.253">   NS_IMETHOD GetWarningCount(mdb_count* outCount,</span>
<a href="#l1.254"></a><span id="l1.254">     mdb_bool* outShouldAbort) = 0;</span>
<a href="#l1.255"></a><span id="l1.255" class="difflineminus">-  </span>
<a href="#l1.256"></a><span id="l1.256" class="difflineplus">+</span>
<a href="#l1.257"></a><span id="l1.257">   NS_IMETHOD GetEnvBeVerbose(mdb_bool* outBeVerbose) = 0;</span>
<a href="#l1.258"></a><span id="l1.258">   NS_IMETHOD SetEnvBeVerbose(mdb_bool inBeVerbose) = 0;</span>
<a href="#l1.259"></a><span id="l1.259" class="difflineminus">-  </span>
<a href="#l1.260"></a><span id="l1.260" class="difflineplus">+</span>
<a href="#l1.261"></a><span id="l1.261">   NS_IMETHOD GetDoTrace(mdb_bool* outDoTrace) = 0;</span>
<a href="#l1.262"></a><span id="l1.262">   NS_IMETHOD SetDoTrace(mdb_bool inDoTrace) = 0;</span>
<a href="#l1.263"></a><span id="l1.263" class="difflineminus">-  </span>
<a href="#l1.264"></a><span id="l1.264" class="difflineplus">+</span>
<a href="#l1.265"></a><span id="l1.265">   NS_IMETHOD GetAutoClear(mdb_bool* outAutoClear) = 0;</span>
<a href="#l1.266"></a><span id="l1.266">   NS_IMETHOD SetAutoClear(mdb_bool inAutoClear) = 0;</span>
<a href="#l1.267"></a><span id="l1.267" class="difflineminus">-  </span>
<a href="#l1.268"></a><span id="l1.268" class="difflineplus">+</span>
<a href="#l1.269"></a><span id="l1.269">   NS_IMETHOD GetErrorHook(nsIMdbErrorHook** acqErrorHook) = 0;</span>
<a href="#l1.270"></a><span id="l1.270">   NS_IMETHOD SetErrorHook(</span>
<a href="#l1.271"></a><span id="l1.271">     nsIMdbErrorHook* ioErrorHook) = 0; // becomes referenced</span>
<a href="#l1.272"></a><span id="l1.272" class="difflineminus">-  </span>
<a href="#l1.273"></a><span id="l1.273" class="difflineplus">+</span>
<a href="#l1.274"></a><span id="l1.274">   NS_IMETHOD GetHeap(nsIMdbHeap** acqHeap) = 0;</span>
<a href="#l1.275"></a><span id="l1.275">   NS_IMETHOD SetHeap(</span>
<a href="#l1.276"></a><span id="l1.276">     nsIMdbHeap* ioHeap) = 0; // becomes referenced</span>
<a href="#l1.277"></a><span id="l1.277">   // } ----- end attribute methods -----</span>
<a href="#l1.278"></a><span id="l1.278" class="difflineminus">-  </span>
<a href="#l1.279"></a><span id="l1.279" class="difflineplus">+</span>
<a href="#l1.280"></a><span id="l1.280">   NS_IMETHOD ClearErrors() = 0; // clear errors beore re-entering db API</span>
<a href="#l1.281"></a><span id="l1.281">   NS_IMETHOD ClearWarnings() = 0; // clear warnings</span>
<a href="#l1.282"></a><span id="l1.282">   NS_IMETHOD ClearErrorsAndWarnings() = 0; // clear both errors &amp; warnings</span>
<a href="#l1.283"></a><span id="l1.283"> // } ===== end nsIMdbEnv methods =====</span>
<a href="#l1.284"></a><span id="l1.284"> };</span>
<a href="#l1.285"></a><span id="l1.285"> </span>
<a href="#l1.286"></a><span id="l1.286"> NS_DEFINE_STATIC_IID_ACCESSOR(nsIMdbEnv, NS_IMDBENV_IID)</span>
<a href="#l1.287"></a><span id="l1.287"> </span>
<a href="#l1.288"></a><span id="l1.288" class="difflineat">@@ -633,17 +633,17 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsIMdbEnv,</span>
<a href="#l1.289"></a><span id="l1.289"> **| not ready to tackle issues of format fidelity and factory chain ordering.</span>
<a href="#l1.290"></a><span id="l1.290"> **|</span>
<a href="#l1.291"></a><span id="l1.291"> **|| stores: a store is a mutable interface to a specific database file, and</span>
<a href="#l1.292"></a><span id="l1.292"> **| includes the port interface plus any methods particular to writing, which</span>
<a href="#l1.293"></a><span id="l1.293"> **| are few in number.  Presumably the set of files that can be opened as</span>
<a href="#l1.294"></a><span id="l1.294"> **| stores is a subset of the set of files that can be opened as ports.  A</span>
<a href="#l1.295"></a><span id="l1.295"> **| new store can be created with CreateNewFileStore() by supplying a new</span>
<a href="#l1.296"></a><span id="l1.296"> **| file name which does not yet exist (callers are always responsible for</span>
<a href="#l1.297"></a><span id="l1.297" class="difflineminus">-**| destroying any existing files before calling this method). </span>
<a href="#l1.298"></a><span id="l1.298" class="difflineplus">+**| destroying any existing files before calling this method).</span>
<a href="#l1.299"></a><span id="l1.299"> |*/</span>
<a href="#l1.300"></a><span id="l1.300"> </span>
<a href="#l1.301"></a><span id="l1.301"> #define NS_IMDBFACTORY_IID_STR &quot;2b80395c-b91e-4990-b1a7-023e99ab14e9&quot;</span>
<a href="#l1.302"></a><span id="l1.302"> </span>
<a href="#l1.303"></a><span id="l1.303"> #define NS_IMDBFACTORY_IID \</span>
<a href="#l1.304"></a><span id="l1.304"> {0xf04aa4ab, 0x1fe, 0x4115, \</span>
<a href="#l1.305"></a><span id="l1.305"> { 0xa4, 0xa5, 0x68, 0x19, 0xdf, 0xf1, 0x10, 0x3d}}</span>
<a href="#l1.306"></a><span id="l1.306"> </span>
<a href="#l1.307"></a><span id="l1.307" class="difflineat">@@ -685,83 +685,83 @@ public:</span>
<a href="#l1.308"></a><span id="l1.308">   // { ----- begin heap methods -----</span>
<a href="#l1.309"></a><span id="l1.309">   NS_IMETHOD MakeHeap(nsIMdbEnv* ev, nsIMdbHeap** acqHeap) = 0; // acquire new heap</span>
<a href="#l1.310"></a><span id="l1.310">   // } ----- end heap methods -----</span>
<a href="#l1.311"></a><span id="l1.311"> </span>
<a href="#l1.312"></a><span id="l1.312">   // { ----- begin row methods -----</span>
<a href="#l1.313"></a><span id="l1.313">   NS_IMETHOD MakeRow(nsIMdbEnv* ev, nsIMdbHeap* ioHeap, nsIMdbRow** acqRow) = 0; // new row</span>
<a href="#l1.314"></a><span id="l1.314">   // ioHeap can be nil, causing the heap associated with ev to be used</span>
<a href="#l1.315"></a><span id="l1.315">   // } ----- end row methods -----</span>
<a href="#l1.316"></a><span id="l1.316" class="difflineminus">-  </span>
<a href="#l1.317"></a><span id="l1.317" class="difflineplus">+</span>
<a href="#l1.318"></a><span id="l1.318">   // { ----- begin port methods -----</span>
<a href="#l1.319"></a><span id="l1.319">   NS_IMETHOD CanOpenFilePort(</span>
<a href="#l1.320"></a><span id="l1.320">     nsIMdbEnv* ev, // context</span>
<a href="#l1.321"></a><span id="l1.321">     // const char* inFilePath, // the file to investigate</span>
<a href="#l1.322"></a><span id="l1.322">     // const mdbYarn* inFirst512Bytes,</span>
<a href="#l1.323"></a><span id="l1.323">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l1.324"></a><span id="l1.324">     mdb_bool* outCanOpen, // whether OpenFilePort() might succeed</span>
<a href="#l1.325"></a><span id="l1.325">     mdbYarn* outFormatVersion) = 0; // informal file format description</span>
<a href="#l1.326"></a><span id="l1.326" class="difflineminus">-    </span>
<a href="#l1.327"></a><span id="l1.327" class="difflineplus">+</span>
<a href="#l1.328"></a><span id="l1.328">   NS_IMETHOD OpenFilePort(</span>
<a href="#l1.329"></a><span id="l1.329">     nsIMdbEnv* ev, // context</span>
<a href="#l1.330"></a><span id="l1.330">     nsIMdbHeap* ioHeap, // can be nil to cause ev's heap attribute to be used</span>
<a href="#l1.331"></a><span id="l1.331">     // const char* inFilePath, // the file to open for readonly import</span>
<a href="#l1.332"></a><span id="l1.332">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l1.333"></a><span id="l1.333">     const mdbOpenPolicy* inOpenPolicy, // runtime policies for using db</span>
<a href="#l1.334"></a><span id="l1.334">     nsIMdbThumb** acqThumb) = 0; // acquire thumb for incremental port open</span>
<a href="#l1.335"></a><span id="l1.335">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l1.336"></a><span id="l1.336">   // then call nsIMdbFactory::ThumbToOpenPort() to get the port instance.</span>
<a href="#l1.337"></a><span id="l1.337"> </span>
<a href="#l1.338"></a><span id="l1.338">   NS_IMETHOD ThumbToOpenPort( // redeeming a completed thumb from OpenFilePort()</span>
<a href="#l1.339"></a><span id="l1.339">     nsIMdbEnv* ev, // context</span>
<a href="#l1.340"></a><span id="l1.340">     nsIMdbThumb* ioThumb, // thumb from OpenFilePort() with done status</span>
<a href="#l1.341"></a><span id="l1.341">     nsIMdbPort** acqPort) = 0; // acquire new port object</span>
<a href="#l1.342"></a><span id="l1.342">   // } ----- end port methods -----</span>
<a href="#l1.343"></a><span id="l1.343" class="difflineminus">-  </span>
<a href="#l1.344"></a><span id="l1.344" class="difflineplus">+</span>
<a href="#l1.345"></a><span id="l1.345">   // { ----- begin store methods -----</span>
<a href="#l1.346"></a><span id="l1.346">   NS_IMETHOD CanOpenFileStore(</span>
<a href="#l1.347"></a><span id="l1.347">     nsIMdbEnv* ev, // context</span>
<a href="#l1.348"></a><span id="l1.348">     // const char* inFilePath, // the file to investigate</span>
<a href="#l1.349"></a><span id="l1.349">     // const mdbYarn* inFirst512Bytes,</span>
<a href="#l1.350"></a><span id="l1.350">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l1.351"></a><span id="l1.351">     mdb_bool* outCanOpenAsStore, // whether OpenFileStore() might succeed</span>
<a href="#l1.352"></a><span id="l1.352">     mdb_bool* outCanOpenAsPort, // whether OpenFilePort() might succeed</span>
<a href="#l1.353"></a><span id="l1.353">     mdbYarn* outFormatVersion) = 0; // informal file format description</span>
<a href="#l1.354"></a><span id="l1.354" class="difflineminus">-    </span>
<a href="#l1.355"></a><span id="l1.355" class="difflineplus">+</span>
<a href="#l1.356"></a><span id="l1.356">   NS_IMETHOD OpenFileStore( // open an existing database</span>
<a href="#l1.357"></a><span id="l1.357">     nsIMdbEnv* ev, // context</span>
<a href="#l1.358"></a><span id="l1.358">     nsIMdbHeap* ioHeap, // can be nil to cause ev's heap attribute to be used</span>
<a href="#l1.359"></a><span id="l1.359">     // const char* inFilePath, // the file to open for general db usage</span>
<a href="#l1.360"></a><span id="l1.360">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l1.361"></a><span id="l1.361">     const mdbOpenPolicy* inOpenPolicy, // runtime policies for using db</span>
<a href="#l1.362"></a><span id="l1.362">     nsIMdbThumb** acqThumb) = 0; // acquire thumb for incremental store open</span>
<a href="#l1.363"></a><span id="l1.363">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l1.364"></a><span id="l1.364">   // then call nsIMdbFactory::ThumbToOpenStore() to get the store instance.</span>
<a href="#l1.365"></a><span id="l1.365" class="difflineminus">-    </span>
<a href="#l1.366"></a><span id="l1.366" class="difflineplus">+</span>
<a href="#l1.367"></a><span id="l1.367">   NS_IMETHOD</span>
<a href="#l1.368"></a><span id="l1.368">   ThumbToOpenStore( // redeem completed thumb from OpenFileStore()</span>
<a href="#l1.369"></a><span id="l1.369">     nsIMdbEnv* ev, // context</span>
<a href="#l1.370"></a><span id="l1.370">     nsIMdbThumb* ioThumb, // thumb from OpenFileStore() with done status</span>
<a href="#l1.371"></a><span id="l1.371">     nsIMdbStore** acqStore) = 0; // acquire new db store object</span>
<a href="#l1.372"></a><span id="l1.372" class="difflineminus">-  </span>
<a href="#l1.373"></a><span id="l1.373" class="difflineplus">+</span>
<a href="#l1.374"></a><span id="l1.374">   NS_IMETHOD CreateNewFileStore( // create a new db with minimal content</span>
<a href="#l1.375"></a><span id="l1.375">     nsIMdbEnv* ev, // context</span>
<a href="#l1.376"></a><span id="l1.376">     nsIMdbHeap* ioHeap, // can be nil to cause ev's heap attribute to be used</span>
<a href="#l1.377"></a><span id="l1.377">     // const char* inFilePath, // name of file which should not yet exist</span>
<a href="#l1.378"></a><span id="l1.378">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l1.379"></a><span id="l1.379">     const mdbOpenPolicy* inOpenPolicy, // runtime policies for using db</span>
<a href="#l1.380"></a><span id="l1.380">     nsIMdbStore** acqStore) = 0; // acquire new db store object</span>
<a href="#l1.381"></a><span id="l1.381">   // } ----- end store methods -----</span>
<a href="#l1.382"></a><span id="l1.382"> </span>
<a href="#l1.383"></a><span id="l1.383"> // } ===== end nsIMdbFactory methods =====</span>
<a href="#l1.384"></a><span id="l1.384"> };</span>
<a href="#l1.385"></a><span id="l1.385"> </span>
<a href="#l1.386"></a><span id="l1.386"> NS_DEFINE_STATIC_IID_ACCESSOR(nsIMdbFactory, NS_IMDBFACTORY_IID)</span>
<a href="#l1.387"></a><span id="l1.387"> </span>
<a href="#l1.388"></a><span id="l1.388" class="difflineminus">-extern &quot;C&quot; nsIMdbFactory* MakeMdbFactory(); </span>
<a href="#l1.389"></a><span id="l1.389" class="difflineplus">+extern &quot;C&quot; nsIMdbFactory* MakeMdbFactory();</span>
<a href="#l1.390"></a><span id="l1.390"> </span>
<a href="#l1.391"></a><span id="l1.391"> /*| nsIMdbFile: abstract file interface resembling the original morkFile</span>
<a href="#l1.392"></a><span id="l1.392"> **| abstract interface (which was in turn modeled on the file interface</span>
<a href="#l1.393"></a><span id="l1.393"> **| from public domain IronDoc).  The design of this file interface is</span>
<a href="#l1.394"></a><span id="l1.394"> **| complicated by the fact that some DB's will not find this interface</span>
<a href="#l1.395"></a><span id="l1.395"> **| adequate for all runtime requirements (even though this file API is</span>
<a href="#l1.396"></a><span id="l1.396"> **| enough to implement text-based DB's like Mork).  For this reason,</span>
<a href="#l1.397"></a><span id="l1.397"> **| more methods have been added to let a DB library force the file to</span>
<a href="#l1.398"></a><span id="l1.398" class="difflineat">@@ -822,29 +822,29 @@ public:</span>
<a href="#l1.399"></a><span id="l1.399">   // } ----- end pos methods -----</span>
<a href="#l1.400"></a><span id="l1.400"> </span>
<a href="#l1.401"></a><span id="l1.401">   // { ----- begin read methods -----</span>
<a href="#l1.402"></a><span id="l1.402">   NS_IMETHOD Read(nsIMdbEnv* ev, void* outBuf, mdb_size inSize,</span>
<a href="#l1.403"></a><span id="l1.403">     mdb_size* outActualSize) = 0;</span>
<a href="#l1.404"></a><span id="l1.404">   NS_IMETHOD Get(nsIMdbEnv* ev, void* outBuf, mdb_size inSize,</span>
<a href="#l1.405"></a><span id="l1.405">     mdb_pos inPos, mdb_size* outActualSize) = 0;</span>
<a href="#l1.406"></a><span id="l1.406">   // } ----- end read methods -----</span>
<a href="#l1.407"></a><span id="l1.407" class="difflineminus">-    </span>
<a href="#l1.408"></a><span id="l1.408" class="difflineplus">+</span>
<a href="#l1.409"></a><span id="l1.409">   // { ----- begin write methods -----</span>
<a href="#l1.410"></a><span id="l1.410">   NS_IMETHOD  Write(nsIMdbEnv* ev, const void* inBuf, mdb_size inSize,</span>
<a href="#l1.411"></a><span id="l1.411">     mdb_size* outActualSize) = 0;</span>
<a href="#l1.412"></a><span id="l1.412">   NS_IMETHOD  Put(nsIMdbEnv* ev, const void* inBuf, mdb_size inSize,</span>
<a href="#l1.413"></a><span id="l1.413">     mdb_pos inPos, mdb_size* outActualSize) = 0;</span>
<a href="#l1.414"></a><span id="l1.414">   NS_IMETHOD  Flush(nsIMdbEnv* ev) = 0;</span>
<a href="#l1.415"></a><span id="l1.415">   // } ----- end attribute methods -----</span>
<a href="#l1.416"></a><span id="l1.416" class="difflineminus">-    </span>
<a href="#l1.417"></a><span id="l1.417" class="difflineplus">+</span>
<a href="#l1.418"></a><span id="l1.418">   // { ----- begin path methods -----</span>
<a href="#l1.419"></a><span id="l1.419">   NS_IMETHOD  Path(nsIMdbEnv* ev, mdbYarn* outFilePath) = 0;</span>
<a href="#l1.420"></a><span id="l1.420">   // } ----- end path methods -----</span>
<a href="#l1.421"></a><span id="l1.421" class="difflineminus">-    </span>
<a href="#l1.422"></a><span id="l1.422" class="difflineplus">+</span>
<a href="#l1.423"></a><span id="l1.423">   // { ----- begin replacement methods -----</span>
<a href="#l1.424"></a><span id="l1.424">   NS_IMETHOD  Steal(nsIMdbEnv* ev, nsIMdbFile* ioThief) = 0;</span>
<a href="#l1.425"></a><span id="l1.425">   NS_IMETHOD  Thief(nsIMdbEnv* ev, nsIMdbFile** acqThief) = 0;</span>
<a href="#l1.426"></a><span id="l1.426">   // } ----- end replacement methods -----</span>
<a href="#l1.427"></a><span id="l1.427"> </span>
<a href="#l1.428"></a><span id="l1.428">   // { ----- begin versioning methods -----</span>
<a href="#l1.429"></a><span id="l1.429">   NS_IMETHOD BecomeTrunk(nsIMdbEnv* ev) = 0;</span>
<a href="#l1.430"></a><span id="l1.430">   // If this file is a file version branch created by calling AcquireBud(),</span>
<a href="#l1.431"></a><span id="l1.431" class="difflineat">@@ -941,24 +941,24 @@ public:</span>
<a href="#l1.432"></a><span id="l1.432"> </span>
<a href="#l1.433"></a><span id="l1.433"> // { ===== begin nsIMdbPort methods =====</span>
<a href="#l1.434"></a><span id="l1.434"> </span>
<a href="#l1.435"></a><span id="l1.435">   // { ----- begin attribute methods -----</span>
<a href="#l1.436"></a><span id="l1.436">   NS_IMETHOD GetIsPortReadonly(nsIMdbEnv* ev, mdb_bool* outBool) = 0;</span>
<a href="#l1.437"></a><span id="l1.437">   NS_IMETHOD GetIsStore(nsIMdbEnv* ev, mdb_bool* outBool) = 0;</span>
<a href="#l1.438"></a><span id="l1.438">   NS_IMETHOD GetIsStoreAndDirty(nsIMdbEnv* ev, mdb_bool* outBool) = 0;</span>
<a href="#l1.439"></a><span id="l1.439"> </span>
<a href="#l1.440"></a><span id="l1.440" class="difflineminus">-  NS_IMETHOD GetUsagePolicy(nsIMdbEnv* ev, </span>
<a href="#l1.441"></a><span id="l1.441" class="difflineplus">+  NS_IMETHOD GetUsagePolicy(nsIMdbEnv* ev,</span>
<a href="#l1.442"></a><span id="l1.442">     mdbUsagePolicy* ioUsagePolicy) = 0;</span>
<a href="#l1.443"></a><span id="l1.443"> </span>
<a href="#l1.444"></a><span id="l1.444" class="difflineminus">-  NS_IMETHOD SetUsagePolicy(nsIMdbEnv* ev, </span>
<a href="#l1.445"></a><span id="l1.445" class="difflineplus">+  NS_IMETHOD SetUsagePolicy(nsIMdbEnv* ev,</span>
<a href="#l1.446"></a><span id="l1.446">     const mdbUsagePolicy* inUsagePolicy) = 0;</span>
<a href="#l1.447"></a><span id="l1.447">   // } ----- end attribute methods -----</span>
<a href="#l1.448"></a><span id="l1.448"> </span>
<a href="#l1.449"></a><span id="l1.449" class="difflineminus">-  // { ----- begin memory policy methods -----  </span>
<a href="#l1.450"></a><span id="l1.450" class="difflineplus">+  // { ----- begin memory policy methods -----</span>
<a href="#l1.451"></a><span id="l1.451">   NS_IMETHOD IdleMemoryPurge( // do memory management already scheduled</span>
<a href="#l1.452"></a><span id="l1.452">     nsIMdbEnv* ev, // context</span>
<a href="#l1.453"></a><span id="l1.453">     mdb_size* outEstimatedBytesFreed) = 0; // approximate bytes actually freed</span>
<a href="#l1.454"></a><span id="l1.454"> </span>
<a href="#l1.455"></a><span id="l1.455">   NS_IMETHOD SessionMemoryPurge( // request specific footprint decrease</span>
<a href="#l1.456"></a><span id="l1.456">     nsIMdbEnv* ev, // context</span>
<a href="#l1.457"></a><span id="l1.457">     mdb_size inDesiredBytesFreed, // approximate number of bytes wanted</span>
<a href="#l1.458"></a><span id="l1.458">     mdb_size* outEstimatedBytesFreed) = 0; // approximate bytes actually freed</span>
<a href="#l1.459"></a><span id="l1.459" class="difflineat">@@ -968,17 +968,17 @@ public:</span>
<a href="#l1.460"></a><span id="l1.460">     mdb_size* outEstimatedBytesFreed) = 0; // approximate bytes actually freed</span>
<a href="#l1.461"></a><span id="l1.461">   // } ----- end memory policy methods -----</span>
<a href="#l1.462"></a><span id="l1.462"> </span>
<a href="#l1.463"></a><span id="l1.463">   // { ----- begin filepath methods -----</span>
<a href="#l1.464"></a><span id="l1.464">   NS_IMETHOD GetPortFilePath(</span>
<a href="#l1.465"></a><span id="l1.465">     nsIMdbEnv* ev, // context</span>
<a href="#l1.466"></a><span id="l1.466">     mdbYarn* outFilePath, // name of file holding port content</span>
<a href="#l1.467"></a><span id="l1.467">     mdbYarn* outFormatVersion) = 0; // file format description</span>
<a href="#l1.468"></a><span id="l1.468" class="difflineminus">-    </span>
<a href="#l1.469"></a><span id="l1.469" class="difflineplus">+</span>
<a href="#l1.470"></a><span id="l1.470">   NS_IMETHOD GetPortFile(</span>
<a href="#l1.471"></a><span id="l1.471">     nsIMdbEnv* ev, // context</span>
<a href="#l1.472"></a><span id="l1.472">     nsIMdbFile** acqFile) = 0; // acquire file used by port or store</span>
<a href="#l1.473"></a><span id="l1.473">   // } ----- end filepath methods -----</span>
<a href="#l1.474"></a><span id="l1.474"> </span>
<a href="#l1.475"></a><span id="l1.475">   // { ----- begin export methods -----</span>
<a href="#l1.476"></a><span id="l1.476">   NS_IMETHOD BestExportFormat( // determine preferred export format</span>
<a href="#l1.477"></a><span id="l1.477">     nsIMdbEnv* ev, // context</span>
<a href="#l1.478"></a><span id="l1.478" class="difflineat">@@ -1018,54 +1018,54 @@ public:</span>
<a href="#l1.479"></a><span id="l1.479"> </span>
<a href="#l1.480"></a><span id="l1.480">   // } ----- end export methods -----</span>
<a href="#l1.481"></a><span id="l1.481"> </span>
<a href="#l1.482"></a><span id="l1.482">   // { ----- begin token methods -----</span>
<a href="#l1.483"></a><span id="l1.483">   NS_IMETHOD TokenToString( // return a string name for an integer token</span>
<a href="#l1.484"></a><span id="l1.484">     nsIMdbEnv* ev, // context</span>
<a href="#l1.485"></a><span id="l1.485">     mdb_token inToken, // token for inTokenName inside this port</span>
<a href="#l1.486"></a><span id="l1.486">     mdbYarn* outTokenName) = 0; // the type of table to access</span>
<a href="#l1.487"></a><span id="l1.487" class="difflineminus">-  </span>
<a href="#l1.488"></a><span id="l1.488" class="difflineplus">+</span>
<a href="#l1.489"></a><span id="l1.489">   NS_IMETHOD StringToToken( // return an integer token for scope name</span>
<a href="#l1.490"></a><span id="l1.490">     nsIMdbEnv* ev, // context</span>
<a href="#l1.491"></a><span id="l1.491">     const char* inTokenName, // Latin1 string to tokenize if possible</span>
<a href="#l1.492"></a><span id="l1.492">     mdb_token* outToken) = 0; // token for inTokenName inside this port</span>
<a href="#l1.493"></a><span id="l1.493" class="difflineminus">-    </span>
<a href="#l1.494"></a><span id="l1.494" class="difflineplus">+</span>
<a href="#l1.495"></a><span id="l1.495">   // String token zero is never used and never supported. If the port</span>
<a href="#l1.496"></a><span id="l1.496">   // is a mutable store, then StringToToken() to create a new</span>
<a href="#l1.497"></a><span id="l1.497">   // association of inTokenName with a new integer token if possible.</span>
<a href="#l1.498"></a><span id="l1.498">   // But a readonly port will return zero for an unknown scope name.</span>
<a href="#l1.499"></a><span id="l1.499"> </span>
<a href="#l1.500"></a><span id="l1.500">   NS_IMETHOD QueryToken( // like StringToToken(), but without adding</span>
<a href="#l1.501"></a><span id="l1.501">     nsIMdbEnv* ev, // context</span>
<a href="#l1.502"></a><span id="l1.502">     const char* inTokenName, // Latin1 string to tokenize if possible</span>
<a href="#l1.503"></a><span id="l1.503">     mdb_token* outToken) = 0; // token for inTokenName inside this port</span>
<a href="#l1.504"></a><span id="l1.504" class="difflineminus">-  </span>
<a href="#l1.505"></a><span id="l1.505" class="difflineplus">+</span>
<a href="#l1.506"></a><span id="l1.506">   // QueryToken() will return a string token if one already exists,</span>
<a href="#l1.507"></a><span id="l1.507">   // but unlike StringToToken(), will not assign a new token if not</span>
<a href="#l1.508"></a><span id="l1.508">   // already in use.</span>
<a href="#l1.509"></a><span id="l1.509"> </span>
<a href="#l1.510"></a><span id="l1.510">   // } ----- end token methods -----</span>
<a href="#l1.511"></a><span id="l1.511"> </span>
<a href="#l1.512"></a><span id="l1.512" class="difflineminus">-  // { ----- begin row methods -----  </span>
<a href="#l1.513"></a><span id="l1.513" class="difflineplus">+  // { ----- begin row methods -----</span>
<a href="#l1.514"></a><span id="l1.514">   NS_IMETHOD HasRow( // contains a row with the specified oid?</span>
<a href="#l1.515"></a><span id="l1.515">     nsIMdbEnv* ev, // context</span>
<a href="#l1.516"></a><span id="l1.516">     const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l1.517"></a><span id="l1.517">     mdb_bool* outHasRow) = 0; // whether GetRow() might succeed</span>
<a href="#l1.518"></a><span id="l1.518"> </span>
<a href="#l1.519"></a><span id="l1.519" class="difflineminus">-  NS_IMETHOD GetRowRefCount( // get number of tables that contain a row </span>
<a href="#l1.520"></a><span id="l1.520" class="difflineplus">+  NS_IMETHOD GetRowRefCount( // get number of tables that contain a row</span>
<a href="#l1.521"></a><span id="l1.521">     nsIMdbEnv* ev, // context</span>
<a href="#l1.522"></a><span id="l1.522">     const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l1.523"></a><span id="l1.523" class="difflineminus">-    mdb_count* outRefCount) = 0; // number of tables containing inRowKey </span>
<a href="#l1.524"></a><span id="l1.524" class="difflineminus">-    </span>
<a href="#l1.525"></a><span id="l1.525" class="difflineplus">+    mdb_count* outRefCount) = 0; // number of tables containing inRowKey</span>
<a href="#l1.526"></a><span id="l1.526" class="difflineplus">+</span>
<a href="#l1.527"></a><span id="l1.527">   NS_IMETHOD GetRow( // access one row with specific oid</span>
<a href="#l1.528"></a><span id="l1.528">     nsIMdbEnv* ev, // context</span>
<a href="#l1.529"></a><span id="l1.529">     const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l1.530"></a><span id="l1.530">     nsIMdbRow** acqRow) = 0; // acquire specific row (or null)</span>
<a href="#l1.531"></a><span id="l1.531" class="difflineminus">-    </span>
<a href="#l1.532"></a><span id="l1.532" class="difflineplus">+</span>
<a href="#l1.533"></a><span id="l1.533">   // NS_IMETHOD</span>
<a href="#l1.534"></a><span id="l1.534">   // GetPortRowCursor( // get cursor for all rows in specific scope</span>
<a href="#l1.535"></a><span id="l1.535">   //   nsIMdbEnv* ev, // context</span>
<a href="#l1.536"></a><span id="l1.536">   //   mdb_scope inRowScope, // row scope for row ids</span>
<a href="#l1.537"></a><span id="l1.537">   //   nsIMdbPortRowCursor** acqCursor) = 0; // all such rows in the port</span>
<a href="#l1.538"></a><span id="l1.538"> </span>
<a href="#l1.539"></a><span id="l1.539">   NS_IMETHOD FindRow(nsIMdbEnv* ev, // search for row with matching cell</span>
<a href="#l1.540"></a><span id="l1.540">     mdb_scope inRowScope,   // row scope for row ids</span>
<a href="#l1.541"></a><span id="l1.541" class="difflineat">@@ -1102,56 +1102,56 @@ public:</span>
<a href="#l1.542"></a><span id="l1.542">   //</span>
<a href="#l1.543"></a><span id="l1.543">   // In other words, the FindRow() implementation is allowed to assume simple</span>
<a href="#l1.544"></a><span id="l1.544">   // hash tables mapping unqiue column keys to associated row values will be</span>
<a href="#l1.545"></a><span id="l1.545">   // sufficient, where any duplication is not recorded because only one copy</span>
<a href="#l1.546"></a><span id="l1.546">   // of a given key need be remembered.  Implementors are not required to sort</span>
<a href="#l1.547"></a><span id="l1.547">   // all rows by the specified column.</span>
<a href="#l1.548"></a><span id="l1.548">   // } ----- end row methods -----</span>
<a href="#l1.549"></a><span id="l1.549"> </span>
<a href="#l1.550"></a><span id="l1.550" class="difflineminus">-  // { ----- begin table methods -----  </span>
<a href="#l1.551"></a><span id="l1.551" class="difflineplus">+  // { ----- begin table methods -----</span>
<a href="#l1.552"></a><span id="l1.552">   NS_IMETHOD HasTable( // supports a table with the specified oid?</span>
<a href="#l1.553"></a><span id="l1.553">     nsIMdbEnv* ev, // context</span>
<a href="#l1.554"></a><span id="l1.554">     const mdbOid* inOid,  // hypothetical table oid</span>
<a href="#l1.555"></a><span id="l1.555">     mdb_bool* outHasTable) = 0; // whether GetTable() might succeed</span>
<a href="#l1.556"></a><span id="l1.556" class="difflineminus">-    </span>
<a href="#l1.557"></a><span id="l1.557" class="difflineplus">+</span>
<a href="#l1.558"></a><span id="l1.558">   NS_IMETHOD GetTable( // access one table with specific oid</span>
<a href="#l1.559"></a><span id="l1.559">     nsIMdbEnv* ev, // context</span>
<a href="#l1.560"></a><span id="l1.560">     const mdbOid* inOid,  // hypothetical table oid</span>
<a href="#l1.561"></a><span id="l1.561">     nsIMdbTable** acqTable) = 0; // acquire specific table (or null)</span>
<a href="#l1.562"></a><span id="l1.562" class="difflineminus">-  </span>
<a href="#l1.563"></a><span id="l1.563" class="difflineplus">+</span>
<a href="#l1.564"></a><span id="l1.564">   NS_IMETHOD HasTableKind( // supports a table of the specified type?</span>
<a href="#l1.565"></a><span id="l1.565">     nsIMdbEnv* ev, // context</span>
<a href="#l1.566"></a><span id="l1.566">     mdb_scope inRowScope, // rid scope for row ids</span>
<a href="#l1.567"></a><span id="l1.567">     mdb_kind inTableKind, // the type of table to access</span>
<a href="#l1.568"></a><span id="l1.568">     mdb_count* outTableCount, // current number of such tables</span>
<a href="#l1.569"></a><span id="l1.569">     mdb_bool* outSupportsTable) = 0; // whether GetTableKind() might succeed</span>
<a href="#l1.570"></a><span id="l1.570" class="difflineminus">-    </span>
<a href="#l1.571"></a><span id="l1.571" class="difflineplus">+</span>
<a href="#l1.572"></a><span id="l1.572">   // row scopes to be supported include the following suggestions:</span>
<a href="#l1.573"></a><span id="l1.573">   // &quot;ns:msg:db:row:scope:address:cards:all&quot;</span>
<a href="#l1.574"></a><span id="l1.574">   // &quot;ns:msg:db:row:scope:mail:messages:all&quot;</span>
<a href="#l1.575"></a><span id="l1.575">   // &quot;ns:msg:db:row:scope:news:articles:all&quot;</span>
<a href="#l1.576"></a><span id="l1.576" class="difflineminus">- </span>
<a href="#l1.577"></a><span id="l1.577" class="difflineplus">+</span>
<a href="#l1.578"></a><span id="l1.578">   // table kinds to be supported include the following suggestions:</span>
<a href="#l1.579"></a><span id="l1.579">   // &quot;ns:msg:db:table:kind:address:cards:main&quot;</span>
<a href="#l1.580"></a><span id="l1.580" class="difflineminus">-  // &quot;ns:msg:db:table:kind:address:lists:all&quot; </span>
<a href="#l1.581"></a><span id="l1.581" class="difflineminus">-  // &quot;ns:msg:db:table:kind:address:list&quot; </span>
<a href="#l1.582"></a><span id="l1.582" class="difflineminus">-  // &quot;ns:msg:db:table:kind:news:threads:all&quot; </span>
<a href="#l1.583"></a><span id="l1.583" class="difflineminus">-  // &quot;ns:msg:db:table:kind:news:thread&quot; </span>
<a href="#l1.584"></a><span id="l1.584" class="difflineplus">+  // &quot;ns:msg:db:table:kind:address:lists:all&quot;</span>
<a href="#l1.585"></a><span id="l1.585" class="difflineplus">+  // &quot;ns:msg:db:table:kind:address:list&quot;</span>
<a href="#l1.586"></a><span id="l1.586" class="difflineplus">+  // &quot;ns:msg:db:table:kind:news:threads:all&quot;</span>
<a href="#l1.587"></a><span id="l1.587" class="difflineplus">+  // &quot;ns:msg:db:table:kind:news:thread&quot;</span>
<a href="#l1.588"></a><span id="l1.588">   // &quot;ns:msg:db:table:kind:mail:threads:all&quot;</span>
<a href="#l1.589"></a><span id="l1.589">   // &quot;ns:msg:db:table:kind:mail:thread&quot;</span>
<a href="#l1.590"></a><span id="l1.590" class="difflineminus">-    </span>
<a href="#l1.591"></a><span id="l1.591" class="difflineplus">+</span>
<a href="#l1.592"></a><span id="l1.592">   NS_IMETHOD GetTableKind( // access one (random) table of specific type</span>
<a href="#l1.593"></a><span id="l1.593">     nsIMdbEnv* ev, // context</span>
<a href="#l1.594"></a><span id="l1.594">     mdb_scope inRowScope,      // row scope for row ids</span>
<a href="#l1.595"></a><span id="l1.595">     mdb_kind inTableKind,      // the type of table to access</span>
<a href="#l1.596"></a><span id="l1.596">     mdb_count* outTableCount, // current number of such tables</span>
<a href="#l1.597"></a><span id="l1.597">     mdb_bool* outMustBeUnique, // whether port can hold only one of these</span>
<a href="#l1.598"></a><span id="l1.598">     nsIMdbTable** acqTable) = 0;       // acquire scoped collection of rows</span>
<a href="#l1.599"></a><span id="l1.599" class="difflineminus">-    </span>
<a href="#l1.600"></a><span id="l1.600" class="difflineplus">+</span>
<a href="#l1.601"></a><span id="l1.601">   NS_IMETHOD</span>
<a href="#l1.602"></a><span id="l1.602">   GetPortTableCursor( // get cursor for all tables of specific type</span>
<a href="#l1.603"></a><span id="l1.603">     nsIMdbEnv* ev, // context</span>
<a href="#l1.604"></a><span id="l1.604">     mdb_scope inRowScope, // row scope for row ids</span>
<a href="#l1.605"></a><span id="l1.605">     mdb_kind inTableKind, // the type of table to access</span>
<a href="#l1.606"></a><span id="l1.606">     nsIMdbPortTableCursor** acqCursor) = 0; // all such tables in the port</span>
<a href="#l1.607"></a><span id="l1.607">   // } ----- end table methods -----</span>
<a href="#l1.608"></a><span id="l1.608"> </span>
<a href="#l1.609"></a><span id="l1.609" class="difflineat">@@ -1161,17 +1161,17 @@ public:</span>
<a href="#l1.610"></a><span id="l1.610">   NS_IMETHOD ShouldCompress( // store wastes at least inPercentWaste?</span>
<a href="#l1.611"></a><span id="l1.611">     nsIMdbEnv* ev, // context</span>
<a href="#l1.612"></a><span id="l1.612">     mdb_percent inPercentWaste, // 0..100 percent file size waste threshold</span>
<a href="#l1.613"></a><span id="l1.613">     mdb_percent* outActualWaste, // 0..100 percent of file actually wasted</span>
<a href="#l1.614"></a><span id="l1.614">     mdb_bool* outShould) = 0; // true when about inPercentWaste% is wasted</span>
<a href="#l1.615"></a><span id="l1.615">   // ShouldCompress() returns true if the store can determine that the file</span>
<a href="#l1.616"></a><span id="l1.616">   // will shrink by an estimated percentage of inPercentWaste% (or more) if</span>
<a href="#l1.617"></a><span id="l1.617">   // CompressCommit() is called, because that percentage of the file seems</span>
<a href="#l1.618"></a><span id="l1.618" class="difflineminus">-  // to be recoverable free space.  The granularity is only in terms of </span>
<a href="#l1.619"></a><span id="l1.619" class="difflineplus">+  // to be recoverable free space.  The granularity is only in terms of</span>
<a href="#l1.620"></a><span id="l1.620">   // percentage points, and any value over 100 is considered equal to 100.</span>
<a href="#l1.621"></a><span id="l1.621">   //</span>
<a href="#l1.622"></a><span id="l1.622">   // If a store only has an approximate idea how much space might be saved</span>
<a href="#l1.623"></a><span id="l1.623">   // during a compress, then a best guess should be made.  For example, the</span>
<a href="#l1.624"></a><span id="l1.624">   // Mork implementation might keep track of how much file space began with</span>
<a href="#l1.625"></a><span id="l1.625">   // text content before the first updating transaction, and then consider</span>
<a href="#l1.626"></a><span id="l1.626">   // all content following the start of the first transaction as potentially</span>
<a href="#l1.627"></a><span id="l1.627">   // wasted space if it is all updates and not just new content.  (This is</span>
<a href="#l1.628"></a><span id="l1.628" class="difflineat">@@ -1210,17 +1210,17 @@ public:</span>
<a href="#l1.629"></a><span id="l1.629">   // of total file size to pass as in the inPercentWaste parameter.  A zero</span>
<a href="#l1.630"></a><span id="l1.630">   // likely returns always trivially true, and 100 always trivially false.</span>
<a href="#l1.631"></a><span id="l1.631">   // The great majority of callers are expected to use values from 25 to 75,</span>
<a href="#l1.632"></a><span id="l1.632">   // since most plausible thresholds for compressing might fall between the</span>
<a href="#l1.633"></a><span id="l1.633">   // extremes of 133% of ideal size and 400% of ideal size.  (Presumably the</span>
<a href="#l1.634"></a><span id="l1.634">   // larger a file gets, the more important the percentage waste involved, so</span>
<a href="#l1.635"></a><span id="l1.635">   // a sliding scale for compress thresholds might use smaller numbers for</span>
<a href="#l1.636"></a><span id="l1.636">   // much bigger file sizes.)</span>
<a href="#l1.637"></a><span id="l1.637" class="difflineminus">-  </span>
<a href="#l1.638"></a><span id="l1.638" class="difflineplus">+</span>
<a href="#l1.639"></a><span id="l1.639">   // } ----- end commit methods -----</span>
<a href="#l1.640"></a><span id="l1.640"> </span>
<a href="#l1.641"></a><span id="l1.641"> // } ===== end nsIMdbPort methods =====</span>
<a href="#l1.642"></a><span id="l1.642"> };</span>
<a href="#l1.643"></a><span id="l1.643"> </span>
<a href="#l1.644"></a><span id="l1.644"> /*| nsIMdbStore: a mutable interface to a specific database file.</span>
<a href="#l1.645"></a><span id="l1.645"> **|</span>
<a href="#l1.646"></a><span id="l1.646"> **|| tables: one can force a new table to exist in a store with NewTable()</span>
<a href="#l1.647"></a><span id="l1.647" class="difflineat">@@ -1242,17 +1242,17 @@ public:</span>
<a href="#l1.648"></a><span id="l1.648"> **| row content and imported row content, and this involves a specific kind of</span>
<a href="#l1.649"></a><span id="l1.649"> **| definition for row identity involving either row IDs or unique attributes,</span>
<a href="#l1.650"></a><span id="l1.650"> **| or some combination of these two.  At the moment I am just going to wave</span>
<a href="#l1.651"></a><span id="l1.651"> **| my hands, and say the default behavior is to assign all new row identities</span>
<a href="#l1.652"></a><span id="l1.652"> **| to all imported content, which will result in no merging of content; this</span>
<a href="#l1.653"></a><span id="l1.653"> **| must change later because it is unacceptable in some contexts.</span>
<a href="#l1.654"></a><span id="l1.654"> **|</span>
<a href="#l1.655"></a><span id="l1.655"> **|| commits: to manage modifications in a mutable store, very few methods are</span>
<a href="#l1.656"></a><span id="l1.656" class="difflineminus">-**| really needed to indicate global policy choices that are independent of </span>
<a href="#l1.657"></a><span id="l1.657" class="difflineplus">+**| really needed to indicate global policy choices that are independent of</span>
<a href="#l1.658"></a><span id="l1.658"> **| the actual modifications that happen in objects at the level of tables,</span>
<a href="#l1.659"></a><span id="l1.659"> **| rows, and cells, etc.  The most important policy to specify is which sets</span>
<a href="#l1.660"></a><span id="l1.660"> **| of changes are considered associated in a manner such that they should be</span>
<a href="#l1.661"></a><span id="l1.661"> **| applied together atomically to a given store.  We call each such group of</span>
<a href="#l1.662"></a><span id="l1.662"> **| changes a transaction.  We handle three different grades of transaction,</span>
<a href="#l1.663"></a><span id="l1.663"> **| but they differ only in semantic significance to the application, and are</span>
<a href="#l1.664"></a><span id="l1.664"> **| not intended to nest.  (If small transactions were nested inside large</span>
<a href="#l1.665"></a><span id="l1.665"> **| transactions, that would imply that a single large transaction must be</span>
<a href="#l1.666"></a><span id="l1.666" class="difflineat">@@ -1300,23 +1300,23 @@ public:</span>
<a href="#l1.667"></a><span id="l1.667">   // { ----- begin table methods -----</span>
<a href="#l1.668"></a><span id="l1.668">   NS_IMETHOD NewTable( // make one new table of specific type</span>
<a href="#l1.669"></a><span id="l1.669">     nsIMdbEnv* ev, // context</span>
<a href="#l1.670"></a><span id="l1.670">     mdb_scope inRowScope,    // row scope for row ids</span>
<a href="#l1.671"></a><span id="l1.671">     mdb_kind inTableKind,    // the type of table to access</span>
<a href="#l1.672"></a><span id="l1.672">     mdb_bool inMustBeUnique, // whether store can hold only one of these</span>
<a href="#l1.673"></a><span id="l1.673">     const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l1.674"></a><span id="l1.674">     nsIMdbTable** acqTable) = 0;     // acquire scoped collection of rows</span>
<a href="#l1.675"></a><span id="l1.675" class="difflineminus">-    </span>
<a href="#l1.676"></a><span id="l1.676" class="difflineplus">+</span>
<a href="#l1.677"></a><span id="l1.677">   NS_IMETHOD NewTableWithOid( // make one new table of specific type</span>
<a href="#l1.678"></a><span id="l1.678">     nsIMdbEnv* ev, // context</span>
<a href="#l1.679"></a><span id="l1.679">     const mdbOid* inOid,   // caller assigned oid</span>
<a href="#l1.680"></a><span id="l1.680">     mdb_kind inTableKind,    // the type of table to access</span>
<a href="#l1.681"></a><span id="l1.681">     mdb_bool inMustBeUnique, // whether store can hold only one of these</span>
<a href="#l1.682"></a><span id="l1.682" class="difflineminus">-    const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l1.683"></a><span id="l1.683" class="difflineplus">+    const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l1.684"></a><span id="l1.684">     nsIMdbTable** acqTable) = 0;     // acquire scoped collection of rows</span>
<a href="#l1.685"></a><span id="l1.685">   // } ----- end table methods -----</span>
<a href="#l1.686"></a><span id="l1.686"> </span>
<a href="#l1.687"></a><span id="l1.687">   // { ----- begin row scope methods -----</span>
<a href="#l1.688"></a><span id="l1.688">   NS_IMETHOD RowScopeHasAssignedIds(nsIMdbEnv* ev,</span>
<a href="#l1.689"></a><span id="l1.689">     mdb_scope inRowScope,   // row scope for row ids</span>
<a href="#l1.690"></a><span id="l1.690">     mdb_bool* outCallerAssigned, // nonzero if caller assigned specified</span>
<a href="#l1.691"></a><span id="l1.691">     mdb_bool* outStoreAssigned) = 0; // nonzero if store db assigned specified</span>
<a href="#l1.692"></a><span id="l1.692" class="difflineat">@@ -1395,17 +1395,17 @@ public:</span>
<a href="#l1.693"></a><span id="l1.693">   NS_IMETHOD</span>
<a href="#l1.694"></a><span id="l1.694">   CompressCommit( // commit and make db physically smaller if possible</span>
<a href="#l1.695"></a><span id="l1.695">     nsIMdbEnv* ev, // context</span>
<a href="#l1.696"></a><span id="l1.696">     nsIMdbThumb** acqThumb) = 0; // acquire thumb for incremental commit</span>
<a href="#l1.697"></a><span id="l1.697">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l1.698"></a><span id="l1.698">   // then the commit will be finished.  Note the store is effectively write</span>
<a href="#l1.699"></a><span id="l1.699">   // locked until commit is finished or canceled through the thumb instance.</span>
<a href="#l1.700"></a><span id="l1.700">   // Until the commit is done, the store will report it has readonly status.</span>
<a href="#l1.701"></a><span id="l1.701" class="difflineminus">-  </span>
<a href="#l1.702"></a><span id="l1.702" class="difflineplus">+</span>
<a href="#l1.703"></a><span id="l1.703">   // } ----- end commit methods -----</span>
<a href="#l1.704"></a><span id="l1.704"> </span>
<a href="#l1.705"></a><span id="l1.705"> // } ===== end nsIMdbStore methods =====</span>
<a href="#l1.706"></a><span id="l1.706"> };</span>
<a href="#l1.707"></a><span id="l1.707"> </span>
<a href="#l1.708"></a><span id="l1.708"> NS_DEFINE_STATIC_IID_ACCESSOR(nsIMdbStore, NS_IMDBSTORE_IID)</span>
<a href="#l1.709"></a><span id="l1.709"> </span>
<a href="#l1.710"></a><span id="l1.710"> /*| nsIMdbCursor: base cursor class for iterating row cells and table rows</span>
<a href="#l1.711"></a><span id="l1.711" class="difflineat">@@ -1441,20 +1441,20 @@ class nsIMdbCursor  : public nsISupports</span>
<a href="#l1.712"></a><span id="l1.712"> public:</span>
<a href="#l1.713"></a><span id="l1.713"> </span>
<a href="#l1.714"></a><span id="l1.714">   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMDBCURSOR_IID)</span>
<a href="#l1.715"></a><span id="l1.715"> // { ===== begin nsIMdbCursor methods =====</span>
<a href="#l1.716"></a><span id="l1.716"> </span>
<a href="#l1.717"></a><span id="l1.717">   // { ----- begin attribute methods -----</span>
<a href="#l1.718"></a><span id="l1.718">   NS_IMETHOD GetCount(nsIMdbEnv* ev, mdb_count* outCount) = 0; // readonly</span>
<a href="#l1.719"></a><span id="l1.719">   NS_IMETHOD GetSeed(nsIMdbEnv* ev, mdb_seed* outSeed) = 0;    // readonly</span>
<a href="#l1.720"></a><span id="l1.720" class="difflineminus">-  </span>
<a href="#l1.721"></a><span id="l1.721" class="difflineplus">+</span>
<a href="#l1.722"></a><span id="l1.722">   NS_IMETHOD SetPos(nsIMdbEnv* ev, mdb_pos inPos) = 0;   // mutable</span>
<a href="#l1.723"></a><span id="l1.723">   NS_IMETHOD GetPos(nsIMdbEnv* ev, mdb_pos* outPos) = 0;</span>
<a href="#l1.724"></a><span id="l1.724" class="difflineminus">-  </span>
<a href="#l1.725"></a><span id="l1.725" class="difflineplus">+</span>
<a href="#l1.726"></a><span id="l1.726">   NS_IMETHOD SetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool inFail) = 0;</span>
<a href="#l1.727"></a><span id="l1.727">   NS_IMETHOD GetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool* outFail) = 0;</span>
<a href="#l1.728"></a><span id="l1.728">   // } ----- end attribute methods -----</span>
<a href="#l1.729"></a><span id="l1.729"> </span>
<a href="#l1.730"></a><span id="l1.730"> // } ===== end nsIMdbCursor methods =====</span>
<a href="#l1.731"></a><span id="l1.731"> };</span>
<a href="#l1.732"></a><span id="l1.732"> </span>
<a href="#l1.733"></a><span id="l1.733"> NS_DEFINE_STATIC_IID_ACCESSOR(nsIMdbCursor, NS_IMDBCURSOR_IID)</span>
<a href="#l1.734"></a><span id="l1.734" class="difflineat">@@ -1476,22 +1476,22 @@ class nsIMdbPortTableCursor : public nsI</span>
<a href="#l1.735"></a><span id="l1.735"> public:</span>
<a href="#l1.736"></a><span id="l1.736"> </span>
<a href="#l1.737"></a><span id="l1.737">   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMDBPORTTABLECURSOR_IID)</span>
<a href="#l1.738"></a><span id="l1.738"> // { ===== begin nsIMdbPortTableCursor methods =====</span>
<a href="#l1.739"></a><span id="l1.739"> </span>
<a href="#l1.740"></a><span id="l1.740">   // { ----- begin attribute methods -----</span>
<a href="#l1.741"></a><span id="l1.741">   NS_IMETHOD SetPort(nsIMdbEnv* ev, nsIMdbPort* ioPort) = 0; // sets pos to -1</span>
<a href="#l1.742"></a><span id="l1.742">   NS_IMETHOD GetPort(nsIMdbEnv* ev, nsIMdbPort** acqPort) = 0;</span>
<a href="#l1.743"></a><span id="l1.743" class="difflineminus">-  </span>
<a href="#l1.744"></a><span id="l1.744" class="difflineplus">+</span>
<a href="#l1.745"></a><span id="l1.745">   NS_IMETHOD SetRowScope(nsIMdbEnv* ev, // sets pos to -1</span>
<a href="#l1.746"></a><span id="l1.746">     mdb_scope inRowScope) = 0;</span>
<a href="#l1.747"></a><span id="l1.747" class="difflineminus">-  NS_IMETHOD GetRowScope(nsIMdbEnv* ev, mdb_scope* outRowScope) = 0; </span>
<a href="#l1.748"></a><span id="l1.748" class="difflineplus">+  NS_IMETHOD GetRowScope(nsIMdbEnv* ev, mdb_scope* outRowScope) = 0;</span>
<a href="#l1.749"></a><span id="l1.749">   // setting row scope to zero iterates over all row scopes in port</span>
<a href="#l1.750"></a><span id="l1.750" class="difflineminus">-    </span>
<a href="#l1.751"></a><span id="l1.751" class="difflineplus">+</span>
<a href="#l1.752"></a><span id="l1.752">   NS_IMETHOD SetTableKind(nsIMdbEnv* ev, // sets pos to -1</span>
<a href="#l1.753"></a><span id="l1.753">     mdb_kind inTableKind) = 0;</span>
<a href="#l1.754"></a><span id="l1.754">   NS_IMETHOD GetTableKind(nsIMdbEnv* ev, mdb_kind* outTableKind) = 0;</span>
<a href="#l1.755"></a><span id="l1.755">   // setting table kind to zero iterates over all table kinds in row scope</span>
<a href="#l1.756"></a><span id="l1.756">   // } ----- end attribute methods -----</span>
<a href="#l1.757"></a><span id="l1.757"> </span>
<a href="#l1.758"></a><span id="l1.758">   // { ----- begin table iteration methods -----</span>
<a href="#l1.759"></a><span id="l1.759">   NS_IMETHOD NextTable( // get table at next position in the db</span>
<a href="#l1.760"></a><span id="l1.760" class="difflineat">@@ -1707,28 +1707,28 @@ class nsIMdbTable : public nsIMdbCollect</span>
<a href="#l1.761"></a><span id="l1.761"> public:</span>
<a href="#l1.762"></a><span id="l1.762"> </span>
<a href="#l1.763"></a><span id="l1.763">   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMDBTABLE_IID)</span>
<a href="#l1.764"></a><span id="l1.764"> // { ===== begin nsIMdbTable methods =====</span>
<a href="#l1.765"></a><span id="l1.765"> </span>
<a href="#l1.766"></a><span id="l1.766">   // { ----- begin meta attribute methods -----</span>
<a href="#l1.767"></a><span id="l1.767">   NS_IMETHOD SetTablePriority(nsIMdbEnv* ev, mdb_priority inPrio) = 0;</span>
<a href="#l1.768"></a><span id="l1.768">   NS_IMETHOD GetTablePriority(nsIMdbEnv* ev, mdb_priority* outPrio) = 0;</span>
<a href="#l1.769"></a><span id="l1.769" class="difflineminus">-  </span>
<a href="#l1.770"></a><span id="l1.770" class="difflineplus">+</span>
<a href="#l1.771"></a><span id="l1.771">   NS_IMETHOD GetTableBeVerbose(nsIMdbEnv* ev, mdb_bool* outBeVerbose) = 0;</span>
<a href="#l1.772"></a><span id="l1.772">   NS_IMETHOD SetTableBeVerbose(nsIMdbEnv* ev, mdb_bool inBeVerbose) = 0;</span>
<a href="#l1.773"></a><span id="l1.773" class="difflineminus">-  </span>
<a href="#l1.774"></a><span id="l1.774" class="difflineplus">+</span>
<a href="#l1.775"></a><span id="l1.775">   NS_IMETHOD GetTableIsUnique(nsIMdbEnv* ev, mdb_bool* outIsUnique) = 0;</span>
<a href="#l1.776"></a><span id="l1.776" class="difflineminus">-  </span>
<a href="#l1.777"></a><span id="l1.777" class="difflineplus">+</span>
<a href="#l1.778"></a><span id="l1.778">   NS_IMETHOD GetTableKind(nsIMdbEnv* ev, mdb_kind* outTableKind) = 0;</span>
<a href="#l1.779"></a><span id="l1.779">   NS_IMETHOD GetRowScope(nsIMdbEnv* ev, mdb_scope* outRowScope) = 0;</span>
<a href="#l1.780"></a><span id="l1.780" class="difflineminus">-  </span>
<a href="#l1.781"></a><span id="l1.781" class="difflineplus">+</span>
<a href="#l1.782"></a><span id="l1.782">   NS_IMETHOD GetMetaRow(</span>
<a href="#l1.783"></a><span id="l1.783">     nsIMdbEnv* ev, // context</span>
<a href="#l1.784"></a><span id="l1.784" class="difflineminus">-    const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l1.785"></a><span id="l1.785" class="difflineplus">+    const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l1.786"></a><span id="l1.786">     mdbOid* outOid, // output meta row oid, can be nil to suppress output</span>
<a href="#l1.787"></a><span id="l1.787">     nsIMdbRow** acqRow) = 0; // acquire table's unique singleton meta row</span>
<a href="#l1.788"></a><span id="l1.788">     // The purpose of a meta row is to support the persistent recording of</span>
<a href="#l1.789"></a><span id="l1.789">     // meta info about a table as cells put into the distinguished meta row.</span>
<a href="#l1.790"></a><span id="l1.790">     // Each table has exactly one meta row, which is not considered a member</span>
<a href="#l1.791"></a><span id="l1.791">     // of the collection of rows inside the table.  The only way to tell</span>
<a href="#l1.792"></a><span id="l1.792">     // whether a row is a meta row is by the fact that it is returned by this</span>
<a href="#l1.793"></a><span id="l1.793">     // GetMetaRow() method from some table. Otherwise nothing distinguishes</span>
<a href="#l1.794"></a><span id="l1.794" class="difflineat">@@ -1763,83 +1763,83 @@ public:</span>
<a href="#l1.795"></a><span id="l1.795">     nsIMdbEnv* ev, // context</span>
<a href="#l1.796"></a><span id="l1.796">     mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l1.797"></a><span id="l1.797">     mdbOid* outOid) = 0; // row oid at the specified position</span>
<a href="#l1.798"></a><span id="l1.798"> </span>
<a href="#l1.799"></a><span id="l1.799">   NS_IMETHOD OidToPos( // test for the table position of a row member</span>
<a href="#l1.800"></a><span id="l1.800">     nsIMdbEnv* ev, // context</span>
<a href="#l1.801"></a><span id="l1.801">     const mdbOid* inOid, // row to find in table</span>
<a href="#l1.802"></a><span id="l1.802">     mdb_pos* outPos) = 0; // zero-based ordinal position of row in table</span>
<a href="#l1.803"></a><span id="l1.803" class="difflineminus">-    </span>
<a href="#l1.804"></a><span id="l1.804" class="difflineplus">+</span>
<a href="#l1.805"></a><span id="l1.805">   NS_IMETHOD PosToRow( // test for the table position of a row member</span>
<a href="#l1.806"></a><span id="l1.806">     nsIMdbEnv* ev, // context</span>
<a href="#l1.807"></a><span id="l1.807">     mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l1.808"></a><span id="l1.808">     nsIMdbRow** acqRow) = 0; // acquire row at table position inRowPos</span>
<a href="#l1.809"></a><span id="l1.809" class="difflineminus">-    </span>
<a href="#l1.810"></a><span id="l1.810" class="difflineplus">+</span>
<a href="#l1.811"></a><span id="l1.811">   NS_IMETHOD RowToPos( // test for the table position of a row member</span>
<a href="#l1.812"></a><span id="l1.812">     nsIMdbEnv* ev, // context</span>
<a href="#l1.813"></a><span id="l1.813">     nsIMdbRow* ioRow, // row to find in table</span>
<a href="#l1.814"></a><span id="l1.814">     mdb_pos* outPos) = 0; // zero-based ordinal position of row in table</span>
<a href="#l1.815"></a><span id="l1.815">   // } ----- end row position methods -----</span>
<a href="#l1.816"></a><span id="l1.816"> </span>
<a href="#l1.817"></a><span id="l1.817">   // { ----- begin oid set methods -----</span>
<a href="#l1.818"></a><span id="l1.818" class="difflineminus">-  NS_IMETHOD AddOid( // make sure the row with inOid is a table member </span>
<a href="#l1.819"></a><span id="l1.819" class="difflineplus">+  NS_IMETHOD AddOid( // make sure the row with inOid is a table member</span>
<a href="#l1.820"></a><span id="l1.820">     nsIMdbEnv* ev, // context</span>
<a href="#l1.821"></a><span id="l1.821">     const mdbOid* inOid) = 0; // row to ensure membership in table</span>
<a href="#l1.822"></a><span id="l1.822"> </span>
<a href="#l1.823"></a><span id="l1.823">   NS_IMETHOD HasOid( // test for the table position of a row member</span>
<a href="#l1.824"></a><span id="l1.824">     nsIMdbEnv* ev, // context</span>
<a href="#l1.825"></a><span id="l1.825">     const mdbOid* inOid, // row to find in table</span>
<a href="#l1.826"></a><span id="l1.826">     mdb_bool* outHasOid) = 0; // whether inOid is a member row</span>
<a href="#l1.827"></a><span id="l1.827"> </span>
<a href="#l1.828"></a><span id="l1.828" class="difflineminus">-  NS_IMETHOD CutOid( // make sure the row with inOid is not a member </span>
<a href="#l1.829"></a><span id="l1.829" class="difflineplus">+  NS_IMETHOD CutOid( // make sure the row with inOid is not a member</span>
<a href="#l1.830"></a><span id="l1.830">     nsIMdbEnv* ev, // context</span>
<a href="#l1.831"></a><span id="l1.831">     const mdbOid* inOid) = 0; // row to remove from table</span>
<a href="#l1.832"></a><span id="l1.832">   // } ----- end oid set methods -----</span>
<a href="#l1.833"></a><span id="l1.833"> </span>
<a href="#l1.834"></a><span id="l1.834">   // { ----- begin row set methods -----</span>
<a href="#l1.835"></a><span id="l1.835">   NS_IMETHOD NewRow( // create a new row instance in table</span>
<a href="#l1.836"></a><span id="l1.836">     nsIMdbEnv* ev, // context</span>
<a href="#l1.837"></a><span id="l1.837">     mdbOid* ioOid, // please use minus one (unbound) rowId for db-assigned IDs</span>
<a href="#l1.838"></a><span id="l1.838">     nsIMdbRow** acqRow) = 0; // create new row</span>
<a href="#l1.839"></a><span id="l1.839"> </span>
<a href="#l1.840"></a><span id="l1.840" class="difflineminus">-  NS_IMETHOD AddRow( // make sure the row with inOid is a table member </span>
<a href="#l1.841"></a><span id="l1.841" class="difflineplus">+  NS_IMETHOD AddRow( // make sure the row with inOid is a table member</span>
<a href="#l1.842"></a><span id="l1.842">     nsIMdbEnv* ev, // context</span>
<a href="#l1.843"></a><span id="l1.843">     nsIMdbRow* ioRow) = 0; // row to ensure membership in table</span>
<a href="#l1.844"></a><span id="l1.844"> </span>
<a href="#l1.845"></a><span id="l1.845">   NS_IMETHOD HasRow( // test for the table position of a row member</span>
<a href="#l1.846"></a><span id="l1.846">     nsIMdbEnv* ev, // context</span>
<a href="#l1.847"></a><span id="l1.847">     nsIMdbRow* ioRow, // row to find in table</span>
<a href="#l1.848"></a><span id="l1.848">     mdb_bool* outHasRow) = 0; // whether row is a table member</span>
<a href="#l1.849"></a><span id="l1.849"> </span>
<a href="#l1.850"></a><span id="l1.850" class="difflineminus">-  NS_IMETHOD CutRow( // make sure the row with inOid is not a member </span>
<a href="#l1.851"></a><span id="l1.851" class="difflineplus">+  NS_IMETHOD CutRow( // make sure the row with inOid is not a member</span>
<a href="#l1.852"></a><span id="l1.852">     nsIMdbEnv* ev, // context</span>
<a href="#l1.853"></a><span id="l1.853">     nsIMdbRow* ioRow) = 0; // row to remove from table</span>
<a href="#l1.854"></a><span id="l1.854"> </span>
<a href="#l1.855"></a><span id="l1.855">   NS_IMETHOD CutAllRows( // remove all rows from the table</span>
<a href="#l1.856"></a><span id="l1.856">     nsIMdbEnv* ev) = 0; // context</span>
<a href="#l1.857"></a><span id="l1.857">   // } ----- end row set methods -----</span>
<a href="#l1.858"></a><span id="l1.858"> </span>
<a href="#l1.859"></a><span id="l1.859">   // { ----- begin hinting methods -----</span>
<a href="#l1.860"></a><span id="l1.860" class="difflineminus">-  NS_IMETHOD SearchColumnsHint( // advise re future expected search cols  </span>
<a href="#l1.861"></a><span id="l1.861" class="difflineplus">+  NS_IMETHOD SearchColumnsHint( // advise re future expected search cols</span>
<a href="#l1.862"></a><span id="l1.862">     nsIMdbEnv* ev, // context</span>
<a href="#l1.863"></a><span id="l1.863">     const mdbColumnSet* inColumnSet) = 0; // columns likely to be searched</span>
<a href="#l1.864"></a><span id="l1.864" class="difflineminus">-    </span>
<a href="#l1.865"></a><span id="l1.865" class="difflineminus">-  NS_IMETHOD SortColumnsHint( // advise re future expected sort columns  </span>
<a href="#l1.866"></a><span id="l1.866" class="difflineplus">+</span>
<a href="#l1.867"></a><span id="l1.867" class="difflineplus">+  NS_IMETHOD SortColumnsHint( // advise re future expected sort columns</span>
<a href="#l1.868"></a><span id="l1.868">     nsIMdbEnv* ev, // context</span>
<a href="#l1.869"></a><span id="l1.869">     const mdbColumnSet* inColumnSet) = 0; // columns for likely sort requests</span>
<a href="#l1.870"></a><span id="l1.870" class="difflineminus">-    </span>
<a href="#l1.871"></a><span id="l1.871" class="difflineminus">-  NS_IMETHOD StartBatchChangeHint( // advise before many adds and cuts  </span>
<a href="#l1.872"></a><span id="l1.872" class="difflineplus">+</span>
<a href="#l1.873"></a><span id="l1.873" class="difflineplus">+  NS_IMETHOD StartBatchChangeHint( // advise before many adds and cuts</span>
<a href="#l1.874"></a><span id="l1.874">     nsIMdbEnv* ev, // context</span>
<a href="#l1.875"></a><span id="l1.875">     const void* inLabel) = 0; // intend unique address to match end call</span>
<a href="#l1.876"></a><span id="l1.876">     // If batch starts nest by virtue of nesting calls in the stack, then</span>
<a href="#l1.877"></a><span id="l1.877">     // the address of a local variable makes a good batch start label that</span>
<a href="#l1.878"></a><span id="l1.878">     // can be used at batch end time, and such addresses remain unique.</span>
<a href="#l1.879"></a><span id="l1.879" class="difflineminus">-    </span>
<a href="#l1.880"></a><span id="l1.880" class="difflineminus">-  NS_IMETHOD EndBatchChangeHint( // advise before many adds and cuts  </span>
<a href="#l1.881"></a><span id="l1.881" class="difflineplus">+</span>
<a href="#l1.882"></a><span id="l1.882" class="difflineplus">+  NS_IMETHOD EndBatchChangeHint( // advise before many adds and cuts</span>
<a href="#l1.883"></a><span id="l1.883">     nsIMdbEnv* ev, // context</span>
<a href="#l1.884"></a><span id="l1.884">     const void* inLabel) = 0; // label matching start label</span>
<a href="#l1.885"></a><span id="l1.885">     // Suppose a table is maintaining one or many sort orders for a table,</span>
<a href="#l1.886"></a><span id="l1.886">     // so that every row added to the table must be inserted in each sort,</span>
<a href="#l1.887"></a><span id="l1.887">     // and every row cut must be removed from each sort.  If a db client</span>
<a href="#l1.888"></a><span id="l1.888">     // intends to make many such changes before needing any information</span>
<a href="#l1.889"></a><span id="l1.889">     // about the order or positions of rows inside a table, then a client</span>
<a href="#l1.890"></a><span id="l1.890">     // might tell the table to start batch changes in order to disable</span>
<a href="#l1.891"></a><span id="l1.891" class="difflineat">@@ -1848,17 +1848,17 @@ public:</span>
<a href="#l1.892"></a><span id="l1.892">     // a surprise request occurs for row position during batch changes.</span>
<a href="#l1.893"></a><span id="l1.893">   // } ----- end hinting methods -----</span>
<a href="#l1.894"></a><span id="l1.894"> </span>
<a href="#l1.895"></a><span id="l1.895">   // { ----- begin searching methods -----</span>
<a href="#l1.896"></a><span id="l1.896">   NS_IMETHOD FindRowMatches( // search variable number of sorted cols</span>
<a href="#l1.897"></a><span id="l1.897">     nsIMdbEnv* ev, // context</span>
<a href="#l1.898"></a><span id="l1.898">     const mdbYarn* inPrefix, // content to find as prefix in row's column cell</span>
<a href="#l1.899"></a><span id="l1.899">     nsIMdbTableRowCursor** acqCursor) = 0; // set of matching rows</span>
<a href="#l1.900"></a><span id="l1.900" class="difflineminus">-    </span>
<a href="#l1.901"></a><span id="l1.901" class="difflineplus">+</span>
<a href="#l1.902"></a><span id="l1.902">   NS_IMETHOD GetSearchColumns( // query columns used by FindRowMatches()</span>
<a href="#l1.903"></a><span id="l1.903">     nsIMdbEnv* ev, // context</span>
<a href="#l1.904"></a><span id="l1.904">     mdb_count* outCount, // context</span>
<a href="#l1.905"></a><span id="l1.905">     mdbColumnSet* outColSet) = 0; // caller supplied space to put columns</span>
<a href="#l1.906"></a><span id="l1.906">     // GetSearchColumns() returns the columns actually searched when the</span>
<a href="#l1.907"></a><span id="l1.907">     // FindRowMatches() method is called.  No more than mColumnSet_Count</span>
<a href="#l1.908"></a><span id="l1.908">     // slots of mColumnSet_Columns will be written, since mColumnSet_Count</span>
<a href="#l1.909"></a><span id="l1.909">     // indicates how many slots are present in the column array.  The</span>
<a href="#l1.910"></a><span id="l1.910" class="difflineat">@@ -1876,22 +1876,22 @@ public:</span>
<a href="#l1.911"></a><span id="l1.911">   // sorting: note all rows are assumed sorted by row ID as a secondary</span>
<a href="#l1.912"></a><span id="l1.912">   // sort following the primary column sort, when table rows are sorted.</span>
<a href="#l1.913"></a><span id="l1.913"> </span>
<a href="#l1.914"></a><span id="l1.914">   NS_IMETHOD</span>
<a href="#l1.915"></a><span id="l1.915">   CanSortColumn( // query which column is currently used for sorting</span>
<a href="#l1.916"></a><span id="l1.916">     nsIMdbEnv* ev, // context</span>
<a href="#l1.917"></a><span id="l1.917">     mdb_column inColumn, // column to query sorting potential</span>
<a href="#l1.918"></a><span id="l1.918">     mdb_bool* outCanSort) = 0; // whether the column can be sorted</span>
<a href="#l1.919"></a><span id="l1.919" class="difflineminus">-    </span>
<a href="#l1.920"></a><span id="l1.920" class="difflineplus">+</span>
<a href="#l1.921"></a><span id="l1.921">   NS_IMETHOD GetSorting( // view same table in particular sorting</span>
<a href="#l1.922"></a><span id="l1.922">     nsIMdbEnv* ev, // context</span>
<a href="#l1.923"></a><span id="l1.923">     mdb_column inColumn, // requested new column for sorting table</span>
<a href="#l1.924"></a><span id="l1.924">     nsIMdbSorting** acqSorting) = 0; // acquire sorting for column</span>
<a href="#l1.925"></a><span id="l1.925" class="difflineminus">-    </span>
<a href="#l1.926"></a><span id="l1.926" class="difflineplus">+</span>
<a href="#l1.927"></a><span id="l1.927">   NS_IMETHOD SetSearchSorting( // use this sorting in FindRowMatches()</span>
<a href="#l1.928"></a><span id="l1.928">     nsIMdbEnv* ev, // context</span>
<a href="#l1.929"></a><span id="l1.929">     mdb_column inColumn, // often same as nsIMdbSorting::GetSortColumn()</span>
<a href="#l1.930"></a><span id="l1.930">     nsIMdbSorting* ioSorting) = 0; // requested sorting for some column</span>
<a href="#l1.931"></a><span id="l1.931">     // SetSearchSorting() attempts to inform the table that ioSorting</span>
<a href="#l1.932"></a><span id="l1.932">     // should be used during calls to FindRowMatches() for searching</span>
<a href="#l1.933"></a><span id="l1.933">     // the column which is actually sorted by ioSorting.  This method</span>
<a href="#l1.934"></a><span id="l1.934">     // is most useful in conjunction with nsIMdbSorting::SetCompare(),</span>
<a href="#l1.935"></a><span id="l1.935" class="difflineat">@@ -1912,62 +1912,62 @@ public:</span>
<a href="#l1.936"></a><span id="l1.936">     // implementations are instructed to give precedence to the column</span>
<a href="#l1.937"></a><span id="l1.937">     // specified by ioSorting (so this means callers might just pass</span>
<a href="#l1.938"></a><span id="l1.938">     // zero for inColumn when ioSorting is also provided, since then</span>
<a href="#l1.939"></a><span id="l1.939">     // inColumn is both redundant and ignored).</span>
<a href="#l1.940"></a><span id="l1.940">   // } ----- end sorting methods -----</span>
<a href="#l1.941"></a><span id="l1.941"> </span>
<a href="#l1.942"></a><span id="l1.942">   // { ----- begin moving methods -----</span>
<a href="#l1.943"></a><span id="l1.943">   // moving a row does nothing unless a table is currently unsorted</span>
<a href="#l1.944"></a><span id="l1.944" class="difflineminus">-  </span>
<a href="#l1.945"></a><span id="l1.945" class="difflineplus">+</span>
<a href="#l1.946"></a><span id="l1.946">   NS_IMETHOD MoveOid( // change position of row in unsorted table</span>
<a href="#l1.947"></a><span id="l1.947">     nsIMdbEnv* ev, // context</span>
<a href="#l1.948"></a><span id="l1.948">     const mdbOid* inOid,  // row oid to find in table</span>
<a href="#l1.949"></a><span id="l1.949">     mdb_pos inHintFromPos, // suggested hint regarding start position</span>
<a href="#l1.950"></a><span id="l1.950">     mdb_pos inToPos,       // desired new position for row inRowId</span>
<a href="#l1.951"></a><span id="l1.951">     mdb_pos* outActualPos) = 0; // actual new position of row in table</span>
<a href="#l1.952"></a><span id="l1.952"> </span>
<a href="#l1.953"></a><span id="l1.953">   NS_IMETHOD MoveRow( // change position of row in unsorted table</span>
<a href="#l1.954"></a><span id="l1.954">     nsIMdbEnv* ev, // context</span>
<a href="#l1.955"></a><span id="l1.955">     nsIMdbRow* ioRow,  // row oid to find in table</span>
<a href="#l1.956"></a><span id="l1.956">     mdb_pos inHintFromPos, // suggested hint regarding start position</span>
<a href="#l1.957"></a><span id="l1.957">     mdb_pos inToPos,       // desired new position for row inRowId</span>
<a href="#l1.958"></a><span id="l1.958">     mdb_pos* outActualPos) = 0; // actual new position of row in table</span>
<a href="#l1.959"></a><span id="l1.959">   // } ----- end moving methods -----</span>
<a href="#l1.960"></a><span id="l1.960" class="difflineminus">-  </span>
<a href="#l1.961"></a><span id="l1.961" class="difflineplus">+</span>
<a href="#l1.962"></a><span id="l1.962">   // { ----- begin index methods -----</span>
<a href="#l1.963"></a><span id="l1.963">   NS_IMETHOD AddIndex( // create a sorting index for column if possible</span>
<a href="#l1.964"></a><span id="l1.964">     nsIMdbEnv* ev, // context</span>
<a href="#l1.965"></a><span id="l1.965">     mdb_column inColumn, // the column to sort by index</span>
<a href="#l1.966"></a><span id="l1.966">     nsIMdbThumb** acqThumb) = 0; // acquire thumb for incremental index building</span>
<a href="#l1.967"></a><span id="l1.967">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l1.968"></a><span id="l1.968">   // then the index addition will be finished.</span>
<a href="#l1.969"></a><span id="l1.969" class="difflineminus">-  </span>
<a href="#l1.970"></a><span id="l1.970" class="difflineplus">+</span>
<a href="#l1.971"></a><span id="l1.971">   NS_IMETHOD CutIndex( // stop supporting a specific column index</span>
<a href="#l1.972"></a><span id="l1.972">     nsIMdbEnv* ev, // context</span>
<a href="#l1.973"></a><span id="l1.973">     mdb_column inColumn, // the column with index to be removed</span>
<a href="#l1.974"></a><span id="l1.974">     nsIMdbThumb** acqThumb) = 0; // acquire thumb for incremental index destroy</span>
<a href="#l1.975"></a><span id="l1.975">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l1.976"></a><span id="l1.976">   // then the index removal will be finished.</span>
<a href="#l1.977"></a><span id="l1.977" class="difflineminus">-  </span>
<a href="#l1.978"></a><span id="l1.978" class="difflineplus">+</span>
<a href="#l1.979"></a><span id="l1.979">   NS_IMETHOD HasIndex( // query for current presence of a column index</span>
<a href="#l1.980"></a><span id="l1.980">     nsIMdbEnv* ev, // context</span>
<a href="#l1.981"></a><span id="l1.981">     mdb_column inColumn, // the column to investigate</span>
<a href="#l1.982"></a><span id="l1.982">     mdb_bool* outHasIndex) = 0; // whether column has index for this column</span>
<a href="#l1.983"></a><span id="l1.983"> </span>
<a href="#l1.984"></a><span id="l1.984" class="difflineminus">-  </span>
<a href="#l1.985"></a><span id="l1.985" class="difflineplus">+</span>
<a href="#l1.986"></a><span id="l1.986">   NS_IMETHOD EnableIndexOnSort( // create an index for col on first sort</span>
<a href="#l1.987"></a><span id="l1.987">     nsIMdbEnv* ev, // context</span>
<a href="#l1.988"></a><span id="l1.988">     mdb_column inColumn) = 0; // the column to index if ever sorted</span>
<a href="#l1.989"></a><span id="l1.989" class="difflineminus">-  </span>
<a href="#l1.990"></a><span id="l1.990" class="difflineplus">+</span>
<a href="#l1.991"></a><span id="l1.991">   NS_IMETHOD QueryIndexOnSort( // check whether index on sort is enabled</span>
<a href="#l1.992"></a><span id="l1.992">     nsIMdbEnv* ev, // context</span>
<a href="#l1.993"></a><span id="l1.993">     mdb_column inColumn, // the column to investigate</span>
<a href="#l1.994"></a><span id="l1.994">     mdb_bool* outIndexOnSort) = 0; // whether column has index-on-sort enabled</span>
<a href="#l1.995"></a><span id="l1.995" class="difflineminus">-  </span>
<a href="#l1.996"></a><span id="l1.996" class="difflineplus">+</span>
<a href="#l1.997"></a><span id="l1.997">   NS_IMETHOD DisableIndexOnSort( // prevent future index creation on sort</span>
<a href="#l1.998"></a><span id="l1.998">     nsIMdbEnv* ev, // context</span>
<a href="#l1.999"></a><span id="l1.999">     mdb_column inColumn) = 0; // the column to index if ever sorted</span>
<a href="#l1.1000"></a><span id="l1.1000">   // } ----- end index methods -----</span>
<a href="#l1.1001"></a><span id="l1.1001"> </span>
<a href="#l1.1002"></a><span id="l1.1002"> // } ===== end nsIMdbTable methods =====</span>
<a href="#l1.1003"></a><span id="l1.1003"> };</span>
<a href="#l1.1004"></a><span id="l1.1004"> </span>
<a href="#l1.1005"></a><span id="l1.1005" class="difflineat">@@ -1993,28 +1993,28 @@ NS_DEFINE_STATIC_IID_ACCESSOR(nsIMdbTabl</span>
<a href="#l1.1006"></a><span id="l1.1006"> **|</span>
<a href="#l1.1007"></a><span id="l1.1007"> **|| cursor: in case callers are more comfortable with a cursor style</span>
<a href="#l1.1008"></a><span id="l1.1008"> **| of accessing row members, each sorting will happily return a cursor</span>
<a href="#l1.1009"></a><span id="l1.1009"> **| instance with behavior very similar to a cursor returned from a call</span>
<a href="#l1.1010"></a><span id="l1.1010"> **| to nsIMdbTable::GetTableRowCursor(), but with different row order.</span>
<a href="#l1.1011"></a><span id="l1.1011"> **| A cursor should show exactly the same information as the pos methods.</span>
<a href="#l1.1012"></a><span id="l1.1012"> **|</span>
<a href="#l1.1013"></a><span id="l1.1013"> **|| pos: the PosToOid() and PosToRow() methods are just like the table</span>
<a href="#l1.1014"></a><span id="l1.1014" class="difflineminus">-**| methods of the same name, except they show rows in the sort order of </span>
<a href="#l1.1015"></a><span id="l1.1015" class="difflineplus">+**| methods of the same name, except they show rows in the sort order of</span>
<a href="#l1.1016"></a><span id="l1.1016"> **| the sorting, rather than that of the table.  These methods are like</span>
<a href="#l1.1017"></a><span id="l1.1017"> **| readonly array position accessor's, or like a C++ operator[].</span>
<a href="#l1.1018"></a><span id="l1.1018"> |*/</span>
<a href="#l1.1019"></a><span id="l1.1019"> class nsIMdbSorting : public nsIMdbObject { // sorting of some table</span>
<a href="#l1.1020"></a><span id="l1.1020"> public:</span>
<a href="#l1.1021"></a><span id="l1.1021"> // { ===== begin nsIMdbSorting methods =====</span>
<a href="#l1.1022"></a><span id="l1.1022"> </span>
<a href="#l1.1023"></a><span id="l1.1023">   // { ----- begin attribute methods -----</span>
<a href="#l1.1024"></a><span id="l1.1024">   // sorting: note all rows are assumed sorted by row ID as a secondary</span>
<a href="#l1.1025"></a><span id="l1.1025">   // sort following the primary column sort, when table rows are sorted.</span>
<a href="#l1.1026"></a><span id="l1.1026" class="difflineminus">-  </span>
<a href="#l1.1027"></a><span id="l1.1027" class="difflineplus">+</span>
<a href="#l1.1028"></a><span id="l1.1028">   NS_IMETHOD GetTable(nsIMdbEnv* ev, nsIMdbTable** acqTable) = 0;</span>
<a href="#l1.1029"></a><span id="l1.1029">   NS_IMETHOD GetSortColumn( // query which col is currently sorted</span>
<a href="#l1.1030"></a><span id="l1.1030">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1031"></a><span id="l1.1031">     mdb_column* outColumn) = 0; // col the table uses for sorting (or zero)</span>
<a href="#l1.1032"></a><span id="l1.1032"> </span>
<a href="#l1.1033"></a><span id="l1.1033">   // } ----- end attribute methods -----</span>
<a href="#l1.1034"></a><span id="l1.1034"> </span>
<a href="#l1.1035"></a><span id="l1.1035">   // { ----- begin cursor methods -----</span>
<a href="#l1.1036"></a><span id="l1.1036" class="difflineat">@@ -2025,17 +2025,17 @@ public:</span>
<a href="#l1.1037"></a><span id="l1.1037">     // A cursor interface turning same info as PosToOid() or PosToRow().</span>
<a href="#l1.1038"></a><span id="l1.1038">   // } ----- end row position methods -----</span>
<a href="#l1.1039"></a><span id="l1.1039"> </span>
<a href="#l1.1040"></a><span id="l1.1040">   // { ----- begin row position methods -----</span>
<a href="#l1.1041"></a><span id="l1.1041">   NS_IMETHOD PosToOid( // get row member for a table position</span>
<a href="#l1.1042"></a><span id="l1.1042">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1043"></a><span id="l1.1043">     mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l1.1044"></a><span id="l1.1044">     mdbOid* outOid) = 0; // row oid at the specified position</span>
<a href="#l1.1045"></a><span id="l1.1045" class="difflineminus">-    </span>
<a href="#l1.1046"></a><span id="l1.1046" class="difflineplus">+</span>
<a href="#l1.1047"></a><span id="l1.1047">   NS_IMETHOD PosToRow( // test for the table position of a row member</span>
<a href="#l1.1048"></a><span id="l1.1048">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1049"></a><span id="l1.1049">     mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l1.1050"></a><span id="l1.1050">     nsIMdbRow** acqRow) = 0; // acquire row at table position inRowPos</span>
<a href="#l1.1051"></a><span id="l1.1051">   // } ----- end row position methods -----</span>
<a href="#l1.1052"></a><span id="l1.1052"> </span>
<a href="#l1.1053"></a><span id="l1.1053"> // } ===== end nsIMdbSorting methods =====</span>
<a href="#l1.1054"></a><span id="l1.1054"> };</span>
<a href="#l1.1055"></a><span id="l1.1055" class="difflineat">@@ -2077,24 +2077,24 @@ class nsIMdbTableRowCursor : public nsIS</span>
<a href="#l1.1056"></a><span id="l1.1056"> public:</span>
<a href="#l1.1057"></a><span id="l1.1057">   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMDBTABLEROWCURSOR_IID)</span>
<a href="#l1.1058"></a><span id="l1.1058"> </span>
<a href="#l1.1059"></a><span id="l1.1059"> // { ===== begin nsIMdbTableRowCursor methods =====</span>
<a href="#l1.1060"></a><span id="l1.1060"> </span>
<a href="#l1.1061"></a><span id="l1.1061">   // { ----- begin attribute methods -----</span>
<a href="#l1.1062"></a><span id="l1.1062">   // NS_IMETHOD SetTable(nsIMdbEnv* ev, nsIMdbTable* ioTable) = 0; // sets pos to -1</span>
<a href="#l1.1063"></a><span id="l1.1063">   // Method SetTable() cut and made obsolete in keeping with new sorting methods.</span>
<a href="#l1.1064"></a><span id="l1.1064" class="difflineminus">-  </span>
<a href="#l1.1065"></a><span id="l1.1065" class="difflineplus">+</span>
<a href="#l1.1066"></a><span id="l1.1066">   NS_IMETHOD GetTable(nsIMdbEnv* ev, nsIMdbTable** acqTable) = 0;</span>
<a href="#l1.1067"></a><span id="l1.1067">   // } ----- end attribute methods -----</span>
<a href="#l1.1068"></a><span id="l1.1068"> </span>
<a href="#l1.1069"></a><span id="l1.1069">   // { ----- begin duplicate row removal methods -----</span>
<a href="#l1.1070"></a><span id="l1.1070">   NS_IMETHOD CanHaveDupRowMembers(nsIMdbEnv* ev, // cursor might hold dups?</span>
<a href="#l1.1071"></a><span id="l1.1071">     mdb_bool* outCanHaveDups) = 0;</span>
<a href="#l1.1072"></a><span id="l1.1072" class="difflineminus">-    </span>
<a href="#l1.1073"></a><span id="l1.1073" class="difflineplus">+</span>
<a href="#l1.1074"></a><span id="l1.1074">   NS_IMETHOD MakeUniqueCursor( // clone cursor, removing duplicate rows</span>
<a href="#l1.1075"></a><span id="l1.1075">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1076"></a><span id="l1.1076">     nsIMdbTableRowCursor** acqCursor) = 0;    // acquire clone with no dups</span>
<a href="#l1.1077"></a><span id="l1.1077">     // Note that MakeUniqueCursor() is never necessary for a cursor which was</span>
<a href="#l1.1078"></a><span id="l1.1078">     // created by table method nsIMdbTable::GetTableRowCursor(), because a table</span>
<a href="#l1.1079"></a><span id="l1.1079">     // never contains the same row as a member more than once.  However, a cursor</span>
<a href="#l1.1080"></a><span id="l1.1080">     // created by table method nsIMdbTable::FindRowMatches() might contain the</span>
<a href="#l1.1081"></a><span id="l1.1081">     // same row more than once, because the same row can generate a hit by more</span>
<a href="#l1.1082"></a><span id="l1.1082" class="difflineat">@@ -2144,17 +2144,17 @@ public:</span>
<a href="#l1.1083"></a><span id="l1.1083">   // } ----- end row iteration methods -----</span>
<a href="#l1.1084"></a><span id="l1.1084"> </span>
<a href="#l1.1085"></a><span id="l1.1085">   // { ----- begin copy iteration methods -----</span>
<a href="#l1.1086"></a><span id="l1.1086">   // NS_IMETHOD NextRowCopy( // put row cells into sink only when already in sink</span>
<a href="#l1.1087"></a><span id="l1.1087">   //   nsIMdbEnv* ev, // context</span>
<a href="#l1.1088"></a><span id="l1.1088">   //   nsIMdbRow* ioSinkRow, // sink for row cells read from next row</span>
<a href="#l1.1089"></a><span id="l1.1089">   //   mdbOid* outOid, // out row oid</span>
<a href="#l1.1090"></a><span id="l1.1090">   //   mdb_pos* outRowPos) = 0;    // zero-based position of the row in table</span>
<a href="#l1.1091"></a><span id="l1.1091" class="difflineminus">-  // </span>
<a href="#l1.1092"></a><span id="l1.1092" class="difflineplus">+  //</span>
<a href="#l1.1093"></a><span id="l1.1093">   // NS_IMETHOD NextRowCopyAll( // put all row cells into sink, adding to sink</span>
<a href="#l1.1094"></a><span id="l1.1094">   //   nsIMdbEnv* ev, // context</span>
<a href="#l1.1095"></a><span id="l1.1095">   //   nsIMdbRow* ioSinkRow, // sink for row cells read from next row</span>
<a href="#l1.1096"></a><span id="l1.1096">   //   mdbOid* outOid, // out row oid</span>
<a href="#l1.1097"></a><span id="l1.1097">   //   mdb_pos* outRowPos) = 0;    // zero-based position of the row in table</span>
<a href="#l1.1098"></a><span id="l1.1098">   // } ----- end copy iteration methods -----</span>
<a href="#l1.1099"></a><span id="l1.1099"> </span>
<a href="#l1.1100"></a><span id="l1.1100"> // } ===== end nsIMdbTableRowCursor methods =====</span>
<a href="#l1.1101"></a><span id="l1.1101" class="difflineat">@@ -2201,58 +2201,58 @@ public:</span>
<a href="#l1.1102"></a><span id="l1.1102">     nsIMdbEnv* ev) = 0; // context</span>
<a href="#l1.1103"></a><span id="l1.1103">   // } ----- end column methods -----</span>
<a href="#l1.1104"></a><span id="l1.1104"> </span>
<a href="#l1.1105"></a><span id="l1.1105">   // { ----- begin cell methods -----</span>
<a href="#l1.1106"></a><span id="l1.1106">   NS_IMETHOD NewCell( // get cell for specified column, or add new one</span>
<a href="#l1.1107"></a><span id="l1.1107">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1108"></a><span id="l1.1108">     mdb_column inColumn, // column to add</span>
<a href="#l1.1109"></a><span id="l1.1109">     nsIMdbCell** acqCell) = 0; // cell column and value</span>
<a href="#l1.1110"></a><span id="l1.1110" class="difflineminus">-    </span>
<a href="#l1.1111"></a><span id="l1.1111" class="difflineplus">+</span>
<a href="#l1.1112"></a><span id="l1.1112">   NS_IMETHOD AddCell( // copy a cell from another row to this row</span>
<a href="#l1.1113"></a><span id="l1.1113">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1114"></a><span id="l1.1114">     const nsIMdbCell* inCell) = 0; // cell column and value</span>
<a href="#l1.1115"></a><span id="l1.1115" class="difflineminus">-    </span>
<a href="#l1.1116"></a><span id="l1.1116" class="difflineplus">+</span>
<a href="#l1.1117"></a><span id="l1.1117">   NS_IMETHOD GetCell( // find a cell in this row</span>
<a href="#l1.1118"></a><span id="l1.1118">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1119"></a><span id="l1.1119">     mdb_column inColumn, // column to find</span>
<a href="#l1.1120"></a><span id="l1.1120">     nsIMdbCell** acqCell) = 0; // cell for specified column, or null</span>
<a href="#l1.1121"></a><span id="l1.1121" class="difflineminus">-    </span>
<a href="#l1.1122"></a><span id="l1.1122" class="difflineplus">+</span>
<a href="#l1.1123"></a><span id="l1.1123">   NS_IMETHOD EmptyAllCells( // make all cells in row empty of content</span>
<a href="#l1.1124"></a><span id="l1.1124">     nsIMdbEnv* ev) = 0; // context</span>
<a href="#l1.1125"></a><span id="l1.1125">   // } ----- end cell methods -----</span>
<a href="#l1.1126"></a><span id="l1.1126"> </span>
<a href="#l1.1127"></a><span id="l1.1127">   // { ----- begin row methods -----</span>
<a href="#l1.1128"></a><span id="l1.1128">   NS_IMETHOD AddRow( // add all cells in another row to this one</span>
<a href="#l1.1129"></a><span id="l1.1129">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1130"></a><span id="l1.1130">     nsIMdbRow* ioSourceRow) = 0; // row to union with</span>
<a href="#l1.1131"></a><span id="l1.1131" class="difflineminus">-    </span>
<a href="#l1.1132"></a><span id="l1.1132" class="difflineplus">+</span>
<a href="#l1.1133"></a><span id="l1.1133">   NS_IMETHOD SetRow( // make exact duplicate of another row</span>
<a href="#l1.1134"></a><span id="l1.1134">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1135"></a><span id="l1.1135">     nsIMdbRow* ioSourceRow) = 0; // row to duplicate</span>
<a href="#l1.1136"></a><span id="l1.1136">   // } ----- end row methods -----</span>
<a href="#l1.1137"></a><span id="l1.1137"> </span>
<a href="#l1.1138"></a><span id="l1.1138" class="difflineminus">-  // { ----- begin blob methods -----  </span>
<a href="#l1.1139"></a><span id="l1.1139" class="difflineplus">+  // { ----- begin blob methods -----</span>
<a href="#l1.1140"></a><span id="l1.1140">   NS_IMETHOD SetCellYarn(nsIMdbEnv* ev, // synonym for AddColumn()</span>
<a href="#l1.1141"></a><span id="l1.1141">     mdb_column inColumn, // column to write</span>
<a href="#l1.1142"></a><span id="l1.1142">     const mdbYarn* inYarn) = 0;   // reads from yarn slots</span>
<a href="#l1.1143"></a><span id="l1.1143">   // make this text object contain content from the yarn's buffer</span>
<a href="#l1.1144"></a><span id="l1.1144" class="difflineminus">-  </span>
<a href="#l1.1145"></a><span id="l1.1145" class="difflineminus">-  NS_IMETHOD GetCellYarn(nsIMdbEnv* ev, </span>
<a href="#l1.1146"></a><span id="l1.1146" class="difflineminus">-    mdb_column inColumn, // column to read </span>
<a href="#l1.1147"></a><span id="l1.1147" class="difflineminus">-    mdbYarn* outYarn) = 0;  // writes some yarn slots </span>
<a href="#l1.1148"></a><span id="l1.1148" class="difflineplus">+</span>
<a href="#l1.1149"></a><span id="l1.1149" class="difflineplus">+  NS_IMETHOD GetCellYarn(nsIMdbEnv* ev,</span>
<a href="#l1.1150"></a><span id="l1.1150" class="difflineplus">+    mdb_column inColumn, // column to read</span>
<a href="#l1.1151"></a><span id="l1.1151" class="difflineplus">+    mdbYarn* outYarn) = 0;  // writes some yarn slots</span>
<a href="#l1.1152"></a><span id="l1.1152">   // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l1.1153"></a><span id="l1.1153" class="difflineminus">-  </span>
<a href="#l1.1154"></a><span id="l1.1154" class="difflineminus">-  NS_IMETHOD AliasCellYarn(nsIMdbEnv* ev, </span>
<a href="#l1.1155"></a><span id="l1.1155" class="difflineplus">+</span>
<a href="#l1.1156"></a><span id="l1.1156" class="difflineplus">+  NS_IMETHOD AliasCellYarn(nsIMdbEnv* ev,</span>
<a href="#l1.1157"></a><span id="l1.1157">     mdb_column inColumn, // column to alias</span>
<a href="#l1.1158"></a><span id="l1.1158">     mdbYarn* outYarn) = 0; // writes ALL yarn slots</span>
<a href="#l1.1159"></a><span id="l1.1159" class="difflineminus">-  </span>
<a href="#l1.1160"></a><span id="l1.1160" class="difflineplus">+</span>
<a href="#l1.1161"></a><span id="l1.1161">   NS_IMETHOD NextCellYarn(nsIMdbEnv* ev, // iterative version of GetCellYarn()</span>
<a href="#l1.1162"></a><span id="l1.1162">     mdb_column* ioColumn, // next column to read</span>
<a href="#l1.1163"></a><span id="l1.1163" class="difflineminus">-    mdbYarn* outYarn) = 0;  // writes some yarn slots </span>
<a href="#l1.1164"></a><span id="l1.1164" class="difflineplus">+    mdbYarn* outYarn) = 0;  // writes some yarn slots</span>
<a href="#l1.1165"></a><span id="l1.1165">   // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l1.1166"></a><span id="l1.1166">   //</span>
<a href="#l1.1167"></a><span id="l1.1167">   // The ioColumn argument is an inout parameter which initially contains the</span>
<a href="#l1.1168"></a><span id="l1.1168">   // last column accessed and returns the next column corresponding to the</span>
<a href="#l1.1169"></a><span id="l1.1169">   // content read into the yarn.  Callers should start with a zero column</span>
<a href="#l1.1170"></a><span id="l1.1170">   // value to say 'no previous column', which causes the first column to be</span>
<a href="#l1.1171"></a><span id="l1.1171">   // read.  Then the value returned in ioColumn is perfect for the next call</span>
<a href="#l1.1172"></a><span id="l1.1172">   // to NextCellYarn(), since it will then be the previous column accessed.</span>
<a href="#l1.1173"></a><span id="l1.1173" class="difflineat">@@ -2324,17 +2324,17 @@ public:</span>
<a href="#l1.1174"></a><span id="l1.1174">   // } ----- end cell seeking methods -----</span>
<a href="#l1.1175"></a><span id="l1.1175"> </span>
<a href="#l1.1176"></a><span id="l1.1176">   // { ----- begin cell iteration methods -----</span>
<a href="#l1.1177"></a><span id="l1.1177">   NS_IMETHOD NextCell( // get next cell in the row</span>
<a href="#l1.1178"></a><span id="l1.1178">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1179"></a><span id="l1.1179">     nsIMdbCell** acqCell, // changes to the next cell in the iteration</span>
<a href="#l1.1180"></a><span id="l1.1180">     mdb_column* outColumn, // column for this particular cell</span>
<a href="#l1.1181"></a><span id="l1.1181">     mdb_pos* outPos) = 0; // position of cell in row sequence</span>
<a href="#l1.1182"></a><span id="l1.1182" class="difflineminus">-    </span>
<a href="#l1.1183"></a><span id="l1.1183" class="difflineplus">+</span>
<a href="#l1.1184"></a><span id="l1.1184">   NS_IMETHOD PickNextCell( // get next cell in row within filter set</span>
<a href="#l1.1185"></a><span id="l1.1185">     nsIMdbEnv* ev, // context</span>
<a href="#l1.1186"></a><span id="l1.1186">     nsIMdbCell* ioCell, // changes to the next cell in the iteration</span>
<a href="#l1.1187"></a><span id="l1.1187">     const mdbColumnSet* inFilterSet, // col set of actual caller interest</span>
<a href="#l1.1188"></a><span id="l1.1188">     mdb_column* outColumn, // column for this particular cell</span>
<a href="#l1.1189"></a><span id="l1.1189">     mdb_pos* outPos) = 0; // position of cell in row sequence</span>
<a href="#l1.1190"></a><span id="l1.1190"> </span>
<a href="#l1.1191"></a><span id="l1.1191">   // Note that inFilterSet should not have too many (many more than 10?)</span>
<a href="#l1.1192"></a><span id="l1.1192" class="difflineat">@@ -2355,35 +2355,35 @@ class nsIMdbBlob : public nsISupports { </span>
<a href="#l1.1193"></a><span id="l1.1193"> public:</span>
<a href="#l1.1194"></a><span id="l1.1194"> </span>
<a href="#l1.1195"></a><span id="l1.1195"> // { ===== begin nsIMdbBlob methods =====</span>
<a href="#l1.1196"></a><span id="l1.1196"> </span>
<a href="#l1.1197"></a><span id="l1.1197">   // { ----- begin attribute methods -----</span>
<a href="#l1.1198"></a><span id="l1.1198">   NS_IMETHOD SetBlob(nsIMdbEnv* ev,</span>
<a href="#l1.1199"></a><span id="l1.1199">     nsIMdbBlob* ioBlob) = 0; // reads inBlob slots</span>
<a href="#l1.1200"></a><span id="l1.1200">   // when inBlob is in the same suite, this might be fastest cell-to-cell</span>
<a href="#l1.1201"></a><span id="l1.1201" class="difflineminus">-  </span>
<a href="#l1.1202"></a><span id="l1.1202" class="difflineplus">+</span>
<a href="#l1.1203"></a><span id="l1.1203">   NS_IMETHOD ClearBlob( // make empty (so content has zero length)</span>
<a href="#l1.1204"></a><span id="l1.1204">     nsIMdbEnv* ev) = 0;</span>
<a href="#l1.1205"></a><span id="l1.1205">   // clearing a yarn is like SetYarn() with empty yarn instance content</span>
<a href="#l1.1206"></a><span id="l1.1206" class="difflineminus">-  </span>
<a href="#l1.1207"></a><span id="l1.1207" class="difflineplus">+</span>
<a href="#l1.1208"></a><span id="l1.1208">   NS_IMETHOD GetBlobFill(nsIMdbEnv* ev,</span>
<a href="#l1.1209"></a><span id="l1.1209" class="difflineminus">-    mdb_fill* outFill) = 0;  // size of blob </span>
<a href="#l1.1210"></a><span id="l1.1210" class="difflineplus">+    mdb_fill* outFill) = 0;  // size of blob</span>
<a href="#l1.1211"></a><span id="l1.1211">   // Same value that would be put into mYarn_Fill, if one called GetYarn()</span>
<a href="#l1.1212"></a><span id="l1.1212">   // with a yarn instance that had mYarn_Buf==nil and mYarn_Size==0.</span>
<a href="#l1.1213"></a><span id="l1.1213" class="difflineminus">-  </span>
<a href="#l1.1214"></a><span id="l1.1214" class="difflineminus">-  NS_IMETHOD SetYarn(nsIMdbEnv* ev, </span>
<a href="#l1.1215"></a><span id="l1.1215" class="difflineplus">+</span>
<a href="#l1.1216"></a><span id="l1.1216" class="difflineplus">+  NS_IMETHOD SetYarn(nsIMdbEnv* ev,</span>
<a href="#l1.1217"></a><span id="l1.1217">     const mdbYarn* inYarn) = 0;   // reads from yarn slots</span>
<a href="#l1.1218"></a><span id="l1.1218">   // make this text object contain content from the yarn's buffer</span>
<a href="#l1.1219"></a><span id="l1.1219" class="difflineminus">-  </span>
<a href="#l1.1220"></a><span id="l1.1220" class="difflineminus">-  NS_IMETHOD GetYarn(nsIMdbEnv* ev, </span>
<a href="#l1.1221"></a><span id="l1.1221" class="difflineminus">-    mdbYarn* outYarn) = 0;  // writes some yarn slots </span>
<a href="#l1.1222"></a><span id="l1.1222" class="difflineplus">+</span>
<a href="#l1.1223"></a><span id="l1.1223" class="difflineplus">+  NS_IMETHOD GetYarn(nsIMdbEnv* ev,</span>
<a href="#l1.1224"></a><span id="l1.1224" class="difflineplus">+    mdbYarn* outYarn) = 0;  // writes some yarn slots</span>
<a href="#l1.1225"></a><span id="l1.1225">   // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l1.1226"></a><span id="l1.1226" class="difflineminus">-  </span>
<a href="#l1.1227"></a><span id="l1.1227" class="difflineminus">-  NS_IMETHOD AliasYarn(nsIMdbEnv* ev, </span>
<a href="#l1.1228"></a><span id="l1.1228" class="difflineplus">+</span>
<a href="#l1.1229"></a><span id="l1.1229" class="difflineplus">+  NS_IMETHOD AliasYarn(nsIMdbEnv* ev,</span>
<a href="#l1.1230"></a><span id="l1.1230">     mdbYarn* outYarn) = 0; // writes ALL yarn slots</span>
<a href="#l1.1231"></a><span id="l1.1231">   // AliasYarn() reveals sensitive internal text buffer state to the caller</span>
<a href="#l1.1232"></a><span id="l1.1232">   // by setting mYarn_Buf to point into the guts of this text implementation.</span>
<a href="#l1.1233"></a><span id="l1.1233">   //</span>
<a href="#l1.1234"></a><span id="l1.1234">   // The caller must take great care to avoid writing on this space, and to</span>
<a href="#l1.1235"></a><span id="l1.1235">   // avoid calling any method that would cause the state of this text object</span>
<a href="#l1.1236"></a><span id="l1.1236">   // to change (say by directly or indirectly setting the text to hold more</span>
<a href="#l1.1237"></a><span id="l1.1237">   // content that might grow the size of the buffer and free the old buffer).</span>
<a href="#l1.1238"></a><span id="l1.1238" class="difflineat">@@ -2407,17 +2407,17 @@ public:</span>
<a href="#l1.1239"></a><span id="l1.1239">   // some other canonical representation that would necessitate an additional</span>
<a href="#l1.1240"></a><span id="l1.1240">   // copy and transformation when such is incompatible with the mdbYarn format.</span>
<a href="#l1.1241"></a><span id="l1.1241">   //</span>
<a href="#l1.1242"></a><span id="l1.1242">   // The implementation of AliasYarn() should have extremely little overhead</span>
<a href="#l1.1243"></a><span id="l1.1243">   // besides the virtual dispatch to the method implementation, and the code</span>
<a href="#l1.1244"></a><span id="l1.1244">   // necessary to populate all the mdbYarn member slots with internal buffer</span>
<a href="#l1.1245"></a><span id="l1.1245">   // address and metainformation that describes the buffer content.  Note that</span>
<a href="#l1.1246"></a><span id="l1.1246">   // mYarn_Grow must always be set to nil to indicate no resizing is allowed.</span>
<a href="#l1.1247"></a><span id="l1.1247" class="difflineminus">-  </span>
<a href="#l1.1248"></a><span id="l1.1248" class="difflineplus">+</span>
<a href="#l1.1249"></a><span id="l1.1249">   // } ----- end attribute methods -----</span>
<a href="#l1.1250"></a><span id="l1.1250"> </span>
<a href="#l1.1251"></a><span id="l1.1251"> // } ===== end nsIMdbBlob methods =====</span>
<a href="#l1.1252"></a><span id="l1.1252"> };</span>
<a href="#l1.1253"></a><span id="l1.1253"> </span>
<a href="#l1.1254"></a><span id="l1.1254"> /*| nsIMdbCell: the text in a single column of a row.  The base nsIMdbBlob</span>
<a href="#l1.1255"></a><span id="l1.1255"> **| class provides all the interface related to accessing cell text.</span>
<a href="#l1.1256"></a><span id="l1.1256"> **|</span>
<a href="#l1.1257"></a><span id="l1.1257" class="difflineat">@@ -2437,17 +2437,17 @@ public:</span>
<a href="#l1.1258"></a><span id="l1.1258"> **|| text: a cell can either be text, or it can have a child row or table,</span>
<a href="#l1.1259"></a><span id="l1.1259"> **| but not both at once.  If text is read from a cell with a child, the text</span>
<a href="#l1.1260"></a><span id="l1.1260"> **| content should be empty (for AliasYarn()) or a description of the type</span>
<a href="#l1.1261"></a><span id="l1.1261"> **| of child (perhaps &quot;mdb:cell:child:row&quot; or &quot;mdb:cell:child:table&quot;).</span>
<a href="#l1.1262"></a><span id="l1.1262"> **|</span>
<a href="#l1.1263"></a><span id="l1.1263"> **|| child: a cell might reference another row or a table, rather than text.</span>
<a href="#l1.1264"></a><span id="l1.1264"> **| The interface for putting and getting children rows and tables was first</span>
<a href="#l1.1265"></a><span id="l1.1265"> **| defined in the nsIMdbTable interface, but then this was moved to this cell</span>
<a href="#l1.1266"></a><span id="l1.1266" class="difflineminus">-**| interface as more natural. </span>
<a href="#l1.1267"></a><span id="l1.1267" class="difflineplus">+**| interface as more natural.</span>
<a href="#l1.1268"></a><span id="l1.1268"> |*/</span>
<a href="#l1.1269"></a><span id="l1.1269"> </span>
<a href="#l1.1270"></a><span id="l1.1270"> </span>
<a href="#l1.1271"></a><span id="l1.1271"> </span>
<a href="#l1.1272"></a><span id="l1.1272"> #define NS_IMDBCELL_IID \</span>
<a href="#l1.1273"></a><span id="l1.1273"> {0xa3b62f71, 0xa181, 0x4a91, \</span>
<a href="#l1.1274"></a><span id="l1.1274"> {0xb6, 0x6b, 0x27, 0x10, 0x9b, 0x88, 0x98, 0x35}}</span>
<a href="#l1.1275"></a><span id="l1.1275"> </span>
<a href="#l1.1276"></a><span id="l1.1276" class="difflineat">@@ -2455,29 +2455,29 @@ public:</span>
<a href="#l1.1277"></a><span id="l1.1277"> </span>
<a href="#l1.1278"></a><span id="l1.1278"> class nsIMdbCell : public nsIMdbBlob { // text attribute in row with column scope</span>
<a href="#l1.1279"></a><span id="l1.1279"> public:</span>
<a href="#l1.1280"></a><span id="l1.1280"> </span>
<a href="#l1.1281"></a><span id="l1.1281">   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMDBTABLEROWCURSOR_IID)</span>
<a href="#l1.1282"></a><span id="l1.1282"> // { ===== begin nsIMdbCell methods =====</span>
<a href="#l1.1283"></a><span id="l1.1283"> </span>
<a href="#l1.1284"></a><span id="l1.1284">   // { ----- begin attribute methods -----</span>
<a href="#l1.1285"></a><span id="l1.1285" class="difflineminus">-  NS_IMETHOD SetColumn(nsIMdbEnv* ev, mdb_column inColumn) = 0; </span>
<a href="#l1.1286"></a><span id="l1.1286" class="difflineplus">+  NS_IMETHOD SetColumn(nsIMdbEnv* ev, mdb_column inColumn) = 0;</span>
<a href="#l1.1287"></a><span id="l1.1287">   NS_IMETHOD GetColumn(nsIMdbEnv* ev, mdb_column* outColumn) = 0;</span>
<a href="#l1.1288"></a><span id="l1.1288" class="difflineminus">-  </span>
<a href="#l1.1289"></a><span id="l1.1289" class="difflineplus">+</span>
<a href="#l1.1290"></a><span id="l1.1290">   NS_IMETHOD GetCellInfo(  // all cell metainfo except actual content</span>
<a href="#l1.1291"></a><span id="l1.1291" class="difflineminus">-    nsIMdbEnv* ev, </span>
<a href="#l1.1292"></a><span id="l1.1292" class="difflineplus">+    nsIMdbEnv* ev,</span>
<a href="#l1.1293"></a><span id="l1.1293">     mdb_column* outColumn,           // the column in the containing row</span>
<a href="#l1.1294"></a><span id="l1.1294">     mdb_fill*   outBlobFill,         // the size of text content in bytes</span>
<a href="#l1.1295"></a><span id="l1.1295">     mdbOid*     outChildOid,         // oid of possible row or table child</span>
<a href="#l1.1296"></a><span id="l1.1296">     mdb_bool*   outIsRowChild) = 0;  // nonzero if child, and a row child</span>
<a href="#l1.1297"></a><span id="l1.1297"> </span>
<a href="#l1.1298"></a><span id="l1.1298">   // Checking all cell metainfo is a good way to avoid forcing a large cell</span>
<a href="#l1.1299"></a><span id="l1.1299">   // in to memory when you don't actually want to use the content.</span>
<a href="#l1.1300"></a><span id="l1.1300" class="difflineminus">-  </span>
<a href="#l1.1301"></a><span id="l1.1301" class="difflineplus">+</span>
<a href="#l1.1302"></a><span id="l1.1302">   NS_IMETHOD GetRow(nsIMdbEnv* ev, // parent row for this cell</span>
<a href="#l1.1303"></a><span id="l1.1303">     nsIMdbRow** acqRow) = 0;</span>
<a href="#l1.1304"></a><span id="l1.1304">   NS_IMETHOD GetPort(nsIMdbEnv* ev, // port containing cell</span>
<a href="#l1.1305"></a><span id="l1.1305">     nsIMdbPort** acqPort) = 0;</span>
<a href="#l1.1306"></a><span id="l1.1306">   // } ----- end attribute methods -----</span>
<a href="#l1.1307"></a><span id="l1.1307"> </span>
<a href="#l1.1308"></a><span id="l1.1308">   // { ----- begin children methods -----</span>
<a href="#l1.1309"></a><span id="l1.1309">   NS_IMETHOD HasAnyChild( // does cell have a child instead of text?</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/db/mork/src/mork.h</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/db/mork/src/mork.h</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -93,17 +93,17 @@ typedef mork_u2 mork_derived; // 2-byte </span>
<a href="#l2.4"></a><span id="l2.4"> </span>
<a href="#l2.5"></a><span id="l2.5"> typedef mork_u4 mork_token;      // unsigned token for atomized string</span>
<a href="#l2.6"></a><span id="l2.6"> typedef mork_token mork_scope;   // token used to id scope for rows</span>
<a href="#l2.7"></a><span id="l2.7"> typedef mork_token mork_kind;    // token used to id kind for tables</span>
<a href="#l2.8"></a><span id="l2.8"> typedef mork_token mork_cscode;  // token used to id charset names</span>
<a href="#l2.9"></a><span id="l2.9"> typedef mork_token mork_aid;     // token used to id atomize cell values</span>
<a href="#l2.10"></a><span id="l2.10"> </span>
<a href="#l2.11"></a><span id="l2.11"> typedef mork_token mork_column;  // token used to id columns for rows</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-typedef mork_column mork_delta;  // mork_column plus mork_change </span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+typedef mork_column mork_delta;  // mork_column plus mork_change</span>
<a href="#l2.14"></a><span id="l2.14"> </span>
<a href="#l2.15"></a><span id="l2.15"> typedef mork_token mork_color;   // bead ID</span>
<a href="#l2.16"></a><span id="l2.16"> #define morkColor_kNone ((mork_color) 0)</span>
<a href="#l2.17"></a><span id="l2.17"> </span>
<a href="#l2.18"></a><span id="l2.18"> typedef mork_u4 mork_magic;      // unsigned magic signature</span>
<a href="#l2.19"></a><span id="l2.19"> </span>
<a href="#l2.20"></a><span id="l2.20"> typedef mork_u4 mork_seed;       // unsigned collection change counter</span>
<a href="#l2.21"></a><span id="l2.21"> typedef mork_u4 mork_count;      // unsigned collection member count</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineat">@@ -181,17 +181,17 @@ typedef mdb_bool mork_bool; // unsigned </span>
<a href="#l2.23"></a><span id="l2.23"> </span>
<a href="#l2.24"></a><span id="l2.24"> // mdb clients can assign these, so we cannot pick maximum size:</span>
<a href="#l2.25"></a><span id="l2.25"> typedef mdb_id mork_id;    // unsigned object identity in a scope</span>
<a href="#l2.26"></a><span id="l2.26"> typedef mork_id mork_rid;  // unsigned row identity inside scope</span>
<a href="#l2.27"></a><span id="l2.27"> typedef mork_id mork_tid;  // unsigned table identity inside scope</span>
<a href="#l2.28"></a><span id="l2.28"> typedef mork_id mork_gid;  // unsigned group identity without any scope</span>
<a href="#l2.29"></a><span id="l2.29"> </span>
<a href="#l2.30"></a><span id="l2.30"> // we only care about neg, zero, pos -- so we don't care about size:</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineminus">-typedef mdb_order mork_order; // neg:lessthan, zero:equalto, pos:greaterthan </span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+typedef mdb_order mork_order; // neg:lessthan, zero:equalto, pos:greaterthan</span>
<a href="#l2.33"></a><span id="l2.33"> // } %%%%% end mdb-driven scalar typedefs %%%%%</span>
<a href="#l2.34"></a><span id="l2.34"> </span>
<a href="#l2.35"></a><span id="l2.35"> #define morkId_kMinusOne ((mdb_id) -1)</span>
<a href="#l2.36"></a><span id="l2.36"> </span>
<a href="#l2.37"></a><span id="l2.37"> // { %%%%% begin class forward defines %%%%%</span>
<a href="#l2.38"></a><span id="l2.38"> // try to put these in alphabetical order for easier examination:</span>
<a href="#l2.39"></a><span id="l2.39"> class morkMid;</span>
<a href="#l2.40"></a><span id="l2.40"> class morkAtom;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/db/mork/src/morkArray.cpp</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/db/mork/src/morkArray.cpp</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -22,17 +22,17 @@</span>
<a href="#l3.4"></a><span id="l3.4"> #endif</span>
<a href="#l3.5"></a><span id="l3.5"> </span>
<a href="#l3.6"></a><span id="l3.6"> #ifndef _MORKARRAY_</span>
<a href="#l3.7"></a><span id="l3.7"> #include &quot;morkArray.h&quot;</span>
<a href="#l3.8"></a><span id="l3.8"> #endif</span>
<a href="#l3.9"></a><span id="l3.9"> </span>
<a href="#l3.10"></a><span id="l3.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l3.11"></a><span id="l3.11"> </span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l3.14"></a><span id="l3.14"> // { ===== begin morkNode interface =====</span>
<a href="#l3.15"></a><span id="l3.15"> </span>
<a href="#l3.16"></a><span id="l3.16"> /*public virtual*/ void</span>
<a href="#l3.17"></a><span id="l3.17"> morkArray::CloseMorkNode(morkEnv* ev) // CloseTable() only if open</span>
<a href="#l3.18"></a><span id="l3.18"> {</span>
<a href="#l3.19"></a><span id="l3.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l3.20"></a><span id="l3.20">   {</span>
<a href="#l3.21"></a><span id="l3.21">     this-&gt;MarkClosing();</span>
<a href="#l3.22"></a><span id="l3.22" class="difflineat">@@ -87,30 +87,30 @@ morkArray::morkArray(morkEnv* ev, const </span>
<a href="#l3.23"></a><span id="l3.23"> </span>
<a href="#l3.24"></a><span id="l3.24"> /*public non-poly*/ void</span>
<a href="#l3.25"></a><span id="l3.25"> morkArray::CloseArray(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l3.26"></a><span id="l3.26"> {</span>
<a href="#l3.27"></a><span id="l3.27">     if ( this-&gt;IsNode() )</span>
<a href="#l3.28"></a><span id="l3.28">     {</span>
<a href="#l3.29"></a><span id="l3.29">       if ( mArray_Heap &amp;&amp; mArray_Slots )</span>
<a href="#l3.30"></a><span id="l3.30">         mArray_Heap-&gt;Free(ev-&gt;AsMdbEnv(), mArray_Slots);</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-        </span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+</span>
<a href="#l3.33"></a><span id="l3.33">       mArray_Slots = 0;</span>
<a href="#l3.34"></a><span id="l3.34">       mArray_Size = 0;</span>
<a href="#l3.35"></a><span id="l3.35">       mArray_Fill = 0;</span>
<a href="#l3.36"></a><span id="l3.36">       ++mArray_Seed;</span>
<a href="#l3.37"></a><span id="l3.37">       nsIMdbHeap_SlotStrongHeap((nsIMdbHeap*) 0, ev, &amp;mArray_Heap);</span>
<a href="#l3.38"></a><span id="l3.38">       this-&gt;MarkShut();</span>
<a href="#l3.39"></a><span id="l3.39">     }</span>
<a href="#l3.40"></a><span id="l3.40">     else</span>
<a href="#l3.41"></a><span id="l3.41">       this-&gt;NonNodeError(ev);</span>
<a href="#l3.42"></a><span id="l3.42"> }</span>
<a href="#l3.43"></a><span id="l3.43"> </span>
<a href="#l3.44"></a><span id="l3.44"> // } ===== end morkNode methods =====</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l3.46"></a><span id="l3.46" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l3.47"></a><span id="l3.47"> </span>
<a href="#l3.48"></a><span id="l3.48"> /*static*/ void</span>
<a href="#l3.49"></a><span id="l3.49"> morkArray::NonArrayTypeError(morkEnv* ev)</span>
<a href="#l3.50"></a><span id="l3.50"> {</span>
<a href="#l3.51"></a><span id="l3.51">   ev-&gt;NewError(&quot;non morkArray&quot;);</span>
<a href="#l3.52"></a><span id="l3.52"> }</span>
<a href="#l3.53"></a><span id="l3.53"> </span>
<a href="#l3.54"></a><span id="l3.54"> /*static*/ void</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineat">@@ -138,31 +138,31 @@ morkArray::Grow(morkEnv* ev, mork_size i</span>
<a href="#l3.56"></a><span id="l3.56">   if ( ev-&gt;Good() &amp;&amp; inNewSize &gt; mArray_Size ) // make array larger?</span>
<a href="#l3.57"></a><span id="l3.57">   {</span>
<a href="#l3.58"></a><span id="l3.58">     if ( mArray_Fill &lt;= mArray_Size ) // fill and size fit the invariant?</span>
<a href="#l3.59"></a><span id="l3.59">     {</span>
<a href="#l3.60"></a><span id="l3.60">       if (mArray_Size &lt;= 3)</span>
<a href="#l3.61"></a><span id="l3.61">         inNewSize = mArray_Size + 3;</span>
<a href="#l3.62"></a><span id="l3.62">       else</span>
<a href="#l3.63"></a><span id="l3.63">         inNewSize = mArray_Size  * 2;// + 3;  // try doubling size here - used to grow by 3</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineminus">-        </span>
<a href="#l3.65"></a><span id="l3.65" class="difflineplus">+</span>
<a href="#l3.66"></a><span id="l3.66">       mdb_size newByteSize = inNewSize * sizeof(void*);</span>
<a href="#l3.67"></a><span id="l3.67">       void** newBlock = 0;</span>
<a href="#l3.68"></a><span id="l3.68">       mArray_Heap-&gt;Alloc(ev-&gt;AsMdbEnv(), newByteSize, (void**) &amp;newBlock);</span>
<a href="#l3.69"></a><span id="l3.69">       if ( newBlock &amp;&amp; ev-&gt;Good() ) // okay new block?</span>
<a href="#l3.70"></a><span id="l3.70">       {</span>
<a href="#l3.71"></a><span id="l3.71">         void** oldSlots = mArray_Slots;</span>
<a href="#l3.72"></a><span id="l3.72">         void** oldEnd = oldSlots + mArray_Fill;</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineminus">-        </span>
<a href="#l3.74"></a><span id="l3.74" class="difflineplus">+</span>
<a href="#l3.75"></a><span id="l3.75">         void** newSlots = newBlock;</span>
<a href="#l3.76"></a><span id="l3.76">         void** newEnd = newBlock + inNewSize;</span>
<a href="#l3.77"></a><span id="l3.77" class="difflineminus">-        </span>
<a href="#l3.78"></a><span id="l3.78" class="difflineplus">+</span>
<a href="#l3.79"></a><span id="l3.79">         while ( oldSlots &lt; oldEnd )</span>
<a href="#l3.80"></a><span id="l3.80">           *newSlots++ = *oldSlots++;</span>
<a href="#l3.81"></a><span id="l3.81" class="difflineminus">-          </span>
<a href="#l3.82"></a><span id="l3.82" class="difflineplus">+</span>
<a href="#l3.83"></a><span id="l3.83">         while ( newSlots &lt; newEnd )</span>
<a href="#l3.84"></a><span id="l3.84">           *newSlots++ = (void*) 0;</span>
<a href="#l3.85"></a><span id="l3.85"> </span>
<a href="#l3.86"></a><span id="l3.86">         oldSlots = mArray_Slots;</span>
<a href="#l3.87"></a><span id="l3.87">         mArray_Size = inNewSize;</span>
<a href="#l3.88"></a><span id="l3.88">         mArray_Slots = newBlock;</span>
<a href="#l3.89"></a><span id="l3.89">         mArray_Heap-&gt;Free(ev-&gt;AsMdbEnv(), oldSlots);</span>
<a href="#l3.90"></a><span id="l3.90">       }</span>
<a href="#l3.91"></a><span id="l3.91" class="difflineat">@@ -181,17 +181,17 @@ morkArray::SafeAt(morkEnv* ev, mork_pos </span>
<a href="#l3.92"></a><span id="l3.92">   {</span>
<a href="#l3.93"></a><span id="l3.93">     if ( inPos &gt;= 0 &amp;&amp; inPos &lt; (mork_pos) mArray_Fill )</span>
<a href="#l3.94"></a><span id="l3.94">       return mArray_Slots[ inPos ];</span>
<a href="#l3.95"></a><span id="l3.95">     else</span>
<a href="#l3.96"></a><span id="l3.96">       this-&gt;IndexBeyondEndError(ev);</span>
<a href="#l3.97"></a><span id="l3.97">   }</span>
<a href="#l3.98"></a><span id="l3.98">   else</span>
<a href="#l3.99"></a><span id="l3.99">     this-&gt;NilSlotsAddressError(ev);</span>
<a href="#l3.100"></a><span id="l3.100" class="difflineminus">-    </span>
<a href="#l3.101"></a><span id="l3.101" class="difflineplus">+</span>
<a href="#l3.102"></a><span id="l3.102">   return (void*) 0;</span>
<a href="#l3.103"></a><span id="l3.103"> }</span>
<a href="#l3.104"></a><span id="l3.104"> </span>
<a href="#l3.105"></a><span id="l3.105"> void</span>
<a href="#l3.106"></a><span id="l3.106"> morkArray::SafeAtPut(morkEnv* ev, mork_pos inPos, void* ioSlot)</span>
<a href="#l3.107"></a><span id="l3.107"> {</span>
<a href="#l3.108"></a><span id="l3.108">   if ( mArray_Slots )</span>
<a href="#l3.109"></a><span id="l3.109">   {</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineat">@@ -219,17 +219,17 @@ morkArray::AppendSlot(morkEnv* ev, void*</span>
<a href="#l3.111"></a><span id="l3.111">       outPos = (mork_pos) fill;</span>
<a href="#l3.112"></a><span id="l3.112">       mArray_Slots[ fill ] = ioSlot;</span>
<a href="#l3.113"></a><span id="l3.113">       mArray_Fill = fill + 1;</span>
<a href="#l3.114"></a><span id="l3.114">       // note Grow() increments mArray_Seed</span>
<a href="#l3.115"></a><span id="l3.115">     }</span>
<a href="#l3.116"></a><span id="l3.116">   }</span>
<a href="#l3.117"></a><span id="l3.117">   else</span>
<a href="#l3.118"></a><span id="l3.118">     this-&gt;NilSlotsAddressError(ev);</span>
<a href="#l3.119"></a><span id="l3.119" class="difflineminus">-    </span>
<a href="#l3.120"></a><span id="l3.120" class="difflineplus">+</span>
<a href="#l3.121"></a><span id="l3.121">   return outPos;</span>
<a href="#l3.122"></a><span id="l3.122"> }</span>
<a href="#l3.123"></a><span id="l3.123"> </span>
<a href="#l3.124"></a><span id="l3.124"> void</span>
<a href="#l3.125"></a><span id="l3.125"> morkArray::AddSlot(morkEnv* ev, mork_pos inPos, void* ioSlot)</span>
<a href="#l3.126"></a><span id="l3.126"> {</span>
<a href="#l3.127"></a><span id="l3.127">   if ( mArray_Slots )</span>
<a href="#l3.128"></a><span id="l3.128">   {</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineat">@@ -257,22 +257,22 @@ morkArray::CutSlot(morkEnv* ev, mork_pos</span>
<a href="#l3.130"></a><span id="l3.130"> {</span>
<a href="#l3.131"></a><span id="l3.131">   MORK_USED_1(ev);</span>
<a href="#l3.132"></a><span id="l3.132">   mork_fill fill = mArray_Fill;</span>
<a href="#l3.133"></a><span id="l3.133">   if ( inPos &gt;= 0 &amp;&amp; inPos &lt; (mork_pos) fill ) // cutting slot in used array portion?</span>
<a href="#l3.134"></a><span id="l3.134">   {</span>
<a href="#l3.135"></a><span id="l3.135">     void** slot = mArray_Slots; // the slot vector</span>
<a href="#l3.136"></a><span id="l3.136">     void** end = slot + fill; // one past the last used array slot</span>
<a href="#l3.137"></a><span id="l3.137">     slot += inPos; // the slot to be cut</span>
<a href="#l3.138"></a><span id="l3.138" class="difflineminus">-    </span>
<a href="#l3.139"></a><span id="l3.139" class="difflineplus">+</span>
<a href="#l3.140"></a><span id="l3.140">     while ( ++slot &lt; end ) // another slot to move downward?</span>
<a href="#l3.141"></a><span id="l3.141">       slot[ -1 ] = *slot;</span>
<a href="#l3.142"></a><span id="l3.142" class="difflineminus">-      </span>
<a href="#l3.143"></a><span id="l3.143" class="difflineplus">+</span>
<a href="#l3.144"></a><span id="l3.144">     slot[ -1 ] = 0; // clear the last used slot which is now unused</span>
<a href="#l3.145"></a><span id="l3.145" class="difflineminus">-    </span>
<a href="#l3.146"></a><span id="l3.146" class="difflineplus">+</span>
<a href="#l3.147"></a><span id="l3.147">     // note inPos&lt;fill implies fill&gt;0, so fill-1 must be nonnegative:</span>
<a href="#l3.148"></a><span id="l3.148">     mArray_Fill = fill - 1;</span>
<a href="#l3.149"></a><span id="l3.149">     ++mArray_Seed;</span>
<a href="#l3.150"></a><span id="l3.150">   }</span>
<a href="#l3.151"></a><span id="l3.151"> }</span>
<a href="#l3.152"></a><span id="l3.152"> </span>
<a href="#l3.153"></a><span id="l3.153"> void</span>
<a href="#l3.154"></a><span id="l3.154"> morkArray::CutAllSlots(morkEnv* ev)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/db/mork/src/morkArray.h</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/db/mork/src/morkArray.h</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -32,22 +32,22 @@ class morkArray : public morkNode { // r</span>
<a href="#l4.4"></a><span id="l4.4">   // mork_refs    mNode_Refs;    // refcount for strong refs + weak refs</span>
<a href="#l4.5"></a><span id="l4.5"> </span>
<a href="#l4.6"></a><span id="l4.6"> public: // state is public because the entire Mork system is private</span>
<a href="#l4.7"></a><span id="l4.7">   void**       mArray_Slots; // array of pointers</span>
<a href="#l4.8"></a><span id="l4.8">   nsIMdbHeap*  mArray_Heap;  // required heap for allocating mArray_Slots</span>
<a href="#l4.9"></a><span id="l4.9">   mork_fill    mArray_Fill;  // logical count of used slots in mArray_Slots</span>
<a href="#l4.10"></a><span id="l4.10">   mork_size    mArray_Size;  // physical count of mArray_Slots ( &gt;= Fill)</span>
<a href="#l4.11"></a><span id="l4.11">   mork_seed    mArray_Seed;  // change counter for syncing with iterators</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-  </span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+</span>
<a href="#l4.14"></a><span id="l4.14"> // { ===== begin morkNode interface =====</span>
<a href="#l4.15"></a><span id="l4.15"> public: // morkNode virtual methods</span>
<a href="#l4.16"></a><span id="l4.16">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseArray()</span>
<a href="#l4.17"></a><span id="l4.17">   virtual ~morkArray(); // assert that close executed earlier</span>
<a href="#l4.18"></a><span id="l4.18" class="difflineminus">-  </span>
<a href="#l4.19"></a><span id="l4.19" class="difflineplus">+</span>
<a href="#l4.20"></a><span id="l4.20"> public: // morkArray construction &amp; destruction</span>
<a href="#l4.21"></a><span id="l4.21">   morkArray(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l4.22"></a><span id="l4.22">     nsIMdbHeap* ioHeap, mork_size inSize, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l4.23"></a><span id="l4.23">   void CloseArray(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l4.24"></a><span id="l4.24"> </span>
<a href="#l4.25"></a><span id="l4.25"> private: // copying is not allowed</span>
<a href="#l4.26"></a><span id="l4.26">   morkArray(const morkArray&amp; other);</span>
<a href="#l4.27"></a><span id="l4.27">   morkArray&amp; operator=(const morkArray&amp; other);</span>
<a href="#l4.28"></a><span id="l4.28" class="difflineat">@@ -62,37 +62,37 @@ public: // typing &amp; errors</span>
<a href="#l4.29"></a><span id="l4.29">   static void IndexBeyondEndError(morkEnv* ev);</span>
<a href="#l4.30"></a><span id="l4.30">   static void NilSlotsAddressError(morkEnv* ev);</span>
<a href="#l4.31"></a><span id="l4.31">   static void FillBeyondSizeError(morkEnv* ev);</span>
<a href="#l4.32"></a><span id="l4.32"> </span>
<a href="#l4.33"></a><span id="l4.33"> public: // other table row cursor methods</span>
<a href="#l4.34"></a><span id="l4.34"> </span>
<a href="#l4.35"></a><span id="l4.35">   mork_fill  Length() const { return mArray_Fill; }</span>
<a href="#l4.36"></a><span id="l4.36">   mork_size  Capacity() const { return mArray_Size; }</span>
<a href="#l4.37"></a><span id="l4.37" class="difflineminus">-  </span>
<a href="#l4.38"></a><span id="l4.38" class="difflineplus">+</span>
<a href="#l4.39"></a><span id="l4.39">   mork_bool  Grow(morkEnv* ev, mork_size inNewSize);</span>
<a href="#l4.40"></a><span id="l4.40">   // Grow() returns true if capacity becomes &gt;= inNewSize and ev-&gt;Good()</span>
<a href="#l4.41"></a><span id="l4.41" class="difflineminus">-  </span>
<a href="#l4.42"></a><span id="l4.42" class="difflineplus">+</span>
<a href="#l4.43"></a><span id="l4.43">   void*      At(mork_pos inPos) const { return mArray_Slots[ inPos ]; }</span>
<a href="#l4.44"></a><span id="l4.44">   void       AtPut(mork_pos inPos, void* ioSlot)</span>
<a href="#l4.45"></a><span id="l4.45">   { mArray_Slots[ inPos ] = ioSlot; }</span>
<a href="#l4.46"></a><span id="l4.46" class="difflineminus">-  </span>
<a href="#l4.47"></a><span id="l4.47" class="difflineplus">+</span>
<a href="#l4.48"></a><span id="l4.48">   void*      SafeAt(morkEnv* ev, mork_pos inPos);</span>
<a href="#l4.49"></a><span id="l4.49">   void       SafeAtPut(morkEnv* ev, mork_pos inPos, void* ioSlot);</span>
<a href="#l4.50"></a><span id="l4.50" class="difflineminus">-  </span>
<a href="#l4.51"></a><span id="l4.51" class="difflineplus">+</span>
<a href="#l4.52"></a><span id="l4.52">   mork_pos   AppendSlot(morkEnv* ev, void* ioSlot);</span>
<a href="#l4.53"></a><span id="l4.53">   void       AddSlot(morkEnv* ev, mork_pos inPos, void* ioSlot);</span>
<a href="#l4.54"></a><span id="l4.54">   void       CutSlot(morkEnv* ev, mork_pos inPos);</span>
<a href="#l4.55"></a><span id="l4.55">   void       CutAllSlots(morkEnv* ev);</span>
<a href="#l4.56"></a><span id="l4.56"> </span>
<a href="#l4.57"></a><span id="l4.57"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l4.58"></a><span id="l4.58">   static void SlotWeakArray(morkArray* me,</span>
<a href="#l4.59"></a><span id="l4.59">     morkEnv* ev, morkArray** ioSlot)</span>
<a href="#l4.60"></a><span id="l4.60">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineminus">-  </span>
<a href="#l4.62"></a><span id="l4.62" class="difflineplus">+</span>
<a href="#l4.63"></a><span id="l4.63">   static void SlotStrongArray(morkArray* me,</span>
<a href="#l4.64"></a><span id="l4.64">     morkEnv* ev, morkArray** ioSlot)</span>
<a href="#l4.65"></a><span id="l4.65">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l4.66"></a><span id="l4.66"> };</span>
<a href="#l4.67"></a><span id="l4.67"> </span>
<a href="#l4.68"></a><span id="l4.68"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l4.69"></a><span id="l4.69"> </span>
<a href="#l4.70"></a><span id="l4.70"> #endif /* _MORKTABLEROWCURSOR_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/db/mork/src/morkAtom.cpp</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/db/mork/src/morkAtom.cpp</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -27,18 +27,18 @@</span>
<a href="#l5.4"></a><span id="l5.4"> #include &quot;morkAtomSpace.h&quot;</span>
<a href="#l5.5"></a><span id="l5.5"> #endif</span>
<a href="#l5.6"></a><span id="l5.6"> </span>
<a href="#l5.7"></a><span id="l5.7"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l5.8"></a><span id="l5.8"> </span>
<a href="#l5.9"></a><span id="l5.9"> mork_bool</span>
<a href="#l5.10"></a><span id="l5.10"> morkAtom::GetYarn(mdbYarn* outYarn) const</span>
<a href="#l5.11"></a><span id="l5.11"> {</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">-  const void* source = 0;  </span>
<a href="#l5.13"></a><span id="l5.13" class="difflineminus">-  mdb_fill fill = 0; </span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+  const void* source = 0;</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+  mdb_fill fill = 0;</span>
<a href="#l5.16"></a><span id="l5.16">   mdb_cscode form = 0;</span>
<a href="#l5.17"></a><span id="l5.17">   outYarn-&gt;mYarn_More = 0;</span>
<a href="#l5.18"></a><span id="l5.18"> </span>
<a href="#l5.19"></a><span id="l5.19">     if ( this-&gt;IsWeeBook() )</span>
<a href="#l5.20"></a><span id="l5.20">     {</span>
<a href="#l5.21"></a><span id="l5.21">       morkWeeBookAtom* weeBook = (morkWeeBookAtom*) this;</span>
<a href="#l5.22"></a><span id="l5.22">       source = weeBook-&gt;mWeeBookAtom_Body;</span>
<a href="#l5.23"></a><span id="l5.23">       fill = weeBook-&gt;mAtom_Size;</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineat">@@ -64,38 +64,38 @@ morkAtom::GetYarn(mdbYarn* outYarn) cons</span>
<a href="#l5.25"></a><span id="l5.25">       form = bigAnon-&gt;mBigAnonAtom_Form;</span>
<a href="#l5.26"></a><span id="l5.26">     }</span>
<a href="#l5.27"></a><span id="l5.27"> </span>
<a href="#l5.28"></a><span id="l5.28">   if ( source &amp;&amp; fill ) // have an atom with nonempty content?</span>
<a href="#l5.29"></a><span id="l5.29">   {</span>
<a href="#l5.30"></a><span id="l5.30">     // if we have too many bytes, and yarn seems growable:</span>
<a href="#l5.31"></a><span id="l5.31">     if ( fill &gt; outYarn-&gt;mYarn_Size &amp;&amp; outYarn-&gt;mYarn_Grow ) // try grow?</span>
<a href="#l5.32"></a><span id="l5.32">       (*outYarn-&gt;mYarn_Grow)(outYarn, (mdb_size) fill); // request bigger</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineminus">-      </span>
<a href="#l5.34"></a><span id="l5.34" class="difflineplus">+</span>
<a href="#l5.35"></a><span id="l5.35">     mdb_size size = outYarn-&gt;mYarn_Size; // max dest size</span>
<a href="#l5.36"></a><span id="l5.36">     if ( fill &gt; size ) // too much atom content?</span>
<a href="#l5.37"></a><span id="l5.37">     {</span>
<a href="#l5.38"></a><span id="l5.38">       outYarn-&gt;mYarn_More = fill - size; // extra atom bytes omitted</span>
<a href="#l5.39"></a><span id="l5.39">       fill = size; // copy no more bytes than size of yarn buffer</span>
<a href="#l5.40"></a><span id="l5.40">     }</span>
<a href="#l5.41"></a><span id="l5.41">     void* dest = outYarn-&gt;mYarn_Buf; // where bytes are going</span>
<a href="#l5.42"></a><span id="l5.42">     if ( !dest ) // nil destination address buffer?</span>
<a href="#l5.43"></a><span id="l5.43">       fill = 0; // we can't write any content at all</span>
<a href="#l5.44"></a><span id="l5.44" class="difflineminus">-      </span>
<a href="#l5.45"></a><span id="l5.45" class="difflineplus">+</span>
<a href="#l5.46"></a><span id="l5.46">     if ( fill ) // anything to copy?</span>
<a href="#l5.47"></a><span id="l5.47">       MORK_MEMCPY(dest, source, fill); // copy fill bytes to yarn</span>
<a href="#l5.48"></a><span id="l5.48" class="difflineminus">-      </span>
<a href="#l5.49"></a><span id="l5.49" class="difflineplus">+</span>
<a href="#l5.50"></a><span id="l5.50">     outYarn-&gt;mYarn_Fill = fill; // tell yarn size of copied content</span>
<a href="#l5.51"></a><span id="l5.51">   }</span>
<a href="#l5.52"></a><span id="l5.52">   else // no content to put into the yarn</span>
<a href="#l5.53"></a><span id="l5.53">   {</span>
<a href="#l5.54"></a><span id="l5.54">     outYarn-&gt;mYarn_Fill = 0; // tell yarn that atom has no bytes</span>
<a href="#l5.55"></a><span id="l5.55">   }</span>
<a href="#l5.56"></a><span id="l5.56">   outYarn-&gt;mYarn_Form = form; // always update the form slot</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineminus">-  </span>
<a href="#l5.58"></a><span id="l5.58" class="difflineplus">+</span>
<a href="#l5.59"></a><span id="l5.59">   return ( source != 0 );</span>
<a href="#l5.60"></a><span id="l5.60"> }</span>
<a href="#l5.61"></a><span id="l5.61"> </span>
<a href="#l5.62"></a><span id="l5.62"> /* static */</span>
<a href="#l5.63"></a><span id="l5.63"> mork_bool</span>
<a href="#l5.64"></a><span id="l5.64"> morkAtom::AliasYarn(const morkAtom* atom, mdbYarn* outYarn)</span>
<a href="#l5.65"></a><span id="l5.65"> {</span>
<a href="#l5.66"></a><span id="l5.66">   outYarn-&gt;mYarn_More = 0;</span>
<a href="#l5.67"></a><span id="l5.67" class="difflineat">@@ -131,17 +131,17 @@ morkAtom::AliasYarn(const morkAtom* atom</span>
<a href="#l5.68"></a><span id="l5.68">       outYarn-&gt;mYarn_Buf = bigAnon-&gt;mBigAnonAtom_Body;</span>
<a href="#l5.69"></a><span id="l5.69">       outYarn-&gt;mYarn_Fill = bigAnon-&gt;mBigAnonAtom_Size;</span>
<a href="#l5.70"></a><span id="l5.70">       outYarn-&gt;mYarn_Size = bigAnon-&gt;mBigAnonAtom_Size;</span>
<a href="#l5.71"></a><span id="l5.71">       outYarn-&gt;mYarn_Form = bigAnon-&gt;mBigAnonAtom_Form;</span>
<a href="#l5.72"></a><span id="l5.72">     }</span>
<a href="#l5.73"></a><span id="l5.73">     else</span>
<a href="#l5.74"></a><span id="l5.74">       atom = 0; // show desire to put empty content in yarn</span>
<a href="#l5.75"></a><span id="l5.75">   }</span>
<a href="#l5.76"></a><span id="l5.76" class="difflineminus">-  </span>
<a href="#l5.77"></a><span id="l5.77" class="difflineplus">+</span>
<a href="#l5.78"></a><span id="l5.78">   if ( !atom ) // empty content for yarn?</span>
<a href="#l5.79"></a><span id="l5.79">   {</span>
<a href="#l5.80"></a><span id="l5.80">     outYarn-&gt;mYarn_Buf = 0;</span>
<a href="#l5.81"></a><span id="l5.81">     outYarn-&gt;mYarn_Fill = 0;</span>
<a href="#l5.82"></a><span id="l5.82">     outYarn-&gt;mYarn_Size = 0;</span>
<a href="#l5.83"></a><span id="l5.83">     // outYarn-&gt;mYarn_Grow = 0; // please don't modify the Grow slot</span>
<a href="#l5.84"></a><span id="l5.84">   }</span>
<a href="#l5.85"></a><span id="l5.85">   return ( atom != 0 );</span>
<a href="#l5.86"></a><span id="l5.86" class="difflineat">@@ -161,48 +161,48 @@ morkAtom::GetBookAtomSpaceScope(morkEnv*</span>
<a href="#l5.87"></a><span id="l5.87">   {</span>
<a href="#l5.88"></a><span id="l5.88">     const morkBookAtom* bookAtom = (const morkBookAtom*) this;</span>
<a href="#l5.89"></a><span id="l5.89">     morkAtomSpace* space = bookAtom-&gt;mBookAtom_Space;</span>
<a href="#l5.90"></a><span id="l5.90">     if ( space-&gt;IsAtomSpace() )</span>
<a href="#l5.91"></a><span id="l5.91">       outScope = space-&gt;SpaceScope();</span>
<a href="#l5.92"></a><span id="l5.92">     else</span>
<a href="#l5.93"></a><span id="l5.93">       space-&gt;NonAtomSpaceTypeError(ev);</span>
<a href="#l5.94"></a><span id="l5.94">   }</span>
<a href="#l5.95"></a><span id="l5.95" class="difflineminus">-  </span>
<a href="#l5.96"></a><span id="l5.96" class="difflineplus">+</span>
<a href="#l5.97"></a><span id="l5.97">   return outScope;</span>
<a href="#l5.98"></a><span id="l5.98"> }</span>
<a href="#l5.99"></a><span id="l5.99"> </span>
<a href="#l5.100"></a><span id="l5.100"> void</span>
<a href="#l5.101"></a><span id="l5.101"> morkAtom::MakeCellUseForever(morkEnv* ev)</span>
<a href="#l5.102"></a><span id="l5.102"> {</span>
<a href="#l5.103"></a><span id="l5.103" class="difflineminus">-  MORK_USED_1(ev); </span>
<a href="#l5.104"></a><span id="l5.104" class="difflineplus">+  MORK_USED_1(ev);</span>
<a href="#l5.105"></a><span id="l5.105">   mAtom_CellUses = morkAtom_kForeverCellUses;</span>
<a href="#l5.106"></a><span id="l5.106"> }</span>
<a href="#l5.107"></a><span id="l5.107"> </span>
<a href="#l5.108"></a><span id="l5.108"> mork_u1</span>
<a href="#l5.109"></a><span id="l5.109"> morkAtom::AddCellUse(morkEnv* ev)</span>
<a href="#l5.110"></a><span id="l5.110"> {</span>
<a href="#l5.111"></a><span id="l5.111" class="difflineminus">-  MORK_USED_1(ev); </span>
<a href="#l5.112"></a><span id="l5.112" class="difflineplus">+  MORK_USED_1(ev);</span>
<a href="#l5.113"></a><span id="l5.113">   if ( mAtom_CellUses &lt; morkAtom_kMaxCellUses ) // not already maxed out?</span>
<a href="#l5.114"></a><span id="l5.114">     ++mAtom_CellUses;</span>
<a href="#l5.115"></a><span id="l5.115" class="difflineminus">-    </span>
<a href="#l5.116"></a><span id="l5.116" class="difflineplus">+</span>
<a href="#l5.117"></a><span id="l5.117">   return mAtom_CellUses;</span>
<a href="#l5.118"></a><span id="l5.118"> }</span>
<a href="#l5.119"></a><span id="l5.119"> </span>
<a href="#l5.120"></a><span id="l5.120"> mork_u1</span>
<a href="#l5.121"></a><span id="l5.121"> morkAtom::CutCellUse(morkEnv* ev)</span>
<a href="#l5.122"></a><span id="l5.122"> {</span>
<a href="#l5.123"></a><span id="l5.123">   if ( mAtom_CellUses ) // any outstanding uses to cut?</span>
<a href="#l5.124"></a><span id="l5.124">   {</span>
<a href="#l5.125"></a><span id="l5.125">     if ( mAtom_CellUses &lt; morkAtom_kMaxCellUses ) // not frozen at max?</span>
<a href="#l5.126"></a><span id="l5.126">       --mAtom_CellUses;</span>
<a href="#l5.127"></a><span id="l5.127">   }</span>
<a href="#l5.128"></a><span id="l5.128">   else</span>
<a href="#l5.129"></a><span id="l5.129">     this-&gt;CellUsesUnderflowWarning(ev);</span>
<a href="#l5.130"></a><span id="l5.130" class="difflineminus">-    </span>
<a href="#l5.131"></a><span id="l5.131" class="difflineplus">+</span>
<a href="#l5.132"></a><span id="l5.132">   return mAtom_CellUses;</span>
<a href="#l5.133"></a><span id="l5.133"> }</span>
<a href="#l5.134"></a><span id="l5.134"> </span>
<a href="#l5.135"></a><span id="l5.135"> /*static*/ void</span>
<a href="#l5.136"></a><span id="l5.136"> morkAtom::CellUsesUnderflowWarning(morkEnv* ev)</span>
<a href="#l5.137"></a><span id="l5.137"> {</span>
<a href="#l5.138"></a><span id="l5.138">   ev-&gt;NewWarning(&quot;mAtom_CellUses underflow&quot;);</span>
<a href="#l5.139"></a><span id="l5.139"> }</span>
<a href="#l5.140"></a><span id="l5.140" class="difflineat">@@ -223,28 +223,28 @@ morkAtom::ZeroAidError(morkEnv* ev)</span>
<a href="#l5.141"></a><span id="l5.141"> morkAtom::AtomSizeOverflowError(morkEnv* ev)</span>
<a href="#l5.142"></a><span id="l5.142"> {</span>
<a href="#l5.143"></a><span id="l5.143">   ev-&gt;NewError(&quot;atom mAtom_Size overflow&quot;);</span>
<a href="#l5.144"></a><span id="l5.144"> }</span>
<a href="#l5.145"></a><span id="l5.145"> </span>
<a href="#l5.146"></a><span id="l5.146"> void</span>
<a href="#l5.147"></a><span id="l5.147"> morkOidAtom::InitRowOidAtom(morkEnv* ev, const mdbOid&amp; inOid)</span>
<a href="#l5.148"></a><span id="l5.148"> {</span>
<a href="#l5.149"></a><span id="l5.149" class="difflineminus">-  MORK_USED_1(ev); </span>
<a href="#l5.150"></a><span id="l5.150" class="difflineplus">+  MORK_USED_1(ev);</span>
<a href="#l5.151"></a><span id="l5.151">   mAtom_CellUses = 0;</span>
<a href="#l5.152"></a><span id="l5.152">   mAtom_Kind = morkAtom_kKindRowOid;</span>
<a href="#l5.153"></a><span id="l5.153">   mAtom_Change = morkChange_kNil;</span>
<a href="#l5.154"></a><span id="l5.154">   mAtom_Size = 0;</span>
<a href="#l5.155"></a><span id="l5.155">   mOidAtom_Oid = inOid; // bitwise copy</span>
<a href="#l5.156"></a><span id="l5.156"> }</span>
<a href="#l5.157"></a><span id="l5.157"> </span>
<a href="#l5.158"></a><span id="l5.158"> void</span>
<a href="#l5.159"></a><span id="l5.159"> morkOidAtom::InitTableOidAtom(morkEnv* ev, const mdbOid&amp; inOid)</span>
<a href="#l5.160"></a><span id="l5.160"> {</span>
<a href="#l5.161"></a><span id="l5.161" class="difflineminus">-  MORK_USED_1(ev); </span>
<a href="#l5.162"></a><span id="l5.162" class="difflineplus">+  MORK_USED_1(ev);</span>
<a href="#l5.163"></a><span id="l5.163">   mAtom_CellUses = 0;</span>
<a href="#l5.164"></a><span id="l5.164">   mAtom_Kind = morkAtom_kKindTableOid;</span>
<a href="#l5.165"></a><span id="l5.165">   mAtom_Change = morkChange_kNil;</span>
<a href="#l5.166"></a><span id="l5.166">   mAtom_Size = 0;</span>
<a href="#l5.167"></a><span id="l5.167">   mOidAtom_Oid = inOid; // bitwise copy</span>
<a href="#l5.168"></a><span id="l5.168"> }</span>
<a href="#l5.169"></a><span id="l5.169"> </span>
<a href="#l5.170"></a><span id="l5.170"> void</span>
<a href="#l5.171"></a><span id="l5.171" class="difflineat">@@ -255,38 +255,38 @@ morkWeeAnonAtom::InitWeeAnonAtom(morkEnv</span>
<a href="#l5.172"></a><span id="l5.172">   if ( inBuf.mBuf_Fill &lt;= morkAtom_kMaxByteSize )</span>
<a href="#l5.173"></a><span id="l5.173">   {</span>
<a href="#l5.174"></a><span id="l5.174">     mAtom_CellUses = 0;</span>
<a href="#l5.175"></a><span id="l5.175">     mAtom_Kind = morkAtom_kKindWeeAnon;</span>
<a href="#l5.176"></a><span id="l5.176">     mork_size size = inBuf.mBuf_Fill;</span>
<a href="#l5.177"></a><span id="l5.177">     mAtom_Size = (mork_u1) size;</span>
<a href="#l5.178"></a><span id="l5.178">     if ( size &amp;&amp; inBuf.mBuf_Body )</span>
<a href="#l5.179"></a><span id="l5.179">       MORK_MEMCPY(mWeeAnonAtom_Body, inBuf.mBuf_Body, size);</span>
<a href="#l5.180"></a><span id="l5.180" class="difflineminus">-        </span>
<a href="#l5.181"></a><span id="l5.181" class="difflineplus">+</span>
<a href="#l5.182"></a><span id="l5.182">     mWeeAnonAtom_Body[ size ] = 0;</span>
<a href="#l5.183"></a><span id="l5.183">   }</span>
<a href="#l5.184"></a><span id="l5.184">   else</span>
<a href="#l5.185"></a><span id="l5.185">     this-&gt;AtomSizeOverflowError(ev);</span>
<a href="#l5.186"></a><span id="l5.186"> }</span>
<a href="#l5.187"></a><span id="l5.187"> </span>
<a href="#l5.188"></a><span id="l5.188"> void</span>
<a href="#l5.189"></a><span id="l5.189"> morkBigAnonAtom::InitBigAnonAtom(morkEnv* ev, const morkBuf&amp; inBuf,</span>
<a href="#l5.190"></a><span id="l5.190">   mork_cscode inForm)</span>
<a href="#l5.191"></a><span id="l5.191"> {</span>
<a href="#l5.192"></a><span id="l5.192" class="difflineminus">-  MORK_USED_1(ev); </span>
<a href="#l5.193"></a><span id="l5.193" class="difflineplus">+  MORK_USED_1(ev);</span>
<a href="#l5.194"></a><span id="l5.194">   mAtom_CellUses = 0;</span>
<a href="#l5.195"></a><span id="l5.195">   mAtom_Kind = morkAtom_kKindBigAnon;</span>
<a href="#l5.196"></a><span id="l5.196">   mAtom_Change = morkChange_kNil;</span>
<a href="#l5.197"></a><span id="l5.197">   mAtom_Size = 0;</span>
<a href="#l5.198"></a><span id="l5.198">   mBigAnonAtom_Form = inForm;</span>
<a href="#l5.199"></a><span id="l5.199">   mork_size size = inBuf.mBuf_Fill;</span>
<a href="#l5.200"></a><span id="l5.200">   mBigAnonAtom_Size = size;</span>
<a href="#l5.201"></a><span id="l5.201">   if ( size &amp;&amp; inBuf.mBuf_Body )</span>
<a href="#l5.202"></a><span id="l5.202">     MORK_MEMCPY(mBigAnonAtom_Body, inBuf.mBuf_Body, size);</span>
<a href="#l5.203"></a><span id="l5.203" class="difflineminus">-        </span>
<a href="#l5.204"></a><span id="l5.204" class="difflineplus">+</span>
<a href="#l5.205"></a><span id="l5.205">   mBigAnonAtom_Body[ size ] = 0;</span>
<a href="#l5.206"></a><span id="l5.206"> }</span>
<a href="#l5.207"></a><span id="l5.207"> </span>
<a href="#l5.208"></a><span id="l5.208"> /*static*/ void</span>
<a href="#l5.209"></a><span id="l5.209"> morkBookAtom::NonBookAtomTypeError(morkEnv* ev)</span>
<a href="#l5.210"></a><span id="l5.210"> {</span>
<a href="#l5.211"></a><span id="l5.211">   ev-&gt;NewError(&quot;non morkBookAtom&quot;);</span>
<a href="#l5.212"></a><span id="l5.212"> }</span>
<a href="#l5.213"></a><span id="l5.213" class="difflineat">@@ -317,39 +317,39 @@ morkBookAtom::HashFormAndBody(morkEnv* e</span>
<a href="#l5.214"></a><span id="l5.214">     size = ((const morkFarBookAtom*) this)-&gt;mFarBookAtom_Size;</span>
<a href="#l5.215"></a><span id="l5.215">     body = ((const morkFarBookAtom*) this)-&gt;mFarBookAtom_Body;</span>
<a href="#l5.216"></a><span id="l5.216">   }</span>
<a href="#l5.217"></a><span id="l5.217">   else</span>
<a href="#l5.218"></a><span id="l5.218">   {</span>
<a href="#l5.219"></a><span id="l5.219">     this-&gt;NonBookAtomTypeError(ev);</span>
<a href="#l5.220"></a><span id="l5.220">     return 0;</span>
<a href="#l5.221"></a><span id="l5.221">   }</span>
<a href="#l5.222"></a><span id="l5.222" class="difflineminus">-  </span>
<a href="#l5.223"></a><span id="l5.223" class="difflineplus">+</span>
<a href="#l5.224"></a><span id="l5.224">   const mork_u1* end = body + size;</span>
<a href="#l5.225"></a><span id="l5.225">   while ( body &lt; end )</span>
<a href="#l5.226"></a><span id="l5.226">   {</span>
<a href="#l5.227"></a><span id="l5.227">     c = *body++;</span>
<a href="#l5.228"></a><span id="l5.228">     outHash &lt;&lt;= 4;</span>
<a href="#l5.229"></a><span id="l5.229">     outHash += c;</span>
<a href="#l5.230"></a><span id="l5.230">     mork_u4 top = outHash &amp; 0xF0000000L; // top four bits</span>
<a href="#l5.231"></a><span id="l5.231" class="difflineminus">-    if ( top ) // any of high four bits equal to one? </span>
<a href="#l5.232"></a><span id="l5.232" class="difflineplus">+    if ( top ) // any of high four bits equal to one?</span>
<a href="#l5.233"></a><span id="l5.233">     {</span>
<a href="#l5.234"></a><span id="l5.234">       outHash ^= (top &gt;&gt; 24); // fold down high bits</span>
<a href="#l5.235"></a><span id="l5.235">       outHash ^= top; // zero top four bits</span>
<a href="#l5.236"></a><span id="l5.236">     }</span>
<a href="#l5.237"></a><span id="l5.237">   }</span>
<a href="#l5.238"></a><span id="l5.238" class="difflineminus">-    </span>
<a href="#l5.239"></a><span id="l5.239" class="difflineplus">+</span>
<a href="#l5.240"></a><span id="l5.240">   return outHash;</span>
<a href="#l5.241"></a><span id="l5.241"> }</span>
<a href="#l5.242"></a><span id="l5.242"> </span>
<a href="#l5.243"></a><span id="l5.243"> mork_bool</span>
<a href="#l5.244"></a><span id="l5.244"> morkBookAtom::EqualFormAndBody(morkEnv* ev, const morkBookAtom* inAtom) const</span>
<a href="#l5.245"></a><span id="l5.245"> {</span>
<a href="#l5.246"></a><span id="l5.246">   mork_bool outEqual = morkBool_kFalse;</span>
<a href="#l5.247"></a><span id="l5.247" class="difflineminus">-  </span>
<a href="#l5.248"></a><span id="l5.248" class="difflineplus">+</span>
<a href="#l5.249"></a><span id="l5.249">   const mork_u1* body = 0; // body of inAtom bytes to compare</span>
<a href="#l5.250"></a><span id="l5.250">   mork_size size; // the number of inAtom bytes to compare</span>
<a href="#l5.251"></a><span id="l5.251">   mork_cscode form; // nominal charset for ioAtom</span>
<a href="#l5.252"></a><span id="l5.252"> </span>
<a href="#l5.253"></a><span id="l5.253">   if ( inAtom-&gt;IsWeeBook() )</span>
<a href="#l5.254"></a><span id="l5.254">   {</span>
<a href="#l5.255"></a><span id="l5.255">     size = inAtom-&gt;mAtom_Size;</span>
<a href="#l5.256"></a><span id="l5.256">     body = ((const morkWeeBookAtom*) inAtom)-&gt;mWeeBookAtom_Body;</span>
<a href="#l5.257"></a><span id="l5.257" class="difflineat">@@ -371,17 +371,17 @@ morkBookAtom::EqualFormAndBody(morkEnv* </span>
<a href="#l5.258"></a><span id="l5.258">   {</span>
<a href="#l5.259"></a><span id="l5.259">     inAtom-&gt;NonBookAtomTypeError(ev);</span>
<a href="#l5.260"></a><span id="l5.260">     return morkBool_kFalse;</span>
<a href="#l5.261"></a><span id="l5.261">   }</span>
<a href="#l5.262"></a><span id="l5.262"> </span>
<a href="#l5.263"></a><span id="l5.263">   const mork_u1* thisBody = 0; // body of bytes in this to compare</span>
<a href="#l5.264"></a><span id="l5.264">   mork_size thisSize; // the number of bytes in this to compare</span>
<a href="#l5.265"></a><span id="l5.265">   mork_cscode thisForm; // nominal charset for this atom</span>
<a href="#l5.266"></a><span id="l5.266" class="difflineminus">-  </span>
<a href="#l5.267"></a><span id="l5.267" class="difflineplus">+</span>
<a href="#l5.268"></a><span id="l5.268">   if ( this-&gt;IsWeeBook() )</span>
<a href="#l5.269"></a><span id="l5.269">   {</span>
<a href="#l5.270"></a><span id="l5.270">     thisSize = mAtom_Size;</span>
<a href="#l5.271"></a><span id="l5.271">     thisBody = ((const morkWeeBookAtom*) this)-&gt;mWeeBookAtom_Body;</span>
<a href="#l5.272"></a><span id="l5.272">     thisForm = 0;</span>
<a href="#l5.273"></a><span id="l5.273">   }</span>
<a href="#l5.274"></a><span id="l5.274">   else if ( this-&gt;IsBigBook() )</span>
<a href="#l5.275"></a><span id="l5.275">   {</span>
<a href="#l5.276"></a><span id="l5.276" class="difflineat">@@ -395,21 +395,21 @@ morkBookAtom::EqualFormAndBody(morkEnv* </span>
<a href="#l5.277"></a><span id="l5.277">     thisBody = ((const morkFarBookAtom*) this)-&gt;mFarBookAtom_Body;</span>
<a href="#l5.278"></a><span id="l5.278">     thisForm = ((const morkFarBookAtom*) this)-&gt;mFarBookAtom_Form;</span>
<a href="#l5.279"></a><span id="l5.279">   }</span>
<a href="#l5.280"></a><span id="l5.280">   else</span>
<a href="#l5.281"></a><span id="l5.281">   {</span>
<a href="#l5.282"></a><span id="l5.282">     this-&gt;NonBookAtomTypeError(ev);</span>
<a href="#l5.283"></a><span id="l5.283">     return morkBool_kFalse;</span>
<a href="#l5.284"></a><span id="l5.284">   }</span>
<a href="#l5.285"></a><span id="l5.285" class="difflineminus">-  </span>
<a href="#l5.286"></a><span id="l5.286" class="difflineplus">+</span>
<a href="#l5.287"></a><span id="l5.287">   // if atoms are empty, form is irrelevant</span>
<a href="#l5.288"></a><span id="l5.288">   if ( body &amp;&amp; thisBody &amp;&amp; size == thisSize &amp;&amp; (!size || form == thisForm ))</span>
<a href="#l5.289"></a><span id="l5.289">     outEqual = (MORK_MEMCMP(body, thisBody, size) == 0);</span>
<a href="#l5.290"></a><span id="l5.290" class="difflineminus">-  </span>
<a href="#l5.291"></a><span id="l5.291" class="difflineplus">+</span>
<a href="#l5.292"></a><span id="l5.292">   return outEqual;</span>
<a href="#l5.293"></a><span id="l5.293"> }</span>
<a href="#l5.294"></a><span id="l5.294"> </span>
<a href="#l5.295"></a><span id="l5.295"> </span>
<a href="#l5.296"></a><span id="l5.296"> void</span>
<a href="#l5.297"></a><span id="l5.297"> morkBookAtom::CutBookAtomFromSpace(morkEnv* ev)</span>
<a href="#l5.298"></a><span id="l5.298"> {</span>
<a href="#l5.299"></a><span id="l5.299">   morkAtomSpace* space = mBookAtom_Space;</span>
<a href="#l5.300"></a><span id="l5.300" class="difflineat">@@ -451,17 +451,17 @@ morkWeeBookAtom::InitWeeBookAtom(morkEnv</span>
<a href="#l5.301"></a><span id="l5.301">         mAtom_CellUses = 0;</span>
<a href="#l5.302"></a><span id="l5.302">         mAtom_Kind = morkAtom_kKindWeeBook;</span>
<a href="#l5.303"></a><span id="l5.303">         mBookAtom_Space = ioSpace;</span>
<a href="#l5.304"></a><span id="l5.304">         mBookAtom_Id = inAid;</span>
<a href="#l5.305"></a><span id="l5.305">         mork_size size = inBuf.mBuf_Fill;</span>
<a href="#l5.306"></a><span id="l5.306">         mAtom_Size = (mork_u1) size;</span>
<a href="#l5.307"></a><span id="l5.307">         if ( size &amp;&amp; inBuf.mBuf_Body )</span>
<a href="#l5.308"></a><span id="l5.308">           MORK_MEMCPY(mWeeBookAtom_Body, inBuf.mBuf_Body, size);</span>
<a href="#l5.309"></a><span id="l5.309" class="difflineminus">-        </span>
<a href="#l5.310"></a><span id="l5.310" class="difflineplus">+</span>
<a href="#l5.311"></a><span id="l5.311">         mWeeBookAtom_Body[ size ] = 0;</span>
<a href="#l5.312"></a><span id="l5.312">       }</span>
<a href="#l5.313"></a><span id="l5.313">       else</span>
<a href="#l5.314"></a><span id="l5.314">         this-&gt;AtomSizeOverflowError(ev);</span>
<a href="#l5.315"></a><span id="l5.315">     }</span>
<a href="#l5.316"></a><span id="l5.316">     else</span>
<a href="#l5.317"></a><span id="l5.317">       this-&gt;ZeroAidError(ev);</span>
<a href="#l5.318"></a><span id="l5.318">   }</span>
<a href="#l5.319"></a><span id="l5.319" class="difflineat">@@ -484,17 +484,17 @@ morkBigBookAtom::InitBigBookAtom(morkEnv</span>
<a href="#l5.320"></a><span id="l5.320">       mAtom_Size = 0;</span>
<a href="#l5.321"></a><span id="l5.321">       mBookAtom_Space = ioSpace;</span>
<a href="#l5.322"></a><span id="l5.322">       mBookAtom_Id = inAid;</span>
<a href="#l5.323"></a><span id="l5.323">       mBigBookAtom_Form = inForm;</span>
<a href="#l5.324"></a><span id="l5.324">       mork_size size = inBuf.mBuf_Fill;</span>
<a href="#l5.325"></a><span id="l5.325">       mBigBookAtom_Size = size;</span>
<a href="#l5.326"></a><span id="l5.326">       if ( size &amp;&amp; inBuf.mBuf_Body )</span>
<a href="#l5.327"></a><span id="l5.327">         MORK_MEMCPY(mBigBookAtom_Body, inBuf.mBuf_Body, size);</span>
<a href="#l5.328"></a><span id="l5.328" class="difflineminus">-        </span>
<a href="#l5.329"></a><span id="l5.329" class="difflineplus">+</span>
<a href="#l5.330"></a><span id="l5.330">       mBigBookAtom_Body[ size ] = 0;</span>
<a href="#l5.331"></a><span id="l5.331">     }</span>
<a href="#l5.332"></a><span id="l5.332">     else</span>
<a href="#l5.333"></a><span id="l5.333">       this-&gt;ZeroAidError(ev);</span>
<a href="#l5.334"></a><span id="l5.334">   }</span>
<a href="#l5.335"></a><span id="l5.335">   else</span>
<a href="#l5.336"></a><span id="l5.336">     ev-&gt;NilPointerError();</span>
<a href="#l5.337"></a><span id="l5.337"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/db/mork/src/morkAtom.h</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/db/mork/src/morkAtom.h</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -23,64 +23,64 @@</span>
<a href="#l6.4"></a><span id="l6.4"> #define morkAtom_kKindBigBook  'B'  /* means morkBigBookAtom subclass */</span>
<a href="#l6.5"></a><span id="l6.5"> #define morkAtom_kKindFarBook  'f'  /* means morkFarBookAtom subclass */</span>
<a href="#l6.6"></a><span id="l6.6"> #define morkAtom_kKindRowOid   'r'  /* means morkOidAtom subclass */</span>
<a href="#l6.7"></a><span id="l6.7"> #define morkAtom_kKindTableOid 't'  /* means morkOidAtom subclass */</span>
<a href="#l6.8"></a><span id="l6.8"> </span>
<a href="#l6.9"></a><span id="l6.9"> /*| Atom: .</span>
<a href="#l6.10"></a><span id="l6.10"> |*/</span>
<a href="#l6.11"></a><span id="l6.11"> class morkAtom { //</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">- </span>
<a href="#l6.13"></a><span id="l6.13" class="difflineminus">-public: </span>
<a href="#l6.14"></a><span id="l6.14" class="difflineplus">+</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineplus">+public:</span>
<a href="#l6.16"></a><span id="l6.16"> </span>
<a href="#l6.17"></a><span id="l6.17">   mork_u1       mAtom_Kind;      // identifies a specific atom subclass</span>
<a href="#l6.18"></a><span id="l6.18">   mork_u1       mAtom_CellUses;  // number of persistent uses in a cell</span>
<a href="#l6.19"></a><span id="l6.19">   mork_change   mAtom_Change;    // how has this atom been changed?</span>
<a href="#l6.20"></a><span id="l6.20">   mork_u1       mAtom_Size;      // only for atoms smaller than 256 bytes</span>
<a href="#l6.21"></a><span id="l6.21"> </span>
<a href="#l6.22"></a><span id="l6.22" class="difflineminus">-public: </span>
<a href="#l6.23"></a><span id="l6.23" class="difflineplus">+public:</span>
<a href="#l6.24"></a><span id="l6.24">   morkAtom(mork_aid inAid, mork_u1 inKind);</span>
<a href="#l6.25"></a><span id="l6.25" class="difflineminus">-  </span>
<a href="#l6.26"></a><span id="l6.26" class="difflineplus">+</span>
<a href="#l6.27"></a><span id="l6.27">   mork_bool IsWeeAnon() const { return mAtom_Kind == morkAtom_kKindWeeAnon; }</span>
<a href="#l6.28"></a><span id="l6.28">   mork_bool IsBigAnon() const { return mAtom_Kind == morkAtom_kKindBigAnon; }</span>
<a href="#l6.29"></a><span id="l6.29">   mork_bool IsWeeBook() const { return mAtom_Kind == morkAtom_kKindWeeBook; }</span>
<a href="#l6.30"></a><span id="l6.30">   mork_bool IsBigBook() const { return mAtom_Kind == morkAtom_kKindBigBook; }</span>
<a href="#l6.31"></a><span id="l6.31">   mork_bool IsFarBook() const { return mAtom_Kind == morkAtom_kKindFarBook; }</span>
<a href="#l6.32"></a><span id="l6.32">   mork_bool IsRowOid() const { return mAtom_Kind == morkAtom_kKindRowOid; }</span>
<a href="#l6.33"></a><span id="l6.33">   mork_bool IsTableOid() const { return mAtom_Kind == morkAtom_kKindTableOid; }</span>
<a href="#l6.34"></a><span id="l6.34"> </span>
<a href="#l6.35"></a><span id="l6.35">   mork_bool IsBook() const { return this-&gt;IsWeeBook() || this-&gt;IsBigBook(); }</span>
<a href="#l6.36"></a><span id="l6.36"> </span>
<a href="#l6.37"></a><span id="l6.37"> public: // clean vs dirty</span>
<a href="#l6.38"></a><span id="l6.38"> </span>
<a href="#l6.39"></a><span id="l6.39">   void SetAtomClean() { mAtom_Change = morkChange_kNil; }</span>
<a href="#l6.40"></a><span id="l6.40">   void SetAtomDirty() { mAtom_Change = morkChange_kAdd; }</span>
<a href="#l6.41"></a><span id="l6.41" class="difflineminus">-  </span>
<a href="#l6.42"></a><span id="l6.42" class="difflineplus">+</span>
<a href="#l6.43"></a><span id="l6.43">   mork_bool IsAtomClean() const { return mAtom_Change == morkChange_kNil; }</span>
<a href="#l6.44"></a><span id="l6.44">   mork_bool IsAtomDirty() const { return mAtom_Change == morkChange_kAdd; }</span>
<a href="#l6.45"></a><span id="l6.45"> </span>
<a href="#l6.46"></a><span id="l6.46"> public: // atom space scope if IsBook() is true, or else zero:</span>
<a href="#l6.47"></a><span id="l6.47"> </span>
<a href="#l6.48"></a><span id="l6.48">   mork_scope GetBookAtomSpaceScope(morkEnv* ev) const;</span>
<a href="#l6.49"></a><span id="l6.49">   // zero or book's space's scope</span>
<a href="#l6.50"></a><span id="l6.50"> </span>
<a href="#l6.51"></a><span id="l6.51">   mork_aid   GetBookAtomAid() const;</span>
<a href="#l6.52"></a><span id="l6.52">   // zero or book atom's ID</span>
<a href="#l6.53"></a><span id="l6.53" class="difflineminus">- </span>
<a href="#l6.54"></a><span id="l6.54" class="difflineplus">+</span>
<a href="#l6.55"></a><span id="l6.55"> public: // empty construction does nothing</span>
<a href="#l6.56"></a><span id="l6.56">   morkAtom() { }</span>
<a href="#l6.57"></a><span id="l6.57"> </span>
<a href="#l6.58"></a><span id="l6.58"> public: // one-byte refcounting, freezing at maximum</span>
<a href="#l6.59"></a><span id="l6.59">   void       MakeCellUseForever(morkEnv* ev);</span>
<a href="#l6.60"></a><span id="l6.60">   mork_u1    AddCellUse(morkEnv* ev);</span>
<a href="#l6.61"></a><span id="l6.61">   mork_u1    CutCellUse(morkEnv* ev);</span>
<a href="#l6.62"></a><span id="l6.62" class="difflineminus">-  </span>
<a href="#l6.63"></a><span id="l6.63" class="difflineminus">-  mork_bool  IsCellUseForever() const </span>
<a href="#l6.64"></a><span id="l6.64" class="difflineplus">+</span>
<a href="#l6.65"></a><span id="l6.65" class="difflineplus">+  mork_bool  IsCellUseForever() const</span>
<a href="#l6.66"></a><span id="l6.66">   { return mAtom_CellUses == morkAtom_kForeverCellUses; }</span>
<a href="#l6.67"></a><span id="l6.67" class="difflineminus">-  </span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+</span>
<a href="#l6.69"></a><span id="l6.69"> private: // warnings</span>
<a href="#l6.70"></a><span id="l6.70"> </span>
<a href="#l6.71"></a><span id="l6.71">   static void CellUsesUnderflowWarning(morkEnv* ev);</span>
<a href="#l6.72"></a><span id="l6.72"> </span>
<a href="#l6.73"></a><span id="l6.73"> public: // errors</span>
<a href="#l6.74"></a><span id="l6.74"> </span>
<a href="#l6.75"></a><span id="l6.75">   static void BadAtomKindError(morkEnv* ev);</span>
<a href="#l6.76"></a><span id="l6.76">   static void ZeroAidError(morkEnv* ev);</span>
<a href="#l6.77"></a><span id="l6.77" class="difflineat">@@ -99,17 +99,17 @@ private: // copying is not allowed</span>
<a href="#l6.78"></a><span id="l6.78"> /*| OidAtom: an atom that references a row or table by identity.</span>
<a href="#l6.79"></a><span id="l6.79"> |*/</span>
<a href="#l6.80"></a><span id="l6.80"> class morkOidAtom : public morkAtom { //</span>
<a href="#l6.81"></a><span id="l6.81"> </span>
<a href="#l6.82"></a><span id="l6.82">   // mork_u1       mAtom_Kind;      // identifies a specific atom subclass</span>
<a href="#l6.83"></a><span id="l6.83">   // mork_u1       mAtom_CellUses;  // number of persistent uses in a cell</span>
<a href="#l6.84"></a><span id="l6.84">   // mork_change   mAtom_Change;    // how has this atom been changed?</span>
<a href="#l6.85"></a><span id="l6.85">   // mork_u1       mAtom_Size;      // NOT USED IN &quot;BIG&quot; format atoms</span>
<a href="#l6.86"></a><span id="l6.86" class="difflineminus">- </span>
<a href="#l6.87"></a><span id="l6.87" class="difflineplus">+</span>
<a href="#l6.88"></a><span id="l6.88"> public:</span>
<a href="#l6.89"></a><span id="l6.89">   mdbOid           mOidAtom_Oid;       // identity of referenced object</span>
<a href="#l6.90"></a><span id="l6.90"> </span>
<a href="#l6.91"></a><span id="l6.91"> public: // empty construction does nothing</span>
<a href="#l6.92"></a><span id="l6.92">   morkOidAtom() { }</span>
<a href="#l6.93"></a><span id="l6.93">   void InitRowOidAtom(morkEnv* ev, const mdbOid&amp; inOid);</span>
<a href="#l6.94"></a><span id="l6.94">   void InitTableOidAtom(morkEnv* ev, const mdbOid&amp; inOid);</span>
<a href="#l6.95"></a><span id="l6.95"> </span>
<a href="#l6.96"></a><span id="l6.96" class="difflineat">@@ -134,24 +134,24 @@ private: // copying is not allowed</span>
<a href="#l6.97"></a><span id="l6.97"> **| applies to the larger format morkBigAnonAtom, which has more slots.</span>
<a href="#l6.98"></a><span id="l6.98"> |*/</span>
<a href="#l6.99"></a><span id="l6.99"> class morkWeeAnonAtom : public morkAtom { //</span>
<a href="#l6.100"></a><span id="l6.100"> </span>
<a href="#l6.101"></a><span id="l6.101">   // mork_u1       mAtom_Kind;      // identifies a specific atom subclass</span>
<a href="#l6.102"></a><span id="l6.102">   // mork_u1       mAtom_CellUses;  // number of persistent uses in a cell</span>
<a href="#l6.103"></a><span id="l6.103">   // mork_change   mAtom_Change;    // how has this atom been changed?</span>
<a href="#l6.104"></a><span id="l6.104">   // mork_u1       mAtom_Size;      // only for atoms smaller than 256 bytes</span>
<a href="#l6.105"></a><span id="l6.105" class="difflineminus">-  </span>
<a href="#l6.106"></a><span id="l6.106" class="difflineplus">+</span>
<a href="#l6.107"></a><span id="l6.107"> public:</span>
<a href="#l6.108"></a><span id="l6.108">   mork_u1 mWeeAnonAtom_Body[ 1 ]; // 1st byte of immediate content vector</span>
<a href="#l6.109"></a><span id="l6.109"> </span>
<a href="#l6.110"></a><span id="l6.110"> public: // empty construction does nothing</span>
<a href="#l6.111"></a><span id="l6.111">   morkWeeAnonAtom() { }</span>
<a href="#l6.112"></a><span id="l6.112">   void InitWeeAnonAtom(morkEnv* ev, const morkBuf&amp; inBuf);</span>
<a href="#l6.113"></a><span id="l6.113" class="difflineminus">-  </span>
<a href="#l6.114"></a><span id="l6.114" class="difflineplus">+</span>
<a href="#l6.115"></a><span id="l6.115">   // allow extra trailing byte for a null byte:</span>
<a href="#l6.116"></a><span id="l6.116">   static mork_size SizeForFill(mork_fill inFill)</span>
<a href="#l6.117"></a><span id="l6.117">   { return sizeof(morkWeeAnonAtom) + inFill; }</span>
<a href="#l6.118"></a><span id="l6.118"> </span>
<a href="#l6.119"></a><span id="l6.119"> private: // copying is not allowed</span>
<a href="#l6.120"></a><span id="l6.120">   morkWeeAnonAtom(const morkWeeAnonAtom&amp; other);</span>
<a href="#l6.121"></a><span id="l6.121">   morkWeeAnonAtom&amp; operator=(const morkWeeAnonAtom&amp; other);</span>
<a href="#l6.122"></a><span id="l6.122"> };</span>
<a href="#l6.123"></a><span id="l6.123" class="difflineat">@@ -164,26 +164,26 @@ private: // copying is not allowed</span>
<a href="#l6.124"></a><span id="l6.124"> **| for lookup needed for sharing like a book atom.</span>
<a href="#l6.125"></a><span id="l6.125"> |*/</span>
<a href="#l6.126"></a><span id="l6.126"> class morkBigAnonAtom : public morkAtom { //</span>
<a href="#l6.127"></a><span id="l6.127"> </span>
<a href="#l6.128"></a><span id="l6.128">   // mork_u1       mAtom_Kind;      // identifies a specific atom subclass</span>
<a href="#l6.129"></a><span id="l6.129">   // mork_u1       mAtom_CellUses;  // number of persistent uses in a cell</span>
<a href="#l6.130"></a><span id="l6.130">   // mork_change   mAtom_Change;    // how has this atom been changed?</span>
<a href="#l6.131"></a><span id="l6.131">   // mork_u1       mAtom_Size;      // NOT USED IN &quot;BIG&quot; format atoms</span>
<a href="#l6.132"></a><span id="l6.132" class="difflineminus">- </span>
<a href="#l6.133"></a><span id="l6.133" class="difflineplus">+</span>
<a href="#l6.134"></a><span id="l6.134"> public:</span>
<a href="#l6.135"></a><span id="l6.135">   mork_cscode   mBigAnonAtom_Form;      // charset format encoding</span>
<a href="#l6.136"></a><span id="l6.136">   mork_size     mBigAnonAtom_Size;      // size of content vector</span>
<a href="#l6.137"></a><span id="l6.137">   mork_u1       mBigAnonAtom_Body[ 1 ]; // 1st byte of immed content vector</span>
<a href="#l6.138"></a><span id="l6.138"> </span>
<a href="#l6.139"></a><span id="l6.139"> public: // empty construction does nothing</span>
<a href="#l6.140"></a><span id="l6.140">   morkBigAnonAtom() { }</span>
<a href="#l6.141"></a><span id="l6.141">   void InitBigAnonAtom(morkEnv* ev, const morkBuf&amp; inBuf, mork_cscode inForm);</span>
<a href="#l6.142"></a><span id="l6.142" class="difflineminus">-  </span>
<a href="#l6.143"></a><span id="l6.143" class="difflineplus">+</span>
<a href="#l6.144"></a><span id="l6.144">   // allow extra trailing byte for a null byte:</span>
<a href="#l6.145"></a><span id="l6.145">   static mork_size SizeForFill(mork_fill inFill)</span>
<a href="#l6.146"></a><span id="l6.146">   { return sizeof(morkBigAnonAtom) + inFill; }</span>
<a href="#l6.147"></a><span id="l6.147"> </span>
<a href="#l6.148"></a><span id="l6.148"> private: // copying is not allowed</span>
<a href="#l6.149"></a><span id="l6.149">   morkBigAnonAtom(const morkBigAnonAtom&amp; other);</span>
<a href="#l6.150"></a><span id="l6.150">   morkBigAnonAtom&amp; operator=(const morkBigAnonAtom&amp; other);</span>
<a href="#l6.151"></a><span id="l6.151"> };</span>
<a href="#l6.152"></a><span id="l6.152" class="difflineat">@@ -194,39 +194,39 @@ private: // copying is not allowed</span>
<a href="#l6.153"></a><span id="l6.153"> **| includes the atom ID and the pointer to the space referencing this atom</span>
<a href="#l6.154"></a><span id="l6.154"> **| through a hash table.</span>
<a href="#l6.155"></a><span id="l6.155"> |*/</span>
<a href="#l6.156"></a><span id="l6.156"> class morkBookAtom : public morkAtom { //</span>
<a href="#l6.157"></a><span id="l6.157">   // mork_u1       mAtom_Kind;      // identifies a specific atom subclass</span>
<a href="#l6.158"></a><span id="l6.158">   // mork_u1       mAtom_CellUses;  // number of persistent uses in a cell</span>
<a href="#l6.159"></a><span id="l6.159">   // mork_change   mAtom_Change;    // how has this atom been changed?</span>
<a href="#l6.160"></a><span id="l6.160">   // mork_u1       mAtom_Size;      // only for atoms smaller than 256 bytes</span>
<a href="#l6.161"></a><span id="l6.161" class="difflineminus">-  </span>
<a href="#l6.162"></a><span id="l6.162" class="difflineplus">+</span>
<a href="#l6.163"></a><span id="l6.163"> public:</span>
<a href="#l6.164"></a><span id="l6.164" class="difflineminus">-  morkAtomSpace* mBookAtom_Space; // mBookAtom_Space-&gt;SpaceScope() is atom scope </span>
<a href="#l6.165"></a><span id="l6.165" class="difflineplus">+  morkAtomSpace* mBookAtom_Space; // mBookAtom_Space-&gt;SpaceScope() is atom scope</span>
<a href="#l6.166"></a><span id="l6.166">   mork_aid       mBookAtom_Id;    // identity token for this shared atom</span>
<a href="#l6.167"></a><span id="l6.167"> </span>
<a href="#l6.168"></a><span id="l6.168"> public: // empty construction does nothing</span>
<a href="#l6.169"></a><span id="l6.169">   morkBookAtom() { }</span>
<a href="#l6.170"></a><span id="l6.170"> </span>
<a href="#l6.171"></a><span id="l6.171">   static void NonBookAtomTypeError(morkEnv* ev);</span>
<a href="#l6.172"></a><span id="l6.172"> </span>
<a href="#l6.173"></a><span id="l6.173"> public: // Hash() and Equal() for atom ID maps are same for all subclasses:</span>
<a href="#l6.174"></a><span id="l6.174"> </span>
<a href="#l6.175"></a><span id="l6.175">   mork_u4 HashAid() const { return mBookAtom_Id; }</span>
<a href="#l6.176"></a><span id="l6.176">   mork_bool EqualAid(const morkBookAtom* inAtom) const</span>
<a href="#l6.177"></a><span id="l6.177">   { return ( mBookAtom_Id == inAtom-&gt;mBookAtom_Id); }</span>
<a href="#l6.178"></a><span id="l6.178"> </span>
<a href="#l6.179"></a><span id="l6.179"> public: // Hash() and Equal() for atom body maps know about subclasses:</span>
<a href="#l6.180"></a><span id="l6.180" class="difflineminus">-  </span>
<a href="#l6.181"></a><span id="l6.181" class="difflineplus">+</span>
<a href="#l6.182"></a><span id="l6.182">   // YOU CANNOT SUBCLASS morkBookAtom WITHOUT FIXING Hash and Equal METHODS:</span>
<a href="#l6.183"></a><span id="l6.183"> </span>
<a href="#l6.184"></a><span id="l6.184">   mork_u4 HashFormAndBody(morkEnv* ev) const;</span>
<a href="#l6.185"></a><span id="l6.185">   mork_bool EqualFormAndBody(morkEnv* ev, const morkBookAtom* inAtom) const;</span>
<a href="#l6.186"></a><span id="l6.186" class="difflineminus">-  </span>
<a href="#l6.187"></a><span id="l6.187" class="difflineplus">+</span>
<a href="#l6.188"></a><span id="l6.188"> public: // separation from containing space</span>
<a href="#l6.189"></a><span id="l6.189"> </span>
<a href="#l6.190"></a><span id="l6.190">   void CutBookAtomFromSpace(morkEnv* ev);</span>
<a href="#l6.191"></a><span id="l6.191"> </span>
<a href="#l6.192"></a><span id="l6.192"> private: // copying is not allowed</span>
<a href="#l6.193"></a><span id="l6.193">   morkBookAtom(const morkBookAtom&amp; other);</span>
<a href="#l6.194"></a><span id="l6.194">   morkBookAtom&amp; operator=(const morkBookAtom&amp; other);</span>
<a href="#l6.195"></a><span id="l6.195"> };</span>
<a href="#l6.196"></a><span id="l6.196" class="difflineat">@@ -239,117 +239,117 @@ private: // copying is not allowed</span>
<a href="#l6.197"></a><span id="l6.197"> **| fix HashFormAndBody() and EqualFormAndBody() to use morkFarBookAtom</span>
<a href="#l6.198"></a><span id="l6.198"> **| correctly.</span>
<a href="#l6.199"></a><span id="l6.199"> **|</span>
<a href="#l6.200"></a><span id="l6.200"> **|| Note we do NOT intend that instances of morkFarBookAtom will ever</span>
<a href="#l6.201"></a><span id="l6.201"> **| be installed in hash tables, because this is not space efficient.</span>
<a href="#l6.202"></a><span id="l6.202"> **| We only expect to create temp instances for table lookups.</span>
<a href="#l6.203"></a><span id="l6.203"> |*/</span>
<a href="#l6.204"></a><span id="l6.204"> class morkFarBookAtom : public morkBookAtom { //</span>
<a href="#l6.205"></a><span id="l6.205" class="difflineminus">-  </span>
<a href="#l6.206"></a><span id="l6.206" class="difflineplus">+</span>
<a href="#l6.207"></a><span id="l6.207">   // mork_u1       mAtom_Kind;      // identifies a specific atom subclass</span>
<a href="#l6.208"></a><span id="l6.208">   // mork_u1       mAtom_CellUses;  // number of persistent uses in a cell</span>
<a href="#l6.209"></a><span id="l6.209">   // mork_change   mAtom_Change;    // how has this atom been changed?</span>
<a href="#l6.210"></a><span id="l6.210">   // mork_u1       mAtom_Size;      // NOT USED IN &quot;BIG&quot; format atoms</span>
<a href="#l6.211"></a><span id="l6.211"> </span>
<a href="#l6.212"></a><span id="l6.212" class="difflineminus">-  // morkAtomSpace* mBookAtom_Space; // mBookAtom_Space-&gt;SpaceScope() is scope </span>
<a href="#l6.213"></a><span id="l6.213" class="difflineplus">+  // morkAtomSpace* mBookAtom_Space; // mBookAtom_Space-&gt;SpaceScope() is scope</span>
<a href="#l6.214"></a><span id="l6.214">   // mork_aid       mBookAtom_Id;    // identity token for this shared atom</span>
<a href="#l6.215"></a><span id="l6.215" class="difflineminus">-  </span>
<a href="#l6.216"></a><span id="l6.216" class="difflineplus">+</span>
<a href="#l6.217"></a><span id="l6.217"> public:</span>
<a href="#l6.218"></a><span id="l6.218">   mork_cscode   mFarBookAtom_Form;      // charset format encoding</span>
<a href="#l6.219"></a><span id="l6.219">   mork_size     mFarBookAtom_Size;      // size of content vector</span>
<a href="#l6.220"></a><span id="l6.220">   mork_u1*      mFarBookAtom_Body;      // bytes are elsewere, out of line</span>
<a href="#l6.221"></a><span id="l6.221"> </span>
<a href="#l6.222"></a><span id="l6.222"> public: // empty construction does nothing</span>
<a href="#l6.223"></a><span id="l6.223">   morkFarBookAtom() { }</span>
<a href="#l6.224"></a><span id="l6.224">   void InitFarBookAtom(morkEnv* ev, const morkBuf&amp; inBuf,</span>
<a href="#l6.225"></a><span id="l6.225">     mork_cscode inForm, morkAtomSpace* ioSpace, mork_aid inAid);</span>
<a href="#l6.226"></a><span id="l6.226" class="difflineminus">-  </span>
<a href="#l6.227"></a><span id="l6.227" class="difflineplus">+</span>
<a href="#l6.228"></a><span id="l6.228"> private: // copying is not allowed</span>
<a href="#l6.229"></a><span id="l6.229">   morkFarBookAtom(const morkFarBookAtom&amp; other);</span>
<a href="#l6.230"></a><span id="l6.230">   morkFarBookAtom&amp; operator=(const morkFarBookAtom&amp; other);</span>
<a href="#l6.231"></a><span id="l6.231"> };</span>
<a href="#l6.232"></a><span id="l6.232"> </span>
<a href="#l6.233"></a><span id="l6.233"> /*| WeeBookAtom: .</span>
<a href="#l6.234"></a><span id="l6.234"> |*/</span>
<a href="#l6.235"></a><span id="l6.235"> class morkWeeBookAtom : public morkBookAtom { //</span>
<a href="#l6.236"></a><span id="l6.236">   // mork_u1       mAtom_Kind;      // identifies a specific atom subclass</span>
<a href="#l6.237"></a><span id="l6.237">   // mork_u1       mAtom_CellUses;  // number of persistent uses in a cell</span>
<a href="#l6.238"></a><span id="l6.238">   // mork_change   mAtom_Change;    // how has this atom been changed?</span>
<a href="#l6.239"></a><span id="l6.239">   // mork_u1       mAtom_Size;      // only for atoms smaller than 256 bytes</span>
<a href="#l6.240"></a><span id="l6.240"> </span>
<a href="#l6.241"></a><span id="l6.241" class="difflineminus">-  // morkAtomSpace* mBookAtom_Space; // mBookAtom_Space-&gt;SpaceScope() is scope </span>
<a href="#l6.242"></a><span id="l6.242" class="difflineplus">+  // morkAtomSpace* mBookAtom_Space; // mBookAtom_Space-&gt;SpaceScope() is scope</span>
<a href="#l6.243"></a><span id="l6.243">   // mork_aid       mBookAtom_Id;    // identity token for this shared atom</span>
<a href="#l6.244"></a><span id="l6.244" class="difflineminus">-  </span>
<a href="#l6.245"></a><span id="l6.245" class="difflineplus">+</span>
<a href="#l6.246"></a><span id="l6.246"> public:</span>
<a href="#l6.247"></a><span id="l6.247">   mork_u1     mWeeBookAtom_Body[ 1 ]; // 1st byte of immed content vector</span>
<a href="#l6.248"></a><span id="l6.248"> </span>
<a href="#l6.249"></a><span id="l6.249"> public: // empty construction does nothing</span>
<a href="#l6.250"></a><span id="l6.250">   morkWeeBookAtom() { }</span>
<a href="#l6.251"></a><span id="l6.251">   morkWeeBookAtom(mork_aid inAid);</span>
<a href="#l6.252"></a><span id="l6.252" class="difflineminus">-  </span>
<a href="#l6.253"></a><span id="l6.253" class="difflineplus">+</span>
<a href="#l6.254"></a><span id="l6.254">   void InitWeeBookAtom(morkEnv* ev, const morkBuf&amp; inBuf,</span>
<a href="#l6.255"></a><span id="l6.255">     morkAtomSpace* ioSpace, mork_aid inAid);</span>
<a href="#l6.256"></a><span id="l6.256" class="difflineminus">-  </span>
<a href="#l6.257"></a><span id="l6.257" class="difflineplus">+</span>
<a href="#l6.258"></a><span id="l6.258">   // allow extra trailing byte for a null byte:</span>
<a href="#l6.259"></a><span id="l6.259">   static mork_size SizeForFill(mork_fill inFill)</span>
<a href="#l6.260"></a><span id="l6.260">   { return sizeof(morkWeeBookAtom) + inFill; }</span>
<a href="#l6.261"></a><span id="l6.261"> </span>
<a href="#l6.262"></a><span id="l6.262"> private: // copying is not allowed</span>
<a href="#l6.263"></a><span id="l6.263">   morkWeeBookAtom(const morkWeeBookAtom&amp; other);</span>
<a href="#l6.264"></a><span id="l6.264">   morkWeeBookAtom&amp; operator=(const morkWeeBookAtom&amp; other);</span>
<a href="#l6.265"></a><span id="l6.265"> };</span>
<a href="#l6.266"></a><span id="l6.266"> </span>
<a href="#l6.267"></a><span id="l6.267"> /*| BigBookAtom: .</span>
<a href="#l6.268"></a><span id="l6.268"> |*/</span>
<a href="#l6.269"></a><span id="l6.269"> class morkBigBookAtom : public morkBookAtom { //</span>
<a href="#l6.270"></a><span id="l6.270" class="difflineminus">-  </span>
<a href="#l6.271"></a><span id="l6.271" class="difflineplus">+</span>
<a href="#l6.272"></a><span id="l6.272">   // mork_u1       mAtom_Kind;      // identifies a specific atom subclass</span>
<a href="#l6.273"></a><span id="l6.273">   // mork_u1       mAtom_CellUses;  // number of persistent uses in a cell</span>
<a href="#l6.274"></a><span id="l6.274">   // mork_change   mAtom_Change;    // how has this atom been changed?</span>
<a href="#l6.275"></a><span id="l6.275">   // mork_u1       mAtom_Size;      // NOT USED IN &quot;BIG&quot; format atoms</span>
<a href="#l6.276"></a><span id="l6.276"> </span>
<a href="#l6.277"></a><span id="l6.277" class="difflineminus">-  // morkAtomSpace* mBookAtom_Space; // mBookAtom_Space-&gt;SpaceScope() is scope </span>
<a href="#l6.278"></a><span id="l6.278" class="difflineplus">+  // morkAtomSpace* mBookAtom_Space; // mBookAtom_Space-&gt;SpaceScope() is scope</span>
<a href="#l6.279"></a><span id="l6.279">   // mork_aid       mBookAtom_Id;    // identity token for this shared atom</span>
<a href="#l6.280"></a><span id="l6.280" class="difflineminus">-  </span>
<a href="#l6.281"></a><span id="l6.281" class="difflineplus">+</span>
<a href="#l6.282"></a><span id="l6.282"> public:</span>
<a href="#l6.283"></a><span id="l6.283">   mork_cscode   mBigBookAtom_Form;      // charset format encoding</span>
<a href="#l6.284"></a><span id="l6.284">   mork_size     mBigBookAtom_Size;      // size of content vector</span>
<a href="#l6.285"></a><span id="l6.285">   mork_u1       mBigBookAtom_Body[ 1 ]; // 1st byte of immed content vector</span>
<a href="#l6.286"></a><span id="l6.286"> </span>
<a href="#l6.287"></a><span id="l6.287"> public: // empty construction does nothing</span>
<a href="#l6.288"></a><span id="l6.288">   morkBigBookAtom() { }</span>
<a href="#l6.289"></a><span id="l6.289">   void InitBigBookAtom(morkEnv* ev, const morkBuf&amp; inBuf,</span>
<a href="#l6.290"></a><span id="l6.290">     mork_cscode inForm, morkAtomSpace* ioSpace, mork_aid inAid);</span>
<a href="#l6.291"></a><span id="l6.291" class="difflineminus">-  </span>
<a href="#l6.292"></a><span id="l6.292" class="difflineplus">+</span>
<a href="#l6.293"></a><span id="l6.293">   // allow extra trailing byte for a null byte:</span>
<a href="#l6.294"></a><span id="l6.294">   static mork_size SizeForFill(mork_fill inFill)</span>
<a href="#l6.295"></a><span id="l6.295">   { return sizeof(morkBigBookAtom) + inFill; }</span>
<a href="#l6.296"></a><span id="l6.296"> </span>
<a href="#l6.297"></a><span id="l6.297"> private: // copying is not allowed</span>
<a href="#l6.298"></a><span id="l6.298">   morkBigBookAtom(const morkBigBookAtom&amp; other);</span>
<a href="#l6.299"></a><span id="l6.299">   morkBigBookAtom&amp; operator=(const morkBigBookAtom&amp; other);</span>
<a href="#l6.300"></a><span id="l6.300"> };</span>
<a href="#l6.301"></a><span id="l6.301"> </span>
<a href="#l6.302"></a><span id="l6.302"> /*| MaxBookAtom: .</span>
<a href="#l6.303"></a><span id="l6.303"> |*/</span>
<a href="#l6.304"></a><span id="l6.304"> class morkMaxBookAtom : public morkBigBookAtom { //</span>
<a href="#l6.305"></a><span id="l6.305" class="difflineminus">-  </span>
<a href="#l6.306"></a><span id="l6.306" class="difflineplus">+</span>
<a href="#l6.307"></a><span id="l6.307">   // mork_u1       mAtom_Kind;      // identifies a specific atom subclass</span>
<a href="#l6.308"></a><span id="l6.308">   // mork_u1       mAtom_CellUses;  // number of persistent uses in a cell</span>
<a href="#l6.309"></a><span id="l6.309">   // mork_change   mAtom_Change;    // how has this atom been changed?</span>
<a href="#l6.310"></a><span id="l6.310">   // mork_u1       mAtom_Size;      // NOT USED IN &quot;BIG&quot; format atoms</span>
<a href="#l6.311"></a><span id="l6.311"> </span>
<a href="#l6.312"></a><span id="l6.312" class="difflineminus">-  // morkAtomSpace* mBookAtom_Space; // mBookAtom_Space-&gt;SpaceScope() is scope </span>
<a href="#l6.313"></a><span id="l6.313" class="difflineplus">+  // morkAtomSpace* mBookAtom_Space; // mBookAtom_Space-&gt;SpaceScope() is scope</span>
<a href="#l6.314"></a><span id="l6.314">   // mork_aid       mBookAtom_Id;    // identity token for this shared atom</span>
<a href="#l6.315"></a><span id="l6.315"> </span>
<a href="#l6.316"></a><span id="l6.316">   // mork_cscode   mBigBookAtom_Form;      // charset format encoding</span>
<a href="#l6.317"></a><span id="l6.317">   // mork_size     mBigBookAtom_Size;      // size of content vector</span>
<a href="#l6.318"></a><span id="l6.318">   // mork_u1       mBigBookAtom_Body[ 1 ]; // 1st byte of immed content vector</span>
<a href="#l6.319"></a><span id="l6.319" class="difflineminus">-  </span>
<a href="#l6.320"></a><span id="l6.320" class="difflineplus">+</span>
<a href="#l6.321"></a><span id="l6.321"> public:</span>
<a href="#l6.322"></a><span id="l6.322">   mork_u1 mMaxBookAtom_Body[ morkBookAtom_kMaxBodySize + 3 ]; // max bytes</span>
<a href="#l6.323"></a><span id="l6.323"> </span>
<a href="#l6.324"></a><span id="l6.324"> public: // empty construction does nothing</span>
<a href="#l6.325"></a><span id="l6.325">   morkMaxBookAtom() { }</span>
<a href="#l6.326"></a><span id="l6.326">   void InitMaxBookAtom(morkEnv* ev, const morkBuf&amp; inBuf,</span>
<a href="#l6.327"></a><span id="l6.327">     mork_cscode inForm, morkAtomSpace* ioSpace, mork_aid inAid)</span>
<a href="#l6.328"></a><span id="l6.328">   { this-&gt;InitBigBookAtom(ev, inBuf, inForm, ioSpace, inAid); }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/db/mork/src/morkAtomMap.cpp</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/db/mork/src/morkAtomMap.cpp</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -36,17 +36,17 @@</span>
<a href="#l7.4"></a><span id="l7.4"> #endif</span>
<a href="#l7.5"></a><span id="l7.5"> </span>
<a href="#l7.6"></a><span id="l7.6"> #ifndef _MORKROW_</span>
<a href="#l7.7"></a><span id="l7.7"> #include &quot;morkRow.h&quot;</span>
<a href="#l7.8"></a><span id="l7.8"> #endif</span>
<a href="#l7.9"></a><span id="l7.9"> </span>
<a href="#l7.10"></a><span id="l7.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l7.11"></a><span id="l7.11"> </span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l7.13"></a><span id="l7.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l7.14"></a><span id="l7.14"> // { ===== begin morkNode interface =====</span>
<a href="#l7.15"></a><span id="l7.15"> </span>
<a href="#l7.16"></a><span id="l7.16"> /*public virtual*/ void</span>
<a href="#l7.17"></a><span id="l7.17"> morkAtomAidMap::CloseMorkNode(morkEnv* ev) // CloseAtomAidMap() only if open</span>
<a href="#l7.18"></a><span id="l7.18"> {</span>
<a href="#l7.19"></a><span id="l7.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l7.20"></a><span id="l7.20">   {</span>
<a href="#l7.21"></a><span id="l7.21">     this-&gt;MarkClosing();</span>
<a href="#l7.22"></a><span id="l7.22" class="difflineat">@@ -63,17 +63,17 @@ morkAtomAidMap::~morkAtomAidMap() // ass</span>
<a href="#l7.23"></a><span id="l7.23"> </span>
<a href="#l7.24"></a><span id="l7.24"> </span>
<a href="#l7.25"></a><span id="l7.25"> /*public non-poly*/</span>
<a href="#l7.26"></a><span id="l7.26"> morkAtomAidMap::morkAtomAidMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l7.27"></a><span id="l7.27">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap)</span>
<a href="#l7.28"></a><span id="l7.28"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.29"></a><span id="l7.29"> : morkProbeMap(ev, inUsage,  ioHeap,</span>
<a href="#l7.30"></a><span id="l7.30">   /*inKeySize*/ sizeof(morkBookAtom*), /*inValSize*/ 0,</span>
<a href="#l7.31"></a><span id="l7.31" class="difflineminus">-  ioSlotHeap, morkAtomAidMap_kStartSlotCount, </span>
<a href="#l7.32"></a><span id="l7.32" class="difflineplus">+  ioSlotHeap, morkAtomAidMap_kStartSlotCount,</span>
<a href="#l7.33"></a><span id="l7.33">   /*inZeroIsClearKey*/ morkBool_kTrue)</span>
<a href="#l7.34"></a><span id="l7.34"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.35"></a><span id="l7.35"> : morkMap(ev, inUsage,  ioHeap,</span>
<a href="#l7.36"></a><span id="l7.36">   /*inKeySize*/ sizeof(morkBookAtom*), /*inValSize*/ 0,</span>
<a href="#l7.37"></a><span id="l7.37">   morkAtomAidMap_kStartSlotCount, ioSlotHeap,</span>
<a href="#l7.38"></a><span id="l7.38">   /*inHoldChanges*/ morkBool_kFalse)</span>
<a href="#l7.39"></a><span id="l7.39"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.40"></a><span id="l7.40"> {</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineat">@@ -93,17 +93,17 @@ morkAtomAidMap::CloseAtomAidMap(morkEnv*</span>
<a href="#l7.42"></a><span id="l7.42"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.43"></a><span id="l7.43">       this-&gt;MarkShut();</span>
<a href="#l7.44"></a><span id="l7.44">     }</span>
<a href="#l7.45"></a><span id="l7.45">     else</span>
<a href="#l7.46"></a><span id="l7.46">       this-&gt;NonNodeError(ev);</span>
<a href="#l7.47"></a><span id="l7.47"> }</span>
<a href="#l7.48"></a><span id="l7.48"> </span>
<a href="#l7.49"></a><span id="l7.49"> // } ===== end morkNode methods =====</span>
<a href="#l7.50"></a><span id="l7.50" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l7.51"></a><span id="l7.51" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l7.52"></a><span id="l7.52"> </span>
<a href="#l7.53"></a><span id="l7.53"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.54"></a><span id="l7.54"> </span>
<a href="#l7.55"></a><span id="l7.55">   /*virtual*/ mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l7.56"></a><span id="l7.56">   morkAtomAidMap::MapTest(morkEnv* ev, const void* inMapKey,</span>
<a href="#l7.57"></a><span id="l7.57">     const void* inAppKey) const</span>
<a href="#l7.58"></a><span id="l7.58">   {</span>
<a href="#l7.59"></a><span id="l7.59">     MORK_USED_1(ev);</span>
<a href="#l7.60"></a><span id="l7.60" class="difflineat">@@ -125,118 +125,118 @@ morkAtomAidMap::CloseAtomAidMap(morkEnv*</span>
<a href="#l7.61"></a><span id="l7.61">       return key-&gt;HashAid();</span>
<a href="#l7.62"></a><span id="l7.62">     else</span>
<a href="#l7.63"></a><span id="l7.63">     {</span>
<a href="#l7.64"></a><span id="l7.64">       ev-&gt;NilPointerWarning();</span>
<a href="#l7.65"></a><span id="l7.65">       return 0;</span>
<a href="#l7.66"></a><span id="l7.66">     }</span>
<a href="#l7.67"></a><span id="l7.67">   }</span>
<a href="#l7.68"></a><span id="l7.68"> </span>
<a href="#l7.69"></a><span id="l7.69" class="difflineminus">-  /*virtual*/ mork_u4 </span>
<a href="#l7.70"></a><span id="l7.70" class="difflineplus">+  /*virtual*/ mork_u4</span>
<a href="#l7.71"></a><span id="l7.71">   morkAtomAidMap::ProbeMapHashMapKey(morkEnv* ev,</span>
<a href="#l7.72"></a><span id="l7.72">     const void* inMapKey) const</span>
<a href="#l7.73"></a><span id="l7.73">   {</span>
<a href="#l7.74"></a><span id="l7.74">     const morkBookAtom* key = *(const morkBookAtom**) inMapKey;</span>
<a href="#l7.75"></a><span id="l7.75">     if ( key )</span>
<a href="#l7.76"></a><span id="l7.76">       return key-&gt;HashAid();</span>
<a href="#l7.77"></a><span id="l7.77">     else</span>
<a href="#l7.78"></a><span id="l7.78">     {</span>
<a href="#l7.79"></a><span id="l7.79">       ev-&gt;NilPointerWarning();</span>
<a href="#l7.80"></a><span id="l7.80">       return 0;</span>
<a href="#l7.81"></a><span id="l7.81">     }</span>
<a href="#l7.82"></a><span id="l7.82">   }</span>
<a href="#l7.83"></a><span id="l7.83"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.84"></a><span id="l7.84">   // { ===== begin morkMap poly interface =====</span>
<a href="#l7.85"></a><span id="l7.85" class="difflineminus">-  /*virtual*/ mork_bool // </span>
<a href="#l7.86"></a><span id="l7.86" class="difflineplus">+  /*virtual*/ mork_bool //</span>
<a href="#l7.87"></a><span id="l7.87">   morkAtomAidMap::Equal(morkEnv* ev, const void* inKeyA,</span>
<a href="#l7.88"></a><span id="l7.88">     const void* inKeyB) const</span>
<a href="#l7.89"></a><span id="l7.89">   {</span>
<a href="#l7.90"></a><span id="l7.90">     MORK_USED_1(ev);</span>
<a href="#l7.91"></a><span id="l7.91">     return (*(const morkBookAtom**) inKeyA)-&gt;EqualAid(</span>
<a href="#l7.92"></a><span id="l7.92">       *(const morkBookAtom**) inKeyB);</span>
<a href="#l7.93"></a><span id="l7.93">   }</span>
<a href="#l7.94"></a><span id="l7.94"> </span>
<a href="#l7.95"></a><span id="l7.95" class="difflineminus">-  /*virtual*/ mork_u4 // </span>
<a href="#l7.96"></a><span id="l7.96" class="difflineplus">+  /*virtual*/ mork_u4 //</span>
<a href="#l7.97"></a><span id="l7.97">   morkAtomAidMap::Hash(morkEnv* ev, const void* inKey) const</span>
<a href="#l7.98"></a><span id="l7.98">   {</span>
<a href="#l7.99"></a><span id="l7.99">     MORK_USED_1(ev);</span>
<a href="#l7.100"></a><span id="l7.100">     return (*(const morkBookAtom**) inKey)-&gt;HashAid();</span>
<a href="#l7.101"></a><span id="l7.101">   }</span>
<a href="#l7.102"></a><span id="l7.102">   // } ===== end morkMap poly interface =====</span>
<a href="#l7.103"></a><span id="l7.103"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.104"></a><span id="l7.104"> </span>
<a href="#l7.105"></a><span id="l7.105"> </span>
<a href="#l7.106"></a><span id="l7.106"> mork_bool</span>
<a href="#l7.107"></a><span id="l7.107"> morkAtomAidMap::AddAtom(morkEnv* ev, morkBookAtom* ioAtom)</span>
<a href="#l7.108"></a><span id="l7.108"> {</span>
<a href="#l7.109"></a><span id="l7.109">   if ( ev-&gt;Good() )</span>
<a href="#l7.110"></a><span id="l7.110">   {</span>
<a href="#l7.111"></a><span id="l7.111"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.112"></a><span id="l7.112" class="difflineminus">-    this-&gt;MapAtPut(ev, &amp;ioAtom, /*val*/ (void*) 0, </span>
<a href="#l7.113"></a><span id="l7.113" class="difflineplus">+    this-&gt;MapAtPut(ev, &amp;ioAtom, /*val*/ (void*) 0,</span>
<a href="#l7.114"></a><span id="l7.114">       /*key*/ (void*) 0, /*val*/ (void*) 0);</span>
<a href="#l7.115"></a><span id="l7.115"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.116"></a><span id="l7.116" class="difflineminus">-    this-&gt;Put(ev, &amp;ioAtom, /*val*/ (void*) 0, </span>
<a href="#l7.117"></a><span id="l7.117" class="difflineplus">+    this-&gt;Put(ev, &amp;ioAtom, /*val*/ (void*) 0,</span>
<a href="#l7.118"></a><span id="l7.118">       /*key*/ (void*) 0, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l7.119"></a><span id="l7.119"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.120"></a><span id="l7.120">   }</span>
<a href="#l7.121"></a><span id="l7.121">   return ev-&gt;Good();</span>
<a href="#l7.122"></a><span id="l7.122"> }</span>
<a href="#l7.123"></a><span id="l7.123"> </span>
<a href="#l7.124"></a><span id="l7.124"> morkBookAtom*</span>
<a href="#l7.125"></a><span id="l7.125"> morkAtomAidMap::CutAtom(morkEnv* ev, const morkBookAtom* inAtom)</span>
<a href="#l7.126"></a><span id="l7.126"> {</span>
<a href="#l7.127"></a><span id="l7.127">   morkBookAtom* oldKey = 0;</span>
<a href="#l7.128"></a><span id="l7.128" class="difflineminus">-  </span>
<a href="#l7.129"></a><span id="l7.129" class="difflineplus">+</span>
<a href="#l7.130"></a><span id="l7.130"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.131"></a><span id="l7.131">   MORK_USED_1(inAtom);</span>
<a href="#l7.132"></a><span id="l7.132">   morkProbeMap::ProbeMapCutError(ev);</span>
<a href="#l7.133"></a><span id="l7.133"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.134"></a><span id="l7.134">   this-&gt;Cut(ev, &amp;inAtom, &amp;oldKey, /*val*/ (void*) 0,</span>
<a href="#l7.135"></a><span id="l7.135">     (mork_change**) 0);</span>
<a href="#l7.136"></a><span id="l7.136"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.137"></a><span id="l7.137" class="difflineminus">-    </span>
<a href="#l7.138"></a><span id="l7.138" class="difflineplus">+</span>
<a href="#l7.139"></a><span id="l7.139">   return oldKey;</span>
<a href="#l7.140"></a><span id="l7.140"> }</span>
<a href="#l7.141"></a><span id="l7.141"> </span>
<a href="#l7.142"></a><span id="l7.142"> morkBookAtom*</span>
<a href="#l7.143"></a><span id="l7.143"> morkAtomAidMap::GetAtom(morkEnv* ev, const morkBookAtom* inAtom)</span>
<a href="#l7.144"></a><span id="l7.144"> {</span>
<a href="#l7.145"></a><span id="l7.145">   morkBookAtom* key = 0; // old val in the map</span>
<a href="#l7.146"></a><span id="l7.146"> </span>
<a href="#l7.147"></a><span id="l7.147"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.148"></a><span id="l7.148">   this-&gt;MapAt(ev, &amp;inAtom, &amp;key, /*val*/ (void*) 0);</span>
<a href="#l7.149"></a><span id="l7.149"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.150"></a><span id="l7.150">   this-&gt;Get(ev, &amp;inAtom, &amp;key, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l7.151"></a><span id="l7.151"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.152"></a><span id="l7.152" class="difflineminus">-  </span>
<a href="#l7.153"></a><span id="l7.153" class="difflineplus">+</span>
<a href="#l7.154"></a><span id="l7.154">   return key;</span>
<a href="#l7.155"></a><span id="l7.155"> }</span>
<a href="#l7.156"></a><span id="l7.156"> </span>
<a href="#l7.157"></a><span id="l7.157"> morkBookAtom*</span>
<a href="#l7.158"></a><span id="l7.158"> morkAtomAidMap::GetAid(morkEnv* ev, mork_aid inAid)</span>
<a href="#l7.159"></a><span id="l7.159"> {</span>
<a href="#l7.160"></a><span id="l7.160">   morkWeeBookAtom weeAtom(inAid);</span>
<a href="#l7.161"></a><span id="l7.161">   morkBookAtom* key = &amp;weeAtom; // we need a pointer</span>
<a href="#l7.162"></a><span id="l7.162">   morkBookAtom* oldKey = 0; // old key in the map</span>
<a href="#l7.163"></a><span id="l7.163"> </span>
<a href="#l7.164"></a><span id="l7.164"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.165"></a><span id="l7.165">   this-&gt;MapAt(ev, &amp;key, &amp;oldKey, /*val*/ (void*) 0);</span>
<a href="#l7.166"></a><span id="l7.166"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.167"></a><span id="l7.167">   this-&gt;Get(ev, &amp;key, &amp;oldKey, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l7.168"></a><span id="l7.168"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.169"></a><span id="l7.169" class="difflineminus">-  </span>
<a href="#l7.170"></a><span id="l7.170" class="difflineplus">+</span>
<a href="#l7.171"></a><span id="l7.171">   return oldKey;</span>
<a href="#l7.172"></a><span id="l7.172"> }</span>
<a href="#l7.173"></a><span id="l7.173"> </span>
<a href="#l7.174"></a><span id="l7.174"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l7.175"></a><span id="l7.175"> </span>
<a href="#l7.176"></a><span id="l7.176"> </span>
<a href="#l7.177"></a><span id="l7.177"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l7.178"></a><span id="l7.178"> </span>
<a href="#l7.179"></a><span id="l7.179" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l7.180"></a><span id="l7.180" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l7.181"></a><span id="l7.181"> // { ===== begin morkNode interface =====</span>
<a href="#l7.182"></a><span id="l7.182"> </span>
<a href="#l7.183"></a><span id="l7.183"> /*public virtual*/ void</span>
<a href="#l7.184"></a><span id="l7.184"> morkAtomBodyMap::CloseMorkNode(morkEnv* ev) // CloseAtomBodyMap() only if open</span>
<a href="#l7.185"></a><span id="l7.185"> {</span>
<a href="#l7.186"></a><span id="l7.186">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l7.187"></a><span id="l7.187">   {</span>
<a href="#l7.188"></a><span id="l7.188">     this-&gt;MarkClosing();</span>
<a href="#l7.189"></a><span id="l7.189" class="difflineat">@@ -253,17 +253,17 @@ morkAtomBodyMap::~morkAtomBodyMap() // a</span>
<a href="#l7.190"></a><span id="l7.190"> </span>
<a href="#l7.191"></a><span id="l7.191"> </span>
<a href="#l7.192"></a><span id="l7.192"> /*public non-poly*/</span>
<a href="#l7.193"></a><span id="l7.193"> morkAtomBodyMap::morkAtomBodyMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l7.194"></a><span id="l7.194">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap)</span>
<a href="#l7.195"></a><span id="l7.195"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.196"></a><span id="l7.196"> : morkProbeMap(ev, inUsage,  ioHeap,</span>
<a href="#l7.197"></a><span id="l7.197">   /*inKeySize*/ sizeof(morkBookAtom*), /*inValSize*/ 0,</span>
<a href="#l7.198"></a><span id="l7.198" class="difflineminus">-  ioSlotHeap, morkAtomBodyMap_kStartSlotCount, </span>
<a href="#l7.199"></a><span id="l7.199" class="difflineplus">+  ioSlotHeap, morkAtomBodyMap_kStartSlotCount,</span>
<a href="#l7.200"></a><span id="l7.200">   /*inZeroIsClearKey*/ morkBool_kTrue)</span>
<a href="#l7.201"></a><span id="l7.201"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.202"></a><span id="l7.202"> : morkMap(ev, inUsage,  ioHeap,</span>
<a href="#l7.203"></a><span id="l7.203">   /*inKeySize*/ sizeof(morkBookAtom*), /*inValSize*/ 0,</span>
<a href="#l7.204"></a><span id="l7.204">   morkAtomBodyMap_kStartSlotCount, ioSlotHeap,</span>
<a href="#l7.205"></a><span id="l7.205">   /*inHoldChanges*/ morkBool_kFalse)</span>
<a href="#l7.206"></a><span id="l7.206"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.207"></a><span id="l7.207"> {</span>
<a href="#l7.208"></a><span id="l7.208" class="difflineat">@@ -283,17 +283,17 @@ morkAtomBodyMap::CloseAtomBodyMap(morkEn</span>
<a href="#l7.209"></a><span id="l7.209"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.210"></a><span id="l7.210">       this-&gt;MarkShut();</span>
<a href="#l7.211"></a><span id="l7.211">     }</span>
<a href="#l7.212"></a><span id="l7.212">     else</span>
<a href="#l7.213"></a><span id="l7.213">       this-&gt;NonNodeError(ev);</span>
<a href="#l7.214"></a><span id="l7.214"> }</span>
<a href="#l7.215"></a><span id="l7.215"> </span>
<a href="#l7.216"></a><span id="l7.216"> // } ===== end morkNode methods =====</span>
<a href="#l7.217"></a><span id="l7.217" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l7.218"></a><span id="l7.218" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l7.219"></a><span id="l7.219"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.220"></a><span id="l7.220"> </span>
<a href="#l7.221"></a><span id="l7.221">   /*virtual*/ mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l7.222"></a><span id="l7.222">   morkAtomBodyMap::MapTest(morkEnv* ev, const void* inMapKey,</span>
<a href="#l7.223"></a><span id="l7.223">     const void* inAppKey) const</span>
<a href="#l7.224"></a><span id="l7.224">   {</span>
<a href="#l7.225"></a><span id="l7.225">     const morkBookAtom* key = *(const morkBookAtom**) inMapKey;</span>
<a href="#l7.226"></a><span id="l7.226">     if ( key )</span>
<a href="#l7.227"></a><span id="l7.227" class="difflineat">@@ -310,54 +310,54 @@ morkAtomBodyMap::CloseAtomBodyMap(morkEn</span>
<a href="#l7.228"></a><span id="l7.228">   {</span>
<a href="#l7.229"></a><span id="l7.229">     const morkBookAtom* key = *(const morkBookAtom**) inAppKey;</span>
<a href="#l7.230"></a><span id="l7.230">     if ( key )</span>
<a href="#l7.231"></a><span id="l7.231">       return key-&gt;HashFormAndBody(ev);</span>
<a href="#l7.232"></a><span id="l7.232">     else</span>
<a href="#l7.233"></a><span id="l7.233">       return 0;</span>
<a href="#l7.234"></a><span id="l7.234">   }</span>
<a href="#l7.235"></a><span id="l7.235"> </span>
<a href="#l7.236"></a><span id="l7.236" class="difflineminus">-  /*virtual*/ mork_u4 </span>
<a href="#l7.237"></a><span id="l7.237" class="difflineplus">+  /*virtual*/ mork_u4</span>
<a href="#l7.238"></a><span id="l7.238">   morkAtomBodyMap::ProbeMapHashMapKey(morkEnv* ev, const void* inMapKey) const</span>
<a href="#l7.239"></a><span id="l7.239">   {</span>
<a href="#l7.240"></a><span id="l7.240">     const morkBookAtom* key = *(const morkBookAtom**) inMapKey;</span>
<a href="#l7.241"></a><span id="l7.241">     if ( key )</span>
<a href="#l7.242"></a><span id="l7.242">       return key-&gt;HashFormAndBody(ev);</span>
<a href="#l7.243"></a><span id="l7.243">     else</span>
<a href="#l7.244"></a><span id="l7.244">       return 0;</span>
<a href="#l7.245"></a><span id="l7.245">   }</span>
<a href="#l7.246"></a><span id="l7.246"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.247"></a><span id="l7.247">   // { ===== begin morkMap poly interface =====</span>
<a href="#l7.248"></a><span id="l7.248" class="difflineminus">-  /*virtual*/ mork_bool // </span>
<a href="#l7.249"></a><span id="l7.249" class="difflineplus">+  /*virtual*/ mork_bool //</span>
<a href="#l7.250"></a><span id="l7.250">   morkAtomBodyMap::Equal(morkEnv* ev, const void* inKeyA,</span>
<a href="#l7.251"></a><span id="l7.251">     const void* inKeyB) const</span>
<a href="#l7.252"></a><span id="l7.252">   {</span>
<a href="#l7.253"></a><span id="l7.253">     return (*(const morkBookAtom**) inKeyA)-&gt;EqualFormAndBody(ev,</span>
<a href="#l7.254"></a><span id="l7.254">       *(const morkBookAtom**) inKeyB);</span>
<a href="#l7.255"></a><span id="l7.255">   }</span>
<a href="#l7.256"></a><span id="l7.256"> </span>
<a href="#l7.257"></a><span id="l7.257" class="difflineminus">-  /*virtual*/ mork_u4 // </span>
<a href="#l7.258"></a><span id="l7.258" class="difflineplus">+  /*virtual*/ mork_u4 //</span>
<a href="#l7.259"></a><span id="l7.259">   morkAtomBodyMap::Hash(morkEnv* ev, const void* inKey) const</span>
<a href="#l7.260"></a><span id="l7.260">   {</span>
<a href="#l7.261"></a><span id="l7.261">     return (*(const morkBookAtom**) inKey)-&gt;HashFormAndBody(ev);</span>
<a href="#l7.262"></a><span id="l7.262">   }</span>
<a href="#l7.263"></a><span id="l7.263">   // } ===== end morkMap poly interface =====</span>
<a href="#l7.264"></a><span id="l7.264"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.265"></a><span id="l7.265"> </span>
<a href="#l7.266"></a><span id="l7.266"> </span>
<a href="#l7.267"></a><span id="l7.267"> mork_bool</span>
<a href="#l7.268"></a><span id="l7.268"> morkAtomBodyMap::AddAtom(morkEnv* ev, morkBookAtom* ioAtom)</span>
<a href="#l7.269"></a><span id="l7.269"> {</span>
<a href="#l7.270"></a><span id="l7.270">   if ( ev-&gt;Good() )</span>
<a href="#l7.271"></a><span id="l7.271">   {</span>
<a href="#l7.272"></a><span id="l7.272"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.273"></a><span id="l7.273" class="difflineminus">-    this-&gt;MapAtPut(ev, &amp;ioAtom, /*val*/ (void*) 0, </span>
<a href="#l7.274"></a><span id="l7.274" class="difflineplus">+    this-&gt;MapAtPut(ev, &amp;ioAtom, /*val*/ (void*) 0,</span>
<a href="#l7.275"></a><span id="l7.275">       /*key*/ (void*) 0, /*val*/ (void*) 0);</span>
<a href="#l7.276"></a><span id="l7.276"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.277"></a><span id="l7.277" class="difflineminus">-    this-&gt;Put(ev, &amp;ioAtom, /*val*/ (void*) 0, </span>
<a href="#l7.278"></a><span id="l7.278" class="difflineplus">+    this-&gt;Put(ev, &amp;ioAtom, /*val*/ (void*) 0,</span>
<a href="#l7.279"></a><span id="l7.279">       /*key*/ (void*) 0, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l7.280"></a><span id="l7.280"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.281"></a><span id="l7.281">   }</span>
<a href="#l7.282"></a><span id="l7.282">   return ev-&gt;Good();</span>
<a href="#l7.283"></a><span id="l7.283"> }</span>
<a href="#l7.284"></a><span id="l7.284"> </span>
<a href="#l7.285"></a><span id="l7.285"> morkBookAtom*</span>
<a href="#l7.286"></a><span id="l7.286"> morkAtomBodyMap::CutAtom(morkEnv* ev, const morkBookAtom* inAtom)</span>
<a href="#l7.287"></a><span id="l7.287" class="difflineat">@@ -366,30 +366,30 @@ morkAtomBodyMap::CutAtom(morkEnv* ev, co</span>
<a href="#l7.288"></a><span id="l7.288"> </span>
<a href="#l7.289"></a><span id="l7.289"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.290"></a><span id="l7.290">   MORK_USED_1(inAtom);</span>
<a href="#l7.291"></a><span id="l7.291">   morkProbeMap::ProbeMapCutError(ev);</span>
<a href="#l7.292"></a><span id="l7.292"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.293"></a><span id="l7.293">   this-&gt;Cut(ev, &amp;inAtom, &amp;oldKey, /*val*/ (void*) 0,</span>
<a href="#l7.294"></a><span id="l7.294">     (mork_change**) 0);</span>
<a href="#l7.295"></a><span id="l7.295"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.296"></a><span id="l7.296" class="difflineminus">-    </span>
<a href="#l7.297"></a><span id="l7.297" class="difflineplus">+</span>
<a href="#l7.298"></a><span id="l7.298">   return oldKey;</span>
<a href="#l7.299"></a><span id="l7.299"> }</span>
<a href="#l7.300"></a><span id="l7.300"> </span>
<a href="#l7.301"></a><span id="l7.301"> morkBookAtom*</span>
<a href="#l7.302"></a><span id="l7.302"> morkAtomBodyMap::GetAtom(morkEnv* ev, const morkBookAtom* inAtom)</span>
<a href="#l7.303"></a><span id="l7.303"> {</span>
<a href="#l7.304"></a><span id="l7.304">   morkBookAtom* key = 0; // old val in the map</span>
<a href="#l7.305"></a><span id="l7.305"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l7.306"></a><span id="l7.306">   this-&gt;MapAt(ev, &amp;inAtom, &amp;key, /*val*/ (void*) 0);</span>
<a href="#l7.307"></a><span id="l7.307"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.308"></a><span id="l7.308">   this-&gt;Get(ev, &amp;inAtom, &amp;key, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l7.309"></a><span id="l7.309"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l7.310"></a><span id="l7.310" class="difflineminus">-  </span>
<a href="#l7.311"></a><span id="l7.311" class="difflineplus">+</span>
<a href="#l7.312"></a><span id="l7.312">   return key;</span>
<a href="#l7.313"></a><span id="l7.313"> }</span>
<a href="#l7.314"></a><span id="l7.314"> </span>
<a href="#l7.315"></a><span id="l7.315"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l7.316"></a><span id="l7.316"> </span>
<a href="#l7.317"></a><span id="l7.317"> morkAtomRowMap::~morkAtomRowMap()</span>
<a href="#l7.318"></a><span id="l7.318"> {</span>
<a href="#l7.319"></a><span id="l7.319"> }</span>
<a href="#l7.320"></a><span id="l7.320" class="difflineat">@@ -404,24 +404,24 @@ morkAtomRowMap::morkAtomRowMap(morkEnv* </span>
<a href="#l7.321"></a><span id="l7.321">     /*inHoldChanges*/ morkBool_kFalse)</span>
<a href="#l7.322"></a><span id="l7.322"> , mAtomRowMap_IndexColumn( inIndexColumn )</span>
<a href="#l7.323"></a><span id="l7.323"> {</span>
<a href="#l7.324"></a><span id="l7.324">   if ( ev-&gt;Good() )</span>
<a href="#l7.325"></a><span id="l7.325">     mNode_Derived = morkDerived_kAtomRowMap;</span>
<a href="#l7.326"></a><span id="l7.326"> }</span>
<a href="#l7.327"></a><span id="l7.327"> </span>
<a href="#l7.328"></a><span id="l7.328"> void morkAtomRowMap::AddRow(morkEnv* ev, morkRow* ioRow)</span>
<a href="#l7.329"></a><span id="l7.329" class="difflineminus">-// add ioRow only if it contains a cell in mAtomRowMap_IndexColumn. </span>
<a href="#l7.330"></a><span id="l7.330" class="difflineplus">+// add ioRow only if it contains a cell in mAtomRowMap_IndexColumn.</span>
<a href="#l7.331"></a><span id="l7.331"> {</span>
<a href="#l7.332"></a><span id="l7.332">   mork_aid aid = ioRow-&gt;GetCellAtomAid(ev, mAtomRowMap_IndexColumn);</span>
<a href="#l7.333"></a><span id="l7.333">   if ( aid )</span>
<a href="#l7.334"></a><span id="l7.334">     this-&gt;AddAid(ev, aid, ioRow);</span>
<a href="#l7.335"></a><span id="l7.335"> }</span>
<a href="#l7.336"></a><span id="l7.336"> </span>
<a href="#l7.337"></a><span id="l7.337"> void morkAtomRowMap::CutRow(morkEnv* ev, morkRow* ioRow)</span>
<a href="#l7.338"></a><span id="l7.338" class="difflineminus">-// cut ioRow only if it contains a cell in mAtomRowMap_IndexColumn. </span>
<a href="#l7.339"></a><span id="l7.339" class="difflineplus">+// cut ioRow only if it contains a cell in mAtomRowMap_IndexColumn.</span>
<a href="#l7.340"></a><span id="l7.340"> {</span>
<a href="#l7.341"></a><span id="l7.341">   mork_aid aid = ioRow-&gt;GetCellAtomAid(ev, mAtomRowMap_IndexColumn);</span>
<a href="#l7.342"></a><span id="l7.342">   if ( aid )</span>
<a href="#l7.343"></a><span id="l7.343">     this-&gt;CutAid(ev, aid);</span>
<a href="#l7.344"></a><span id="l7.344"> }</span>
<a href="#l7.345"></a><span id="l7.345"> </span>
<a href="#l7.346"></a><span id="l7.346"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/db/mork/src/morkAtomMap.h</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/db/mork/src/morkAtomMap.h</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -39,17 +39,17 @@ class morkAtomAidMap : public morkProbeM</span>
<a href="#l8.4"></a><span id="l8.4"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.5"></a><span id="l8.5"> class morkAtomAidMap : public morkMap { // for mapping tokens to maps</span>
<a href="#l8.6"></a><span id="l8.6"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.7"></a><span id="l8.7"> </span>
<a href="#l8.8"></a><span id="l8.8"> // { ===== begin morkNode interface =====</span>
<a href="#l8.9"></a><span id="l8.9"> public: // morkNode virtual methods</span>
<a href="#l8.10"></a><span id="l8.10">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseAtomAidMap() only if open</span>
<a href="#l8.11"></a><span id="l8.11">   virtual ~morkAtomAidMap(); // assert that CloseAtomAidMap() executed earlier</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-  </span>
<a href="#l8.13"></a><span id="l8.13" class="difflineplus">+</span>
<a href="#l8.14"></a><span id="l8.14"> public: // morkMap construction &amp; destruction</span>
<a href="#l8.15"></a><span id="l8.15">   morkAtomAidMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l8.16"></a><span id="l8.16">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l8.17"></a><span id="l8.17">   void CloseAtomAidMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l8.18"></a><span id="l8.18"> </span>
<a href="#l8.19"></a><span id="l8.19"> public: // dynamic type identification</span>
<a href="#l8.20"></a><span id="l8.20">   mork_bool IsAtomAidMap() const</span>
<a href="#l8.21"></a><span id="l8.21">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kAtomAidMap; }</span>
<a href="#l8.22"></a><span id="l8.22" class="difflineat">@@ -93,66 +93,66 @@ public:</span>
<a href="#l8.23"></a><span id="l8.23"> </span>
<a href="#l8.24"></a><span id="l8.24"> public: // other map methods</span>
<a href="#l8.25"></a><span id="l8.25"> </span>
<a href="#l8.26"></a><span id="l8.26">   mork_bool      AddAtom(morkEnv* ev, morkBookAtom* ioAtom);</span>
<a href="#l8.27"></a><span id="l8.27">   // AddAtom() returns ev-&gt;Good()</span>
<a href="#l8.28"></a><span id="l8.28"> </span>
<a href="#l8.29"></a><span id="l8.29">   morkBookAtom*  CutAtom(morkEnv* ev, const morkBookAtom* inAtom);</span>
<a href="#l8.30"></a><span id="l8.30">   // CutAtom() returns the atom removed equal to inAtom, if there was one</span>
<a href="#l8.31"></a><span id="l8.31" class="difflineminus">-  </span>
<a href="#l8.32"></a><span id="l8.32" class="difflineplus">+</span>
<a href="#l8.33"></a><span id="l8.33">   morkBookAtom*  GetAtom(morkEnv* ev, const morkBookAtom* inAtom);</span>
<a href="#l8.34"></a><span id="l8.34">   // GetAtom() returns the atom equal to inAtom, or else nil</span>
<a href="#l8.35"></a><span id="l8.35"> </span>
<a href="#l8.36"></a><span id="l8.36">   morkBookAtom*  GetAid(morkEnv* ev, mork_aid inAid);</span>
<a href="#l8.37"></a><span id="l8.37">   // GetAid() returns the atom equal to inAid, or else nil</span>
<a href="#l8.38"></a><span id="l8.38"> </span>
<a href="#l8.39"></a><span id="l8.39">   // note the atoms are owned elsewhere, usuall by morkAtomSpace</span>
<a href="#l8.40"></a><span id="l8.40"> </span>
<a href="#l8.41"></a><span id="l8.41"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l8.42"></a><span id="l8.42">   static void SlotWeakAtomAidMap(morkAtomAidMap* me,</span>
<a href="#l8.43"></a><span id="l8.43">     morkEnv* ev, morkAtomAidMap** ioSlot)</span>
<a href="#l8.44"></a><span id="l8.44">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l8.45"></a><span id="l8.45" class="difflineminus">-  </span>
<a href="#l8.46"></a><span id="l8.46" class="difflineplus">+</span>
<a href="#l8.47"></a><span id="l8.47">   static void SlotStrongAtomAidMap(morkAtomAidMap* me,</span>
<a href="#l8.48"></a><span id="l8.48">     morkEnv* ev, morkAtomAidMap** ioSlot)</span>
<a href="#l8.49"></a><span id="l8.49">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l8.50"></a><span id="l8.50"> };</span>
<a href="#l8.51"></a><span id="l8.51"> </span>
<a href="#l8.52"></a><span id="l8.52"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l8.53"></a><span id="l8.53"> class morkAtomAidMapIter: public morkProbeMapIter { // typesafe wrapper class</span>
<a href="#l8.54"></a><span id="l8.54"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.55"></a><span id="l8.55"> class morkAtomAidMapIter: public morkMapIter { // typesafe wrapper class</span>
<a href="#l8.56"></a><span id="l8.56"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.57"></a><span id="l8.57"> </span>
<a href="#l8.58"></a><span id="l8.58"> public:</span>
<a href="#l8.59"></a><span id="l8.59"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l8.60"></a><span id="l8.60">   morkAtomAidMapIter(morkEnv* ev, morkAtomAidMap* ioMap)</span>
<a href="#l8.61"></a><span id="l8.61">   : morkProbeMapIter(ev, ioMap) { }</span>
<a href="#l8.62"></a><span id="l8.62" class="difflineminus">- </span>
<a href="#l8.63"></a><span id="l8.63" class="difflineplus">+</span>
<a href="#l8.64"></a><span id="l8.64">   morkAtomAidMapIter( ) : morkProbeMapIter()  { }</span>
<a href="#l8.65"></a><span id="l8.65"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.66"></a><span id="l8.66">   morkAtomAidMapIter(morkEnv* ev, morkAtomAidMap* ioMap)</span>
<a href="#l8.67"></a><span id="l8.67">   : morkMapIter(ev, ioMap) { }</span>
<a href="#l8.68"></a><span id="l8.68" class="difflineminus">- </span>
<a href="#l8.69"></a><span id="l8.69" class="difflineplus">+</span>
<a href="#l8.70"></a><span id="l8.70">   morkAtomAidMapIter( ) : morkMapIter()  { }</span>
<a href="#l8.71"></a><span id="l8.71"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.72"></a><span id="l8.72"> </span>
<a href="#l8.73"></a><span id="l8.73">   void InitAtomAidMapIter(morkEnv* ev, morkAtomAidMap* ioMap)</span>
<a href="#l8.74"></a><span id="l8.74">   { this-&gt;InitMapIter(ev, ioMap); }</span>
<a href="#l8.75"></a><span id="l8.75" class="difflineminus">-   </span>
<a href="#l8.76"></a><span id="l8.76" class="difflineplus">+</span>
<a href="#l8.77"></a><span id="l8.77">   mork_change* FirstAtom(morkEnv* ev, morkBookAtom** outAtomPtr)</span>
<a href="#l8.78"></a><span id="l8.78">   { return this-&gt;First(ev, outAtomPtr, /*val*/ (void*) 0); }</span>
<a href="#l8.79"></a><span id="l8.79" class="difflineminus">-  </span>
<a href="#l8.80"></a><span id="l8.80" class="difflineplus">+</span>
<a href="#l8.81"></a><span id="l8.81">   mork_change* NextAtom(morkEnv* ev, morkBookAtom** outAtomPtr)</span>
<a href="#l8.82"></a><span id="l8.82">   { return this-&gt;Next(ev, outAtomPtr, /*val*/ (void*) 0); }</span>
<a href="#l8.83"></a><span id="l8.83" class="difflineminus">-  </span>
<a href="#l8.84"></a><span id="l8.84" class="difflineplus">+</span>
<a href="#l8.85"></a><span id="l8.85">   mork_change* HereAtom(morkEnv* ev, morkBookAtom** outAtomPtr)</span>
<a href="#l8.86"></a><span id="l8.86">   { return this-&gt;Here(ev, outAtomPtr, /*val*/ (void*) 0); }</span>
<a href="#l8.87"></a><span id="l8.87" class="difflineminus">-  </span>
<a href="#l8.88"></a><span id="l8.88" class="difflineplus">+</span>
<a href="#l8.89"></a><span id="l8.89">   mork_change* CutHereAtom(morkEnv* ev, morkBookAtom** outAtomPtr)</span>
<a href="#l8.90"></a><span id="l8.90">   { return this-&gt;CutHere(ev, outAtomPtr, /*val*/ (void*) 0); }</span>
<a href="#l8.91"></a><span id="l8.91"> };</span>
<a href="#l8.92"></a><span id="l8.92"> </span>
<a href="#l8.93"></a><span id="l8.93"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l8.94"></a><span id="l8.94"> </span>
<a href="#l8.95"></a><span id="l8.95"> </span>
<a href="#l8.96"></a><span id="l8.96"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l8.97"></a><span id="l8.97" class="difflineat">@@ -168,17 +168,17 @@ class morkAtomBodyMap : public morkProbe</span>
<a href="#l8.98"></a><span id="l8.98"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.99"></a><span id="l8.99"> class morkAtomBodyMap : public morkMap { // for mapping tokens to maps</span>
<a href="#l8.100"></a><span id="l8.100"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.101"></a><span id="l8.101"> </span>
<a href="#l8.102"></a><span id="l8.102"> // { ===== begin morkNode interface =====</span>
<a href="#l8.103"></a><span id="l8.103"> public: // morkNode virtual methods</span>
<a href="#l8.104"></a><span id="l8.104">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseAtomBodyMap() only if open</span>
<a href="#l8.105"></a><span id="l8.105">   virtual ~morkAtomBodyMap(); // assert CloseAtomBodyMap() executed earlier</span>
<a href="#l8.106"></a><span id="l8.106" class="difflineminus">-  </span>
<a href="#l8.107"></a><span id="l8.107" class="difflineplus">+</span>
<a href="#l8.108"></a><span id="l8.108"> public: // morkMap construction &amp; destruction</span>
<a href="#l8.109"></a><span id="l8.109">   morkAtomBodyMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l8.110"></a><span id="l8.110">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l8.111"></a><span id="l8.111">   void CloseAtomBodyMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l8.112"></a><span id="l8.112"> </span>
<a href="#l8.113"></a><span id="l8.113"> public: // dynamic type identification</span>
<a href="#l8.114"></a><span id="l8.114">   mork_bool IsAtomBodyMap() const</span>
<a href="#l8.115"></a><span id="l8.115">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kAtomBodyMap; }</span>
<a href="#l8.116"></a><span id="l8.116" class="difflineat">@@ -222,63 +222,63 @@ public:</span>
<a href="#l8.117"></a><span id="l8.117"> </span>
<a href="#l8.118"></a><span id="l8.118"> public: // other map methods</span>
<a href="#l8.119"></a><span id="l8.119"> </span>
<a href="#l8.120"></a><span id="l8.120">   mork_bool      AddAtom(morkEnv* ev, morkBookAtom* ioAtom);</span>
<a href="#l8.121"></a><span id="l8.121">   // AddAtom() returns ev-&gt;Good()</span>
<a href="#l8.122"></a><span id="l8.122"> </span>
<a href="#l8.123"></a><span id="l8.123">   morkBookAtom*  CutAtom(morkEnv* ev, const morkBookAtom* inAtom);</span>
<a href="#l8.124"></a><span id="l8.124">   // CutAtom() returns the atom removed equal to inAtom, if there was one</span>
<a href="#l8.125"></a><span id="l8.125" class="difflineminus">-  </span>
<a href="#l8.126"></a><span id="l8.126" class="difflineplus">+</span>
<a href="#l8.127"></a><span id="l8.127">   morkBookAtom*  GetAtom(morkEnv* ev, const morkBookAtom* inAtom);</span>
<a href="#l8.128"></a><span id="l8.128">   // GetAtom() returns the atom equal to inAtom, or else nil</span>
<a href="#l8.129"></a><span id="l8.129"> </span>
<a href="#l8.130"></a><span id="l8.130">   // note the atoms are owned elsewhere, usuall by morkAtomSpace</span>
<a href="#l8.131"></a><span id="l8.131"> </span>
<a href="#l8.132"></a><span id="l8.132"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l8.133"></a><span id="l8.133">   static void SlotWeakAtomBodyMap(morkAtomBodyMap* me,</span>
<a href="#l8.134"></a><span id="l8.134">     morkEnv* ev, morkAtomBodyMap** ioSlot)</span>
<a href="#l8.135"></a><span id="l8.135">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l8.136"></a><span id="l8.136" class="difflineminus">-  </span>
<a href="#l8.137"></a><span id="l8.137" class="difflineplus">+</span>
<a href="#l8.138"></a><span id="l8.138">   static void SlotStrongAtomBodyMap(morkAtomBodyMap* me,</span>
<a href="#l8.139"></a><span id="l8.139">     morkEnv* ev, morkAtomBodyMap** ioSlot)</span>
<a href="#l8.140"></a><span id="l8.140">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l8.141"></a><span id="l8.141"> };</span>
<a href="#l8.142"></a><span id="l8.142"> </span>
<a href="#l8.143"></a><span id="l8.143"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l8.144"></a><span id="l8.144"> class morkAtomBodyMapIter: public morkProbeMapIter{ // typesafe wrapper class</span>
<a href="#l8.145"></a><span id="l8.145"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.146"></a><span id="l8.146"> class morkAtomBodyMapIter: public morkMapIter{ // typesafe wrapper class</span>
<a href="#l8.147"></a><span id="l8.147"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.148"></a><span id="l8.148"> </span>
<a href="#l8.149"></a><span id="l8.149"> public:</span>
<a href="#l8.150"></a><span id="l8.150"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l8.151"></a><span id="l8.151">   morkAtomBodyMapIter(morkEnv* ev, morkAtomBodyMap* ioMap)</span>
<a href="#l8.152"></a><span id="l8.152">   : morkProbeMapIter(ev, ioMap) { }</span>
<a href="#l8.153"></a><span id="l8.153" class="difflineminus">- </span>
<a href="#l8.154"></a><span id="l8.154" class="difflineplus">+</span>
<a href="#l8.155"></a><span id="l8.155">   morkAtomBodyMapIter( ) : morkProbeMapIter()  { }</span>
<a href="#l8.156"></a><span id="l8.156"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.157"></a><span id="l8.157">   morkAtomBodyMapIter(morkEnv* ev, morkAtomBodyMap* ioMap)</span>
<a href="#l8.158"></a><span id="l8.158">   : morkMapIter(ev, ioMap) { }</span>
<a href="#l8.159"></a><span id="l8.159" class="difflineminus">- </span>
<a href="#l8.160"></a><span id="l8.160" class="difflineplus">+</span>
<a href="#l8.161"></a><span id="l8.161">   morkAtomBodyMapIter( ) : morkMapIter()  { }</span>
<a href="#l8.162"></a><span id="l8.162"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l8.163"></a><span id="l8.163" class="difflineminus">-  </span>
<a href="#l8.164"></a><span id="l8.164" class="difflineplus">+</span>
<a href="#l8.165"></a><span id="l8.165">   void InitAtomBodyMapIter(morkEnv* ev, morkAtomBodyMap* ioMap)</span>
<a href="#l8.166"></a><span id="l8.166">   { this-&gt;InitMapIter(ev, ioMap); }</span>
<a href="#l8.167"></a><span id="l8.167" class="difflineminus">-   </span>
<a href="#l8.168"></a><span id="l8.168" class="difflineplus">+</span>
<a href="#l8.169"></a><span id="l8.169">   mork_change* FirstAtom(morkEnv* ev, morkBookAtom** outAtomPtr)</span>
<a href="#l8.170"></a><span id="l8.170">   { return this-&gt;First(ev, outAtomPtr, /*val*/ (void*) 0); }</span>
<a href="#l8.171"></a><span id="l8.171" class="difflineminus">-  </span>
<a href="#l8.172"></a><span id="l8.172" class="difflineplus">+</span>
<a href="#l8.173"></a><span id="l8.173">   mork_change* NextAtom(morkEnv* ev, morkBookAtom** outAtomPtr)</span>
<a href="#l8.174"></a><span id="l8.174">   { return this-&gt;Next(ev, outAtomPtr, /*val*/ (void*) 0); }</span>
<a href="#l8.175"></a><span id="l8.175" class="difflineminus">-  </span>
<a href="#l8.176"></a><span id="l8.176" class="difflineplus">+</span>
<a href="#l8.177"></a><span id="l8.177">   mork_change* HereAtom(morkEnv* ev, morkBookAtom** outAtomPtr)</span>
<a href="#l8.178"></a><span id="l8.178">   { return this-&gt;Here(ev, outAtomPtr, /*val*/ (void*) 0); }</span>
<a href="#l8.179"></a><span id="l8.179" class="difflineminus">-  </span>
<a href="#l8.180"></a><span id="l8.180" class="difflineplus">+</span>
<a href="#l8.181"></a><span id="l8.181">   mork_change* CutHereAtom(morkEnv* ev, morkBookAtom** outAtomPtr)</span>
<a href="#l8.182"></a><span id="l8.182">   { return this-&gt;CutHere(ev, outAtomPtr, /*val*/ (void*) 0); }</span>
<a href="#l8.183"></a><span id="l8.183"> };</span>
<a href="#l8.184"></a><span id="l8.184"> </span>
<a href="#l8.185"></a><span id="l8.185"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l8.186"></a><span id="l8.186"> </span>
<a href="#l8.187"></a><span id="l8.187"> #define morkDerived_kAtomRowMap  /*i*/ 0x6152 /* ascii 'aR' */</span>
<a href="#l8.188"></a><span id="l8.188"> </span>
<a href="#l8.189"></a><span id="l8.189" class="difflineat">@@ -293,72 +293,72 @@ public:</span>
<a href="#l8.190"></a><span id="l8.190"> </span>
<a href="#l8.191"></a><span id="l8.191">   virtual ~morkAtomRowMap();</span>
<a href="#l8.192"></a><span id="l8.192">   morkAtomRowMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l8.193"></a><span id="l8.193">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap, mork_column inIndexColumn);</span>
<a href="#l8.194"></a><span id="l8.194"> </span>
<a href="#l8.195"></a><span id="l8.195"> public: // adding and cutting from morkRow instance candidate</span>
<a href="#l8.196"></a><span id="l8.196"> </span>
<a href="#l8.197"></a><span id="l8.197">   void  AddRow(morkEnv* ev, morkRow* ioRow);</span>
<a href="#l8.198"></a><span id="l8.198" class="difflineminus">-  // add ioRow only if it contains a cell in mAtomRowMap_IndexColumn. </span>
<a href="#l8.199"></a><span id="l8.199" class="difflineplus">+  // add ioRow only if it contains a cell in mAtomRowMap_IndexColumn.</span>
<a href="#l8.200"></a><span id="l8.200"> </span>
<a href="#l8.201"></a><span id="l8.201">   void  CutRow(morkEnv* ev, morkRow* ioRow);</span>
<a href="#l8.202"></a><span id="l8.202" class="difflineminus">-  // cut ioRow only if it contains a cell in mAtomRowMap_IndexColumn. </span>
<a href="#l8.203"></a><span id="l8.203" class="difflineplus">+  // cut ioRow only if it contains a cell in mAtomRowMap_IndexColumn.</span>
<a href="#l8.204"></a><span id="l8.204"> </span>
<a href="#l8.205"></a><span id="l8.205"> public: // other map methods</span>
<a href="#l8.206"></a><span id="l8.206"> </span>
<a href="#l8.207"></a><span id="l8.207">   mork_bool  AddAid(morkEnv* ev, mork_aid inAid, morkRow* ioRow)</span>
<a href="#l8.208"></a><span id="l8.208">   { return this-&gt;AddInt(ev, inAid, ioRow); }</span>
<a href="#l8.209"></a><span id="l8.209">   // the AddAid() boolean return equals ev-&gt;Good().</span>
<a href="#l8.210"></a><span id="l8.210"> </span>
<a href="#l8.211"></a><span id="l8.211">   mork_bool  CutAid(morkEnv* ev, mork_aid inAid)</span>
<a href="#l8.212"></a><span id="l8.212">   { return this-&gt;CutInt(ev, inAid); }</span>
<a href="#l8.213"></a><span id="l8.213" class="difflineminus">-  // The CutAid() boolean return indicates whether removal happened. </span>
<a href="#l8.214"></a><span id="l8.214" class="difflineminus">-  </span>
<a href="#l8.215"></a><span id="l8.215" class="difflineplus">+  // The CutAid() boolean return indicates whether removal happened.</span>
<a href="#l8.216"></a><span id="l8.216" class="difflineplus">+</span>
<a href="#l8.217"></a><span id="l8.217">   morkRow*   GetAid(morkEnv* ev, mork_aid inAid)</span>
<a href="#l8.218"></a><span id="l8.218">   { return (morkRow*) this-&gt;GetInt(ev, inAid); }</span>
<a href="#l8.219"></a><span id="l8.219">   // Note the returned space does NOT have an increase in refcount for this.</span>
<a href="#l8.220"></a><span id="l8.220" class="difflineminus">-  </span>
<a href="#l8.221"></a><span id="l8.221" class="difflineplus">+</span>
<a href="#l8.222"></a><span id="l8.222"> public: // dynamic type identification</span>
<a href="#l8.223"></a><span id="l8.223">   mork_bool IsAtomRowMap() const</span>
<a href="#l8.224"></a><span id="l8.224">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kAtomRowMap; }</span>
<a href="#l8.225"></a><span id="l8.225"> </span>
<a href="#l8.226"></a><span id="l8.226"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l8.227"></a><span id="l8.227">   static void SlotWeakAtomRowMap(morkAtomRowMap* me,</span>
<a href="#l8.228"></a><span id="l8.228">     morkEnv* ev, morkAtomRowMap** ioSlot)</span>
<a href="#l8.229"></a><span id="l8.229">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l8.230"></a><span id="l8.230" class="difflineminus">-  </span>
<a href="#l8.231"></a><span id="l8.231" class="difflineplus">+</span>
<a href="#l8.232"></a><span id="l8.232">   static void SlotStrongAtomRowMap(morkAtomRowMap* me,</span>
<a href="#l8.233"></a><span id="l8.233">     morkEnv* ev, morkAtomRowMap** ioSlot)</span>
<a href="#l8.234"></a><span id="l8.234">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l8.235"></a><span id="l8.235"> </span>
<a href="#l8.236"></a><span id="l8.236"> };</span>
<a href="#l8.237"></a><span id="l8.237"> </span>
<a href="#l8.238"></a><span id="l8.238"> class morkAtomRowMapIter: public morkMapIter{ // typesafe wrapper class</span>
<a href="#l8.239"></a><span id="l8.239"> </span>
<a href="#l8.240"></a><span id="l8.240"> public:</span>
<a href="#l8.241"></a><span id="l8.241">   morkAtomRowMapIter(morkEnv* ev, morkAtomRowMap* ioMap)</span>
<a href="#l8.242"></a><span id="l8.242">   : morkMapIter(ev, ioMap) { }</span>
<a href="#l8.243"></a><span id="l8.243" class="difflineminus">- </span>
<a href="#l8.244"></a><span id="l8.244" class="difflineplus">+</span>
<a href="#l8.245"></a><span id="l8.245">   morkAtomRowMapIter( ) : morkMapIter()  { }</span>
<a href="#l8.246"></a><span id="l8.246">   void InitAtomRowMapIter(morkEnv* ev, morkAtomRowMap* ioMap)</span>
<a href="#l8.247"></a><span id="l8.247">   { this-&gt;InitMapIter(ev, ioMap); }</span>
<a href="#l8.248"></a><span id="l8.248" class="difflineminus">-   </span>
<a href="#l8.249"></a><span id="l8.249" class="difflineplus">+</span>
<a href="#l8.250"></a><span id="l8.250">   mork_change*</span>
<a href="#l8.251"></a><span id="l8.251">   FirstAtomAndRow(morkEnv* ev, morkAtom** outAtom, morkRow** outRow)</span>
<a href="#l8.252"></a><span id="l8.252">   { return this-&gt;First(ev, outAtom, outRow); }</span>
<a href="#l8.253"></a><span id="l8.253" class="difflineminus">-  </span>
<a href="#l8.254"></a><span id="l8.254" class="difflineplus">+</span>
<a href="#l8.255"></a><span id="l8.255">   mork_change*</span>
<a href="#l8.256"></a><span id="l8.256">   NextAtomAndRow(morkEnv* ev, morkAtom** outAtom, morkRow** outRow)</span>
<a href="#l8.257"></a><span id="l8.257">   { return this-&gt;Next(ev, outAtom, outRow); }</span>
<a href="#l8.258"></a><span id="l8.258" class="difflineminus">-  </span>
<a href="#l8.259"></a><span id="l8.259" class="difflineplus">+</span>
<a href="#l8.260"></a><span id="l8.260">   mork_change*</span>
<a href="#l8.261"></a><span id="l8.261">   HereAtomAndRow(morkEnv* ev, morkAtom** outAtom, morkRow** outRow)</span>
<a href="#l8.262"></a><span id="l8.262">   { return this-&gt;Here(ev, outAtom, outRow); }</span>
<a href="#l8.263"></a><span id="l8.263" class="difflineminus">-  </span>
<a href="#l8.264"></a><span id="l8.264" class="difflineplus">+</span>
<a href="#l8.265"></a><span id="l8.265">   mork_change*</span>
<a href="#l8.266"></a><span id="l8.266">   CutHereAtomAndRow(morkEnv* ev, morkAtom** outAtom, morkRow** outRow)</span>
<a href="#l8.267"></a><span id="l8.267">   { return this-&gt;CutHere(ev, outAtom, outRow); }</span>
<a href="#l8.268"></a><span id="l8.268"> };</span>
<a href="#l8.269"></a><span id="l8.269"> </span>
<a href="#l8.270"></a><span id="l8.270"> </span>
<a href="#l8.271"></a><span id="l8.271"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l8.272"></a><span id="l8.272"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/db/mork/src/morkAtomSpace.cpp</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/db/mork/src/morkAtomSpace.cpp</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -44,17 +44,17 @@</span>
<a href="#l9.4"></a><span id="l9.4"> #endif</span>
<a href="#l9.5"></a><span id="l9.5"> </span>
<a href="#l9.6"></a><span id="l9.6"> #ifndef _MORKATOM_</span>
<a href="#l9.7"></a><span id="l9.7"> #include &quot;morkAtom.h&quot;</span>
<a href="#l9.8"></a><span id="l9.8"> #endif</span>
<a href="#l9.9"></a><span id="l9.9"> </span>
<a href="#l9.10"></a><span id="l9.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l9.11"></a><span id="l9.11"> </span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l9.14"></a><span id="l9.14"> // { ===== begin morkNode interface =====</span>
<a href="#l9.15"></a><span id="l9.15"> </span>
<a href="#l9.16"></a><span id="l9.16"> /*public virtual*/ void</span>
<a href="#l9.17"></a><span id="l9.17"> morkAtomSpace::CloseMorkNode(morkEnv* ev) // CloseAtomSpace() only if open</span>
<a href="#l9.18"></a><span id="l9.18"> {</span>
<a href="#l9.19"></a><span id="l9.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l9.20"></a><span id="l9.20">   {</span>
<a href="#l9.21"></a><span id="l9.21">     this-&gt;MarkClosing();</span>
<a href="#l9.22"></a><span id="l9.22" class="difflineat">@@ -92,64 +92,64 @@ morkAtomSpace::morkAtomSpace(morkEnv* ev</span>
<a href="#l9.23"></a><span id="l9.23"> morkAtomSpace::CloseAtomSpace(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l9.24"></a><span id="l9.24"> {</span>
<a href="#l9.25"></a><span id="l9.25">     if ( this-&gt;IsNode() )</span>
<a href="#l9.26"></a><span id="l9.26">     {</span>
<a href="#l9.27"></a><span id="l9.27">       mAtomSpace_AtomBodies.CloseMorkNode(ev);</span>
<a href="#l9.28"></a><span id="l9.28">       morkStore* store = mSpace_Store;</span>
<a href="#l9.29"></a><span id="l9.29">       if ( store )</span>
<a href="#l9.30"></a><span id="l9.30">         this-&gt;CutAllAtoms(ev, &amp;store-&gt;mStore_Pool);</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineminus">-      </span>
<a href="#l9.32"></a><span id="l9.32" class="difflineplus">+</span>
<a href="#l9.33"></a><span id="l9.33">       mAtomSpace_AtomAids.CloseMorkNode(ev);</span>
<a href="#l9.34"></a><span id="l9.34">       this-&gt;CloseSpace(ev);</span>
<a href="#l9.35"></a><span id="l9.35">       mAtomSpace_HighUnderId = 0;</span>
<a href="#l9.36"></a><span id="l9.36">       mAtomSpace_HighOverId = 0;</span>
<a href="#l9.37"></a><span id="l9.37">       this-&gt;MarkShut();</span>
<a href="#l9.38"></a><span id="l9.38">     }</span>
<a href="#l9.39"></a><span id="l9.39">     else</span>
<a href="#l9.40"></a><span id="l9.40">       this-&gt;NonNodeError(ev);</span>
<a href="#l9.41"></a><span id="l9.41"> }</span>
<a href="#l9.42"></a><span id="l9.42"> </span>
<a href="#l9.43"></a><span id="l9.43"> // } ===== end morkNode methods =====</span>
<a href="#l9.44"></a><span id="l9.44" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l9.45"></a><span id="l9.45" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l9.46"></a><span id="l9.46"> </span>
<a href="#l9.47"></a><span id="l9.47"> /*static*/ void</span>
<a href="#l9.48"></a><span id="l9.48"> morkAtomSpace::NonAtomSpaceTypeError(morkEnv* ev)</span>
<a href="#l9.49"></a><span id="l9.49"> {</span>
<a href="#l9.50"></a><span id="l9.50">   ev-&gt;NewError(&quot;non morkAtomSpace&quot;);</span>
<a href="#l9.51"></a><span id="l9.51"> }</span>
<a href="#l9.52"></a><span id="l9.52"> </span>
<a href="#l9.53"></a><span id="l9.53"> mork_num</span>
<a href="#l9.54"></a><span id="l9.54"> morkAtomSpace::CutAllAtoms(morkEnv* ev, morkPool* ioPool)</span>
<a href="#l9.55"></a><span id="l9.55"> {</span>
<a href="#l9.56"></a><span id="l9.56"> #ifdef MORK_ENABLE_ZONE_ARENAS</span>
<a href="#l9.57"></a><span id="l9.57">   MORK_USED_2(ev, ioPool);</span>
<a href="#l9.58"></a><span id="l9.58">   return 0;</span>
<a href="#l9.59"></a><span id="l9.59"> #else /*MORK_ENABLE_ZONE_ARENAS*/</span>
<a href="#l9.60"></a><span id="l9.60">   if ( this-&gt;IsAtomSpaceClean() )</span>
<a href="#l9.61"></a><span id="l9.61">     this-&gt;MaybeDirtyStoreAndSpace();</span>
<a href="#l9.62"></a><span id="l9.62" class="difflineminus">-  </span>
<a href="#l9.63"></a><span id="l9.63" class="difflineplus">+</span>
<a href="#l9.64"></a><span id="l9.64">   mork_num outSlots = mAtomSpace_AtomAids.MapFill();</span>
<a href="#l9.65"></a><span id="l9.65">   morkBookAtom* a = 0; // old key atom in the map</span>
<a href="#l9.66"></a><span id="l9.66" class="difflineminus">-  </span>
<a href="#l9.67"></a><span id="l9.67" class="difflineplus">+</span>
<a href="#l9.68"></a><span id="l9.68">   morkStore* store = mSpace_Store;</span>
<a href="#l9.69"></a><span id="l9.69">   mork_change* c = 0;</span>
<a href="#l9.70"></a><span id="l9.70">   morkAtomAidMapIter i(ev, &amp;mAtomSpace_AtomAids);</span>
<a href="#l9.71"></a><span id="l9.71">   for ( c = i.FirstAtom(ev, &amp;a); c ; c = i.NextAtom(ev, &amp;a) )</span>
<a href="#l9.72"></a><span id="l9.72">   {</span>
<a href="#l9.73"></a><span id="l9.73">     if ( a )</span>
<a href="#l9.74"></a><span id="l9.74">       ioPool-&gt;ZapAtom(ev, a, &amp;store-&gt;mStore_Zone);</span>
<a href="#l9.75"></a><span id="l9.75"> </span>
<a href="#l9.76"></a><span id="l9.76"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l9.77"></a><span id="l9.77">     // do not cut anything from the map</span>
<a href="#l9.78"></a><span id="l9.78"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l9.79"></a><span id="l9.79">     i.CutHereAtom(ev, /*key*/ (morkBookAtom**) 0);</span>
<a href="#l9.80"></a><span id="l9.80"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l9.81"></a><span id="l9.81">   }</span>
<a href="#l9.82"></a><span id="l9.82" class="difflineminus">-  </span>
<a href="#l9.83"></a><span id="l9.83" class="difflineplus">+</span>
<a href="#l9.84"></a><span id="l9.84">   return outSlots;</span>
<a href="#l9.85"></a><span id="l9.85"> #endif /*MORK_ENABLE_ZONE_ARENAS*/</span>
<a href="#l9.86"></a><span id="l9.86"> }</span>
<a href="#l9.87"></a><span id="l9.87"> </span>
<a href="#l9.88"></a><span id="l9.88"> </span>
<a href="#l9.89"></a><span id="l9.89"> morkBookAtom*</span>
<a href="#l9.90"></a><span id="l9.90"> morkAtomSpace::MakeBookAtomCopyWithAid(morkEnv* ev,</span>
<a href="#l9.91"></a><span id="l9.91">    const morkFarBookAtom&amp; inAtom,  mork_aid inAid)</span>
<a href="#l9.92"></a><span id="l9.92" class="difflineat">@@ -164,17 +164,17 @@ morkAtomSpace::MakeBookAtomCopyWithAid(m</span>
<a href="#l9.93"></a><span id="l9.93">     if ( outAtom )</span>
<a href="#l9.94"></a><span id="l9.94">     {</span>
<a href="#l9.95"></a><span id="l9.95">       if ( store-&gt;mStore_CanDirty )</span>
<a href="#l9.96"></a><span id="l9.96">       {</span>
<a href="#l9.97"></a><span id="l9.97">         outAtom-&gt;SetAtomDirty();</span>
<a href="#l9.98"></a><span id="l9.98">         if ( this-&gt;IsAtomSpaceClean() )</span>
<a href="#l9.99"></a><span id="l9.99">           this-&gt;MaybeDirtyStoreAndSpace();</span>
<a href="#l9.100"></a><span id="l9.100">       }</span>
<a href="#l9.101"></a><span id="l9.101" class="difflineminus">-  </span>
<a href="#l9.102"></a><span id="l9.102" class="difflineplus">+</span>
<a href="#l9.103"></a><span id="l9.103">       outAtom-&gt;mBookAtom_Id = inAid;</span>
<a href="#l9.104"></a><span id="l9.104">       outAtom-&gt;mBookAtom_Space = this;</span>
<a href="#l9.105"></a><span id="l9.105">       mAtomSpace_AtomAids.AddAtom(ev, outAtom);</span>
<a href="#l9.106"></a><span id="l9.106">       mAtomSpace_AtomBodies.AddAtom(ev, outAtom);</span>
<a href="#l9.107"></a><span id="l9.107">       if ( this-&gt;SpaceScope() == morkAtomSpace_kColumnScope )</span>
<a href="#l9.108"></a><span id="l9.108">         outAtom-&gt;MakeCellUseForever(ev);</span>
<a href="#l9.109"></a><span id="l9.109"> </span>
<a href="#l9.110"></a><span id="l9.110">       if ( mAtomSpace_HighUnderId &lt;= inAid )</span>
<a href="#l9.111"></a><span id="l9.111" class="difflineat">@@ -202,18 +202,18 @@ morkAtomSpace::MakeBookAtomCopy(morkEnv*</span>
<a href="#l9.112"></a><span id="l9.112">         if ( id )</span>
<a href="#l9.113"></a><span id="l9.113">         {</span>
<a href="#l9.114"></a><span id="l9.114">           if ( store-&gt;mStore_CanDirty )</span>
<a href="#l9.115"></a><span id="l9.115">           {</span>
<a href="#l9.116"></a><span id="l9.116">             atom-&gt;SetAtomDirty();</span>
<a href="#l9.117"></a><span id="l9.117">             if ( this-&gt;IsAtomSpaceClean() )</span>
<a href="#l9.118"></a><span id="l9.118">               this-&gt;MaybeDirtyStoreAndSpace();</span>
<a href="#l9.119"></a><span id="l9.119">           }</span>
<a href="#l9.120"></a><span id="l9.120" class="difflineminus">-            </span>
<a href="#l9.121"></a><span id="l9.121" class="difflineminus">-          outAtom = atom; </span>
<a href="#l9.122"></a><span id="l9.122" class="difflineplus">+</span>
<a href="#l9.123"></a><span id="l9.123" class="difflineplus">+          outAtom = atom;</span>
<a href="#l9.124"></a><span id="l9.124">           atom-&gt;mBookAtom_Space = this;</span>
<a href="#l9.125"></a><span id="l9.125">           mAtomSpace_AtomAids.AddAtom(ev, atom);</span>
<a href="#l9.126"></a><span id="l9.126">           mAtomSpace_AtomBodies.AddAtom(ev, atom);</span>
<a href="#l9.127"></a><span id="l9.127">           if ( this-&gt;SpaceScope() == morkAtomSpace_kColumnScope )</span>
<a href="#l9.128"></a><span id="l9.128">             outAtom-&gt;MakeCellUseForever(ev);</span>
<a href="#l9.129"></a><span id="l9.129">         }</span>
<a href="#l9.130"></a><span id="l9.130">         else</span>
<a href="#l9.131"></a><span id="l9.131">           pool-&gt;ZapAtom(ev, atom, &amp;mSpace_Store-&gt;mStore_Zone);</span>
<a href="#l9.132"></a><span id="l9.132" class="difflineat">@@ -227,30 +227,30 @@ morkAtomSpace::MakeBookAtomCopy(morkEnv*</span>
<a href="#l9.133"></a><span id="l9.133"> </span>
<a href="#l9.134"></a><span id="l9.134"> </span>
<a href="#l9.135"></a><span id="l9.135"> mork_aid</span>
<a href="#l9.136"></a><span id="l9.136"> morkAtomSpace::MakeNewAtomId(morkEnv* ev, morkBookAtom* ioAtom)</span>
<a href="#l9.137"></a><span id="l9.137"> {</span>
<a href="#l9.138"></a><span id="l9.138">   mork_aid outAid = 0;</span>
<a href="#l9.139"></a><span id="l9.139">   mork_tid id = mAtomSpace_HighUnderId;</span>
<a href="#l9.140"></a><span id="l9.140">   mork_num count = 8; // try up to eight times</span>
<a href="#l9.141"></a><span id="l9.141" class="difflineminus">-  </span>
<a href="#l9.142"></a><span id="l9.142" class="difflineplus">+</span>
<a href="#l9.143"></a><span id="l9.143">   while ( !outAid &amp;&amp; count ) // still trying to find an unused table ID?</span>
<a href="#l9.144"></a><span id="l9.144">   {</span>
<a href="#l9.145"></a><span id="l9.145">     --count;</span>
<a href="#l9.146"></a><span id="l9.146">     ioAtom-&gt;mBookAtom_Id = id;</span>
<a href="#l9.147"></a><span id="l9.147">     if ( !mAtomSpace_AtomAids.GetAtom(ev, ioAtom) )</span>
<a href="#l9.148"></a><span id="l9.148">       outAid = id;</span>
<a href="#l9.149"></a><span id="l9.149">     else</span>
<a href="#l9.150"></a><span id="l9.150">     {</span>
<a href="#l9.151"></a><span id="l9.151">       MORK_ASSERT(morkBool_kFalse); // alert developer about ID problems</span>
<a href="#l9.152"></a><span id="l9.152">       ++id;</span>
<a href="#l9.153"></a><span id="l9.153">     }</span>
<a href="#l9.154"></a><span id="l9.154">   }</span>
<a href="#l9.155"></a><span id="l9.155" class="difflineminus">-  </span>
<a href="#l9.156"></a><span id="l9.156" class="difflineplus">+</span>
<a href="#l9.157"></a><span id="l9.157">   mAtomSpace_HighUnderId = id + 1;</span>
<a href="#l9.158"></a><span id="l9.158">   return outAid;</span>
<a href="#l9.159"></a><span id="l9.159"> }</span>
<a href="#l9.160"></a><span id="l9.160"> </span>
<a href="#l9.161"></a><span id="l9.161"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l9.162"></a><span id="l9.162"> </span>
<a href="#l9.163"></a><span id="l9.163"> </span>
<a href="#l9.164"></a><span id="l9.164"> morkAtomSpaceMap::~morkAtomSpaceMap()</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/db/mork/src/morkAtomSpace.h</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/db/mork/src/morkAtomSpace.h</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -50,75 +50,75 @@</span>
<a href="#l10.4"></a><span id="l10.4"> #define morkAtomSpace_kMinOverId 0x1000  /* using at least four hex bytes */</span>
<a href="#l10.5"></a><span id="l10.5"> </span>
<a href="#l10.6"></a><span id="l10.6"> #define morkDerived_kAtomSpace  /*i*/ 0x6153 /* ascii 'aS' */</span>
<a href="#l10.7"></a><span id="l10.7"> </span>
<a href="#l10.8"></a><span id="l10.8"> #define morkAtomSpace_kColumnScope ((mork_scope) 'c') /* column scope is forever */</span>
<a href="#l10.9"></a><span id="l10.9"> </span>
<a href="#l10.10"></a><span id="l10.10"> /*| morkAtomSpace:</span>
<a href="#l10.11"></a><span id="l10.11"> |*/</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-class morkAtomSpace : public morkSpace { // </span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+class morkAtomSpace : public morkSpace { //</span>
<a href="#l10.14"></a><span id="l10.14"> </span>
<a href="#l10.15"></a><span id="l10.15"> // public: // slots inherited from morkSpace (meant to inform only)</span>
<a href="#l10.16"></a><span id="l10.16">   // nsIMdbHeap*    mNode_Heap;</span>
<a href="#l10.17"></a><span id="l10.17"> </span>
<a href="#l10.18"></a><span id="l10.18">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l10.19"></a><span id="l10.19">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l10.20"></a><span id="l10.20" class="difflineminus">-  </span>
<a href="#l10.21"></a><span id="l10.21" class="difflineplus">+</span>
<a href="#l10.22"></a><span id="l10.22">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l10.23"></a><span id="l10.23">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l10.24"></a><span id="l10.24">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l10.25"></a><span id="l10.25">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l10.26"></a><span id="l10.26" class="difflineminus">-  </span>
<a href="#l10.27"></a><span id="l10.27" class="difflineplus">+</span>
<a href="#l10.28"></a><span id="l10.28">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l10.29"></a><span id="l10.29">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l10.30"></a><span id="l10.30" class="difflineminus">-  </span>
<a href="#l10.31"></a><span id="l10.31" class="difflineplus">+</span>
<a href="#l10.32"></a><span id="l10.32">   // morkStore*  mSpace_Store; // weak ref to containing store</span>
<a href="#l10.33"></a><span id="l10.33" class="difflineminus">-  </span>
<a href="#l10.34"></a><span id="l10.34" class="difflineplus">+</span>
<a href="#l10.35"></a><span id="l10.35">   // mork_bool   mSpace_DoAutoIDs;    // whether db should assign member IDs</span>
<a href="#l10.36"></a><span id="l10.36">   // mork_bool   mSpace_HaveDoneAutoIDs; // whether actually auto assigned IDs</span>
<a href="#l10.37"></a><span id="l10.37">   // mork_u1     mSpace_Pad[ 2 ];     // pad to u4 alignment</span>
<a href="#l10.38"></a><span id="l10.38"> </span>
<a href="#l10.39"></a><span id="l10.39"> public: // state is public because the entire Mork system is private</span>
<a href="#l10.40"></a><span id="l10.40"> </span>
<a href="#l10.41"></a><span id="l10.41">   mork_aid         mAtomSpace_HighUnderId; // high ID in 'under' range</span>
<a href="#l10.42"></a><span id="l10.42">   mork_aid         mAtomSpace_HighOverId;  // high ID in 'over' range</span>
<a href="#l10.43"></a><span id="l10.43" class="difflineminus">-  </span>
<a href="#l10.44"></a><span id="l10.44" class="difflineplus">+</span>
<a href="#l10.45"></a><span id="l10.45">   morkAtomAidMap   mAtomSpace_AtomAids; // all atoms in space by ID</span>
<a href="#l10.46"></a><span id="l10.46">   morkAtomBodyMap  mAtomSpace_AtomBodies; // all atoms in space by body</span>
<a href="#l10.47"></a><span id="l10.47"> </span>
<a href="#l10.48"></a><span id="l10.48"> public: // more specific dirty methods for atom space:</span>
<a href="#l10.49"></a><span id="l10.49">   void SetAtomSpaceDirty() { this-&gt;SetNodeDirty(); }</span>
<a href="#l10.50"></a><span id="l10.50">   void SetAtomSpaceClean() { this-&gt;SetNodeClean(); }</span>
<a href="#l10.51"></a><span id="l10.51" class="difflineminus">-  </span>
<a href="#l10.52"></a><span id="l10.52" class="difflineplus">+</span>
<a href="#l10.53"></a><span id="l10.53">   mork_bool IsAtomSpaceClean() const { return this-&gt;IsNodeClean(); }</span>
<a href="#l10.54"></a><span id="l10.54">   mork_bool IsAtomSpaceDirty() const { return this-&gt;IsNodeDirty(); }</span>
<a href="#l10.55"></a><span id="l10.55"> </span>
<a href="#l10.56"></a><span id="l10.56"> // { ===== begin morkNode interface =====</span>
<a href="#l10.57"></a><span id="l10.57"> public: // morkNode virtual methods</span>
<a href="#l10.58"></a><span id="l10.58">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseAtomSpace() only if open</span>
<a href="#l10.59"></a><span id="l10.59">   virtual ~morkAtomSpace(); // assert that CloseAtomSpace() executed earlier</span>
<a href="#l10.60"></a><span id="l10.60" class="difflineminus">-  </span>
<a href="#l10.61"></a><span id="l10.61" class="difflineplus">+</span>
<a href="#l10.62"></a><span id="l10.62"> public: // morkMap construction &amp; destruction</span>
<a href="#l10.63"></a><span id="l10.63" class="difflineminus">-  morkAtomSpace(morkEnv* ev, const morkUsage&amp; inUsage, mork_scope inScope, </span>
<a href="#l10.64"></a><span id="l10.64" class="difflineplus">+  morkAtomSpace(morkEnv* ev, const morkUsage&amp; inUsage, mork_scope inScope,</span>
<a href="#l10.65"></a><span id="l10.65">     morkStore* ioStore, nsIMdbHeap* ioNodeHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l10.66"></a><span id="l10.66">   void CloseAtomSpace(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l10.67"></a><span id="l10.67"> </span>
<a href="#l10.68"></a><span id="l10.68"> public: // dynamic type identification</span>
<a href="#l10.69"></a><span id="l10.69">   mork_bool IsAtomSpace() const</span>
<a href="#l10.70"></a><span id="l10.70">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kAtomSpace; }</span>
<a href="#l10.71"></a><span id="l10.71"> // } ===== end morkNode methods =====</span>
<a href="#l10.72"></a><span id="l10.72"> </span>
<a href="#l10.73"></a><span id="l10.73"> public: // typing</span>
<a href="#l10.74"></a><span id="l10.74">   void NonAtomSpaceTypeError(morkEnv* ev);</span>
<a href="#l10.75"></a><span id="l10.75"> </span>
<a href="#l10.76"></a><span id="l10.76"> public: // setup</span>
<a href="#l10.77"></a><span id="l10.77"> </span>
<a href="#l10.78"></a><span id="l10.78">   mork_bool MarkAllAtomSpaceContentDirty(morkEnv* ev);</span>
<a href="#l10.79"></a><span id="l10.79" class="difflineminus">-  // MarkAllAtomSpaceContentDirty() visits every space object and marks </span>
<a href="#l10.80"></a><span id="l10.80" class="difflineplus">+  // MarkAllAtomSpaceContentDirty() visits every space object and marks</span>
<a href="#l10.81"></a><span id="l10.81">   // them dirty, including every table, row, cell, and atom.  The return</span>
<a href="#l10.82"></a><span id="l10.82">   // equals ev-&gt;Good(), to show whether any error happened.  This method is</span>
<a href="#l10.83"></a><span id="l10.83">   // intended for use in the beginning of a &quot;compress commit&quot; which writes</span>
<a href="#l10.84"></a><span id="l10.84">   // all store content, whether dirty or not.  We dirty everything first so</span>
<a href="#l10.85"></a><span id="l10.85">   // that later iterations over content can mark things clean as they are</span>
<a href="#l10.86"></a><span id="l10.86">   // written, and organize the process of serialization so that objects are</span>
<a href="#l10.87"></a><span id="l10.87">   // written only at need (because of being dirty).</span>
<a href="#l10.88"></a><span id="l10.88"> </span>
<a href="#l10.89"></a><span id="l10.89" class="difflineat">@@ -127,32 +127,32 @@ public: // other space methods</span>
<a href="#l10.90"></a><span id="l10.90">   // void ReserveColumnAidCount(mork_count inCount)</span>
<a href="#l10.91"></a><span id="l10.91">   // {</span>
<a href="#l10.92"></a><span id="l10.92">   //   mAtomSpace_HighUnderId = morkAtomSpace_kMinUnderId + inCount;</span>
<a href="#l10.93"></a><span id="l10.93">   //   mAtomSpace_HighOverId = morkAtomSpace_kMinOverId + inCount;</span>
<a href="#l10.94"></a><span id="l10.94">   // }</span>
<a href="#l10.95"></a><span id="l10.95"> </span>
<a href="#l10.96"></a><span id="l10.96">   mork_num CutAllAtoms(morkEnv* ev, morkPool* ioPool);</span>
<a href="#l10.97"></a><span id="l10.97">   // CutAllAtoms() puts all the atoms back in the pool.</span>
<a href="#l10.98"></a><span id="l10.98" class="difflineminus">-  </span>
<a href="#l10.99"></a><span id="l10.99" class="difflineplus">+</span>
<a href="#l10.100"></a><span id="l10.100">   morkBookAtom* MakeBookAtomCopyWithAid(morkEnv* ev,</span>
<a href="#l10.101"></a><span id="l10.101">      const morkFarBookAtom&amp; inAtom,  mork_aid inAid);</span>
<a href="#l10.102"></a><span id="l10.102">   // Make copy of inAtom and put it in both maps, using specified ID.</span>
<a href="#l10.103"></a><span id="l10.103" class="difflineminus">-  </span>
<a href="#l10.104"></a><span id="l10.104" class="difflineplus">+</span>
<a href="#l10.105"></a><span id="l10.105">   morkBookAtom* MakeBookAtomCopy(morkEnv* ev, const morkFarBookAtom&amp; inAtom);</span>
<a href="#l10.106"></a><span id="l10.106">   // Make copy of inAtom and put it in both maps, using a new ID as needed.</span>
<a href="#l10.107"></a><span id="l10.107"> </span>
<a href="#l10.108"></a><span id="l10.108">   mork_aid MakeNewAtomId(morkEnv* ev, morkBookAtom* ioAtom);</span>
<a href="#l10.109"></a><span id="l10.109">   // generate an unused atom id.</span>
<a href="#l10.110"></a><span id="l10.110"> </span>
<a href="#l10.111"></a><span id="l10.111"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l10.112"></a><span id="l10.112">   static void SlotWeakAtomSpace(morkAtomSpace* me,</span>
<a href="#l10.113"></a><span id="l10.113">     morkEnv* ev, morkAtomSpace** ioSlot)</span>
<a href="#l10.114"></a><span id="l10.114">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l10.115"></a><span id="l10.115" class="difflineminus">-  </span>
<a href="#l10.116"></a><span id="l10.116" class="difflineplus">+</span>
<a href="#l10.117"></a><span id="l10.117">   static void SlotStrongAtomSpace(morkAtomSpace* me,</span>
<a href="#l10.118"></a><span id="l10.118">     morkEnv* ev, morkAtomSpace** ioSlot)</span>
<a href="#l10.119"></a><span id="l10.119">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l10.120"></a><span id="l10.120"> };</span>
<a href="#l10.121"></a><span id="l10.121"> </span>
<a href="#l10.122"></a><span id="l10.122"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l10.123"></a><span id="l10.123"> </span>
<a href="#l10.124"></a><span id="l10.124"> #define morkDerived_kAtomSpaceMap  /*i*/ 0x615A /* ascii 'aZ' */</span>
<a href="#l10.125"></a><span id="l10.125" class="difflineat">@@ -170,49 +170,49 @@ public:</span>
<a href="#l10.126"></a><span id="l10.126"> public: // other map methods</span>
<a href="#l10.127"></a><span id="l10.127"> </span>
<a href="#l10.128"></a><span id="l10.128">   mork_bool  AddAtomSpace(morkEnv* ev, morkAtomSpace* ioAtomSpace)</span>
<a href="#l10.129"></a><span id="l10.129">   { return this-&gt;AddNode(ev, ioAtomSpace-&gt;SpaceScope(), ioAtomSpace); }</span>
<a href="#l10.130"></a><span id="l10.130">   // the AddAtomSpace() boolean return equals ev-&gt;Good().</span>
<a href="#l10.131"></a><span id="l10.131"> </span>
<a href="#l10.132"></a><span id="l10.132">   mork_bool  CutAtomSpace(morkEnv* ev, mork_scope inScope)</span>
<a href="#l10.133"></a><span id="l10.133">   { return this-&gt;CutNode(ev, inScope); }</span>
<a href="#l10.134"></a><span id="l10.134" class="difflineminus">-  // The CutAtomSpace() boolean return indicates whether removal happened. </span>
<a href="#l10.135"></a><span id="l10.135" class="difflineminus">-  </span>
<a href="#l10.136"></a><span id="l10.136" class="difflineplus">+  // The CutAtomSpace() boolean return indicates whether removal happened.</span>
<a href="#l10.137"></a><span id="l10.137" class="difflineplus">+</span>
<a href="#l10.138"></a><span id="l10.138">   morkAtomSpace*  GetAtomSpace(morkEnv* ev, mork_scope inScope)</span>
<a href="#l10.139"></a><span id="l10.139">   { return (morkAtomSpace*) this-&gt;GetNode(ev, inScope); }</span>
<a href="#l10.140"></a><span id="l10.140">   // Note the returned space does NOT have an increase in refcount for this.</span>
<a href="#l10.141"></a><span id="l10.141"> </span>
<a href="#l10.142"></a><span id="l10.142">   mork_num CutAllAtomSpaces(morkEnv* ev)</span>
<a href="#l10.143"></a><span id="l10.143">   { return this-&gt;CutAllNodes(ev); }</span>
<a href="#l10.144"></a><span id="l10.144">   // CutAllAtomSpaces() releases all the referenced table values.</span>
<a href="#l10.145"></a><span id="l10.145"> };</span>
<a href="#l10.146"></a><span id="l10.146"> </span>
<a href="#l10.147"></a><span id="l10.147"> class morkAtomSpaceMapIter: public morkMapIter{ // typesafe wrapper class</span>
<a href="#l10.148"></a><span id="l10.148"> </span>
<a href="#l10.149"></a><span id="l10.149"> public:</span>
<a href="#l10.150"></a><span id="l10.150">   morkAtomSpaceMapIter(morkEnv* ev, morkAtomSpaceMap* ioMap)</span>
<a href="#l10.151"></a><span id="l10.151">   : morkMapIter(ev, ioMap) { }</span>
<a href="#l10.152"></a><span id="l10.152" class="difflineminus">- </span>
<a href="#l10.153"></a><span id="l10.153" class="difflineplus">+</span>
<a href="#l10.154"></a><span id="l10.154">   morkAtomSpaceMapIter( ) : morkMapIter()  { }</span>
<a href="#l10.155"></a><span id="l10.155">   void InitAtomSpaceMapIter(morkEnv* ev, morkAtomSpaceMap* ioMap)</span>
<a href="#l10.156"></a><span id="l10.156">   { this-&gt;InitMapIter(ev, ioMap); }</span>
<a href="#l10.157"></a><span id="l10.157" class="difflineminus">-   </span>
<a href="#l10.158"></a><span id="l10.158" class="difflineplus">+</span>
<a href="#l10.159"></a><span id="l10.159">   mork_change*</span>
<a href="#l10.160"></a><span id="l10.160">   FirstAtomSpace(morkEnv* ev, mork_scope* outScope, morkAtomSpace** outAtomSpace)</span>
<a href="#l10.161"></a><span id="l10.161">   { return this-&gt;First(ev, outScope, outAtomSpace); }</span>
<a href="#l10.162"></a><span id="l10.162" class="difflineminus">-  </span>
<a href="#l10.163"></a><span id="l10.163" class="difflineplus">+</span>
<a href="#l10.164"></a><span id="l10.164">   mork_change*</span>
<a href="#l10.165"></a><span id="l10.165">   NextAtomSpace(morkEnv* ev, mork_scope* outScope, morkAtomSpace** outAtomSpace)</span>
<a href="#l10.166"></a><span id="l10.166">   { return this-&gt;Next(ev, outScope, outAtomSpace); }</span>
<a href="#l10.167"></a><span id="l10.167" class="difflineminus">-  </span>
<a href="#l10.168"></a><span id="l10.168" class="difflineplus">+</span>
<a href="#l10.169"></a><span id="l10.169">   mork_change*</span>
<a href="#l10.170"></a><span id="l10.170">   HereAtomSpace(morkEnv* ev, mork_scope* outScope, morkAtomSpace** outAtomSpace)</span>
<a href="#l10.171"></a><span id="l10.171">   { return this-&gt;Here(ev, outScope, outAtomSpace); }</span>
<a href="#l10.172"></a><span id="l10.172" class="difflineminus">-  </span>
<a href="#l10.173"></a><span id="l10.173" class="difflineplus">+</span>
<a href="#l10.174"></a><span id="l10.174">   mork_change*</span>
<a href="#l10.175"></a><span id="l10.175">   CutHereAtomSpace(morkEnv* ev, mork_scope* outScope, morkAtomSpace** outAtomSpace)</span>
<a href="#l10.176"></a><span id="l10.176">   { return this-&gt;CutHere(ev, outScope, outAtomSpace); }</span>
<a href="#l10.177"></a><span id="l10.177"> };</span>
<a href="#l10.178"></a><span id="l10.178"> </span>
<a href="#l10.179"></a><span id="l10.179"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l10.180"></a><span id="l10.180"> </span>
<a href="#l10.181"></a><span id="l10.181"> #endif /* _MORKATOMSPACE_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l11.1"></a><span id="l11.1" class="difflineminus">--- a/db/mork/src/morkBead.cpp</span>
<a href="#l11.2"></a><span id="l11.2" class="difflineplus">+++ b/db/mork/src/morkBead.cpp</span>
<a href="#l11.3"></a><span id="l11.3" class="difflineat">@@ -20,17 +20,17 @@</span>
<a href="#l11.4"></a><span id="l11.4"> #endif</span>
<a href="#l11.5"></a><span id="l11.5"> </span>
<a href="#l11.6"></a><span id="l11.6"> #ifndef _MORKBEAD_</span>
<a href="#l11.7"></a><span id="l11.7"> #include &quot;morkBead.h&quot;</span>
<a href="#l11.8"></a><span id="l11.8"> #endif</span>
<a href="#l11.9"></a><span id="l11.9"> </span>
<a href="#l11.10"></a><span id="l11.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l11.11"></a><span id="l11.11"> </span>
<a href="#l11.12"></a><span id="l11.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l11.13"></a><span id="l11.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l11.14"></a><span id="l11.14"> // { ===== begin morkNode interface =====</span>
<a href="#l11.15"></a><span id="l11.15"> </span>
<a href="#l11.16"></a><span id="l11.16"> /*public virtual*/ void</span>
<a href="#l11.17"></a><span id="l11.17"> morkBead::CloseMorkNode(morkEnv* ev) // CloseBead() only if open</span>
<a href="#l11.18"></a><span id="l11.18"> {</span>
<a href="#l11.19"></a><span id="l11.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l11.20"></a><span id="l11.20">   {</span>
<a href="#l11.21"></a><span id="l11.21">     this-&gt;MarkClosing();</span>
<a href="#l11.22"></a><span id="l11.22" class="difflineat">@@ -48,17 +48,17 @@ morkBead::~morkBead() // assert CloseBea</span>
<a href="#l11.23"></a><span id="l11.23"> /*public non-poly*/</span>
<a href="#l11.24"></a><span id="l11.24"> morkBead::morkBead(mork_color inBeadColor)</span>
<a href="#l11.25"></a><span id="l11.25"> : morkNode( morkUsage_kStack )</span>
<a href="#l11.26"></a><span id="l11.26"> , mBead_Color( inBeadColor )</span>
<a href="#l11.27"></a><span id="l11.27"> {</span>
<a href="#l11.28"></a><span id="l11.28"> }</span>
<a href="#l11.29"></a><span id="l11.29"> </span>
<a href="#l11.30"></a><span id="l11.30"> /*public non-poly*/</span>
<a href="#l11.31"></a><span id="l11.31" class="difflineminus">-morkBead::morkBead(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, </span>
<a href="#l11.32"></a><span id="l11.32" class="difflineplus">+morkBead::morkBead(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l11.33"></a><span id="l11.33">   mork_color inBeadColor)</span>
<a href="#l11.34"></a><span id="l11.34"> : morkNode( inUsage, ioHeap )</span>
<a href="#l11.35"></a><span id="l11.35"> , mBead_Color( inBeadColor )</span>
<a href="#l11.36"></a><span id="l11.36"> {</span>
<a href="#l11.37"></a><span id="l11.37"> }</span>
<a href="#l11.38"></a><span id="l11.38"> </span>
<a href="#l11.39"></a><span id="l11.39"> /*public non-poly*/</span>
<a href="#l11.40"></a><span id="l11.40"> morkBead::morkBead(morkEnv* ev,</span>
<a href="#l11.41"></a><span id="l11.41" class="difflineat">@@ -84,21 +84,21 @@ morkBead::CloseBead(morkEnv* ev) // call</span>
<a href="#l11.42"></a><span id="l11.42">         this-&gt;MarkShut();</span>
<a href="#l11.43"></a><span id="l11.43">       }</span>
<a href="#l11.44"></a><span id="l11.44">     }</span>
<a href="#l11.45"></a><span id="l11.45">     else</span>
<a href="#l11.46"></a><span id="l11.46">       this-&gt;NonNodeError(ev);</span>
<a href="#l11.47"></a><span id="l11.47"> }</span>
<a href="#l11.48"></a><span id="l11.48"> </span>
<a href="#l11.49"></a><span id="l11.49"> // } ===== end morkNode methods =====</span>
<a href="#l11.50"></a><span id="l11.50" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l11.51"></a><span id="l11.51" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l11.52"></a><span id="l11.52"> </span>
<a href="#l11.53"></a><span id="l11.53"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l11.54"></a><span id="l11.54"> </span>
<a href="#l11.55"></a><span id="l11.55" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l11.56"></a><span id="l11.56" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l11.57"></a><span id="l11.57"> // { ===== begin morkNode interface =====</span>
<a href="#l11.58"></a><span id="l11.58"> </span>
<a href="#l11.59"></a><span id="l11.59"> /*public virtual*/ void</span>
<a href="#l11.60"></a><span id="l11.60"> morkBeadMap::CloseMorkNode(morkEnv* ev) // CloseBeadMap() only if open</span>
<a href="#l11.61"></a><span id="l11.61"> {</span>
<a href="#l11.62"></a><span id="l11.62">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l11.63"></a><span id="l11.63">   {</span>
<a href="#l11.64"></a><span id="l11.64">     this-&gt;MarkClosing();</span>
<a href="#l11.65"></a><span id="l11.65" class="difflineat">@@ -132,93 +132,93 @@ morkBeadMap::CloseBeadMap(morkEnv* ev) /</span>
<a href="#l11.66"></a><span id="l11.66">       this-&gt;CloseMap(ev);</span>
<a href="#l11.67"></a><span id="l11.67">       this-&gt;MarkShut();</span>
<a href="#l11.68"></a><span id="l11.68">     }</span>
<a href="#l11.69"></a><span id="l11.69">     else</span>
<a href="#l11.70"></a><span id="l11.70">       this-&gt;NonNodeError(ev);</span>
<a href="#l11.71"></a><span id="l11.71"> }</span>
<a href="#l11.72"></a><span id="l11.72"> </span>
<a href="#l11.73"></a><span id="l11.73"> // } ===== end morkNode methods =====</span>
<a href="#l11.74"></a><span id="l11.74" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l11.75"></a><span id="l11.75" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l11.76"></a><span id="l11.76"> </span>
<a href="#l11.77"></a><span id="l11.77"> mork_bool</span>
<a href="#l11.78"></a><span id="l11.78"> morkBeadMap::AddBead(morkEnv* ev, morkBead* ioBead)</span>
<a href="#l11.79"></a><span id="l11.79">   // the AddBead() boolean return equals ev-&gt;Good().</span>
<a href="#l11.80"></a><span id="l11.80"> {</span>
<a href="#l11.81"></a><span id="l11.81">   if ( ioBead &amp;&amp; ev-&gt;Good() )</span>
<a href="#l11.82"></a><span id="l11.82">   {</span>
<a href="#l11.83"></a><span id="l11.83">     morkBead* oldBead = 0; // old key in the map</span>
<a href="#l11.84"></a><span id="l11.84"> </span>
<a href="#l11.85"></a><span id="l11.85">     mork_bool put = this-&gt;Put(ev, &amp;ioBead, /*val*/ (void*) 0,</span>
<a href="#l11.86"></a><span id="l11.86">       /*key*/ &amp;oldBead, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l11.87"></a><span id="l11.87" class="difflineminus">-      </span>
<a href="#l11.88"></a><span id="l11.88" class="difflineplus">+</span>
<a href="#l11.89"></a><span id="l11.89">     if ( put ) // replaced an existing key?</span>
<a href="#l11.90"></a><span id="l11.90">     {</span>
<a href="#l11.91"></a><span id="l11.91">       if ( oldBead != ioBead ) // new bead was not already in table?</span>
<a href="#l11.92"></a><span id="l11.92">         ioBead-&gt;AddStrongRef(ev); // now there's another ref</span>
<a href="#l11.93"></a><span id="l11.93" class="difflineminus">-        </span>
<a href="#l11.94"></a><span id="l11.94" class="difflineplus">+</span>
<a href="#l11.95"></a><span id="l11.95">       if ( oldBead &amp;&amp; oldBead != ioBead ) // need to release old node?</span>
<a href="#l11.96"></a><span id="l11.96">         oldBead-&gt;CutStrongRef(ev);</span>
<a href="#l11.97"></a><span id="l11.97">     }</span>
<a href="#l11.98"></a><span id="l11.98">     else</span>
<a href="#l11.99"></a><span id="l11.99">       ioBead-&gt;AddStrongRef(ev); // another ref if not already in table</span>
<a href="#l11.100"></a><span id="l11.100">   }</span>
<a href="#l11.101"></a><span id="l11.101">   else if ( !ioBead )</span>
<a href="#l11.102"></a><span id="l11.102">     ev-&gt;NilPointerError();</span>
<a href="#l11.103"></a><span id="l11.103" class="difflineminus">-    </span>
<a href="#l11.104"></a><span id="l11.104" class="difflineplus">+</span>
<a href="#l11.105"></a><span id="l11.105">   return ev-&gt;Good();</span>
<a href="#l11.106"></a><span id="l11.106"> }</span>
<a href="#l11.107"></a><span id="l11.107"> </span>
<a href="#l11.108"></a><span id="l11.108"> mork_bool</span>
<a href="#l11.109"></a><span id="l11.109"> morkBeadMap::CutBead(morkEnv* ev, mork_color inColor)</span>
<a href="#l11.110"></a><span id="l11.110"> {</span>
<a href="#l11.111"></a><span id="l11.111">   morkBead* oldBead = 0; // old key in the map</span>
<a href="#l11.112"></a><span id="l11.112">   morkBead bead(inColor);</span>
<a href="#l11.113"></a><span id="l11.113">   morkBead* key = &amp;bead;</span>
<a href="#l11.114"></a><span id="l11.114" class="difflineminus">-  </span>
<a href="#l11.115"></a><span id="l11.115" class="difflineminus">-  mork_bool outCutNode = this-&gt;Cut(ev, &amp;key, </span>
<a href="#l11.116"></a><span id="l11.116" class="difflineplus">+</span>
<a href="#l11.117"></a><span id="l11.117" class="difflineplus">+  mork_bool outCutNode = this-&gt;Cut(ev, &amp;key,</span>
<a href="#l11.118"></a><span id="l11.118">     /*key*/ &amp;oldBead, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l11.119"></a><span id="l11.119" class="difflineminus">-    </span>
<a href="#l11.120"></a><span id="l11.120" class="difflineplus">+</span>
<a href="#l11.121"></a><span id="l11.121">   if ( oldBead )</span>
<a href="#l11.122"></a><span id="l11.122">     oldBead-&gt;CutStrongRef(ev);</span>
<a href="#l11.123"></a><span id="l11.123" class="difflineminus">-  </span>
<a href="#l11.124"></a><span id="l11.124" class="difflineplus">+</span>
<a href="#l11.125"></a><span id="l11.125">   bead.CloseBead(ev);</span>
<a href="#l11.126"></a><span id="l11.126">   return outCutNode;</span>
<a href="#l11.127"></a><span id="l11.127"> }</span>
<a href="#l11.128"></a><span id="l11.128"> </span>
<a href="#l11.129"></a><span id="l11.129"> morkBead*</span>
<a href="#l11.130"></a><span id="l11.130"> morkBeadMap::GetBead(morkEnv* ev, mork_color inColor)</span>
<a href="#l11.131"></a><span id="l11.131">   // Note the returned bead does NOT have an increase in refcount for this.</span>
<a href="#l11.132"></a><span id="l11.132"> {</span>
<a href="#l11.133"></a><span id="l11.133">   morkBead* oldBead = 0; // old key in the map</span>
<a href="#l11.134"></a><span id="l11.134">   morkBead bead(inColor);</span>
<a href="#l11.135"></a><span id="l11.135">   morkBead* key = &amp;bead;</span>
<a href="#l11.136"></a><span id="l11.136"> </span>
<a href="#l11.137"></a><span id="l11.137">   this-&gt;Get(ev, &amp;key, /*key*/ &amp;oldBead, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l11.138"></a><span id="l11.138" class="difflineminus">-  </span>
<a href="#l11.139"></a><span id="l11.139" class="difflineplus">+</span>
<a href="#l11.140"></a><span id="l11.140">   bead.CloseBead(ev);</span>
<a href="#l11.141"></a><span id="l11.141">   return oldBead;</span>
<a href="#l11.142"></a><span id="l11.142"> }</span>
<a href="#l11.143"></a><span id="l11.143"> </span>
<a href="#l11.144"></a><span id="l11.144"> mork_num</span>
<a href="#l11.145"></a><span id="l11.145"> morkBeadMap::CutAllBeads(morkEnv* ev)</span>
<a href="#l11.146"></a><span id="l11.146">   // CutAllBeads() releases all the referenced beads.</span>
<a href="#l11.147"></a><span id="l11.147"> {</span>
<a href="#l11.148"></a><span id="l11.148">   mork_num outSlots = mMap_Slots;</span>
<a href="#l11.149"></a><span id="l11.149" class="difflineminus">-  </span>
<a href="#l11.150"></a><span id="l11.150" class="difflineplus">+</span>
<a href="#l11.151"></a><span id="l11.151">   morkBeadMapIter i(ev, this);</span>
<a href="#l11.152"></a><span id="l11.152">   morkBead* b = i.FirstBead(ev);</span>
<a href="#l11.153"></a><span id="l11.153"> </span>
<a href="#l11.154"></a><span id="l11.154">   while ( b )</span>
<a href="#l11.155"></a><span id="l11.155">   {</span>
<a href="#l11.156"></a><span id="l11.156">     b-&gt;CutStrongRef(ev);</span>
<a href="#l11.157"></a><span id="l11.157">     i.CutHereBead(ev);</span>
<a href="#l11.158"></a><span id="l11.158">     b = i.NextBead(ev);</span>
<a href="#l11.159"></a><span id="l11.159">   }</span>
<a href="#l11.160"></a><span id="l11.160" class="difflineminus">-  </span>
<a href="#l11.161"></a><span id="l11.161" class="difflineplus">+</span>
<a href="#l11.162"></a><span id="l11.162">   return outSlots;</span>
<a href="#l11.163"></a><span id="l11.163"> }</span>
<a href="#l11.164"></a><span id="l11.164"> </span>
<a href="#l11.165"></a><span id="l11.165"> </span>
<a href="#l11.166"></a><span id="l11.166"> // { ===== begin morkMap poly interface =====</span>
<a href="#l11.167"></a><span id="l11.167"> /*virtual*/ mork_bool</span>
<a href="#l11.168"></a><span id="l11.168"> morkBeadMap::Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const</span>
<a href="#l11.169"></a><span id="l11.169"> {</span>
<a href="#l11.170"></a><span id="l11.170" class="difflineat">@@ -233,17 +233,17 @@ morkBeadMap::Hash(morkEnv* ev, const voi</span>
<a href="#l11.171"></a><span id="l11.171">   MORK_USED_1(ev);</span>
<a href="#l11.172"></a><span id="l11.172">     return (*(const morkBead**) inKey)-&gt;BeadHash();</span>
<a href="#l11.173"></a><span id="l11.173"> }</span>
<a href="#l11.174"></a><span id="l11.174"> // } ===== end morkMap poly interface =====</span>
<a href="#l11.175"></a><span id="l11.175"> </span>
<a href="#l11.176"></a><span id="l11.176"> </span>
<a href="#l11.177"></a><span id="l11.177"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l11.178"></a><span id="l11.178"> </span>
<a href="#l11.179"></a><span id="l11.179" class="difflineminus">- </span>
<a href="#l11.180"></a><span id="l11.180" class="difflineplus">+</span>
<a href="#l11.181"></a><span id="l11.181"> morkBead* morkBeadMapIter::FirstBead(morkEnv* ev)</span>
<a href="#l11.182"></a><span id="l11.182"> {</span>
<a href="#l11.183"></a><span id="l11.183">   morkBead* bead = 0;</span>
<a href="#l11.184"></a><span id="l11.184">   this-&gt;First(ev, &amp;bead, /*val*/ (void*) 0);</span>
<a href="#l11.185"></a><span id="l11.185">   return bead;</span>
<a href="#l11.186"></a><span id="l11.186"> }</span>
<a href="#l11.187"></a><span id="l11.187"> </span>
<a href="#l11.188"></a><span id="l11.188"> morkBead* morkBeadMapIter::NextBead(morkEnv* ev)</span>
<a href="#l11.189"></a><span id="l11.189" class="difflineat">@@ -264,17 +264,17 @@ void morkBeadMapIter::CutHereBead(morkEn</span>
<a href="#l11.190"></a><span id="l11.190"> {</span>
<a href="#l11.191"></a><span id="l11.191">   this-&gt;CutHere(ev, /*key*/ (void*) 0, /*val*/ (void*) 0);</span>
<a href="#l11.192"></a><span id="l11.192"> }</span>
<a href="#l11.193"></a><span id="l11.193"> </span>
<a href="#l11.194"></a><span id="l11.194"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l11.195"></a><span id="l11.195"> </span>
<a href="#l11.196"></a><span id="l11.196"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l11.197"></a><span id="l11.197"> </span>
<a href="#l11.198"></a><span id="l11.198" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l11.199"></a><span id="l11.199" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l11.200"></a><span id="l11.200"> // { ===== begin morkNode interface =====</span>
<a href="#l11.201"></a><span id="l11.201"> </span>
<a href="#l11.202"></a><span id="l11.202"> /*public virtual*/ void</span>
<a href="#l11.203"></a><span id="l11.203"> morkBeadProbeMap::CloseMorkNode(morkEnv* ev) // CloseBeadProbeMap() if open</span>
<a href="#l11.204"></a><span id="l11.204"> {</span>
<a href="#l11.205"></a><span id="l11.205">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l11.206"></a><span id="l11.206">   {</span>
<a href="#l11.207"></a><span id="l11.207">     this-&gt;MarkClosing();</span>
<a href="#l11.208"></a><span id="l11.208" class="difflineat">@@ -290,17 +290,17 @@ morkBeadProbeMap::~morkBeadProbeMap() //</span>
<a href="#l11.209"></a><span id="l11.209"> }</span>
<a href="#l11.210"></a><span id="l11.210"> </span>
<a href="#l11.211"></a><span id="l11.211"> </span>
<a href="#l11.212"></a><span id="l11.212"> /*public non-poly*/</span>
<a href="#l11.213"></a><span id="l11.213"> morkBeadProbeMap::morkBeadProbeMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l11.214"></a><span id="l11.214">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap)</span>
<a href="#l11.215"></a><span id="l11.215"> : morkProbeMap(ev, inUsage, ioHeap,</span>
<a href="#l11.216"></a><span id="l11.216">   /*inKeySize*/ sizeof(morkBead*), /*inValSize*/ 0,</span>
<a href="#l11.217"></a><span id="l11.217" class="difflineminus">-  ioSlotHeap, /*startSlotCount*/ 11, </span>
<a href="#l11.218"></a><span id="l11.218" class="difflineplus">+  ioSlotHeap, /*startSlotCount*/ 11,</span>
<a href="#l11.219"></a><span id="l11.219">   /*inZeroIsClearKey*/ morkBool_kTrue)</span>
<a href="#l11.220"></a><span id="l11.220"> {</span>
<a href="#l11.221"></a><span id="l11.221">   if ( ev-&gt;Good() )</span>
<a href="#l11.222"></a><span id="l11.222">     mNode_Derived = morkDerived_kBeadProbeMap;</span>
<a href="#l11.223"></a><span id="l11.223"> }</span>
<a href="#l11.224"></a><span id="l11.224"> </span>
<a href="#l11.225"></a><span id="l11.225"> /*public non-poly*/ void</span>
<a href="#l11.226"></a><span id="l11.226"> morkBeadProbeMap::CloseBeadProbeMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l11.227"></a><span id="l11.227" class="difflineat">@@ -311,17 +311,17 @@ morkBeadProbeMap::CloseBeadProbeMap(mork</span>
<a href="#l11.228"></a><span id="l11.228">       this-&gt;CloseProbeMap(ev);</span>
<a href="#l11.229"></a><span id="l11.229">       this-&gt;MarkShut();</span>
<a href="#l11.230"></a><span id="l11.230">     }</span>
<a href="#l11.231"></a><span id="l11.231">     else</span>
<a href="#l11.232"></a><span id="l11.232">       this-&gt;NonNodeError(ev);</span>
<a href="#l11.233"></a><span id="l11.233"> }</span>
<a href="#l11.234"></a><span id="l11.234"> </span>
<a href="#l11.235"></a><span id="l11.235"> // } ===== end morkNode methods =====</span>
<a href="#l11.236"></a><span id="l11.236" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l11.237"></a><span id="l11.237" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l11.238"></a><span id="l11.238"> </span>
<a href="#l11.239"></a><span id="l11.239"> /*virtual*/ mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l11.240"></a><span id="l11.240"> morkBeadProbeMap::MapTest(morkEnv* ev, const void* inMapKey,</span>
<a href="#l11.241"></a><span id="l11.241">   const void* inAppKey) const</span>
<a href="#l11.242"></a><span id="l11.242"> {</span>
<a href="#l11.243"></a><span id="l11.243">   MORK_USED_1(ev);</span>
<a href="#l11.244"></a><span id="l11.244">   const morkBead* key = *(const morkBead**) inMapKey;</span>
<a href="#l11.245"></a><span id="l11.245">   if ( key )</span>
<a href="#l11.246"></a><span id="l11.246" class="difflineat">@@ -341,17 +341,17 @@ morkBeadProbeMap::MapHash(morkEnv* ev, c</span>
<a href="#l11.247"></a><span id="l11.247">     return key-&gt;BeadHash();</span>
<a href="#l11.248"></a><span id="l11.248">   else</span>
<a href="#l11.249"></a><span id="l11.249">   {</span>
<a href="#l11.250"></a><span id="l11.250">     ev-&gt;NilPointerWarning();</span>
<a href="#l11.251"></a><span id="l11.251">     return 0;</span>
<a href="#l11.252"></a><span id="l11.252">   }</span>
<a href="#l11.253"></a><span id="l11.253"> }</span>
<a href="#l11.254"></a><span id="l11.254"> </span>
<a href="#l11.255"></a><span id="l11.255" class="difflineminus">-/*virtual*/ mork_u4 </span>
<a href="#l11.256"></a><span id="l11.256" class="difflineplus">+/*virtual*/ mork_u4</span>
<a href="#l11.257"></a><span id="l11.257"> morkBeadProbeMap::ProbeMapHashMapKey(morkEnv* ev,</span>
<a href="#l11.258"></a><span id="l11.258">   const void* inMapKey) const</span>
<a href="#l11.259"></a><span id="l11.259"> {</span>
<a href="#l11.260"></a><span id="l11.260">   const morkBead* key = *(const morkBead**) inMapKey;</span>
<a href="#l11.261"></a><span id="l11.261">   if ( key )</span>
<a href="#l11.262"></a><span id="l11.262">     return key-&gt;BeadHash();</span>
<a href="#l11.263"></a><span id="l11.263">   else</span>
<a href="#l11.264"></a><span id="l11.264">   {</span>
<a href="#l11.265"></a><span id="l11.265" class="difflineat">@@ -361,65 +361,65 @@ morkBeadProbeMap::ProbeMapHashMapKey(mor</span>
<a href="#l11.266"></a><span id="l11.266"> }</span>
<a href="#l11.267"></a><span id="l11.267"> </span>
<a href="#l11.268"></a><span id="l11.268"> mork_bool</span>
<a href="#l11.269"></a><span id="l11.269"> morkBeadProbeMap::AddBead(morkEnv* ev, morkBead* ioBead)</span>
<a href="#l11.270"></a><span id="l11.270"> {</span>
<a href="#l11.271"></a><span id="l11.271">   if ( ioBead &amp;&amp; ev-&gt;Good() )</span>
<a href="#l11.272"></a><span id="l11.272">   {</span>
<a href="#l11.273"></a><span id="l11.273">     morkBead* bead = 0; // old key in the map</span>
<a href="#l11.274"></a><span id="l11.274" class="difflineminus">-    </span>
<a href="#l11.275"></a><span id="l11.275" class="difflineminus">-    mork_bool put = this-&gt;MapAtPut(ev, &amp;ioBead, /*val*/ (void*) 0, </span>
<a href="#l11.276"></a><span id="l11.276" class="difflineplus">+</span>
<a href="#l11.277"></a><span id="l11.277" class="difflineplus">+    mork_bool put = this-&gt;MapAtPut(ev, &amp;ioBead, /*val*/ (void*) 0,</span>
<a href="#l11.278"></a><span id="l11.278">       /*key*/ &amp;bead, /*val*/ (void*) 0);</span>
<a href="#l11.279"></a><span id="l11.279" class="difflineminus">-          </span>
<a href="#l11.280"></a><span id="l11.280" class="difflineplus">+</span>
<a href="#l11.281"></a><span id="l11.281">     if ( put ) // replaced an existing key?</span>
<a href="#l11.282"></a><span id="l11.282">     {</span>
<a href="#l11.283"></a><span id="l11.283">       if ( bead != ioBead ) // new bead was not already in table?</span>
<a href="#l11.284"></a><span id="l11.284">         ioBead-&gt;AddStrongRef(ev); // now there's another ref</span>
<a href="#l11.285"></a><span id="l11.285" class="difflineminus">-        </span>
<a href="#l11.286"></a><span id="l11.286" class="difflineplus">+</span>
<a href="#l11.287"></a><span id="l11.287">       if ( bead &amp;&amp; bead != ioBead ) // need to release old node?</span>
<a href="#l11.288"></a><span id="l11.288">         bead-&gt;CutStrongRef(ev);</span>
<a href="#l11.289"></a><span id="l11.289">     }</span>
<a href="#l11.290"></a><span id="l11.290">     else</span>
<a href="#l11.291"></a><span id="l11.291">       ioBead-&gt;AddStrongRef(ev); // now there's another ref</span>
<a href="#l11.292"></a><span id="l11.292">   }</span>
<a href="#l11.293"></a><span id="l11.293">   else if ( !ioBead )</span>
<a href="#l11.294"></a><span id="l11.294">     ev-&gt;NilPointerError();</span>
<a href="#l11.295"></a><span id="l11.295" class="difflineminus">-    </span>
<a href="#l11.296"></a><span id="l11.296" class="difflineplus">+</span>
<a href="#l11.297"></a><span id="l11.297">   return ev-&gt;Good();</span>
<a href="#l11.298"></a><span id="l11.298"> }</span>
<a href="#l11.299"></a><span id="l11.299"> </span>
<a href="#l11.300"></a><span id="l11.300"> morkBead*</span>
<a href="#l11.301"></a><span id="l11.301"> morkBeadProbeMap::GetBead(morkEnv* ev, mork_color inColor)</span>
<a href="#l11.302"></a><span id="l11.302"> {</span>
<a href="#l11.303"></a><span id="l11.303">   morkBead* oldBead = 0; // old key in the map</span>
<a href="#l11.304"></a><span id="l11.304">   morkBead bead(inColor);</span>
<a href="#l11.305"></a><span id="l11.305">   morkBead* key = &amp;bead;</span>
<a href="#l11.306"></a><span id="l11.306"> </span>
<a href="#l11.307"></a><span id="l11.307">   this-&gt;MapAt(ev, &amp;key, &amp;oldBead, /*val*/ (void*) 0);</span>
<a href="#l11.308"></a><span id="l11.308" class="difflineminus">-  </span>
<a href="#l11.309"></a><span id="l11.309" class="difflineplus">+</span>
<a href="#l11.310"></a><span id="l11.310">   bead.CloseBead(ev);</span>
<a href="#l11.311"></a><span id="l11.311">   return oldBead;</span>
<a href="#l11.312"></a><span id="l11.312"> }</span>
<a href="#l11.313"></a><span id="l11.313"> </span>
<a href="#l11.314"></a><span id="l11.314"> mork_num</span>
<a href="#l11.315"></a><span id="l11.315"> morkBeadProbeMap::CutAllBeads(morkEnv* ev)</span>
<a href="#l11.316"></a><span id="l11.316">   // CutAllBeads() releases all the referenced bead values.</span>
<a href="#l11.317"></a><span id="l11.317"> {</span>
<a href="#l11.318"></a><span id="l11.318">   mork_num outSlots = sMap_Slots;</span>
<a href="#l11.319"></a><span id="l11.319" class="difflineminus">-  </span>
<a href="#l11.320"></a><span id="l11.320" class="difflineplus">+</span>
<a href="#l11.321"></a><span id="l11.321">   morkBeadProbeMapIter i(ev, this);</span>
<a href="#l11.322"></a><span id="l11.322">   morkBead* b = i.FirstBead(ev);</span>
<a href="#l11.323"></a><span id="l11.323"> </span>
<a href="#l11.324"></a><span id="l11.324">   while ( b )</span>
<a href="#l11.325"></a><span id="l11.325">   {</span>
<a href="#l11.326"></a><span id="l11.326">     b-&gt;CutStrongRef(ev);</span>
<a href="#l11.327"></a><span id="l11.327">     b = i.NextBead(ev);</span>
<a href="#l11.328"></a><span id="l11.328">   }</span>
<a href="#l11.329"></a><span id="l11.329">   this-&gt;MapCutAll(ev);</span>
<a href="#l11.330"></a><span id="l11.330" class="difflineminus">-  </span>
<a href="#l11.331"></a><span id="l11.331" class="difflineplus">+</span>
<a href="#l11.332"></a><span id="l11.332">   return outSlots;</span>
<a href="#l11.333"></a><span id="l11.333"> }</span>
<a href="#l11.334"></a><span id="l11.334"> </span>
<a href="#l11.335"></a><span id="l11.335"> </span>
<a href="#l11.336"></a><span id="l11.336"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l11.337"></a><span id="l11.337"> </span>
<a href="#l11.338"></a><span id="l11.338"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l12.1"></a><span id="l12.1" class="difflineminus">--- a/db/mork/src/morkBead.h</span>
<a href="#l12.2"></a><span id="l12.2" class="difflineplus">+++ b/db/mork/src/morkBead.h</span>
<a href="#l12.3"></a><span id="l12.3" class="difflineat">@@ -25,75 +25,75 @@</span>
<a href="#l12.4"></a><span id="l12.4"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l12.5"></a><span id="l12.5"> </span>
<a href="#l12.6"></a><span id="l12.6"> #define morkDerived_kBead   /*i*/ 0x426F /* ascii 'Bo' */</span>
<a href="#l12.7"></a><span id="l12.7"> </span>
<a href="#l12.8"></a><span id="l12.8"> /*| morkBead: subclass of morkNode that adds knowledge of db suite factory</span>
<a href="#l12.9"></a><span id="l12.9"> **| and containing port to those objects that are exposed as instances of</span>
<a href="#l12.10"></a><span id="l12.10"> **| nsIMdbBead in the public interface.</span>
<a href="#l12.11"></a><span id="l12.11"> |*/</span>
<a href="#l12.12"></a><span id="l12.12" class="difflineminus">-class morkBead : public morkNode { </span>
<a href="#l12.13"></a><span id="l12.13" class="difflineplus">+class morkBead : public morkNode {</span>
<a href="#l12.14"></a><span id="l12.14"> </span>
<a href="#l12.15"></a><span id="l12.15"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l12.16"></a><span id="l12.16">   // nsIMdbHeap*    mNode_Heap;</span>
<a href="#l12.17"></a><span id="l12.17"> </span>
<a href="#l12.18"></a><span id="l12.18">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l12.19"></a><span id="l12.19">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l12.20"></a><span id="l12.20" class="difflineminus">-  </span>
<a href="#l12.21"></a><span id="l12.21" class="difflineplus">+</span>
<a href="#l12.22"></a><span id="l12.22">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l12.23"></a><span id="l12.23">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l12.24"></a><span id="l12.24">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l12.25"></a><span id="l12.25">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l12.26"></a><span id="l12.26" class="difflineminus">-  </span>
<a href="#l12.27"></a><span id="l12.27" class="difflineplus">+</span>
<a href="#l12.28"></a><span id="l12.28">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l12.29"></a><span id="l12.29">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l12.30"></a><span id="l12.30" class="difflineminus">-  </span>
<a href="#l12.31"></a><span id="l12.31" class="difflineplus">+</span>
<a href="#l12.32"></a><span id="l12.32"> public: // state is public because the entire Mork system is private</span>
<a href="#l12.33"></a><span id="l12.33"> </span>
<a href="#l12.34"></a><span id="l12.34">   mork_color      mBead_Color;   // ID for this bead</span>
<a href="#l12.35"></a><span id="l12.35"> </span>
<a href="#l12.36"></a><span id="l12.36"> public: // Hash() and Equal() for bead maps are same for all subclasses:</span>
<a href="#l12.37"></a><span id="l12.37"> </span>
<a href="#l12.38"></a><span id="l12.38">   mork_u4 BeadHash() const { return (mork_u4) mBead_Color; }</span>
<a href="#l12.39"></a><span id="l12.39">   mork_bool BeadEqual(const morkBead* inBead) const</span>
<a href="#l12.40"></a><span id="l12.40">   { return ( mBead_Color == inBead-&gt;mBead_Color); }</span>
<a href="#l12.41"></a><span id="l12.41" class="difflineminus">-  </span>
<a href="#l12.42"></a><span id="l12.42" class="difflineplus">+</span>
<a href="#l12.43"></a><span id="l12.43"> // { ===== begin morkNode interface =====</span>
<a href="#l12.44"></a><span id="l12.44"> public: // morkNode virtual methods</span>
<a href="#l12.45"></a><span id="l12.45">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseBead() only if open</span>
<a href="#l12.46"></a><span id="l12.46">   virtual ~morkBead(); // assert that CloseBead() executed earlier</span>
<a href="#l12.47"></a><span id="l12.47" class="difflineminus">-  </span>
<a href="#l12.48"></a><span id="l12.48" class="difflineplus">+</span>
<a href="#l12.49"></a><span id="l12.49"> public: // special case for stack construction for map usage:</span>
<a href="#l12.50"></a><span id="l12.50">   morkBead(mork_color inBeadColor); // stack-based bead instance</span>
<a href="#l12.51"></a><span id="l12.51" class="difflineminus">-  </span>
<a href="#l12.52"></a><span id="l12.52" class="difflineplus">+</span>
<a href="#l12.53"></a><span id="l12.53"> protected: // special case for morkObject:</span>
<a href="#l12.54"></a><span id="l12.54">   morkBead(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l12.55"></a><span id="l12.55">     mork_color inBeadColor);</span>
<a href="#l12.56"></a><span id="l12.56" class="difflineminus">-  </span>
<a href="#l12.57"></a><span id="l12.57" class="difflineplus">+</span>
<a href="#l12.58"></a><span id="l12.58"> public: // morkEnv construction &amp; destruction</span>
<a href="#l12.59"></a><span id="l12.59" class="difflineminus">-  morkBead(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, </span>
<a href="#l12.60"></a><span id="l12.60" class="difflineplus">+  morkBead(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l12.61"></a><span id="l12.61">      mork_color inBeadColor);</span>
<a href="#l12.62"></a><span id="l12.62">   void CloseBead(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l12.63"></a><span id="l12.63"> </span>
<a href="#l12.64"></a><span id="l12.64"> private: // copying is not allowed</span>
<a href="#l12.65"></a><span id="l12.65">   morkBead(const morkBead&amp; other);</span>
<a href="#l12.66"></a><span id="l12.66">   morkBead&amp; operator=(const morkBead&amp; other);</span>
<a href="#l12.67"></a><span id="l12.67"> </span>
<a href="#l12.68"></a><span id="l12.68"> public: // dynamic type identification</span>
<a href="#l12.69"></a><span id="l12.69">   mork_bool IsBead() const</span>
<a href="#l12.70"></a><span id="l12.70">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kBead; }</span>
<a href="#l12.71"></a><span id="l12.71"> // } ===== end morkNode methods =====</span>
<a href="#l12.72"></a><span id="l12.72"> </span>
<a href="#l12.73"></a><span id="l12.73">   // void NewNilHandleError(morkEnv* ev); // mBead_Handle is nil</span>
<a href="#l12.74"></a><span id="l12.74" class="difflineminus">-  </span>
<a href="#l12.75"></a><span id="l12.75" class="difflineplus">+</span>
<a href="#l12.76"></a><span id="l12.76"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l12.77"></a><span id="l12.77">   static void SlotWeakBead(morkBead* me,</span>
<a href="#l12.78"></a><span id="l12.78">     morkEnv* ev, morkBead** ioSlot)</span>
<a href="#l12.79"></a><span id="l12.79">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l12.80"></a><span id="l12.80" class="difflineminus">-  </span>
<a href="#l12.81"></a><span id="l12.81" class="difflineplus">+</span>
<a href="#l12.82"></a><span id="l12.82">   static void SlotStrongBead(morkBead* me,</span>
<a href="#l12.83"></a><span id="l12.83">     morkEnv* ev, morkBead** ioSlot)</span>
<a href="#l12.84"></a><span id="l12.84">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l12.85"></a><span id="l12.85"> };</span>
<a href="#l12.86"></a><span id="l12.86"> </span>
<a href="#l12.87"></a><span id="l12.87"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l12.88"></a><span id="l12.88"> </span>
<a href="#l12.89"></a><span id="l12.89"> #define morkDerived_kBeadMap  /*i*/ 0x744D /* ascii 'bM' */</span>
<a href="#l12.90"></a><span id="l12.90" class="difflineat">@@ -102,17 +102,17 @@ public: // typesafe refcounting inlines </span>
<a href="#l12.91"></a><span id="l12.91"> |*/</span>
<a href="#l12.92"></a><span id="l12.92"> class morkBeadMap : public morkMap {</span>
<a href="#l12.93"></a><span id="l12.93"> </span>
<a href="#l12.94"></a><span id="l12.94"> </span>
<a href="#l12.95"></a><span id="l12.95"> // { ===== begin morkNode interface =====</span>
<a href="#l12.96"></a><span id="l12.96"> public: // morkNode virtual methods</span>
<a href="#l12.97"></a><span id="l12.97">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseBeadMap() only if open</span>
<a href="#l12.98"></a><span id="l12.98">   virtual ~morkBeadMap(); // assert that CloseBeadMap() executed earlier</span>
<a href="#l12.99"></a><span id="l12.99" class="difflineminus">-  </span>
<a href="#l12.100"></a><span id="l12.100" class="difflineplus">+</span>
<a href="#l12.101"></a><span id="l12.101"> public: // morkMap construction &amp; destruction</span>
<a href="#l12.102"></a><span id="l12.102">   morkBeadMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l12.103"></a><span id="l12.103">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l12.104"></a><span id="l12.104">   void CloseBeadMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l12.105"></a><span id="l12.105"> </span>
<a href="#l12.106"></a><span id="l12.106"> public: // dynamic type identification</span>
<a href="#l12.107"></a><span id="l12.107">   mork_bool IsBeadMap() const</span>
<a href="#l12.108"></a><span id="l12.108">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kBeadMap; }</span>
<a href="#l12.109"></a><span id="l12.109" class="difflineat">@@ -128,40 +128,40 @@ public:</span>
<a href="#l12.110"></a><span id="l12.110"> // } ===== end morkMap poly interface =====</span>
<a href="#l12.111"></a><span id="l12.111"> </span>
<a href="#l12.112"></a><span id="l12.112"> public: // other map methods</span>
<a href="#l12.113"></a><span id="l12.113"> </span>
<a href="#l12.114"></a><span id="l12.114">   mork_bool  AddBead(morkEnv* ev, morkBead* ioBead);</span>
<a href="#l12.115"></a><span id="l12.115">   // the AddBead() boolean return equals ev-&gt;Good().</span>
<a href="#l12.116"></a><span id="l12.116"> </span>
<a href="#l12.117"></a><span id="l12.117">   mork_bool  CutBead(morkEnv* ev, mork_color inColor);</span>
<a href="#l12.118"></a><span id="l12.118" class="difflineminus">-  // The CutBead() boolean return indicates whether removal happened. </span>
<a href="#l12.119"></a><span id="l12.119" class="difflineminus">-  </span>
<a href="#l12.120"></a><span id="l12.120" class="difflineplus">+  // The CutBead() boolean return indicates whether removal happened.</span>
<a href="#l12.121"></a><span id="l12.121" class="difflineplus">+</span>
<a href="#l12.122"></a><span id="l12.122">   morkBead*  GetBead(morkEnv* ev, mork_color inColor);</span>
<a href="#l12.123"></a><span id="l12.123">   // Note the returned bead does NOT have an increase in refcount for this.</span>
<a href="#l12.124"></a><span id="l12.124"> </span>
<a href="#l12.125"></a><span id="l12.125">   mork_num CutAllBeads(morkEnv* ev);</span>
<a href="#l12.126"></a><span id="l12.126">   // CutAllBeads() releases all the referenced beads.</span>
<a href="#l12.127"></a><span id="l12.127"> };</span>
<a href="#l12.128"></a><span id="l12.128"> </span>
<a href="#l12.129"></a><span id="l12.129"> class morkBeadMapIter: public morkMapIter{ // typesafe wrapper class</span>
<a href="#l12.130"></a><span id="l12.130"> </span>
<a href="#l12.131"></a><span id="l12.131"> public:</span>
<a href="#l12.132"></a><span id="l12.132">   morkBeadMapIter(morkEnv* ev, morkBeadMap* ioMap)</span>
<a href="#l12.133"></a><span id="l12.133">   : morkMapIter(ev, ioMap) { }</span>
<a href="#l12.134"></a><span id="l12.134" class="difflineminus">- </span>
<a href="#l12.135"></a><span id="l12.135" class="difflineplus">+</span>
<a href="#l12.136"></a><span id="l12.136">   morkBeadMapIter( ) : morkMapIter()  { }</span>
<a href="#l12.137"></a><span id="l12.137">   void InitBeadMapIter(morkEnv* ev, morkBeadMap* ioMap)</span>
<a href="#l12.138"></a><span id="l12.138">   { this-&gt;InitMapIter(ev, ioMap); }</span>
<a href="#l12.139"></a><span id="l12.139" class="difflineminus">-   </span>
<a href="#l12.140"></a><span id="l12.140" class="difflineplus">+</span>
<a href="#l12.141"></a><span id="l12.141">   morkBead* FirstBead(morkEnv* ev);</span>
<a href="#l12.142"></a><span id="l12.142">   morkBead* NextBead(morkEnv* ev);</span>
<a href="#l12.143"></a><span id="l12.143">   morkBead* HereBead(morkEnv* ev);</span>
<a href="#l12.144"></a><span id="l12.144">   void      CutHereBead(morkEnv* ev);</span>
<a href="#l12.145"></a><span id="l12.145" class="difflineminus">-  </span>
<a href="#l12.146"></a><span id="l12.146" class="difflineplus">+</span>
<a href="#l12.147"></a><span id="l12.147"> };</span>
<a href="#l12.148"></a><span id="l12.148"> </span>
<a href="#l12.149"></a><span id="l12.149"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l12.150"></a><span id="l12.150"> </span>
<a href="#l12.151"></a><span id="l12.151"> #define morkDerived_kBeadProbeMap  /*i*/ 0x6D74 /* ascii 'mb' */</span>
<a href="#l12.152"></a><span id="l12.152"> </span>
<a href="#l12.153"></a><span id="l12.153"> /*| morkBeadProbeMap: maps bead -&gt; bead (key only using mBead_Color)</span>
<a href="#l12.154"></a><span id="l12.154"> |*/</span>
<a href="#l12.155"></a><span id="l12.155" class="difflineat">@@ -206,40 +206,40 @@ public:</span>
<a href="#l12.156"></a><span id="l12.156">   //   const void* inMapKey, const void* inMapVal, // (key,val) inside map</span>
<a href="#l12.157"></a><span id="l12.157">   //   void* outAppKey, void* outAppVal) const;    // (key,val) outside map</span>
<a href="#l12.158"></a><span id="l12.158">   // } ===== end morkProbeMap methods =====</span>
<a href="#l12.159"></a><span id="l12.159"> </span>
<a href="#l12.160"></a><span id="l12.160"> public: // other map methods</span>
<a href="#l12.161"></a><span id="l12.161"> </span>
<a href="#l12.162"></a><span id="l12.162">   mork_bool  AddBead(morkEnv* ev, morkBead* ioBead);</span>
<a href="#l12.163"></a><span id="l12.163">   // the AddBead() boolean return equals ev-&gt;Good().</span>
<a href="#l12.164"></a><span id="l12.164" class="difflineminus">-  </span>
<a href="#l12.165"></a><span id="l12.165" class="difflineplus">+</span>
<a href="#l12.166"></a><span id="l12.166">   morkBead*  GetBead(morkEnv* ev, mork_color inColor);</span>
<a href="#l12.167"></a><span id="l12.167">   // Note the returned bead does NOT have an increase in refcount for this.</span>
<a href="#l12.168"></a><span id="l12.168"> </span>
<a href="#l12.169"></a><span id="l12.169">   mork_num   CutAllBeads(morkEnv* ev);</span>
<a href="#l12.170"></a><span id="l12.170">   // CutAllBeads() releases all the referenced bead values.</span>
<a href="#l12.171"></a><span id="l12.171"> };</span>
<a href="#l12.172"></a><span id="l12.172"> </span>
<a href="#l12.173"></a><span id="l12.173"> class morkBeadProbeMapIter: public morkProbeMapIter { // typesafe wrapper class</span>
<a href="#l12.174"></a><span id="l12.174"> </span>
<a href="#l12.175"></a><span id="l12.175"> public:</span>
<a href="#l12.176"></a><span id="l12.176">   morkBeadProbeMapIter(morkEnv* ev, morkBeadProbeMap* ioMap)</span>
<a href="#l12.177"></a><span id="l12.177">   : morkProbeMapIter(ev, ioMap) { }</span>
<a href="#l12.178"></a><span id="l12.178" class="difflineminus">- </span>
<a href="#l12.179"></a><span id="l12.179" class="difflineplus">+</span>
<a href="#l12.180"></a><span id="l12.180">   morkBeadProbeMapIter( ) : morkProbeMapIter()  { }</span>
<a href="#l12.181"></a><span id="l12.181">   void InitBeadProbeMapIter(morkEnv* ev, morkBeadProbeMap* ioMap)</span>
<a href="#l12.182"></a><span id="l12.182">   { this-&gt;InitProbeMapIter(ev, ioMap); }</span>
<a href="#l12.183"></a><span id="l12.183" class="difflineminus">-   </span>
<a href="#l12.184"></a><span id="l12.184" class="difflineplus">+</span>
<a href="#l12.185"></a><span id="l12.185">   morkBead* FirstBead(morkEnv* ev)</span>
<a href="#l12.186"></a><span id="l12.186">   { return (morkBead*) this-&gt;IterFirstKey(ev); }</span>
<a href="#l12.187"></a><span id="l12.187" class="difflineminus">-  </span>
<a href="#l12.188"></a><span id="l12.188" class="difflineplus">+</span>
<a href="#l12.189"></a><span id="l12.189">   morkBead* NextBead(morkEnv* ev)</span>
<a href="#l12.190"></a><span id="l12.190">   { return (morkBead*) this-&gt;IterNextKey(ev); }</span>
<a href="#l12.191"></a><span id="l12.191" class="difflineminus">-  </span>
<a href="#l12.192"></a><span id="l12.192" class="difflineplus">+</span>
<a href="#l12.193"></a><span id="l12.193">   morkBead* HereBead(morkEnv* ev)</span>
<a href="#l12.194"></a><span id="l12.194">   { return (morkBead*) this-&gt;IterHereKey(ev); }</span>
<a href="#l12.195"></a><span id="l12.195" class="difflineminus">-  </span>
<a href="#l12.196"></a><span id="l12.196" class="difflineplus">+</span>
<a href="#l12.197"></a><span id="l12.197"> };</span>
<a href="#l12.198"></a><span id="l12.198"> </span>
<a href="#l12.199"></a><span id="l12.199"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l12.200"></a><span id="l12.200"> </span>
<a href="#l12.201"></a><span id="l12.201"> #endif /* _MORKBEAD_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l13.1"></a><span id="l13.1" class="difflineminus">--- a/db/mork/src/morkBlob.cpp</span>
<a href="#l13.2"></a><span id="l13.2" class="difflineplus">+++ b/db/mork/src/morkBlob.cpp</span>
<a href="#l13.3"></a><span id="l13.3" class="difflineat">@@ -40,47 +40,47 @@ morkBlob::BlobFillOverSizeError(morkEnv*</span>
<a href="#l13.4"></a><span id="l13.4"> </span>
<a href="#l13.5"></a><span id="l13.5"> mork_bool</span>
<a href="#l13.6"></a><span id="l13.6"> morkBlob::GrowBlob(morkEnv* ev, nsIMdbHeap* ioHeap, mork_size inNewSize)</span>
<a href="#l13.7"></a><span id="l13.7"> {</span>
<a href="#l13.8"></a><span id="l13.8">   if ( ioHeap )</span>
<a href="#l13.9"></a><span id="l13.9">   {</span>
<a href="#l13.10"></a><span id="l13.10">     if ( !mBuf_Body ) // no body? implies zero sized?</span>
<a href="#l13.11"></a><span id="l13.11">       mBlob_Size = 0;</span>
<a href="#l13.12"></a><span id="l13.12" class="difflineminus">-      </span>
<a href="#l13.13"></a><span id="l13.13" class="difflineplus">+</span>
<a href="#l13.14"></a><span id="l13.14">     if ( mBuf_Fill &gt; mBlob_Size ) // fill more than size?</span>
<a href="#l13.15"></a><span id="l13.15">     {</span>
<a href="#l13.16"></a><span id="l13.16">       ev-&gt;NewWarning(&quot;mBuf_Fill &gt; mBlob_Size&quot;);</span>
<a href="#l13.17"></a><span id="l13.17">       mBuf_Fill = mBlob_Size;</span>
<a href="#l13.18"></a><span id="l13.18">     }</span>
<a href="#l13.19"></a><span id="l13.19" class="difflineminus">-      </span>
<a href="#l13.20"></a><span id="l13.20" class="difflineplus">+</span>
<a href="#l13.21"></a><span id="l13.21">     if ( inNewSize &gt; mBlob_Size ) // need to allocate larger blob?</span>
<a href="#l13.22"></a><span id="l13.22">     {</span>
<a href="#l13.23"></a><span id="l13.23">       mork_u1* body = 0;</span>
<a href="#l13.24"></a><span id="l13.24">       ioHeap-&gt;Alloc(ev-&gt;AsMdbEnv(), inNewSize, (void**) &amp;body);</span>
<a href="#l13.25"></a><span id="l13.25">       if ( body &amp;&amp; ev-&gt;Good() )</span>
<a href="#l13.26"></a><span id="l13.26">       {</span>
<a href="#l13.27"></a><span id="l13.27">         void* oldBody = mBuf_Body;</span>
<a href="#l13.28"></a><span id="l13.28">         if ( mBlob_Size ) // any old content to transfer?</span>
<a href="#l13.29"></a><span id="l13.29">           MORK_MEMCPY(body, oldBody, mBlob_Size);</span>
<a href="#l13.30"></a><span id="l13.30" class="difflineminus">-        </span>
<a href="#l13.31"></a><span id="l13.31" class="difflineplus">+</span>
<a href="#l13.32"></a><span id="l13.32">         mBlob_Size = inNewSize; // install new size</span>
<a href="#l13.33"></a><span id="l13.33">         mBuf_Body = body; // install new body</span>
<a href="#l13.34"></a><span id="l13.34" class="difflineminus">-        </span>
<a href="#l13.35"></a><span id="l13.35" class="difflineplus">+</span>
<a href="#l13.36"></a><span id="l13.36">         if ( oldBody ) // need to free old buffer body?</span>
<a href="#l13.37"></a><span id="l13.37">           ioHeap-&gt;Free(ev-&gt;AsMdbEnv(), oldBody);</span>
<a href="#l13.38"></a><span id="l13.38">       }</span>
<a href="#l13.39"></a><span id="l13.39">     }</span>
<a href="#l13.40"></a><span id="l13.40">   }</span>
<a href="#l13.41"></a><span id="l13.41">   else</span>
<a href="#l13.42"></a><span id="l13.42">     ev-&gt;NilPointerError();</span>
<a href="#l13.43"></a><span id="l13.43" class="difflineminus">-    </span>
<a href="#l13.44"></a><span id="l13.44" class="difflineplus">+</span>
<a href="#l13.45"></a><span id="l13.45">   if ( ev-&gt;Good() &amp;&amp; mBlob_Size &lt; inNewSize )</span>
<a href="#l13.46"></a><span id="l13.46">     ev-&gt;NewError(&quot;mBlob_Size &lt; inNewSize&quot;);</span>
<a href="#l13.47"></a><span id="l13.47" class="difflineminus">-    </span>
<a href="#l13.48"></a><span id="l13.48" class="difflineplus">+</span>
<a href="#l13.49"></a><span id="l13.49">   return ev-&gt;Good();</span>
<a href="#l13.50"></a><span id="l13.50"> }</span>
<a href="#l13.51"></a><span id="l13.51"> </span>
<a href="#l13.52"></a><span id="l13.52"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l13.53"></a><span id="l13.53"> </span>
<a href="#l13.54"></a><span id="l13.54"> morkCoil::morkCoil(morkEnv* ev, nsIMdbHeap* ioHeap)</span>
<a href="#l13.55"></a><span id="l13.55"> {</span>
<a href="#l13.56"></a><span id="l13.56">   mBuf_Body = 0;</span>
<a href="#l13.57"></a><span id="l13.57" class="difflineat">@@ -95,16 +95,16 @@ morkCoil::morkCoil(morkEnv* ev, nsIMdbHe</span>
<a href="#l13.58"></a><span id="l13.58"> void</span>
<a href="#l13.59"></a><span id="l13.59"> morkCoil::CloseCoil(morkEnv* ev)</span>
<a href="#l13.60"></a><span id="l13.60"> {</span>
<a href="#l13.61"></a><span id="l13.61">   void* body = mBuf_Body;</span>
<a href="#l13.62"></a><span id="l13.62">   nsIMdbHeap* heap = mCoil_Heap;</span>
<a href="#l13.63"></a><span id="l13.63"> </span>
<a href="#l13.64"></a><span id="l13.64">   mBuf_Body = 0;</span>
<a href="#l13.65"></a><span id="l13.65">   mCoil_Heap = 0;</span>
<a href="#l13.66"></a><span id="l13.66" class="difflineminus">-  </span>
<a href="#l13.67"></a><span id="l13.67" class="difflineplus">+</span>
<a href="#l13.68"></a><span id="l13.68">   if ( body &amp;&amp; heap )</span>
<a href="#l13.69"></a><span id="l13.69">   {</span>
<a href="#l13.70"></a><span id="l13.70">     heap-&gt;Free(ev-&gt;AsMdbEnv(), body);</span>
<a href="#l13.71"></a><span id="l13.71">   }</span>
<a href="#l13.72"></a><span id="l13.72"> }</span>
<a href="#l13.73"></a><span id="l13.73"> </span>
<a href="#l13.74"></a><span id="l13.74"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l14.1"></a><span id="l14.1" class="difflineminus">--- a/db/mork/src/morkBlob.h</span>
<a href="#l14.2"></a><span id="l14.2" class="difflineplus">+++ b/db/mork/src/morkBlob.h</span>
<a href="#l14.3"></a><span id="l14.3" class="difflineat">@@ -47,27 +47,27 @@ class morkBlob : public morkBuf { // gre</span>
<a href="#l14.4"></a><span id="l14.4">   // mdb_fill      mBuf_Fill;  // logical content in Buf in bytes</span>
<a href="#l14.5"></a><span id="l14.5"> public:</span>
<a href="#l14.6"></a><span id="l14.6">   mork_size      mBlob_Size;  // physical size of Buf in bytes</span>
<a href="#l14.7"></a><span id="l14.7"> </span>
<a href="#l14.8"></a><span id="l14.8"> public:</span>
<a href="#l14.9"></a><span id="l14.9">   morkBlob() { }</span>
<a href="#l14.10"></a><span id="l14.10">   morkBlob(const void* ioBuf, mork_fill inFill, mork_size inSize)</span>
<a href="#l14.11"></a><span id="l14.11">   : morkBuf(ioBuf, inFill), mBlob_Size(inSize) { }</span>
<a href="#l14.12"></a><span id="l14.12" class="difflineminus">- </span>
<a href="#l14.13"></a><span id="l14.13" class="difflineplus">+</span>
<a href="#l14.14"></a><span id="l14.14">   static void BlobFillOverSizeError(morkEnv* ev);</span>
<a href="#l14.15"></a><span id="l14.15" class="difflineminus">- </span>
<a href="#l14.16"></a><span id="l14.16" class="difflineplus">+</span>
<a href="#l14.17"></a><span id="l14.17"> public:</span>
<a href="#l14.18"></a><span id="l14.18">   mork_bool GrowBlob(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l14.19"></a><span id="l14.19">     mork_size inNewSize);</span>
<a href="#l14.20"></a><span id="l14.20"> </span>
<a href="#l14.21"></a><span id="l14.21"> private: // copying is not allowed</span>
<a href="#l14.22"></a><span id="l14.22">   morkBlob(const morkBlob&amp; other);</span>
<a href="#l14.23"></a><span id="l14.23">   morkBlob&amp; operator=(const morkBlob&amp; other);</span>
<a href="#l14.24"></a><span id="l14.24" class="difflineminus">-  </span>
<a href="#l14.25"></a><span id="l14.25" class="difflineplus">+</span>
<a href="#l14.26"></a><span id="l14.26"> };</span>
<a href="#l14.27"></a><span id="l14.27"> </span>
<a href="#l14.28"></a><span id="l14.28"> /*| Text: a blob with an associated charset annotation, where the</span>
<a href="#l14.29"></a><span id="l14.29"> **| charset actually includes the general notion of typing, and not</span>
<a href="#l14.30"></a><span id="l14.30"> **| just a specification of character set alone; we want to permit</span>
<a href="#l14.31"></a><span id="l14.31"> **| arbitrary charset annotations for ad hoc binary types as well.</span>
<a href="#l14.32"></a><span id="l14.32"> **| (We avoid including a nsIMdbHeap pointer in morkText for the same</span>
<a href="#l14.33"></a><span id="l14.33"> **| reason morkBlob does: we want minimal size vectors of morkText.)</span>
<a href="#l14.34"></a><span id="l14.34" class="difflineat">@@ -120,17 +120,17 @@ class morkCoil : public morkText { // se</span>
<a href="#l14.35"></a><span id="l14.35">   // mdb_fill      mBuf_Fill;  // logical content in Buf in bytes</span>
<a href="#l14.36"></a><span id="l14.36">   // mdb_size      mBlob_Size;  // physical size of Buf in bytes</span>
<a href="#l14.37"></a><span id="l14.37">   // mdb_cscode    mText_Form;  // charset format encoding</span>
<a href="#l14.38"></a><span id="l14.38"> public:</span>
<a href="#l14.39"></a><span id="l14.39">   nsIMdbHeap*      mCoil_Heap;  // storage manager for mBuf_Body pointer</span>
<a href="#l14.40"></a><span id="l14.40"> </span>
<a href="#l14.41"></a><span id="l14.41"> public:</span>
<a href="#l14.42"></a><span id="l14.42">   morkCoil(morkEnv* ev, nsIMdbHeap* ioHeap);</span>
<a href="#l14.43"></a><span id="l14.43" class="difflineminus">-  </span>
<a href="#l14.44"></a><span id="l14.44" class="difflineplus">+</span>
<a href="#l14.45"></a><span id="l14.45">   void CloseCoil(morkEnv* ev);</span>
<a href="#l14.46"></a><span id="l14.46"> </span>
<a href="#l14.47"></a><span id="l14.47">   mork_bool GrowCoil(morkEnv* ev, mork_size inNewSize)</span>
<a href="#l14.48"></a><span id="l14.48">   { return this-&gt;GrowBlob(ev, mCoil_Heap, inNewSize); }</span>
<a href="#l14.49"></a><span id="l14.49"> </span>
<a href="#l14.50"></a><span id="l14.50"> private: // copying is not allowed</span>
<a href="#l14.51"></a><span id="l14.51">   morkCoil(const morkCoil&amp; other);</span>
<a href="#l14.52"></a><span id="l14.52">   morkCoil&amp; operator=(const morkCoil&amp; other);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l15.1"></a><span id="l15.1" class="difflineminus">--- a/db/mork/src/morkBuilder.cpp</span>
<a href="#l15.2"></a><span id="l15.2" class="difflineplus">+++ b/db/mork/src/morkBuilder.cpp</span>
<a href="#l15.3"></a><span id="l15.3" class="difflineat">@@ -60,17 +60,17 @@</span>
<a href="#l15.4"></a><span id="l15.4"> #endif</span>
<a href="#l15.5"></a><span id="l15.5"> </span>
<a href="#l15.6"></a><span id="l15.6"> #ifndef _MORKROWSPACE_</span>
<a href="#l15.7"></a><span id="l15.7"> #include &quot;morkRowSpace.h&quot;</span>
<a href="#l15.8"></a><span id="l15.8"> #endif</span>
<a href="#l15.9"></a><span id="l15.9"> </span>
<a href="#l15.10"></a><span id="l15.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l15.11"></a><span id="l15.11"> </span>
<a href="#l15.12"></a><span id="l15.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l15.13"></a><span id="l15.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l15.14"></a><span id="l15.14"> // { ===== begin morkNode interface =====</span>
<a href="#l15.15"></a><span id="l15.15"> </span>
<a href="#l15.16"></a><span id="l15.16"> /*public virtual*/ void</span>
<a href="#l15.17"></a><span id="l15.17"> morkBuilder::CloseMorkNode(morkEnv* ev) // CloseBuilder() only if open</span>
<a href="#l15.18"></a><span id="l15.18"> {</span>
<a href="#l15.19"></a><span id="l15.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l15.20"></a><span id="l15.20">   {</span>
<a href="#l15.21"></a><span id="l15.21">     this-&gt;MarkClosing();</span>
<a href="#l15.22"></a><span id="l15.22" class="difflineat">@@ -87,88 +87,88 @@ morkBuilder::~morkBuilder() // assert Cl</span>
<a href="#l15.23"></a><span id="l15.23">   MORK_ASSERT(mBuilder_Table==0);</span>
<a href="#l15.24"></a><span id="l15.24">   MORK_ASSERT(mBuilder_Cell==0);</span>
<a href="#l15.25"></a><span id="l15.25">   MORK_ASSERT(mBuilder_RowSpace==0);</span>
<a href="#l15.26"></a><span id="l15.26">   MORK_ASSERT(mBuilder_AtomSpace==0);</span>
<a href="#l15.27"></a><span id="l15.27"> }</span>
<a href="#l15.28"></a><span id="l15.28"> </span>
<a href="#l15.29"></a><span id="l15.29"> /*public non-poly*/</span>
<a href="#l15.30"></a><span id="l15.30"> morkBuilder::morkBuilder(morkEnv* ev,</span>
<a href="#l15.31"></a><span id="l15.31" class="difflineminus">-  const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, </span>
<a href="#l15.32"></a><span id="l15.32" class="difflineplus">+  const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l15.33"></a><span id="l15.33">   morkStream* ioStream, mdb_count inBytesPerParseSegment,</span>
<a href="#l15.34"></a><span id="l15.34">   nsIMdbHeap* ioSlotHeap, morkStore* ioStore)</span>
<a href="#l15.35"></a><span id="l15.35"> </span>
<a href="#l15.36"></a><span id="l15.36"> : morkParser(ev, inUsage, ioHeap, ioStream,</span>
<a href="#l15.37"></a><span id="l15.37">   inBytesPerParseSegment, ioSlotHeap)</span>
<a href="#l15.38"></a><span id="l15.38" class="difflineminus">-  </span>
<a href="#l15.39"></a><span id="l15.39" class="difflineplus">+</span>
<a href="#l15.40"></a><span id="l15.40"> , mBuilder_Store( 0 )</span>
<a href="#l15.41"></a><span id="l15.41" class="difflineminus">-  </span>
<a href="#l15.42"></a><span id="l15.42" class="difflineplus">+</span>
<a href="#l15.43"></a><span id="l15.43"> , mBuilder_Table( 0 )</span>
<a href="#l15.44"></a><span id="l15.44"> , mBuilder_Row( 0 )</span>
<a href="#l15.45"></a><span id="l15.45"> , mBuilder_Cell( 0 )</span>
<a href="#l15.46"></a><span id="l15.46" class="difflineminus">-  </span>
<a href="#l15.47"></a><span id="l15.47" class="difflineplus">+</span>
<a href="#l15.48"></a><span id="l15.48"> , mBuilder_RowSpace( 0 )</span>
<a href="#l15.49"></a><span id="l15.49"> , mBuilder_AtomSpace( 0 )</span>
<a href="#l15.50"></a><span id="l15.50" class="difflineminus">-  </span>
<a href="#l15.51"></a><span id="l15.51" class="difflineplus">+</span>
<a href="#l15.52"></a><span id="l15.52"> , mBuilder_OidAtomSpace( 0 )</span>
<a href="#l15.53"></a><span id="l15.53"> , mBuilder_ScopeAtomSpace( 0 )</span>
<a href="#l15.54"></a><span id="l15.54" class="difflineminus">-  </span>
<a href="#l15.55"></a><span id="l15.55" class="difflineplus">+</span>
<a href="#l15.56"></a><span id="l15.56"> , mBuilder_PortForm( 0 )</span>
<a href="#l15.57"></a><span id="l15.57"> , mBuilder_PortRowScope( (mork_scope) 'r' )</span>
<a href="#l15.58"></a><span id="l15.58"> , mBuilder_PortAtomScope( (mork_scope) 'v' )</span>
<a href="#l15.59"></a><span id="l15.59"> </span>
<a href="#l15.60"></a><span id="l15.60"> , mBuilder_TableForm( 0 )</span>
<a href="#l15.61"></a><span id="l15.61"> , mBuilder_TableRowScope( (mork_scope) 'r' )</span>
<a href="#l15.62"></a><span id="l15.62"> , mBuilder_TableAtomScope( (mork_scope) 'v' )</span>
<a href="#l15.63"></a><span id="l15.63"> , mBuilder_TableKind( 0 )</span>
<a href="#l15.64"></a><span id="l15.64"> </span>
<a href="#l15.65"></a><span id="l15.65"> , mBuilder_TablePriority( morkPriority_kLo )</span>
<a href="#l15.66"></a><span id="l15.66"> , mBuilder_TableIsUnique( morkBool_kFalse )</span>
<a href="#l15.67"></a><span id="l15.67"> , mBuilder_TableIsVerbose( morkBool_kFalse )</span>
<a href="#l15.68"></a><span id="l15.68"> , mBuilder_TablePadByte( 0 )</span>
<a href="#l15.69"></a><span id="l15.69" class="difflineminus">-  </span>
<a href="#l15.70"></a><span id="l15.70" class="difflineplus">+</span>
<a href="#l15.71"></a><span id="l15.71"> , mBuilder_RowForm( 0 )</span>
<a href="#l15.72"></a><span id="l15.72"> , mBuilder_RowRowScope( (mork_scope) 'r' )</span>
<a href="#l15.73"></a><span id="l15.73"> , mBuilder_RowAtomScope( (mork_scope) 'v' )</span>
<a href="#l15.74"></a><span id="l15.74"> </span>
<a href="#l15.75"></a><span id="l15.75"> , mBuilder_CellForm( 0 )</span>
<a href="#l15.76"></a><span id="l15.76"> , mBuilder_CellAtomScope( (mork_scope) 'v' )</span>
<a href="#l15.77"></a><span id="l15.77"> </span>
<a href="#l15.78"></a><span id="l15.78"> , mBuilder_DictForm( 0 )</span>
<a href="#l15.79"></a><span id="l15.79"> , mBuilder_DictAtomScope( (mork_scope) 'v' )</span>
<a href="#l15.80"></a><span id="l15.80"> </span>
<a href="#l15.81"></a><span id="l15.81"> , mBuilder_MetaTokenSlot( 0 )</span>
<a href="#l15.82"></a><span id="l15.82" class="difflineminus">-  </span>
<a href="#l15.83"></a><span id="l15.83" class="difflineplus">+</span>
<a href="#l15.84"></a><span id="l15.84"> , mBuilder_DoCutRow( morkBool_kFalse )</span>
<a href="#l15.85"></a><span id="l15.85"> , mBuilder_DoCutCell( morkBool_kFalse )</span>
<a href="#l15.86"></a><span id="l15.86"> , mBuilder_CellsVecFill( 0 )</span>
<a href="#l15.87"></a><span id="l15.87"> {</span>
<a href="#l15.88"></a><span id="l15.88">   if ( ev-&gt;Good() )</span>
<a href="#l15.89"></a><span id="l15.89">   {</span>
<a href="#l15.90"></a><span id="l15.90">     if ( ioStore )</span>
<a href="#l15.91"></a><span id="l15.91">     {</span>
<a href="#l15.92"></a><span id="l15.92">       morkStore::SlotWeakStore(ioStore, ev, &amp;mBuilder_Store);</span>
<a href="#l15.93"></a><span id="l15.93">       if ( ev-&gt;Good() )</span>
<a href="#l15.94"></a><span id="l15.94">         mNode_Derived = morkDerived_kBuilder;</span>
<a href="#l15.95"></a><span id="l15.95">     }</span>
<a href="#l15.96"></a><span id="l15.96">     else</span>
<a href="#l15.97"></a><span id="l15.97">       ev-&gt;NilPointerError();</span>
<a href="#l15.98"></a><span id="l15.98">   }</span>
<a href="#l15.99"></a><span id="l15.99" class="difflineminus">-   </span>
<a href="#l15.100"></a><span id="l15.100" class="difflineplus">+</span>
<a href="#l15.101"></a><span id="l15.101"> }</span>
<a href="#l15.102"></a><span id="l15.102"> </span>
<a href="#l15.103"></a><span id="l15.103"> /*public non-poly*/ void</span>
<a href="#l15.104"></a><span id="l15.104"> morkBuilder::CloseBuilder(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l15.105"></a><span id="l15.105"> {</span>
<a href="#l15.106"></a><span id="l15.106">     if ( this-&gt;IsNode() )</span>
<a href="#l15.107"></a><span id="l15.107">     {</span>
<a href="#l15.108"></a><span id="l15.108">       mBuilder_Row = 0;</span>
<a href="#l15.109"></a><span id="l15.109">       mBuilder_Cell = 0;</span>
<a href="#l15.110"></a><span id="l15.110">       mBuilder_MetaTokenSlot = 0;</span>
<a href="#l15.111"></a><span id="l15.111" class="difflineminus">-      </span>
<a href="#l15.112"></a><span id="l15.112" class="difflineplus">+</span>
<a href="#l15.113"></a><span id="l15.113">       morkTable::SlotStrongTable((morkTable*) 0, ev, &amp;mBuilder_Table);</span>
<a href="#l15.114"></a><span id="l15.114">       morkStore::SlotWeakStore((morkStore*) 0, ev, &amp;mBuilder_Store);</span>
<a href="#l15.115"></a><span id="l15.115"> </span>
<a href="#l15.116"></a><span id="l15.116">       morkRowSpace::SlotStrongRowSpace((morkRowSpace*) 0, ev,</span>
<a href="#l15.117"></a><span id="l15.117">         &amp;mBuilder_RowSpace);</span>
<a href="#l15.118"></a><span id="l15.118"> </span>
<a href="#l15.119"></a><span id="l15.119">       morkAtomSpace::SlotStrongAtomSpace((morkAtomSpace*) 0, ev,</span>
<a href="#l15.120"></a><span id="l15.120">         &amp;mBuilder_AtomSpace);</span>
<a href="#l15.121"></a><span id="l15.121" class="difflineat">@@ -181,17 +181,17 @@ morkBuilder::CloseBuilder(morkEnv* ev) /</span>
<a href="#l15.122"></a><span id="l15.122">       this-&gt;CloseParser(ev);</span>
<a href="#l15.123"></a><span id="l15.123">       this-&gt;MarkShut();</span>
<a href="#l15.124"></a><span id="l15.124">     }</span>
<a href="#l15.125"></a><span id="l15.125">     else</span>
<a href="#l15.126"></a><span id="l15.126">       this-&gt;NonNodeError(ev);</span>
<a href="#l15.127"></a><span id="l15.127"> }</span>
<a href="#l15.128"></a><span id="l15.128"> </span>
<a href="#l15.129"></a><span id="l15.129"> // } ===== end morkNode methods =====</span>
<a href="#l15.130"></a><span id="l15.130" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l15.131"></a><span id="l15.131" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l15.132"></a><span id="l15.132"> </span>
<a href="#l15.133"></a><span id="l15.133"> /*static*/ void</span>
<a href="#l15.134"></a><span id="l15.134"> morkBuilder::NonBuilderTypeError(morkEnv* ev)</span>
<a href="#l15.135"></a><span id="l15.135"> {</span>
<a href="#l15.136"></a><span id="l15.136">   ev-&gt;NewError(&quot;non morkBuilder&quot;);</span>
<a href="#l15.137"></a><span id="l15.137"> }</span>
<a href="#l15.138"></a><span id="l15.138"> </span>
<a href="#l15.139"></a><span id="l15.139"> /*static*/ void</span>
<a href="#l15.140"></a><span id="l15.140" class="difflineat">@@ -214,17 +214,17 @@ morkBuilder::NilBuilderTableError(morkEn</span>
<a href="#l15.141"></a><span id="l15.141"> </span>
<a href="#l15.142"></a><span id="l15.142"> /*static*/ void</span>
<a href="#l15.143"></a><span id="l15.143"> morkBuilder::NonColumnSpaceScopeError(morkEnv* ev)</span>
<a href="#l15.144"></a><span id="l15.144"> {</span>
<a href="#l15.145"></a><span id="l15.145">   ev-&gt;NewError(&quot;column space != 'c'&quot;);</span>
<a href="#l15.146"></a><span id="l15.146"> }</span>
<a href="#l15.147"></a><span id="l15.147"> </span>
<a href="#l15.148"></a><span id="l15.148"> void</span>
<a href="#l15.149"></a><span id="l15.149" class="difflineminus">-morkBuilder::LogGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch, </span>
<a href="#l15.150"></a><span id="l15.150" class="difflineplus">+morkBuilder::LogGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch,</span>
<a href="#l15.151"></a><span id="l15.151">   const char* inKind)</span>
<a href="#l15.152"></a><span id="l15.152"> {</span>
<a href="#l15.153"></a><span id="l15.153">   MORK_USED_2(inGlitch,inKind);</span>
<a href="#l15.154"></a><span id="l15.154">   ev-&gt;NewWarning(&quot;parsing glitch&quot;);</span>
<a href="#l15.155"></a><span id="l15.155"> }</span>
<a href="#l15.156"></a><span id="l15.156"> </span>
<a href="#l15.157"></a><span id="l15.157"> /*virtual*/ void</span>
<a href="#l15.158"></a><span id="l15.158"> morkBuilder::MidToYarn(morkEnv* ev,</span>
<a href="#l15.159"></a><span id="l15.159" class="difflineat">@@ -247,17 +247,17 @@ morkBuilder::OnNewPort(morkEnv* ev, cons</span>
<a href="#l15.160"></a><span id="l15.160">   MORK_USED_2(ev,inPlace);</span>
<a href="#l15.161"></a><span id="l15.161">   // mParser_InPort = morkBool_kTrue;</span>
<a href="#l15.162"></a><span id="l15.162">   mBuilder_PortForm = 0;</span>
<a href="#l15.163"></a><span id="l15.163">   mBuilder_PortRowScope = (mork_scope) 'r';</span>
<a href="#l15.164"></a><span id="l15.164">   mBuilder_PortAtomScope = (mork_scope) 'v';</span>
<a href="#l15.165"></a><span id="l15.165"> }</span>
<a href="#l15.166"></a><span id="l15.166"> </span>
<a href="#l15.167"></a><span id="l15.167"> /*virtual*/ void</span>
<a href="#l15.168"></a><span id="l15.168" class="difflineminus">-morkBuilder::OnPortGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch)  </span>
<a href="#l15.169"></a><span id="l15.169" class="difflineplus">+morkBuilder::OnPortGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch)</span>
<a href="#l15.170"></a><span id="l15.170"> {</span>
<a href="#l15.171"></a><span id="l15.171">   this-&gt;LogGlitch(ev, inGlitch, &quot;port&quot;);</span>
<a href="#l15.172"></a><span id="l15.172"> }</span>
<a href="#l15.173"></a><span id="l15.173"> </span>
<a href="#l15.174"></a><span id="l15.174"> /*virtual*/ void</span>
<a href="#l15.175"></a><span id="l15.175"> morkBuilder::OnPortEnd(morkEnv* ev, const morkSpan&amp; inSpan)</span>
<a href="#l15.176"></a><span id="l15.176"> // mp:Start     ::= OnNewPort mp:PortItem* OnPortEnd</span>
<a href="#l15.177"></a><span id="l15.177"> {</span>
<a href="#l15.178"></a><span id="l15.178" class="difflineat">@@ -274,48 +274,48 @@ morkBuilder::OnNewGroup(morkEnv* ev, con</span>
<a href="#l15.179"></a><span id="l15.179">   mParser_InGroup = morkBool_kTrue;</span>
<a href="#l15.180"></a><span id="l15.180">   mork_pos startPos = inPlace.mPlace_Pos;</span>
<a href="#l15.181"></a><span id="l15.181"> </span>
<a href="#l15.182"></a><span id="l15.182">   morkStore* store = mBuilder_Store;</span>
<a href="#l15.183"></a><span id="l15.183">   if ( store )</span>
<a href="#l15.184"></a><span id="l15.184">   {</span>
<a href="#l15.185"></a><span id="l15.185">     if ( inGid &gt;= store-&gt;mStore_CommitGroupIdentity )</span>
<a href="#l15.186"></a><span id="l15.186">       store-&gt;mStore_CommitGroupIdentity = inGid + 1;</span>
<a href="#l15.187"></a><span id="l15.187" class="difflineminus">-  </span>
<a href="#l15.188"></a><span id="l15.188" class="difflineplus">+</span>
<a href="#l15.189"></a><span id="l15.189">     if ( !store-&gt;mStore_FirstCommitGroupPos )</span>
<a href="#l15.190"></a><span id="l15.190">       store-&gt;mStore_FirstCommitGroupPos = startPos;</span>
<a href="#l15.191"></a><span id="l15.191">     else if ( !store-&gt;mStore_SecondCommitGroupPos )</span>
<a href="#l15.192"></a><span id="l15.192">       store-&gt;mStore_SecondCommitGroupPos = startPos;</span>
<a href="#l15.193"></a><span id="l15.193">   }</span>
<a href="#l15.194"></a><span id="l15.194"> }</span>
<a href="#l15.195"></a><span id="l15.195"> </span>
<a href="#l15.196"></a><span id="l15.196"> /*virtual*/ void</span>
<a href="#l15.197"></a><span id="l15.197" class="difflineminus">-morkBuilder::OnGroupGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) </span>
<a href="#l15.198"></a><span id="l15.198" class="difflineplus">+morkBuilder::OnGroupGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch)</span>
<a href="#l15.199"></a><span id="l15.199"> {</span>
<a href="#l15.200"></a><span id="l15.200">   this-&gt;LogGlitch(ev, inGlitch, &quot;group&quot;);</span>
<a href="#l15.201"></a><span id="l15.201"> }</span>
<a href="#l15.202"></a><span id="l15.202"> </span>
<a href="#l15.203"></a><span id="l15.203"> /*virtual*/ void</span>
<a href="#l15.204"></a><span id="l15.204" class="difflineminus">-morkBuilder::OnGroupCommitEnd(morkEnv* ev, const morkSpan&amp; inSpan)  </span>
<a href="#l15.205"></a><span id="l15.205" class="difflineplus">+morkBuilder::OnGroupCommitEnd(morkEnv* ev, const morkSpan&amp; inSpan)</span>
<a href="#l15.206"></a><span id="l15.206"> {</span>
<a href="#l15.207"></a><span id="l15.207">   MORK_USED_2(ev,inSpan);</span>
<a href="#l15.208"></a><span id="l15.208">   // mParser_InGroup = morkBool_kFalse;</span>
<a href="#l15.209"></a><span id="l15.209">   // ev-&gt;StubMethodOnlyError();</span>
<a href="#l15.210"></a><span id="l15.210"> }</span>
<a href="#l15.211"></a><span id="l15.211"> </span>
<a href="#l15.212"></a><span id="l15.212"> /*virtual*/ void</span>
<a href="#l15.213"></a><span id="l15.213" class="difflineminus">-morkBuilder::OnGroupAbortEnd(morkEnv* ev, const morkSpan&amp; inSpan) </span>
<a href="#l15.214"></a><span id="l15.214" class="difflineplus">+morkBuilder::OnGroupAbortEnd(morkEnv* ev, const morkSpan&amp; inSpan)</span>
<a href="#l15.215"></a><span id="l15.215"> {</span>
<a href="#l15.216"></a><span id="l15.216">   MORK_USED_1(inSpan);</span>
<a href="#l15.217"></a><span id="l15.217">   // mParser_InGroup = morkBool_kFalse;</span>
<a href="#l15.218"></a><span id="l15.218">   ev-&gt;StubMethodOnlyError();</span>
<a href="#l15.219"></a><span id="l15.219"> }</span>
<a href="#l15.220"></a><span id="l15.220"> </span>
<a href="#l15.221"></a><span id="l15.221"> /*virtual*/ void</span>
<a href="#l15.222"></a><span id="l15.222" class="difflineminus">-morkBuilder::OnNewPortRow(morkEnv* ev, const morkPlace&amp; inPlace, </span>
<a href="#l15.223"></a><span id="l15.223" class="difflineplus">+morkBuilder::OnNewPortRow(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l15.224"></a><span id="l15.224">   const morkMid&amp; inMid, mork_change inChange)</span>
<a href="#l15.225"></a><span id="l15.225"> {</span>
<a href="#l15.226"></a><span id="l15.226">   MORK_USED_3(inMid,inPlace,inChange);</span>
<a href="#l15.227"></a><span id="l15.227">   // mParser_InPortRow = morkBool_kTrue;</span>
<a href="#l15.228"></a><span id="l15.228">   ev-&gt;StubMethodOnlyError();</span>
<a href="#l15.229"></a><span id="l15.229"> }</span>
<a href="#l15.230"></a><span id="l15.230"> </span>
<a href="#l15.231"></a><span id="l15.231"> /*virtual*/ void</span>
<a href="#l15.232"></a><span id="l15.232" class="difflineat">@@ -342,28 +342,28 @@ morkBuilder::OnNewTable(morkEnv* ev, con</span>
<a href="#l15.233"></a><span id="l15.233"> // mp:MetaItem  ::= mp:Cell | OnMetaGlitch</span>
<a href="#l15.234"></a><span id="l15.234"> {</span>
<a href="#l15.235"></a><span id="l15.235">   MORK_USED_1(inPlace);</span>
<a href="#l15.236"></a><span id="l15.236">   // mParser_InTable = morkBool_kTrue;</span>
<a href="#l15.237"></a><span id="l15.237">   mBuilder_TableForm = mBuilder_PortForm;</span>
<a href="#l15.238"></a><span id="l15.238">   mBuilder_TableRowScope = mBuilder_PortRowScope;</span>
<a href="#l15.239"></a><span id="l15.239">   mBuilder_TableAtomScope = mBuilder_PortAtomScope;</span>
<a href="#l15.240"></a><span id="l15.240">   mBuilder_TableKind = morkStore_kNoneToken;</span>
<a href="#l15.241"></a><span id="l15.241" class="difflineminus">-  </span>
<a href="#l15.242"></a><span id="l15.242" class="difflineplus">+</span>
<a href="#l15.243"></a><span id="l15.243">   mBuilder_TablePriority = morkPriority_kLo;</span>
<a href="#l15.244"></a><span id="l15.244">   mBuilder_TableIsUnique = morkBool_kFalse;</span>
<a href="#l15.245"></a><span id="l15.245">   mBuilder_TableIsVerbose = morkBool_kFalse;</span>
<a href="#l15.246"></a><span id="l15.246"> </span>
<a href="#l15.247"></a><span id="l15.247">   morkTable* table = mBuilder_Store-&gt;MidToTable(ev, inMid);</span>
<a href="#l15.248"></a><span id="l15.248">   morkTable::SlotStrongTable(table, ev, &amp;mBuilder_Table);</span>
<a href="#l15.249"></a><span id="l15.249">   if ( table )</span>
<a href="#l15.250"></a><span id="l15.250">   {</span>
<a href="#l15.251"></a><span id="l15.251">     if ( table-&gt;mTable_RowSpace )</span>
<a href="#l15.252"></a><span id="l15.252">       mBuilder_TableRowScope = table-&gt;mTable_RowSpace-&gt;SpaceScope();</span>
<a href="#l15.253"></a><span id="l15.253" class="difflineminus">-      </span>
<a href="#l15.254"></a><span id="l15.254" class="difflineplus">+</span>
<a href="#l15.255"></a><span id="l15.255">     if ( inCutAllRows )</span>
<a href="#l15.256"></a><span id="l15.256">       table-&gt;CutAllRows(ev);</span>
<a href="#l15.257"></a><span id="l15.257">   }</span>
<a href="#l15.258"></a><span id="l15.258"> }</span>
<a href="#l15.259"></a><span id="l15.259"> </span>
<a href="#l15.260"></a><span id="l15.260"> /*virtual*/ void</span>
<a href="#l15.261"></a><span id="l15.261"> morkBuilder::OnTableGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch)</span>
<a href="#l15.262"></a><span id="l15.262"> {</span>
<a href="#l15.263"></a><span id="l15.263" class="difflineat">@@ -374,32 +374,32 @@ morkBuilder::OnTableGlitch(morkEnv* ev, </span>
<a href="#l15.264"></a><span id="l15.264"> morkBuilder::OnTableEnd(morkEnv* ev, const morkSpan&amp; inSpan)</span>
<a href="#l15.265"></a><span id="l15.265"> // mp:Table     ::= OnNewTable mp:TableItem* OnTableEnd</span>
<a href="#l15.266"></a><span id="l15.266"> {</span>
<a href="#l15.267"></a><span id="l15.267">   MORK_USED_1(inSpan);</span>
<a href="#l15.268"></a><span id="l15.268">   // mParser_InTable = morkBool_kFalse;</span>
<a href="#l15.269"></a><span id="l15.269">   if ( mBuilder_Table )</span>
<a href="#l15.270"></a><span id="l15.270">   {</span>
<a href="#l15.271"></a><span id="l15.271">     mBuilder_Table-&gt;mTable_Priority = mBuilder_TablePriority;</span>
<a href="#l15.272"></a><span id="l15.272" class="difflineminus">-    </span>
<a href="#l15.273"></a><span id="l15.273" class="difflineplus">+</span>
<a href="#l15.274"></a><span id="l15.274">     if ( mBuilder_TableIsUnique )</span>
<a href="#l15.275"></a><span id="l15.275">       mBuilder_Table-&gt;SetTableUnique();</span>
<a href="#l15.276"></a><span id="l15.276"> </span>
<a href="#l15.277"></a><span id="l15.277">     if ( mBuilder_TableIsVerbose )</span>
<a href="#l15.278"></a><span id="l15.278">       mBuilder_Table-&gt;SetTableVerbose();</span>
<a href="#l15.279"></a><span id="l15.279" class="difflineminus">-  </span>
<a href="#l15.280"></a><span id="l15.280" class="difflineplus">+</span>
<a href="#l15.281"></a><span id="l15.281">     morkTable::SlotStrongTable((morkTable*) 0, ev, &amp;mBuilder_Table);</span>
<a href="#l15.282"></a><span id="l15.282">   }</span>
<a href="#l15.283"></a><span id="l15.283">   else</span>
<a href="#l15.284"></a><span id="l15.284">     this-&gt;NilBuilderTableError(ev);</span>
<a href="#l15.285"></a><span id="l15.285" class="difflineminus">-    </span>
<a href="#l15.286"></a><span id="l15.286" class="difflineplus">+</span>
<a href="#l15.287"></a><span id="l15.287">   mBuilder_Row = 0;</span>
<a href="#l15.288"></a><span id="l15.288">   mBuilder_Cell = 0;</span>
<a href="#l15.289"></a><span id="l15.289" class="difflineminus">-  </span>
<a href="#l15.290"></a><span id="l15.290" class="difflineminus">-  </span>
<a href="#l15.291"></a><span id="l15.291" class="difflineplus">+</span>
<a href="#l15.292"></a><span id="l15.292" class="difflineplus">+</span>
<a href="#l15.293"></a><span id="l15.293">   mBuilder_TablePriority = morkPriority_kLo;</span>
<a href="#l15.294"></a><span id="l15.294">   mBuilder_TableIsUnique = morkBool_kFalse;</span>
<a href="#l15.295"></a><span id="l15.295">   mBuilder_TableIsVerbose = morkBool_kFalse;</span>
<a href="#l15.296"></a><span id="l15.296"> </span>
<a href="#l15.297"></a><span id="l15.297">   if ( mBuilder_TableKind == morkStore_kNoneToken )</span>
<a href="#l15.298"></a><span id="l15.298">     ev-&gt;NewError(&quot;missing table kind&quot;);</span>
<a href="#l15.299"></a><span id="l15.299"> </span>
<a href="#l15.300"></a><span id="l15.300">   mBuilder_CellAtomScope = mBuilder_RowAtomScope =</span>
<a href="#l15.301"></a><span id="l15.301" class="difflineat">@@ -414,17 +414,17 @@ morkBuilder::OnNewMeta(morkEnv* ev, cons</span>
<a href="#l15.302"></a><span id="l15.302"> // mp:Meta      ::= OnNewMeta mp:MetaItem* OnMetaEnd</span>
<a href="#l15.303"></a><span id="l15.303"> // mp:MetaItem  ::= mp:Cell | OnMetaGlitch</span>
<a href="#l15.304"></a><span id="l15.304"> // mp:Cell      ::= OnMinusCell? OnNewCell mp:CellItem? OnCellEnd</span>
<a href="#l15.305"></a><span id="l15.305"> // mp:CellItem  ::= mp:Slot | OnCellForm | OnCellGlitch</span>
<a href="#l15.306"></a><span id="l15.306"> // mp:Slot      ::= OnValue | OnValueMid | OnRowMid | OnTableMid</span>
<a href="#l15.307"></a><span id="l15.307"> {</span>
<a href="#l15.308"></a><span id="l15.308">   MORK_USED_2(ev,inPlace);</span>
<a href="#l15.309"></a><span id="l15.309">   // mParser_InMeta = morkBool_kTrue;</span>
<a href="#l15.310"></a><span id="l15.310" class="difflineminus">-  </span>
<a href="#l15.311"></a><span id="l15.311" class="difflineplus">+</span>
<a href="#l15.312"></a><span id="l15.312"> }</span>
<a href="#l15.313"></a><span id="l15.313"> </span>
<a href="#l15.314"></a><span id="l15.314"> /*virtual*/ void</span>
<a href="#l15.315"></a><span id="l15.315"> morkBuilder::OnMetaGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch)</span>
<a href="#l15.316"></a><span id="l15.316"> {</span>
<a href="#l15.317"></a><span id="l15.317">   this-&gt;LogGlitch(ev, inGlitch, &quot;meta&quot;);</span>
<a href="#l15.318"></a><span id="l15.318"> }</span>
<a href="#l15.319"></a><span id="l15.319"> </span>
<a href="#l15.320"></a><span id="l15.320" class="difflineat">@@ -439,35 +439,35 @@ morkBuilder::OnMetaEnd(morkEnv* ev, cons</span>
<a href="#l15.321"></a><span id="l15.321"> /*virtual*/ void</span>
<a href="#l15.322"></a><span id="l15.322"> morkBuilder::OnMinusRow(morkEnv* ev)</span>
<a href="#l15.323"></a><span id="l15.323"> {</span>
<a href="#l15.324"></a><span id="l15.324">   MORK_USED_1(ev);</span>
<a href="#l15.325"></a><span id="l15.325">   mBuilder_DoCutRow = morkBool_kTrue;</span>
<a href="#l15.326"></a><span id="l15.326"> }</span>
<a href="#l15.327"></a><span id="l15.327"> </span>
<a href="#l15.328"></a><span id="l15.328"> /*virtual*/ void</span>
<a href="#l15.329"></a><span id="l15.329" class="difflineminus">-morkBuilder::OnNewRow(morkEnv* ev, const morkPlace&amp; inPlace, </span>
<a href="#l15.330"></a><span id="l15.330" class="difflineplus">+morkBuilder::OnNewRow(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l15.331"></a><span id="l15.331">   const morkMid&amp; inMid, mork_bool inCutAllCols)</span>
<a href="#l15.332"></a><span id="l15.332"> // mp:Table     ::= OnNewTable mp:TableItem* OnTableEnd</span>
<a href="#l15.333"></a><span id="l15.333"> // mp:TableItem ::= mp:Row | mp:MetaTable | OnTableGlitch</span>
<a href="#l15.334"></a><span id="l15.334"> // mp:MetaTable ::= OnNewMeta mp:MetaItem* mp:Row OnMetaEnd</span>
<a href="#l15.335"></a><span id="l15.335"> // mp:Row       ::= OnMinusRow? OnNewRow mp:RowItem* OnRowEnd</span>
<a href="#l15.336"></a><span id="l15.336"> // mp:RowItem   ::= mp:Cell | mp:Meta | OnRowGlitch</span>
<a href="#l15.337"></a><span id="l15.337"> // mp:Cell      ::= OnMinusCell? OnNewCell mp:CellItem? OnCellEnd</span>
<a href="#l15.338"></a><span id="l15.338"> // mp:CellItem  ::= mp:Slot | OnCellForm | OnCellGlitch</span>
<a href="#l15.339"></a><span id="l15.339"> // mp:Slot      ::= OnValue | OnValueMid | OnRowMid | OnTableMid</span>
<a href="#l15.340"></a><span id="l15.340"> {</span>
<a href="#l15.341"></a><span id="l15.341">   MORK_USED_1(inPlace);</span>
<a href="#l15.342"></a><span id="l15.342">   // mParser_InRow = morkBool_kTrue;</span>
<a href="#l15.343"></a><span id="l15.343" class="difflineminus">-  </span>
<a href="#l15.344"></a><span id="l15.344" class="difflineplus">+</span>
<a href="#l15.345"></a><span id="l15.345">   mBuilder_CellForm = mBuilder_RowForm = mBuilder_TableForm;</span>
<a href="#l15.346"></a><span id="l15.346">   mBuilder_CellAtomScope = mBuilder_RowAtomScope = mBuilder_TableAtomScope;</span>
<a href="#l15.347"></a><span id="l15.347">   mBuilder_RowRowScope = mBuilder_TableRowScope;</span>
<a href="#l15.348"></a><span id="l15.348">   morkStore* store = mBuilder_Store;</span>
<a href="#l15.349"></a><span id="l15.349" class="difflineminus">-  </span>
<a href="#l15.350"></a><span id="l15.350" class="difflineplus">+</span>
<a href="#l15.351"></a><span id="l15.351">   if ( !inMid.mMid_Buf &amp;&amp; !inMid.mMid_Oid.mOid_Scope )</span>
<a href="#l15.352"></a><span id="l15.352">   {</span>
<a href="#l15.353"></a><span id="l15.353">     morkMid mid(inMid);</span>
<a href="#l15.354"></a><span id="l15.354">     mid.mMid_Oid.mOid_Scope = mBuilder_RowRowScope;</span>
<a href="#l15.355"></a><span id="l15.355">     mBuilder_Row = store-&gt;MidToRow(ev, mid);</span>
<a href="#l15.356"></a><span id="l15.356">   }</span>
<a href="#l15.357"></a><span id="l15.357">   else</span>
<a href="#l15.358"></a><span id="l15.358">   {</span>
<a href="#l15.359"></a><span id="l15.359" class="difflineat">@@ -502,32 +502,32 @@ morkBuilder::OnNewRow(morkEnv* ev, const</span>
<a href="#l15.360"></a><span id="l15.360">           table-&gt;CutRow(ev, row);</span>
<a href="#l15.361"></a><span id="l15.361">         else</span>
<a href="#l15.362"></a><span id="l15.362">           table-&gt;AddRow(ev, row);</span>
<a href="#l15.363"></a><span id="l15.363">       }</span>
<a href="#l15.364"></a><span id="l15.364">     }</span>
<a href="#l15.365"></a><span id="l15.365">   }</span>
<a href="#l15.366"></a><span id="l15.366">   // else // it is now okay to have rows outside a table:</span>
<a href="#l15.367"></a><span id="l15.367">   //  this-&gt;NilBuilderTableError(ev);</span>
<a href="#l15.368"></a><span id="l15.368" class="difflineminus">-    </span>
<a href="#l15.369"></a><span id="l15.369" class="difflineplus">+</span>
<a href="#l15.370"></a><span id="l15.370">   mBuilder_DoCutRow = morkBool_kFalse;</span>
<a href="#l15.371"></a><span id="l15.371"> }</span>
<a href="#l15.372"></a><span id="l15.372"> </span>
<a href="#l15.373"></a><span id="l15.373"> /*virtual*/ void</span>
<a href="#l15.374"></a><span id="l15.374" class="difflineminus">-morkBuilder::OnRowPos(morkEnv* ev, mork_pos inRowPos) </span>
<a href="#l15.375"></a><span id="l15.375" class="difflineplus">+morkBuilder::OnRowPos(morkEnv* ev, mork_pos inRowPos)</span>
<a href="#l15.376"></a><span id="l15.376"> {</span>
<a href="#l15.377"></a><span id="l15.377">   if ( mBuilder_Row &amp;&amp; mBuilder_Table &amp;&amp; !mParser_InMeta )</span>
<a href="#l15.378"></a><span id="l15.378">   {</span>
<a href="#l15.379"></a><span id="l15.379">     mork_pos hintFromPos = 0; // best hint when we don't know position</span>
<a href="#l15.380"></a><span id="l15.380">     mBuilder_Table-&gt;MoveRow(ev, mBuilder_Row, hintFromPos, inRowPos);</span>
<a href="#l15.381"></a><span id="l15.381">   }</span>
<a href="#l15.382"></a><span id="l15.382"> }</span>
<a href="#l15.383"></a><span id="l15.383"> </span>
<a href="#l15.384"></a><span id="l15.384"> /*virtual*/ void</span>
<a href="#l15.385"></a><span id="l15.385" class="difflineminus">-morkBuilder::OnRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) </span>
<a href="#l15.386"></a><span id="l15.386" class="difflineplus">+morkBuilder::OnRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch)</span>
<a href="#l15.387"></a><span id="l15.387"> {</span>
<a href="#l15.388"></a><span id="l15.388">   this-&gt;LogGlitch(ev, inGlitch, &quot;row&quot;);</span>
<a href="#l15.389"></a><span id="l15.389"> }</span>
<a href="#l15.390"></a><span id="l15.390"> </span>
<a href="#l15.391"></a><span id="l15.391"> void</span>
<a href="#l15.392"></a><span id="l15.392"> morkBuilder::FlushBuilderCells(morkEnv* ev)</span>
<a href="#l15.393"></a><span id="l15.393"> {</span>
<a href="#l15.394"></a><span id="l15.394">   if ( mBuilder_Row )</span>
<a href="#l15.395"></a><span id="l15.395" class="difflineat">@@ -546,55 +546,55 @@ morkBuilder::FlushBuilderCells(morkEnv* </span>
<a href="#l15.396"></a><span id="l15.396">     }</span>
<a href="#l15.397"></a><span id="l15.397">     mBuilder_CellsVecFill = 0;</span>
<a href="#l15.398"></a><span id="l15.398">   }</span>
<a href="#l15.399"></a><span id="l15.399">   else</span>
<a href="#l15.400"></a><span id="l15.400">     this-&gt;NilBuilderRowError(ev);</span>
<a href="#l15.401"></a><span id="l15.401"> }</span>
<a href="#l15.402"></a><span id="l15.402"> </span>
<a href="#l15.403"></a><span id="l15.403"> /*virtual*/ void</span>
<a href="#l15.404"></a><span id="l15.404" class="difflineminus">-morkBuilder::OnRowEnd(morkEnv* ev, const morkSpan&amp; inSpan) </span>
<a href="#l15.405"></a><span id="l15.405" class="difflineplus">+morkBuilder::OnRowEnd(morkEnv* ev, const morkSpan&amp; inSpan)</span>
<a href="#l15.406"></a><span id="l15.406"> // mp:Row       ::= OnMinusRow? OnNewRow mp:RowItem* OnRowEnd</span>
<a href="#l15.407"></a><span id="l15.407"> {</span>
<a href="#l15.408"></a><span id="l15.408">   MORK_USED_1(inSpan);</span>
<a href="#l15.409"></a><span id="l15.409">   // mParser_InRow = morkBool_kFalse;</span>
<a href="#l15.410"></a><span id="l15.410">   if ( mBuilder_Row )</span>
<a href="#l15.411"></a><span id="l15.411">   {</span>
<a href="#l15.412"></a><span id="l15.412">     this-&gt;FlushBuilderCells(ev);</span>
<a href="#l15.413"></a><span id="l15.413">   }</span>
<a href="#l15.414"></a><span id="l15.414">   else</span>
<a href="#l15.415"></a><span id="l15.415">     this-&gt;NilBuilderRowError(ev);</span>
<a href="#l15.416"></a><span id="l15.416" class="difflineminus">-    </span>
<a href="#l15.417"></a><span id="l15.417" class="difflineplus">+</span>
<a href="#l15.418"></a><span id="l15.418">   mBuilder_Row = 0;</span>
<a href="#l15.419"></a><span id="l15.419">   mBuilder_Cell = 0;</span>
<a href="#l15.420"></a><span id="l15.420"> </span>
<a href="#l15.421"></a><span id="l15.421">   mBuilder_DoCutCell = morkBool_kFalse;</span>
<a href="#l15.422"></a><span id="l15.422">   mBuilder_DoCutRow = morkBool_kFalse;</span>
<a href="#l15.423"></a><span id="l15.423"> }</span>
<a href="#l15.424"></a><span id="l15.424"> </span>
<a href="#l15.425"></a><span id="l15.425"> /*virtual*/ void</span>
<a href="#l15.426"></a><span id="l15.426"> morkBuilder::OnNewDict(morkEnv* ev, const morkPlace&amp; inPlace)</span>
<a href="#l15.427"></a><span id="l15.427"> // mp:Dict      ::= OnNewDict mp:DictItem* OnDictEnd</span>
<a href="#l15.428"></a><span id="l15.428"> // mp:DictItem  ::= OnAlias | OnAliasGlitch | mp:Meta | OnDictGlitch</span>
<a href="#l15.429"></a><span id="l15.429"> {</span>
<a href="#l15.430"></a><span id="l15.430">   MORK_USED_2(ev,inPlace);</span>
<a href="#l15.431"></a><span id="l15.431">   // mParser_InDict = morkBool_kTrue;</span>
<a href="#l15.432"></a><span id="l15.432" class="difflineminus">-  </span>
<a href="#l15.433"></a><span id="l15.433" class="difflineplus">+</span>
<a href="#l15.434"></a><span id="l15.434">   mBuilder_CellForm = mBuilder_DictForm = mBuilder_PortForm;</span>
<a href="#l15.435"></a><span id="l15.435">   mBuilder_CellAtomScope = mBuilder_DictAtomScope = mBuilder_PortAtomScope;</span>
<a href="#l15.436"></a><span id="l15.436"> }</span>
<a href="#l15.437"></a><span id="l15.437"> </span>
<a href="#l15.438"></a><span id="l15.438"> /*virtual*/ void</span>
<a href="#l15.439"></a><span id="l15.439" class="difflineminus">-morkBuilder::OnDictGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) </span>
<a href="#l15.440"></a><span id="l15.440" class="difflineplus">+morkBuilder::OnDictGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch)</span>
<a href="#l15.441"></a><span id="l15.441"> {</span>
<a href="#l15.442"></a><span id="l15.442">   this-&gt;LogGlitch(ev, inGlitch, &quot;dict&quot;);</span>
<a href="#l15.443"></a><span id="l15.443"> }</span>
<a href="#l15.444"></a><span id="l15.444"> </span>
<a href="#l15.445"></a><span id="l15.445"> /*virtual*/ void</span>
<a href="#l15.446"></a><span id="l15.446" class="difflineminus">-morkBuilder::OnDictEnd(morkEnv* ev, const morkSpan&amp; inSpan)  </span>
<a href="#l15.447"></a><span id="l15.447" class="difflineplus">+morkBuilder::OnDictEnd(morkEnv* ev, const morkSpan&amp; inSpan)</span>
<a href="#l15.448"></a><span id="l15.448"> // mp:Dict      ::= OnNewDict mp:DictItem* OnDictEnd</span>
<a href="#l15.449"></a><span id="l15.449"> {</span>
<a href="#l15.450"></a><span id="l15.450">   MORK_USED_2(ev,inSpan);</span>
<a href="#l15.451"></a><span id="l15.451">   // mParser_InDict = morkBool_kFalse;</span>
<a href="#l15.452"></a><span id="l15.452"> </span>
<a href="#l15.453"></a><span id="l15.453">   mBuilder_DictForm = 0;</span>
<a href="#l15.454"></a><span id="l15.454">   mBuilder_DictAtomScope = 0;</span>
<a href="#l15.455"></a><span id="l15.455"> }</span>
<a href="#l15.456"></a><span id="l15.456" class="difflineat">@@ -616,23 +616,23 @@ morkBuilder::OnAlias(morkEnv* ev, const </span>
<a href="#l15.457"></a><span id="l15.457"> </span>
<a href="#l15.458"></a><span id="l15.458"> /*virtual*/ void</span>
<a href="#l15.459"></a><span id="l15.459"> morkBuilder::OnAliasGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch)</span>
<a href="#l15.460"></a><span id="l15.460"> {</span>
<a href="#l15.461"></a><span id="l15.461">   this-&gt;LogGlitch(ev, inGlitch, &quot;alias&quot;);</span>
<a href="#l15.462"></a><span id="l15.462"> }</span>
<a href="#l15.463"></a><span id="l15.463"> </span>
<a href="#l15.464"></a><span id="l15.464"> </span>
<a href="#l15.465"></a><span id="l15.465" class="difflineminus">-morkCell* </span>
<a href="#l15.466"></a><span id="l15.466" class="difflineplus">+morkCell*</span>
<a href="#l15.467"></a><span id="l15.467"> morkBuilder::AddBuilderCell(morkEnv* ev,</span>
<a href="#l15.468"></a><span id="l15.468">   const morkMid&amp; inMid, mork_change inChange)</span>
<a href="#l15.469"></a><span id="l15.469"> {</span>
<a href="#l15.470"></a><span id="l15.470">   morkCell* outCell = 0;</span>
<a href="#l15.471"></a><span id="l15.471">   mork_column column = inMid.mMid_Oid.mOid_Id;</span>
<a href="#l15.472"></a><span id="l15.472" class="difflineminus">-  </span>
<a href="#l15.473"></a><span id="l15.473" class="difflineplus">+</span>
<a href="#l15.474"></a><span id="l15.474">   if ( ev-&gt;Good() )</span>
<a href="#l15.475"></a><span id="l15.475">   {</span>
<a href="#l15.476"></a><span id="l15.476">     if ( mBuilder_CellsVecFill &gt;= morkBuilder_kCellsVecSize )</span>
<a href="#l15.477"></a><span id="l15.477">       this-&gt;FlushBuilderCells(ev);</span>
<a href="#l15.478"></a><span id="l15.478">     if ( ev-&gt;Good() )</span>
<a href="#l15.479"></a><span id="l15.479">     {</span>
<a href="#l15.480"></a><span id="l15.480">       if ( mBuilder_CellsVecFill &lt; morkBuilder_kCellsVecSize )</span>
<a href="#l15.481"></a><span id="l15.481">       {</span>
<a href="#l15.482"></a><span id="l15.482" class="difflineat">@@ -656,42 +656,42 @@ morkBuilder::OnMinusCell(morkEnv* ev)</span>
<a href="#l15.483"></a><span id="l15.483"> }</span>
<a href="#l15.484"></a><span id="l15.484"> </span>
<a href="#l15.485"></a><span id="l15.485"> /*virtual*/ void</span>
<a href="#l15.486"></a><span id="l15.486"> morkBuilder::OnNewCell(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l15.487"></a><span id="l15.487">     const morkMid* inMid, const morkBuf* inBuf)</span>
<a href="#l15.488"></a><span id="l15.488"> // Exactly one of inMid and inBuf is nil, and the other is non-nil.</span>
<a href="#l15.489"></a><span id="l15.489"> // When hex ID syntax is used for a column, then inMid is not nil, and</span>
<a href="#l15.490"></a><span id="l15.490"> // when a naked string names a column, then inBuf is not nil.</span>
<a href="#l15.491"></a><span id="l15.491" class="difflineminus">-  </span>
<a href="#l15.492"></a><span id="l15.492" class="difflineplus">+</span>
<a href="#l15.493"></a><span id="l15.493">   // mp:Cell      ::= OnMinusCell? OnNewCell mp:CellItem? OnCellEnd</span>
<a href="#l15.494"></a><span id="l15.494">   // mp:CellItem  ::= mp:Slot | OnCellForm | OnCellGlitch</span>
<a href="#l15.495"></a><span id="l15.495">   // mp:Slot      ::= OnValue | OnValueMid | OnRowMid | OnTableMid</span>
<a href="#l15.496"></a><span id="l15.496"> {</span>
<a href="#l15.497"></a><span id="l15.497">   MORK_USED_1(inPlace);</span>
<a href="#l15.498"></a><span id="l15.498">   // mParser_InCell = morkBool_kTrue;</span>
<a href="#l15.499"></a><span id="l15.499" class="difflineminus">-  </span>
<a href="#l15.500"></a><span id="l15.500" class="difflineplus">+</span>
<a href="#l15.501"></a><span id="l15.501">   mork_change cellChange = ( mBuilder_DoCutCell )?</span>
<a href="#l15.502"></a><span id="l15.502">     morkChange_kCut : morkChange_kAdd;</span>
<a href="#l15.503"></a><span id="l15.503" class="difflineminus">-    </span>
<a href="#l15.504"></a><span id="l15.504" class="difflineplus">+</span>
<a href="#l15.505"></a><span id="l15.505">   mBuilder_DoCutCell = morkBool_kFalse;</span>
<a href="#l15.506"></a><span id="l15.506" class="difflineminus">-  </span>
<a href="#l15.507"></a><span id="l15.507" class="difflineplus">+</span>
<a href="#l15.508"></a><span id="l15.508">   mBuilder_CellAtomScope = mBuilder_RowAtomScope;</span>
<a href="#l15.509"></a><span id="l15.509" class="difflineminus">-  </span>
<a href="#l15.510"></a><span id="l15.510" class="difflineplus">+</span>
<a href="#l15.511"></a><span id="l15.511">   mBuilder_Cell = 0; // nil until determined for a row</span>
<a href="#l15.512"></a><span id="l15.512">   morkStore* store = mBuilder_Store;</span>
<a href="#l15.513"></a><span id="l15.513">   mork_scope scope = morkStore_kColumnSpaceScope;</span>
<a href="#l15.514"></a><span id="l15.514">   morkMid tempMid; // space for local and modifiable cell mid</span>
<a href="#l15.515"></a><span id="l15.515">   morkMid* cellMid = &amp;tempMid; // default to local if inMid==0</span>
<a href="#l15.516"></a><span id="l15.516" class="difflineminus">-  </span>
<a href="#l15.517"></a><span id="l15.517" class="difflineplus">+</span>
<a href="#l15.518"></a><span id="l15.518">   if ( inMid ) // mid parameter is actually provided?</span>
<a href="#l15.519"></a><span id="l15.519">   {</span>
<a href="#l15.520"></a><span id="l15.520">     *cellMid = *inMid; // bitwise copy for modifiable local mid</span>
<a href="#l15.521"></a><span id="l15.521"> </span>
<a href="#l15.522"></a><span id="l15.522" class="difflineminus">-    if ( !cellMid-&gt;mMid_Oid.mOid_Scope ) </span>
<a href="#l15.523"></a><span id="l15.523" class="difflineplus">+    if ( !cellMid-&gt;mMid_Oid.mOid_Scope )</span>
<a href="#l15.524"></a><span id="l15.524">     {</span>
<a href="#l15.525"></a><span id="l15.525">       if ( cellMid-&gt;mMid_Buf )</span>
<a href="#l15.526"></a><span id="l15.526">       {</span>
<a href="#l15.527"></a><span id="l15.527">         scope = store-&gt;BufToToken(ev, cellMid-&gt;mMid_Buf);</span>
<a href="#l15.528"></a><span id="l15.528">         cellMid-&gt;mMid_Buf = 0; // don't do scope lookup again</span>
<a href="#l15.529"></a><span id="l15.529">         ev-&gt;NewWarning(&quot;column mids need column scope&quot;);</span>
<a href="#l15.530"></a><span id="l15.530">       }</span>
<a href="#l15.531"></a><span id="l15.531">       cellMid-&gt;mMid_Oid.mOid_Scope = scope;</span>
<a href="#l15.532"></a><span id="l15.532" class="difflineat">@@ -702,31 +702,31 @@ morkBuilder::OnNewCell(morkEnv* ev, cons</span>
<a href="#l15.533"></a><span id="l15.533">     cellMid-&gt;ClearMid();</span>
<a href="#l15.534"></a><span id="l15.534">     cellMid-&gt;mMid_Oid.mOid_Id = store-&gt;BufToToken(ev, inBuf);</span>
<a href="#l15.535"></a><span id="l15.535">     cellMid-&gt;mMid_Oid.mOid_Scope = scope; // kColumnSpaceScope</span>
<a href="#l15.536"></a><span id="l15.536">   }</span>
<a href="#l15.537"></a><span id="l15.537">   else</span>
<a href="#l15.538"></a><span id="l15.538">     ev-&gt;NilPointerError(); // either inMid or inBuf must be non-nil</span>
<a href="#l15.539"></a><span id="l15.539"> </span>
<a href="#l15.540"></a><span id="l15.540">   mork_column column = cellMid-&gt;mMid_Oid.mOid_Id;</span>
<a href="#l15.541"></a><span id="l15.541" class="difflineminus">-  </span>
<a href="#l15.542"></a><span id="l15.542" class="difflineplus">+</span>
<a href="#l15.543"></a><span id="l15.543">   if ( mBuilder_Row &amp;&amp; ev-&gt;Good() ) // this cell must be inside a row</span>
<a href="#l15.544"></a><span id="l15.544">   {</span>
<a href="#l15.545"></a><span id="l15.545">       // mBuilder_Cell = this-&gt;AddBuilderCell(ev, *cellMid, cellChange);</span>
<a href="#l15.546"></a><span id="l15.546"> </span>
<a href="#l15.547"></a><span id="l15.547">       if ( mBuilder_CellsVecFill &gt;= morkBuilder_kCellsVecSize )</span>
<a href="#l15.548"></a><span id="l15.548">         this-&gt;FlushBuilderCells(ev);</span>
<a href="#l15.549"></a><span id="l15.549">       if ( ev-&gt;Good() )</span>
<a href="#l15.550"></a><span id="l15.550">       {</span>
<a href="#l15.551"></a><span id="l15.551">         if ( mBuilder_CellsVecFill &lt; morkBuilder_kCellsVecSize )</span>
<a href="#l15.552"></a><span id="l15.552">         {</span>
<a href="#l15.553"></a><span id="l15.553">           mork_fill ix = mBuilder_CellsVecFill++;</span>
<a href="#l15.554"></a><span id="l15.554">           morkCell* cell =  mBuilder_CellsVec + ix;</span>
<a href="#l15.555"></a><span id="l15.555">           cell-&gt;SetColumnAndChange(column, cellChange);</span>
<a href="#l15.556"></a><span id="l15.556" class="difflineminus">-          </span>
<a href="#l15.557"></a><span id="l15.557" class="difflineplus">+</span>
<a href="#l15.558"></a><span id="l15.558">           cell-&gt;mCell_Atom = 0;</span>
<a href="#l15.559"></a><span id="l15.559">           mBuilder_Cell = cell;</span>
<a href="#l15.560"></a><span id="l15.560">         }</span>
<a href="#l15.561"></a><span id="l15.561">         else</span>
<a href="#l15.562"></a><span id="l15.562">           ev-&gt;NewError(&quot;out of builder cells&quot;);</span>
<a href="#l15.563"></a><span id="l15.563">       }</span>
<a href="#l15.564"></a><span id="l15.564">   }</span>
<a href="#l15.565"></a><span id="l15.565"> </span>
<a href="#l15.566"></a><span id="l15.566" class="difflineat">@@ -788,17 +788,17 @@ morkBuilder::OnCellForm(morkEnv* ev, mor</span>
<a href="#l15.567"></a><span id="l15.567"> }</span>
<a href="#l15.568"></a><span id="l15.568"> </span>
<a href="#l15.569"></a><span id="l15.569"> /*virtual*/ void</span>
<a href="#l15.570"></a><span id="l15.570"> morkBuilder::OnCellEnd(morkEnv* ev, const morkSpan&amp; inSpan)</span>
<a href="#l15.571"></a><span id="l15.571"> // mp:Cell      ::= OnMinusCell? OnNewCell mp:CellItem? OnCellEnd</span>
<a href="#l15.572"></a><span id="l15.572"> {</span>
<a href="#l15.573"></a><span id="l15.573">   MORK_USED_2(ev,inSpan);</span>
<a href="#l15.574"></a><span id="l15.574">   // mParser_InCell = morkBool_kFalse;</span>
<a href="#l15.575"></a><span id="l15.575" class="difflineminus">-  </span>
<a href="#l15.576"></a><span id="l15.576" class="difflineplus">+</span>
<a href="#l15.577"></a><span id="l15.577">   mBuilder_MetaTokenSlot = 0;</span>
<a href="#l15.578"></a><span id="l15.578">   mBuilder_CellAtomScope = mBuilder_RowAtomScope;</span>
<a href="#l15.579"></a><span id="l15.579"> }</span>
<a href="#l15.580"></a><span id="l15.580"> </span>
<a href="#l15.581"></a><span id="l15.581"> /*virtual*/ void</span>
<a href="#l15.582"></a><span id="l15.582"> morkBuilder::OnValue(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l15.583"></a><span id="l15.583">   const morkBuf&amp; inBuf)</span>
<a href="#l15.584"></a><span id="l15.584"> // mp:CellItem  ::= mp:Slot | OnCellForm | OnCellGlitch</span>
<a href="#l15.585"></a><span id="l15.585" class="difflineat">@@ -844,22 +844,22 @@ morkBuilder::OnValue(morkEnv* ev, const </span>
<a href="#l15.586"></a><span id="l15.586">                 case '4':</span>
<a href="#l15.587"></a><span id="l15.587">                 case '5':</span>
<a href="#l15.588"></a><span id="l15.588">                 case '6':</span>
<a href="#l15.589"></a><span id="l15.589">                 case '7':</span>
<a href="#l15.590"></a><span id="l15.590">                 case '8':</span>
<a href="#l15.591"></a><span id="l15.591">                 case '9':</span>
<a href="#l15.592"></a><span id="l15.592">                   mBuilder_TablePriority = (mork_priority) ( c - '0' );</span>
<a href="#l15.593"></a><span id="l15.593">                   break;</span>
<a href="#l15.594"></a><span id="l15.594" class="difflineminus">-                </span>
<a href="#l15.595"></a><span id="l15.595" class="difflineplus">+</span>
<a href="#l15.596"></a><span id="l15.596">                 case 'u':</span>
<a href="#l15.597"></a><span id="l15.597">                 case 'U':</span>
<a href="#l15.598"></a><span id="l15.598">                   mBuilder_TableIsUnique = morkBool_kTrue;</span>
<a href="#l15.599"></a><span id="l15.599">                   break;</span>
<a href="#l15.600"></a><span id="l15.600" class="difflineminus">-                  </span>
<a href="#l15.601"></a><span id="l15.601" class="difflineplus">+</span>
<a href="#l15.602"></a><span id="l15.602">                 case 'v':</span>
<a href="#l15.603"></a><span id="l15.603">                 case 'V':</span>
<a href="#l15.604"></a><span id="l15.604">                   mBuilder_TableIsVerbose = morkBool_kTrue;</span>
<a href="#l15.605"></a><span id="l15.605">                   break;</span>
<a href="#l15.606"></a><span id="l15.606">               }</span>
<a href="#l15.607"></a><span id="l15.607">             }</span>
<a href="#l15.608"></a><span id="l15.608">           }</span>
<a href="#l15.609"></a><span id="l15.609">         }</span>
<a href="#l15.610"></a><span id="l15.610" class="difflineat">@@ -891,25 +891,25 @@ morkBuilder::OnValueMid(morkEnv* ev, con</span>
<a href="#l15.611"></a><span id="l15.611"> {</span>
<a href="#l15.612"></a><span id="l15.612">   MORK_USED_1(inSpan);</span>
<a href="#l15.613"></a><span id="l15.613">   morkStore* store = mBuilder_Store;</span>
<a href="#l15.614"></a><span id="l15.614">   morkCell* cell = mBuilder_Cell;</span>
<a href="#l15.615"></a><span id="l15.615"> </span>
<a href="#l15.616"></a><span id="l15.616">   morkMid valMid; // local mid for modifications</span>
<a href="#l15.617"></a><span id="l15.617">   mdbOid* valOid = &amp;valMid.mMid_Oid; // ref to oid inside mid</span>
<a href="#l15.618"></a><span id="l15.618">   *valOid = inMid.mMid_Oid; // bitwise copy inMid's oid</span>
<a href="#l15.619"></a><span id="l15.619" class="difflineminus">-  </span>
<a href="#l15.620"></a><span id="l15.620" class="difflineplus">+</span>
<a href="#l15.621"></a><span id="l15.621">   if ( inMid.mMid_Buf )</span>
<a href="#l15.622"></a><span id="l15.622">   {</span>
<a href="#l15.623"></a><span id="l15.623">     if ( !valOid-&gt;mOid_Scope )</span>
<a href="#l15.624"></a><span id="l15.624">       store-&gt;MidToOid(ev, inMid, valOid);</span>
<a href="#l15.625"></a><span id="l15.625">   }</span>
<a href="#l15.626"></a><span id="l15.626">   else if ( !valOid-&gt;mOid_Scope )</span>
<a href="#l15.627"></a><span id="l15.627">     valOid-&gt;mOid_Scope = mBuilder_CellAtomScope;</span>
<a href="#l15.628"></a><span id="l15.628" class="difflineminus">-  </span>
<a href="#l15.629"></a><span id="l15.629" class="difflineplus">+</span>
<a href="#l15.630"></a><span id="l15.630">   if ( cell )</span>
<a href="#l15.631"></a><span id="l15.631">   {</span>
<a href="#l15.632"></a><span id="l15.632">     morkBookAtom* atom = store-&gt;MidToAtom(ev, valMid);</span>
<a href="#l15.633"></a><span id="l15.633">     if ( atom )</span>
<a href="#l15.634"></a><span id="l15.634">       cell-&gt;SetAtom(ev, atom, store-&gt;StorePool());</span>
<a href="#l15.635"></a><span id="l15.635">     else</span>
<a href="#l15.636"></a><span id="l15.636">       ev-&gt;NewError(&quot;undefined cell value alias&quot;);</span>
<a href="#l15.637"></a><span id="l15.637">   }</span>
<a href="#l15.638"></a><span id="l15.638" class="difflineat">@@ -966,17 +966,17 @@ morkBuilder::OnRowMid(morkEnv* ev, const</span>
<a href="#l15.639"></a><span id="l15.639">     mdbOid rowOid = inMid.mMid_Oid;</span>
<a href="#l15.640"></a><span id="l15.640">     if ( inMid.mMid_Buf )</span>
<a href="#l15.641"></a><span id="l15.641">     {</span>
<a href="#l15.642"></a><span id="l15.642">       if ( !rowOid.mOid_Scope )</span>
<a href="#l15.643"></a><span id="l15.643">         store-&gt;MidToOid(ev, inMid, &amp;rowOid);</span>
<a href="#l15.644"></a><span id="l15.644">     }</span>
<a href="#l15.645"></a><span id="l15.645">     else if ( !rowOid.mOid_Scope )</span>
<a href="#l15.646"></a><span id="l15.646">       rowOid.mOid_Scope = mBuilder_RowRowScope;</span>
<a href="#l15.647"></a><span id="l15.647" class="difflineminus">-    </span>
<a href="#l15.648"></a><span id="l15.648" class="difflineplus">+</span>
<a href="#l15.649"></a><span id="l15.649">     if ( ev-&gt;Good() )</span>
<a href="#l15.650"></a><span id="l15.650">      {</span>
<a href="#l15.651"></a><span id="l15.651">        morkPool* pool = store-&gt;StorePool();</span>
<a href="#l15.652"></a><span id="l15.652">        morkAtom* atom = pool-&gt;NewRowOidAtom(ev, rowOid, &amp;store-&gt;mStore_Zone);</span>
<a href="#l15.653"></a><span id="l15.653">        if ( atom )</span>
<a href="#l15.654"></a><span id="l15.654">        {</span>
<a href="#l15.655"></a><span id="l15.655">          cell-&gt;SetAtom(ev, atom, pool);</span>
<a href="#l15.656"></a><span id="l15.656">          morkRow* row = store-&gt;OidToRow(ev, &amp;rowOid);</span>
<a href="#l15.657"></a><span id="l15.657" class="difflineat">@@ -1003,17 +1003,17 @@ morkBuilder::OnTableMid(morkEnv* ev, con</span>
<a href="#l15.658"></a><span id="l15.658">     mdbOid tableOid = inMid.mMid_Oid;</span>
<a href="#l15.659"></a><span id="l15.659">     if ( inMid.mMid_Buf )</span>
<a href="#l15.660"></a><span id="l15.660">     {</span>
<a href="#l15.661"></a><span id="l15.661">       if ( !tableOid.mOid_Scope )</span>
<a href="#l15.662"></a><span id="l15.662">         store-&gt;MidToOid(ev, inMid, &amp;tableOid);</span>
<a href="#l15.663"></a><span id="l15.663">     }</span>
<a href="#l15.664"></a><span id="l15.664">     else if ( !tableOid.mOid_Scope )</span>
<a href="#l15.665"></a><span id="l15.665">       tableOid.mOid_Scope = mBuilder_RowRowScope;</span>
<a href="#l15.666"></a><span id="l15.666" class="difflineminus">-    </span>
<a href="#l15.667"></a><span id="l15.667" class="difflineplus">+</span>
<a href="#l15.668"></a><span id="l15.668">     if ( ev-&gt;Good() )</span>
<a href="#l15.669"></a><span id="l15.669">      {</span>
<a href="#l15.670"></a><span id="l15.670">        morkPool* pool = store-&gt;StorePool();</span>
<a href="#l15.671"></a><span id="l15.671">        morkAtom* atom = pool-&gt;NewTableOidAtom(ev, tableOid, &amp;store-&gt;mStore_Zone);</span>
<a href="#l15.672"></a><span id="l15.672">        if ( atom )</span>
<a href="#l15.673"></a><span id="l15.673">        {</span>
<a href="#l15.674"></a><span id="l15.674">          cell-&gt;SetAtom(ev, atom, pool);</span>
<a href="#l15.675"></a><span id="l15.675">          morkTable* table = store-&gt;OidToTable(ev, &amp;tableOid,</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l16.1"></a><span id="l16.1" class="difflineminus">--- a/db/mork/src/morkBuilder.h</span>
<a href="#l16.2"></a><span id="l16.2" class="difflineplus">+++ b/db/mork/src/morkBuilder.h</span>
<a href="#l16.3"></a><span id="l16.3" class="difflineat">@@ -10,181 +10,181 @@</span>
<a href="#l16.4"></a><span id="l16.4"> #include &quot;mork.h&quot;</span>
<a href="#l16.5"></a><span id="l16.5"> #endif</span>
<a href="#l16.6"></a><span id="l16.6"> </span>
<a href="#l16.7"></a><span id="l16.7"> #ifndef _MORKPARSER_</span>
<a href="#l16.8"></a><span id="l16.8"> #include &quot;morkParser.h&quot;</span>
<a href="#l16.9"></a><span id="l16.9"> #endif</span>
<a href="#l16.10"></a><span id="l16.10"> </span>
<a href="#l16.11"></a><span id="l16.11"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l16.12"></a><span id="l16.12" class="difflineminus">- </span>
<a href="#l16.13"></a><span id="l16.13" class="difflineplus">+</span>
<a href="#l16.14"></a><span id="l16.14"> /*| kCellsVecSize: length of cell vector buffer inside morkBuilder</span>
<a href="#l16.15"></a><span id="l16.15"> |*/</span>
<a href="#l16.16"></a><span id="l16.16"> #define morkBuilder_kCellsVecSize 64</span>
<a href="#l16.17"></a><span id="l16.17"> </span>
<a href="#l16.18"></a><span id="l16.18"> #define morkBuilder_kDefaultBytesPerParseSegment 512 /* plausible to big */</span>
<a href="#l16.19"></a><span id="l16.19"> </span>
<a href="#l16.20"></a><span id="l16.20"> #define morkDerived_kBuilder     /*i*/ 0x4275 /* ascii 'Bu' */</span>
<a href="#l16.21"></a><span id="l16.21"> </span>
<a href="#l16.22"></a><span id="l16.22"> class morkBuilder /*d*/ : public morkParser {</span>
<a href="#l16.23"></a><span id="l16.23"> </span>
<a href="#l16.24"></a><span id="l16.24"> // public: // slots inherited from morkParser (meant to inform only)</span>
<a href="#l16.25"></a><span id="l16.25">   // nsIMdbHeap*       mNode_Heap;</span>
<a href="#l16.26"></a><span id="l16.26"> </span>
<a href="#l16.27"></a><span id="l16.27">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l16.28"></a><span id="l16.28">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l16.29"></a><span id="l16.29" class="difflineminus">-  </span>
<a href="#l16.30"></a><span id="l16.30" class="difflineplus">+</span>
<a href="#l16.31"></a><span id="l16.31">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l16.32"></a><span id="l16.32">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l16.33"></a><span id="l16.33">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l16.34"></a><span id="l16.34">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l16.35"></a><span id="l16.35" class="difflineminus">-  </span>
<a href="#l16.36"></a><span id="l16.36" class="difflineplus">+</span>
<a href="#l16.37"></a><span id="l16.37">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l16.38"></a><span id="l16.38">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l16.39"></a><span id="l16.39"> </span>
<a href="#l16.40"></a><span id="l16.40"> </span>
<a href="#l16.41"></a><span id="l16.41">   // nsIMdbHeap*      mParser_Heap;   // refcounted heap used for allocation</span>
<a href="#l16.42"></a><span id="l16.42">   // morkStream*   mParser_Stream; // refcounted input stream</span>
<a href="#l16.43"></a><span id="l16.43" class="difflineminus">-    </span>
<a href="#l16.44"></a><span id="l16.44" class="difflineplus">+</span>
<a href="#l16.45"></a><span id="l16.45">   // mork_u4       mParser_Tag; // must equal morkParser_kTag</span>
<a href="#l16.46"></a><span id="l16.46">   // mork_count    mParser_MoreGranularity; // constructor inBytesPerParseSegment</span>
<a href="#l16.47"></a><span id="l16.47"> </span>
<a href="#l16.48"></a><span id="l16.48">   // mork_u4       mParser_State; // state where parser should resume</span>
<a href="#l16.49"></a><span id="l16.49" class="difflineminus">- </span>
<a href="#l16.50"></a><span id="l16.50" class="difflineplus">+</span>
<a href="#l16.51"></a><span id="l16.51">   // after finding ends of group transactions, we can re-seek the start:</span>
<a href="#l16.52"></a><span id="l16.52">   // mork_pos      mParser_GroupContentStartPos; // start of this group</span>
<a href="#l16.53"></a><span id="l16.53" class="difflineminus">-    </span>
<a href="#l16.54"></a><span id="l16.54" class="difflineplus">+</span>
<a href="#l16.55"></a><span id="l16.55">   // mdbOid        mParser_TableOid; // table oid if inside a table</span>
<a href="#l16.56"></a><span id="l16.56">   // mdbOid        mParser_RowOid;   // row oid if inside a row</span>
<a href="#l16.57"></a><span id="l16.57">   // mork_gid      mParser_GroupId; // group ID if inside a group</span>
<a href="#l16.58"></a><span id="l16.58" class="difflineminus">-    </span>
<a href="#l16.59"></a><span id="l16.59" class="difflineplus">+</span>
<a href="#l16.60"></a><span id="l16.60">   // mork_bool     mParser_InPort;  // called OnNewPort but not OnPortEnd?</span>
<a href="#l16.61"></a><span id="l16.61">   // mork_bool     mParser_InDict;  // called OnNewDict but not OnDictEnd?</span>
<a href="#l16.62"></a><span id="l16.62">   // mork_bool     mParser_InCell;  // called OnNewCell but not OnCellEnd?</span>
<a href="#l16.63"></a><span id="l16.63">   // mork_bool     mParser_InMeta;  // called OnNewMeta but not OnMetaEnd?</span>
<a href="#l16.64"></a><span id="l16.64" class="difflineminus">-    </span>
<a href="#l16.65"></a><span id="l16.65" class="difflineplus">+</span>
<a href="#l16.66"></a><span id="l16.66">   // morkMid     mParser_Mid;   // current alias being parsed</span>
<a href="#l16.67"></a><span id="l16.67">   // note that mParser_Mid.mMid_Buf points at mParser_ScopeCoil below:</span>
<a href="#l16.68"></a><span id="l16.68" class="difflineminus">-    </span>
<a href="#l16.69"></a><span id="l16.69" class="difflineplus">+</span>
<a href="#l16.70"></a><span id="l16.70">   // blob coils allocated in mParser_Heap</span>
<a href="#l16.71"></a><span id="l16.71">   // morkCoil     mParser_ScopeCoil;   // place to accumulate ID scope blobs</span>
<a href="#l16.72"></a><span id="l16.72">   // morkCoil     mParser_ValueCoil;   // place to accumulate value blobs</span>
<a href="#l16.73"></a><span id="l16.73">   // morkCoil     mParser_ColumnCoil;  // place to accumulate column blobs</span>
<a href="#l16.74"></a><span id="l16.74">   // morkCoil     mParser_StringCoil;  // place to accumulate string blobs</span>
<a href="#l16.75"></a><span id="l16.75" class="difflineminus">-    </span>
<a href="#l16.76"></a><span id="l16.76" class="difflineplus">+</span>
<a href="#l16.77"></a><span id="l16.77">   // morkSpool    mParser_ScopeSpool;  // writes to mParser_ScopeCoil</span>
<a href="#l16.78"></a><span id="l16.78">   // morkSpool    mParser_ValueSpool;  // writes to mParser_ValueCoil</span>
<a href="#l16.79"></a><span id="l16.79">   // morkSpool    mParser_ColumnSpool; // writes to mParser_ColumnCoil</span>
<a href="#l16.80"></a><span id="l16.80">   // morkSpool    mParser_StringSpool; // writes to mParser_StringCoil</span>
<a href="#l16.81"></a><span id="l16.81"> </span>
<a href="#l16.82"></a><span id="l16.82">   // yarns allocated in mParser_Heap</span>
<a href="#l16.83"></a><span id="l16.83">   // morkYarn      mParser_MidYarn;   // place to receive from MidToYarn()</span>
<a href="#l16.84"></a><span id="l16.84" class="difflineminus">-  </span>
<a href="#l16.85"></a><span id="l16.85" class="difflineplus">+</span>
<a href="#l16.86"></a><span id="l16.86">   // span showing current ongoing file position status:</span>
<a href="#l16.87"></a><span id="l16.87">   // morkSpan      mParser_PortSpan; // span of current db port file</span>
<a href="#l16.88"></a><span id="l16.88" class="difflineminus">-    </span>
<a href="#l16.89"></a><span id="l16.89" class="difflineplus">+</span>
<a href="#l16.90"></a><span id="l16.90">   // various spans denoting nested subspaces inside the file's port span:</span>
<a href="#l16.91"></a><span id="l16.91">   // morkSpan      mParser_GroupSpan; // span of current transaction group</span>
<a href="#l16.92"></a><span id="l16.92">   // morkSpan      mParser_DictSpan;</span>
<a href="#l16.93"></a><span id="l16.93">   // morkSpan      mParser_AliasSpan;</span>
<a href="#l16.94"></a><span id="l16.94">   // morkSpan      mParser_MetaDictSpan;</span>
<a href="#l16.95"></a><span id="l16.95">   // morkSpan      mParser_TableSpan;</span>
<a href="#l16.96"></a><span id="l16.96">   // morkSpan      mParser_MetaTableSpan;</span>
<a href="#l16.97"></a><span id="l16.97">   // morkSpan      mParser_RowSpan;</span>
<a href="#l16.98"></a><span id="l16.98">   // morkSpan      mParser_MetaRowSpan;</span>
<a href="#l16.99"></a><span id="l16.99">   // morkSpan      mParser_CellSpan;</span>
<a href="#l16.100"></a><span id="l16.100">   // morkSpan      mParser_ColumnSpan;</span>
<a href="#l16.101"></a><span id="l16.101">   // morkSpan      mParser_SlotSpan;</span>
<a href="#l16.102"></a><span id="l16.102"> </span>
<a href="#l16.103"></a><span id="l16.103" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l16.104"></a><span id="l16.104" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l16.105"></a><span id="l16.105"> protected: // protected morkBuilder members</span>
<a href="#l16.106"></a><span id="l16.106" class="difflineminus">-  </span>
<a href="#l16.107"></a><span id="l16.107" class="difflineplus">+</span>
<a href="#l16.108"></a><span id="l16.108">   // weak refs that do not prevent closure of referenced nodes:</span>
<a href="#l16.109"></a><span id="l16.109">   morkStore*       mBuilder_Store; // weak ref to builder's store</span>
<a href="#l16.110"></a><span id="l16.110" class="difflineminus">-  </span>
<a href="#l16.111"></a><span id="l16.111" class="difflineplus">+</span>
<a href="#l16.112"></a><span id="l16.112">   // strong refs that do indeed prevent closure of referenced nodes:</span>
<a href="#l16.113"></a><span id="l16.113">   morkTable*       mBuilder_Table;    // current table being built (or nil)</span>
<a href="#l16.114"></a><span id="l16.114">   morkRow*         mBuilder_Row;      // current row being built (or nil)</span>
<a href="#l16.115"></a><span id="l16.115">   morkCell*        mBuilder_Cell;     // current cell within CellsVec (or nil)</span>
<a href="#l16.116"></a><span id="l16.116" class="difflineminus">-  </span>
<a href="#l16.117"></a><span id="l16.117" class="difflineplus">+</span>
<a href="#l16.118"></a><span id="l16.118">   morkRowSpace*    mBuilder_RowSpace;  // space for mBuilder_CellRowScope</span>
<a href="#l16.119"></a><span id="l16.119">   morkAtomSpace*   mBuilder_AtomSpace; // space for mBuilder_CellAtomScope</span>
<a href="#l16.120"></a><span id="l16.120" class="difflineminus">-  </span>
<a href="#l16.121"></a><span id="l16.121" class="difflineplus">+</span>
<a href="#l16.122"></a><span id="l16.122">   morkAtomSpace*   mBuilder_OidAtomSpace;   // ground atom space for oids</span>
<a href="#l16.123"></a><span id="l16.123">   morkAtomSpace*   mBuilder_ScopeAtomSpace; // ground atom space for scopes</span>
<a href="#l16.124"></a><span id="l16.124" class="difflineminus">-  </span>
<a href="#l16.125"></a><span id="l16.125" class="difflineplus">+</span>
<a href="#l16.126"></a><span id="l16.126">   // scoped object ids for current objects under construction:</span>
<a href="#l16.127"></a><span id="l16.127">   mdbOid           mBuilder_TableOid; // full oid for current table</span>
<a href="#l16.128"></a><span id="l16.128">   mdbOid           mBuilder_RowOid;   // full oid for current row</span>
<a href="#l16.129"></a><span id="l16.129" class="difflineminus">-      </span>
<a href="#l16.130"></a><span id="l16.130" class="difflineplus">+</span>
<a href="#l16.131"></a><span id="l16.131">   // tokens that become set as the result of meta cells in port rows:</span>
<a href="#l16.132"></a><span id="l16.132">   mork_cscode      mBuilder_PortForm;       // default port charset format</span>
<a href="#l16.133"></a><span id="l16.133">   mork_scope       mBuilder_PortRowScope;   // port row scope</span>
<a href="#l16.134"></a><span id="l16.134">   mork_scope       mBuilder_PortAtomScope;  // port atom scope</span>
<a href="#l16.135"></a><span id="l16.135"> </span>
<a href="#l16.136"></a><span id="l16.136">   // tokens that become set as the result of meta cells in meta tables:</span>
<a href="#l16.137"></a><span id="l16.137">   mork_cscode      mBuilder_TableForm;       // default table charset format</span>
<a href="#l16.138"></a><span id="l16.138">   mork_scope       mBuilder_TableRowScope;   // table row scope</span>
<a href="#l16.139"></a><span id="l16.139">   mork_scope       mBuilder_TableAtomScope;  // table atom scope</span>
<a href="#l16.140"></a><span id="l16.140">   mork_kind        mBuilder_TableKind;       // table kind</span>
<a href="#l16.141"></a><span id="l16.141" class="difflineminus">-  </span>
<a href="#l16.142"></a><span id="l16.142" class="difflineplus">+</span>
<a href="#l16.143"></a><span id="l16.143">   mork_token       mBuilder_TableStatus;  // dummy: priority/unique/verbose</span>
<a href="#l16.144"></a><span id="l16.144" class="difflineminus">-  </span>
<a href="#l16.145"></a><span id="l16.145" class="difflineplus">+</span>
<a href="#l16.146"></a><span id="l16.146">   mork_priority    mBuilder_TablePriority;   // table priority</span>
<a href="#l16.147"></a><span id="l16.147">   mork_bool        mBuilder_TableIsUnique;   // table uniqueness</span>
<a href="#l16.148"></a><span id="l16.148">   mork_bool        mBuilder_TableIsVerbose;  // table verboseness</span>
<a href="#l16.149"></a><span id="l16.149">   mork_u1          mBuilder_TablePadByte;    // for u4 alignment</span>
<a href="#l16.150"></a><span id="l16.150" class="difflineminus">-  </span>
<a href="#l16.151"></a><span id="l16.151" class="difflineplus">+</span>
<a href="#l16.152"></a><span id="l16.152">   // tokens that become set as the result of meta cells in meta rows:</span>
<a href="#l16.153"></a><span id="l16.153">   mork_cscode      mBuilder_RowForm;       // default row charset format</span>
<a href="#l16.154"></a><span id="l16.154">   mork_scope       mBuilder_RowRowScope;   // row scope per row metainfo</span>
<a href="#l16.155"></a><span id="l16.155">   mork_scope       mBuilder_RowAtomScope;  // row atom scope</span>
<a href="#l16.156"></a><span id="l16.156"> </span>
<a href="#l16.157"></a><span id="l16.157">   // meta tokens currently in force, driven by meta info slots above:</span>
<a href="#l16.158"></a><span id="l16.158">   mork_cscode      mBuilder_CellForm;       // cell charset format</span>
<a href="#l16.159"></a><span id="l16.159">   mork_scope       mBuilder_CellAtomScope;  // cell atom scope</span>
<a href="#l16.160"></a><span id="l16.160"> </span>
<a href="#l16.161"></a><span id="l16.161">   mork_cscode      mBuilder_DictForm;       // dict charset format</span>
<a href="#l16.162"></a><span id="l16.162">   mork_scope       mBuilder_DictAtomScope;  // dict atom scope</span>
<a href="#l16.163"></a><span id="l16.163"> </span>
<a href="#l16.164"></a><span id="l16.164">   mork_token*      mBuilder_MetaTokenSlot; // pointer to some slot above</span>
<a href="#l16.165"></a><span id="l16.165" class="difflineminus">-  </span>
<a href="#l16.166"></a><span id="l16.166" class="difflineplus">+</span>
<a href="#l16.167"></a><span id="l16.167">   // If any of these 'cut' bools are true, it means a minus was seen in the</span>
<a href="#l16.168"></a><span id="l16.168">   // Mork source text to indicate removal of content from some container.</span>
<a href="#l16.169"></a><span id="l16.169">   // (Note there is no corresponding 'add' bool, since add is the default.)</span>
<a href="#l16.170"></a><span id="l16.170">   // CutRow implies the current row should be cut from the table.</span>
<a href="#l16.171"></a><span id="l16.171">   // CutCell implies the current column should be cut from the row.</span>
<a href="#l16.172"></a><span id="l16.172">   mork_bool        mBuilder_DoCutRow;    // row with kCut change</span>
<a href="#l16.173"></a><span id="l16.173">   mork_bool        mBuilder_DoCutCell;   // cell with kCut change</span>
<a href="#l16.174"></a><span id="l16.174">   mork_u1          mBuilder_row_pad;    // pad to u4 alignment</span>
<a href="#l16.175"></a><span id="l16.175">   mork_u1          mBuilder_cell_pad;   // pad to u4 alignment</span>
<a href="#l16.176"></a><span id="l16.176" class="difflineminus">-  </span>
<a href="#l16.177"></a><span id="l16.177" class="difflineplus">+</span>
<a href="#l16.178"></a><span id="l16.178">   morkCell         mBuilder_CellsVec[ morkBuilder_kCellsVecSize + 1 ];</span>
<a href="#l16.179"></a><span id="l16.179">   mork_fill        mBuilder_CellsVecFill; // count used in CellsVec</span>
<a href="#l16.180"></a><span id="l16.180" class="difflineminus">-  // Note when mBuilder_CellsVecFill equals morkBuilder_kCellsVecSize, and </span>
<a href="#l16.181"></a><span id="l16.181" class="difflineplus">+  // Note when mBuilder_CellsVecFill equals morkBuilder_kCellsVecSize, and</span>
<a href="#l16.182"></a><span id="l16.182">   // another cell is added, this means all the cells in the vector above</span>
<a href="#l16.183"></a><span id="l16.183">   // must be flushed to the current row being built to create more room.</span>
<a href="#l16.184"></a><span id="l16.184" class="difflineminus">-  </span>
<a href="#l16.185"></a><span id="l16.185" class="difflineplus">+</span>
<a href="#l16.186"></a><span id="l16.186"> protected: // protected inlines</span>
<a href="#l16.187"></a><span id="l16.187"> </span>
<a href="#l16.188"></a><span id="l16.188">   mork_bool  CellVectorIsFull() const</span>
<a href="#l16.189"></a><span id="l16.189">   { return ( mBuilder_CellsVecFill == morkBuilder_kCellsVecSize ); }</span>
<a href="#l16.190"></a><span id="l16.190" class="difflineminus">-  </span>
<a href="#l16.191"></a><span id="l16.191" class="difflineplus">+</span>
<a href="#l16.192"></a><span id="l16.192"> // { ===== begin morkNode interface =====</span>
<a href="#l16.193"></a><span id="l16.193"> public: // morkNode virtual methods</span>
<a href="#l16.194"></a><span id="l16.194">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseBuilder() only if open</span>
<a href="#l16.195"></a><span id="l16.195">   virtual ~morkBuilder(); // assert that CloseBuilder() executed earlier</span>
<a href="#l16.196"></a><span id="l16.196" class="difflineminus">-  </span>
<a href="#l16.197"></a><span id="l16.197" class="difflineplus">+</span>
<a href="#l16.198"></a><span id="l16.198"> public: // morkYarn construction &amp; destruction</span>
<a href="#l16.199"></a><span id="l16.199">   morkBuilder(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l16.200"></a><span id="l16.200">     morkStream* ioStream,  // the readonly stream for input bytes</span>
<a href="#l16.201"></a><span id="l16.201">     mdb_count inBytesPerParseSegment, // target for ParseMore()</span>
<a href="#l16.202"></a><span id="l16.202">     nsIMdbHeap* ioSlotHeap, morkStore* ioStore</span>
<a href="#l16.203"></a><span id="l16.203">     );</span>
<a href="#l16.204"></a><span id="l16.204" class="difflineminus">-      </span>
<a href="#l16.205"></a><span id="l16.205" class="difflineplus">+</span>
<a href="#l16.206"></a><span id="l16.206">   void CloseBuilder(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l16.207"></a><span id="l16.207"> </span>
<a href="#l16.208"></a><span id="l16.208"> private: // copying is not allowed</span>
<a href="#l16.209"></a><span id="l16.209">   morkBuilder(const morkBuilder&amp; other);</span>
<a href="#l16.210"></a><span id="l16.210">   morkBuilder&amp; operator=(const morkBuilder&amp; other);</span>
<a href="#l16.211"></a><span id="l16.211"> </span>
<a href="#l16.212"></a><span id="l16.212"> public: // dynamic type identification</span>
<a href="#l16.213"></a><span id="l16.213">   mork_bool IsBuilder() const</span>
<a href="#l16.214"></a><span id="l16.214" class="difflineat">@@ -192,39 +192,39 @@ public: // dynamic type identification</span>
<a href="#l16.215"></a><span id="l16.215"> // } ===== end morkNode methods =====</span>
<a href="#l16.216"></a><span id="l16.216"> </span>
<a href="#l16.217"></a><span id="l16.217"> public: // errors</span>
<a href="#l16.218"></a><span id="l16.218">   static void NonBuilderTypeError(morkEnv* ev);</span>
<a href="#l16.219"></a><span id="l16.219">   static void NilBuilderCellError(morkEnv* ev);</span>
<a href="#l16.220"></a><span id="l16.220">   static void NilBuilderRowError(morkEnv* ev);</span>
<a href="#l16.221"></a><span id="l16.221">   static void NilBuilderTableError(morkEnv* ev);</span>
<a href="#l16.222"></a><span id="l16.222">   static void NonColumnSpaceScopeError(morkEnv* ev);</span>
<a href="#l16.223"></a><span id="l16.223" class="difflineminus">-  </span>
<a href="#l16.224"></a><span id="l16.224" class="difflineminus">-  void LogGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch, </span>
<a href="#l16.225"></a><span id="l16.225" class="difflineplus">+</span>
<a href="#l16.226"></a><span id="l16.226" class="difflineplus">+  void LogGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch,</span>
<a href="#l16.227"></a><span id="l16.227">     const char* inKind);</span>
<a href="#l16.228"></a><span id="l16.228"> </span>
<a href="#l16.229"></a><span id="l16.229"> public: // other builder methods</span>
<a href="#l16.230"></a><span id="l16.230"> </span>
<a href="#l16.231"></a><span id="l16.231">   morkCell* AddBuilderCell(morkEnv* ev,</span>
<a href="#l16.232"></a><span id="l16.232">     const morkMid&amp; inMid, mork_change inChange);</span>
<a href="#l16.233"></a><span id="l16.233"> </span>
<a href="#l16.234"></a><span id="l16.234">   void FlushBuilderCells(morkEnv* ev);</span>
<a href="#l16.235"></a><span id="l16.235" class="difflineminus">-  </span>
<a href="#l16.236"></a><span id="l16.236" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l16.237"></a><span id="l16.237" class="difflineplus">+</span>
<a href="#l16.238"></a><span id="l16.238" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l16.239"></a><span id="l16.239"> public: // in virtual morkParser methods, data flow subclass to parser</span>
<a href="#l16.240"></a><span id="l16.240"> </span>
<a href="#l16.241"></a><span id="l16.241">     virtual void MidToYarn(morkEnv* ev,</span>
<a href="#l16.242"></a><span id="l16.242">       const morkMid&amp; inMid,  // typically an alias to concat with strings</span>
<a href="#l16.243"></a><span id="l16.243">       mdbYarn* outYarn) override;</span>
<a href="#l16.244"></a><span id="l16.244">     // The parser might ask that some aliases be turned into yarns, so they</span>
<a href="#l16.245"></a><span id="l16.245">     // can be concatenated into longer blobs under some circumstances.  This</span>
<a href="#l16.246"></a><span id="l16.246">     // is an alternative to using a long and complex callback for many parts</span>
<a href="#l16.247"></a><span id="l16.247">     // for a single cell value.</span>
<a href="#l16.248"></a><span id="l16.248" class="difflineminus">-  </span>
<a href="#l16.249"></a><span id="l16.249" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l16.250"></a><span id="l16.250" class="difflineplus">+</span>
<a href="#l16.251"></a><span id="l16.251" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l16.252"></a><span id="l16.252"> public: // out virtual morkParser methods, data flow parser to subclass</span>
<a href="#l16.253"></a><span id="l16.253"> </span>
<a href="#l16.254"></a><span id="l16.254">   virtual void OnNewPort(morkEnv* ev, const morkPlace&amp; inPlace) override;</span>
<a href="#l16.255"></a><span id="l16.255">   virtual void OnPortGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l16.256"></a><span id="l16.256">   virtual void OnPortEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l16.257"></a><span id="l16.257"> </span>
<a href="#l16.258"></a><span id="l16.258">   virtual void OnNewGroup(morkEnv* ev, const morkPlace&amp; inPlace, mork_gid inGid) override;</span>
<a href="#l16.259"></a><span id="l16.259">   virtual void OnGroupGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l16.260"></a><span id="l16.260" class="difflineat">@@ -235,17 +235,17 @@ public: // out virtual morkParser method</span>
<a href="#l16.261"></a><span id="l16.261">     const morkMid&amp; inMid, mork_change inChange) override;</span>
<a href="#l16.262"></a><span id="l16.262">   virtual void OnPortRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l16.263"></a><span id="l16.263">   virtual void OnPortRowEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l16.264"></a><span id="l16.264"> </span>
<a href="#l16.265"></a><span id="l16.265">   virtual void OnNewTable(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l16.266"></a><span id="l16.266">     const morkMid&amp; inMid, mork_bool inCutAllRows) override;</span>
<a href="#l16.267"></a><span id="l16.267">   virtual void OnTableGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l16.268"></a><span id="l16.268">   virtual void OnTableEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l16.269"></a><span id="l16.269" class="difflineminus">-    </span>
<a href="#l16.270"></a><span id="l16.270" class="difflineplus">+</span>
<a href="#l16.271"></a><span id="l16.271">   virtual void OnNewMeta(morkEnv* ev, const morkPlace&amp; inPlace) override;</span>
<a href="#l16.272"></a><span id="l16.272">   virtual void OnMetaGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) override;</span>
<a href="#l16.273"></a><span id="l16.273">   virtual void OnMetaEnd(morkEnv* ev, const morkSpan&amp; inSpan) override;</span>
<a href="#l16.274"></a><span id="l16.274"> </span>
<a href="#l16.275"></a><span id="l16.275">   virtual void OnMinusRow(morkEnv* ev) override;</span>
<a href="#l16.276"></a><span id="l16.276">   virtual void OnNewRow(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l16.277"></a><span id="l16.277">     const morkMid&amp; inMid, mork_bool inCutAllCols) override;</span>
<a href="#l16.278"></a><span id="l16.278">   virtual void OnRowPos(morkEnv* ev, mork_pos inRowPos) override;</span>
<a href="#l16.279"></a><span id="l16.279" class="difflineat">@@ -278,26 +278,26 @@ public: // out virtual morkParser method</span>
<a href="#l16.280"></a><span id="l16.280">   virtual void OnValueMid(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l16.281"></a><span id="l16.281">     const morkMid&amp; inMid) override;</span>
<a href="#l16.282"></a><span id="l16.282"> </span>
<a href="#l16.283"></a><span id="l16.283">   virtual void OnRowMid(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l16.284"></a><span id="l16.284">     const morkMid&amp; inMid) override;</span>
<a href="#l16.285"></a><span id="l16.285"> </span>
<a href="#l16.286"></a><span id="l16.286">   virtual void OnTableMid(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l16.287"></a><span id="l16.287">     const morkMid&amp; inMid) override;</span>
<a href="#l16.288"></a><span id="l16.288" class="difflineminus">-  </span>
<a href="#l16.289"></a><span id="l16.289" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l16.290"></a><span id="l16.290" class="difflineplus">+</span>
<a href="#l16.291"></a><span id="l16.291" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l16.292"></a><span id="l16.292"> public: // public non-poly morkBuilder methods</span>
<a href="#l16.293"></a><span id="l16.293" class="difflineminus">-  </span>
<a href="#l16.294"></a><span id="l16.294" class="difflineminus">-  </span>
<a href="#l16.295"></a><span id="l16.295" class="difflineplus">+</span>
<a href="#l16.296"></a><span id="l16.296" class="difflineplus">+</span>
<a href="#l16.297"></a><span id="l16.297"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l16.298"></a><span id="l16.298">   static void SlotWeakBuilder(morkBuilder* me,</span>
<a href="#l16.299"></a><span id="l16.299">     morkEnv* ev, morkBuilder** ioSlot)</span>
<a href="#l16.300"></a><span id="l16.300">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l16.301"></a><span id="l16.301" class="difflineminus">-  </span>
<a href="#l16.302"></a><span id="l16.302" class="difflineplus">+</span>
<a href="#l16.303"></a><span id="l16.303">   static void SlotStrongBuilder(morkBuilder* me,</span>
<a href="#l16.304"></a><span id="l16.304">     morkEnv* ev, morkBuilder** ioSlot)</span>
<a href="#l16.305"></a><span id="l16.305">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l16.306"></a><span id="l16.306"> };</span>
<a href="#l16.307"></a><span id="l16.307"> </span>
<a href="#l16.308"></a><span id="l16.308"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l16.309"></a><span id="l16.309"> </span>
<a href="#l16.310"></a><span id="l16.310"> #endif /* _MORKBUILDER_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l17.1"></a><span id="l17.1" class="difflineminus">--- a/db/mork/src/morkCell.cpp</span>
<a href="#l17.2"></a><span id="l17.2" class="difflineplus">+++ b/db/mork/src/morkCell.cpp</span>
<a href="#l17.3"></a><span id="l17.3" class="difflineat">@@ -56,17 +56,17 @@ morkCell::AliasYarn(morkEnv* ev, mdbYarn</span>
<a href="#l17.4"></a><span id="l17.4"> }</span>
<a href="#l17.5"></a><span id="l17.5"> </span>
<a href="#l17.6"></a><span id="l17.6"> void</span>
<a href="#l17.7"></a><span id="l17.7"> morkCell::SetCellClean()</span>
<a href="#l17.8"></a><span id="l17.8"> {</span>
<a href="#l17.9"></a><span id="l17.9">   mork_column col = this-&gt;GetColumn();</span>
<a href="#l17.10"></a><span id="l17.10">   this-&gt;SetColumnAndChange(col, morkChange_kNil);</span>
<a href="#l17.11"></a><span id="l17.11"> }</span>
<a href="#l17.12"></a><span id="l17.12" class="difflineminus">-  </span>
<a href="#l17.13"></a><span id="l17.13" class="difflineplus">+</span>
<a href="#l17.14"></a><span id="l17.14"> void</span>
<a href="#l17.15"></a><span id="l17.15"> morkCell::SetCellDirty()</span>
<a href="#l17.16"></a><span id="l17.16"> {</span>
<a href="#l17.17"></a><span id="l17.17">   mork_column col = this-&gt;GetColumn();</span>
<a href="#l17.18"></a><span id="l17.18">   this-&gt;SetColumnAndChange(col, morkChange_kAdd);</span>
<a href="#l17.19"></a><span id="l17.19"> }</span>
<a href="#l17.20"></a><span id="l17.20"> </span>
<a href="#l17.21"></a><span id="l17.21"> void</span>
<a href="#l17.22"></a><span id="l17.22" class="difflineat">@@ -92,23 +92,23 @@ morkCell::SetAtom(morkEnv* ev, morkAtom*</span>
<a href="#l17.23"></a><span id="l17.23">       if ( oldAtom-&gt;CutCellUse(ev) == 0 )</span>
<a href="#l17.24"></a><span id="l17.24">       {</span>
<a href="#l17.25"></a><span id="l17.25">       // this was zapping atoms still in use - comment out until davidmc</span>
<a href="#l17.26"></a><span id="l17.26">       // can figure out a better fix.</span>
<a href="#l17.27"></a><span id="l17.27"> //        if ( ioPool )</span>
<a href="#l17.28"></a><span id="l17.28"> //        {</span>
<a href="#l17.29"></a><span id="l17.29"> //          if ( oldAtom-&gt;IsBook() )</span>
<a href="#l17.30"></a><span id="l17.30"> //            ((morkBookAtom*) oldAtom)-&gt;CutBookAtomFromSpace(ev);</span>
<a href="#l17.31"></a><span id="l17.31" class="difflineminus">-            </span>
<a href="#l17.32"></a><span id="l17.32" class="difflineplus">+</span>
<a href="#l17.33"></a><span id="l17.33"> //          ioPool-&gt;ZapAtom(ev, oldAtom);</span>
<a href="#l17.34"></a><span id="l17.34"> //        }</span>
<a href="#l17.35"></a><span id="l17.35"> //        else</span>
<a href="#l17.36"></a><span id="l17.36"> //          ev-&gt;NilPointerError();</span>
<a href="#l17.37"></a><span id="l17.37">       }</span>
<a href="#l17.38"></a><span id="l17.38">     }</span>
<a href="#l17.39"></a><span id="l17.39">     if ( ioAtom )</span>
<a href="#l17.40"></a><span id="l17.40">       ioAtom-&gt;AddCellUse(ev);</span>
<a href="#l17.41"></a><span id="l17.41" class="difflineminus">-      </span>
<a href="#l17.42"></a><span id="l17.42" class="difflineplus">+</span>
<a href="#l17.43"></a><span id="l17.43">     mCell_Atom = ioAtom;</span>
<a href="#l17.44"></a><span id="l17.44">   }</span>
<a href="#l17.45"></a><span id="l17.45"> }</span>
<a href="#l17.46"></a><span id="l17.46"> </span>
<a href="#l17.47"></a><span id="l17.47"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l18.1"></a><span id="l18.1" class="difflineminus">--- a/db/mork/src/morkCell.h</span>
<a href="#l18.2"></a><span id="l18.2" class="difflineplus">+++ b/db/mork/src/morkCell.h</span>
<a href="#l18.3"></a><span id="l18.3" class="difflineat">@@ -19,71 +19,71 @@</span>
<a href="#l18.4"></a><span id="l18.4"> #define morkDelta_Change(self) ((mork_change) ((self) &amp; morkDelta_kChangeMask))</span>
<a href="#l18.5"></a><span id="l18.5"> #define morkDelta_Column(self) ((self) &gt;&gt; morkDelta_kShift)</span>
<a href="#l18.6"></a><span id="l18.6"> </span>
<a href="#l18.7"></a><span id="l18.7"> class morkCell { // minimal cell format</span>
<a href="#l18.8"></a><span id="l18.8"> </span>
<a href="#l18.9"></a><span id="l18.9"> public:</span>
<a href="#l18.10"></a><span id="l18.10">   mork_delta   mCell_Delta;   // encoding of both column and change</span>
<a href="#l18.11"></a><span id="l18.11">   morkAtom*    mCell_Atom;    // content in this cell</span>
<a href="#l18.12"></a><span id="l18.12" class="difflineminus">-  </span>
<a href="#l18.13"></a><span id="l18.13" class="difflineplus">+</span>
<a href="#l18.14"></a><span id="l18.14"> public:</span>
<a href="#l18.15"></a><span id="l18.15">   morkCell() : mCell_Delta( 0 ), mCell_Atom( 0 ) { }</span>
<a href="#l18.16"></a><span id="l18.16"> </span>
<a href="#l18.17"></a><span id="l18.17">   morkCell(const morkCell&amp; c)</span>
<a href="#l18.18"></a><span id="l18.18">   : mCell_Delta( c.mCell_Delta ), mCell_Atom( c.mCell_Atom ) { }</span>
<a href="#l18.19"></a><span id="l18.19" class="difflineminus">-  </span>
<a href="#l18.20"></a><span id="l18.20" class="difflineplus">+</span>
<a href="#l18.21"></a><span id="l18.21">   // note if ioAtom is non-nil, caller needs to call ioAtom-&gt;AddCellUse():</span>
<a href="#l18.22"></a><span id="l18.22">   morkCell(mork_column inCol, mork_change inChange, morkAtom* ioAtom)</span>
<a href="#l18.23"></a><span id="l18.23">   {</span>
<a href="#l18.24"></a><span id="l18.24">     morkDelta_Init(mCell_Delta, inCol,inChange);</span>
<a href="#l18.25"></a><span id="l18.25">     mCell_Atom = ioAtom;</span>
<a href="#l18.26"></a><span id="l18.26">   }</span>
<a href="#l18.27"></a><span id="l18.27"> </span>
<a href="#l18.28"></a><span id="l18.28">   // note if ioAtom is non-nil, caller needs to call ioAtom-&gt;AddCellUse():</span>
<a href="#l18.29"></a><span id="l18.29">   void Init(mork_column inCol, mork_change inChange, morkAtom* ioAtom)</span>
<a href="#l18.30"></a><span id="l18.30">   {</span>
<a href="#l18.31"></a><span id="l18.31">     morkDelta_Init(mCell_Delta,inCol,inChange);</span>
<a href="#l18.32"></a><span id="l18.32">     mCell_Atom = ioAtom;</span>
<a href="#l18.33"></a><span id="l18.33">   }</span>
<a href="#l18.34"></a><span id="l18.34" class="difflineminus">-  </span>
<a href="#l18.35"></a><span id="l18.35" class="difflineplus">+</span>
<a href="#l18.36"></a><span id="l18.36">   mork_column  GetColumn() const { return morkDelta_Column(mCell_Delta); }</span>
<a href="#l18.37"></a><span id="l18.37">   mork_change  GetChange() const { return morkDelta_Change(mCell_Delta); }</span>
<a href="#l18.38"></a><span id="l18.38" class="difflineminus">-  </span>
<a href="#l18.39"></a><span id="l18.39" class="difflineplus">+</span>
<a href="#l18.40"></a><span id="l18.40">   mork_bool IsCellClean() const { return GetChange() == morkChange_kNil; }</span>
<a href="#l18.41"></a><span id="l18.41">   mork_bool IsCellDirty() const { return GetChange() != morkChange_kNil; }</span>
<a href="#l18.42"></a><span id="l18.42"> </span>
<a href="#l18.43"></a><span id="l18.43">   void SetCellClean(); // set change to kNil</span>
<a href="#l18.44"></a><span id="l18.44">   void SetCellDirty(); // set change to kAdd</span>
<a href="#l18.45"></a><span id="l18.45" class="difflineminus">-  </span>
<a href="#l18.46"></a><span id="l18.46" class="difflineplus">+</span>
<a href="#l18.47"></a><span id="l18.47">   void SetCellColumnDirty(mork_column inCol)</span>
<a href="#l18.48"></a><span id="l18.48">   { this-&gt;SetColumnAndChange(inCol, morkChange_kAdd); }</span>
<a href="#l18.49"></a><span id="l18.49" class="difflineminus">-  </span>
<a href="#l18.50"></a><span id="l18.50" class="difflineplus">+</span>
<a href="#l18.51"></a><span id="l18.51">   void SetCellColumnClean(mork_column inCol)</span>
<a href="#l18.52"></a><span id="l18.52">   { this-&gt;SetColumnAndChange(inCol, morkChange_kNil); }</span>
<a href="#l18.53"></a><span id="l18.53" class="difflineminus">-  </span>
<a href="#l18.54"></a><span id="l18.54" class="difflineplus">+</span>
<a href="#l18.55"></a><span id="l18.55">   void         SetColumnAndChange(mork_column inCol, mork_change inChange)</span>
<a href="#l18.56"></a><span id="l18.56">   { morkDelta_Init(mCell_Delta, inCol, inChange); }</span>
<a href="#l18.57"></a><span id="l18.57" class="difflineminus">-    </span>
<a href="#l18.58"></a><span id="l18.58" class="difflineplus">+</span>
<a href="#l18.59"></a><span id="l18.59">   morkAtom*  GetAtom() { return mCell_Atom; }</span>
<a href="#l18.60"></a><span id="l18.60" class="difflineminus">-  </span>
<a href="#l18.61"></a><span id="l18.61" class="difflineplus">+</span>
<a href="#l18.62"></a><span id="l18.62">   void       SetAtom(morkEnv* ev, morkAtom* ioAtom, morkPool* ioPool);</span>
<a href="#l18.63"></a><span id="l18.63">   // SetAtom() &quot;acquires&quot; the new ioAtom if non-nil, by calling AddCellUse()</span>
<a href="#l18.64"></a><span id="l18.64">   // to increase the refcount, and puts ioAtom into mCell_Atom.  If the old</span>
<a href="#l18.65"></a><span id="l18.65">   // atom in mCell_Atom is non-nil, then it is &quot;released&quot; first by a call to</span>
<a href="#l18.66"></a><span id="l18.66">   // CutCellUse(), and if the use count then becomes zero, then the old atom</span>
<a href="#l18.67"></a><span id="l18.67">   // is deallocated by returning it to the pool ioPool.  (And this is</span>
<a href="#l18.68"></a><span id="l18.68">   // why ioPool is a parameter to this method.)  Note that ioAtom can be nil</span>
<a href="#l18.69"></a><span id="l18.69">   // to cause the cell to refer to nothing, and the old atom in mCell_Atom</span>
<a href="#l18.70"></a><span id="l18.70">   // can also be nil, and all the atom refcounting is handled correctly.</span>
<a href="#l18.71"></a><span id="l18.71">   //</span>
<a href="#l18.72"></a><span id="l18.72">   // Note that if ioAtom was just created, it typically has a zero use count</span>
<a href="#l18.73"></a><span id="l18.73">   // before calling SetAtom().  But use count is one higher after SetAtom().</span>
<a href="#l18.74"></a><span id="l18.74" class="difflineminus">-  </span>
<a href="#l18.75"></a><span id="l18.75" class="difflineplus">+</span>
<a href="#l18.76"></a><span id="l18.76">   void       SetYarn(morkEnv* ev, const mdbYarn* inYarn, morkStore* ioStore);</span>
<a href="#l18.77"></a><span id="l18.77" class="difflineminus">-  </span>
<a href="#l18.78"></a><span id="l18.78" class="difflineplus">+</span>
<a href="#l18.79"></a><span id="l18.79">   void       AliasYarn(morkEnv* ev, mdbYarn* outYarn) const;</span>
<a href="#l18.80"></a><span id="l18.80">   void       GetYarn(morkEnv* ev, mdbYarn* outYarn) const;</span>
<a href="#l18.81"></a><span id="l18.81"> };</span>
<a href="#l18.82"></a><span id="l18.82"> </span>
<a href="#l18.83"></a><span id="l18.83"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l18.84"></a><span id="l18.84"> </span>
<a href="#l18.85"></a><span id="l18.85"> #endif /* _MORKCELL_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l19.1"></a><span id="l19.1" class="difflineminus">--- a/db/mork/src/morkCellObject.cpp</span>
<a href="#l19.2"></a><span id="l19.2" class="difflineplus">+++ b/db/mork/src/morkCellObject.cpp</span>
<a href="#l19.3"></a><span id="l19.3" class="difflineat">@@ -40,17 +40,17 @@</span>
<a href="#l19.4"></a><span id="l19.4"> #endif</span>
<a href="#l19.5"></a><span id="l19.5"> </span>
<a href="#l19.6"></a><span id="l19.6"> #ifndef _MORKSTORE_</span>
<a href="#l19.7"></a><span id="l19.7"> #include &quot;morkStore.h&quot;</span>
<a href="#l19.8"></a><span id="l19.8"> #endif</span>
<a href="#l19.9"></a><span id="l19.9"> </span>
<a href="#l19.10"></a><span id="l19.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l19.11"></a><span id="l19.11"> </span>
<a href="#l19.12"></a><span id="l19.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l19.13"></a><span id="l19.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l19.14"></a><span id="l19.14"> // { ===== begin morkNode interface =====</span>
<a href="#l19.15"></a><span id="l19.15"> </span>
<a href="#l19.16"></a><span id="l19.16"> /*public virtual*/ void</span>
<a href="#l19.17"></a><span id="l19.17"> morkCellObject::CloseMorkNode(morkEnv* ev) // CloseCellObject() only if open</span>
<a href="#l19.18"></a><span id="l19.18"> {</span>
<a href="#l19.19"></a><span id="l19.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l19.20"></a><span id="l19.20">   {</span>
<a href="#l19.21"></a><span id="l19.21">     this-&gt;MarkClosing();</span>
<a href="#l19.22"></a><span id="l19.22" class="difflineat">@@ -88,20 +88,20 @@ morkCellObject::morkCellObject(morkEnv* </span>
<a href="#l19.23"></a><span id="l19.23">         if ( store )</span>
<a href="#l19.24"></a><span id="l19.24">         {</span>
<a href="#l19.25"></a><span id="l19.25">           morkRowObject* rowObj = ioRow-&gt;AcquireRowObject(ev, store);</span>
<a href="#l19.26"></a><span id="l19.26">           if ( rowObj )</span>
<a href="#l19.27"></a><span id="l19.27">           {</span>
<a href="#l19.28"></a><span id="l19.28">             mCellObject_Row = ioRow;</span>
<a href="#l19.29"></a><span id="l19.29">             mCellObject_Cell = ioCell;</span>
<a href="#l19.30"></a><span id="l19.30">             mCellObject_RowSeed = ioRow-&gt;mRow_Seed;</span>
<a href="#l19.31"></a><span id="l19.31" class="difflineminus">-            </span>
<a href="#l19.32"></a><span id="l19.32" class="difflineplus">+</span>
<a href="#l19.33"></a><span id="l19.33">             // morkRowObject::SlotStrongRowObject(rowObj, ev,</span>
<a href="#l19.34"></a><span id="l19.34">             //  &amp;mCellObject_RowObject);</span>
<a href="#l19.35"></a><span id="l19.35" class="difflineminus">-              </span>
<a href="#l19.36"></a><span id="l19.36" class="difflineplus">+</span>
<a href="#l19.37"></a><span id="l19.37">             mCellObject_RowObject = rowObj; // assume control of strong ref</span>
<a href="#l19.38"></a><span id="l19.38">           }</span>
<a href="#l19.39"></a><span id="l19.39">           if ( ev-&gt;Good() )</span>
<a href="#l19.40"></a><span id="l19.40">             mNode_Derived = morkDerived_kCellObject;</span>
<a href="#l19.41"></a><span id="l19.41">         }</span>
<a href="#l19.42"></a><span id="l19.42">       }</span>
<a href="#l19.43"></a><span id="l19.43">       else</span>
<a href="#l19.44"></a><span id="l19.44">         ioRow-&gt;NonRowTypeError(ev);</span>
<a href="#l19.45"></a><span id="l19.45" class="difflineat">@@ -125,17 +125,17 @@ morkCellObject::CloseCellObject(morkEnv*</span>
<a href="#l19.46"></a><span id="l19.46">       this-&gt;CloseObject(ev);</span>
<a href="#l19.47"></a><span id="l19.47">       this-&gt;MarkShut();</span>
<a href="#l19.48"></a><span id="l19.48">     }</span>
<a href="#l19.49"></a><span id="l19.49">     else</span>
<a href="#l19.50"></a><span id="l19.50">       this-&gt;NonNodeError(ev);</span>
<a href="#l19.51"></a><span id="l19.51"> }</span>
<a href="#l19.52"></a><span id="l19.52"> </span>
<a href="#l19.53"></a><span id="l19.53"> // } ===== end morkNode methods =====</span>
<a href="#l19.54"></a><span id="l19.54" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l19.55"></a><span id="l19.55" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l19.56"></a><span id="l19.56"> </span>
<a href="#l19.57"></a><span id="l19.57"> mork_bool</span>
<a href="#l19.58"></a><span id="l19.58"> morkCellObject::ResyncWithRow(morkEnv* ev)</span>
<a href="#l19.59"></a><span id="l19.59"> {</span>
<a href="#l19.60"></a><span id="l19.60">   morkRow* row = mCellObject_Row;</span>
<a href="#l19.61"></a><span id="l19.61">   mork_pos pos = 0;</span>
<a href="#l19.62"></a><span id="l19.62">   morkCell* cell = row-&gt;GetCell(ev, mCellObject_Col, &amp;pos);</span>
<a href="#l19.63"></a><span id="l19.63">   if ( cell )</span>
<a href="#l19.64"></a><span id="l19.64" class="difflineat">@@ -155,17 +155,17 @@ morkCellObject::ResyncWithRow(morkEnv* e</span>
<a href="#l19.65"></a><span id="l19.65"> morkAtom*</span>
<a href="#l19.66"></a><span id="l19.66"> morkCellObject::GetCellAtom(morkEnv* ev) const</span>
<a href="#l19.67"></a><span id="l19.67"> {</span>
<a href="#l19.68"></a><span id="l19.68">   morkCell* cell = mCellObject_Cell;</span>
<a href="#l19.69"></a><span id="l19.69">   if ( cell )</span>
<a href="#l19.70"></a><span id="l19.70">     return cell-&gt;GetAtom();</span>
<a href="#l19.71"></a><span id="l19.71">   else</span>
<a href="#l19.72"></a><span id="l19.72">     this-&gt;NilCellError(ev);</span>
<a href="#l19.73"></a><span id="l19.73" class="difflineminus">-    </span>
<a href="#l19.74"></a><span id="l19.74" class="difflineplus">+</span>
<a href="#l19.75"></a><span id="l19.75">   return (morkAtom*) 0;</span>
<a href="#l19.76"></a><span id="l19.76"> }</span>
<a href="#l19.77"></a><span id="l19.77"> </span>
<a href="#l19.78"></a><span id="l19.78"> /*static*/ void</span>
<a href="#l19.79"></a><span id="l19.79"> morkCellObject::WrongRowObjectRowError(morkEnv* ev)</span>
<a href="#l19.80"></a><span id="l19.80"> {</span>
<a href="#l19.81"></a><span id="l19.81">   ev-&gt;NewError(&quot;mCellObject_Row != mCellObject_RowObject-&gt;mRowObject_Row&quot;);</span>
<a href="#l19.82"></a><span id="l19.82"> }</span>
<a href="#l19.83"></a><span id="l19.83" class="difflineat">@@ -255,17 +255,17 @@ morkCellObject::CanUseCell(nsIMdbEnv* me</span>
<a href="#l19.84"></a><span id="l19.84">         NonMutableNodeError(ev);</span>
<a href="#l19.85"></a><span id="l19.85">     }</span>
<a href="#l19.86"></a><span id="l19.86">     else</span>
<a href="#l19.87"></a><span id="l19.87">       NonCellObjectTypeError(ev);</span>
<a href="#l19.88"></a><span id="l19.88">   }</span>
<a href="#l19.89"></a><span id="l19.89">   *outErr = ev-&gt;AsErr();</span>
<a href="#l19.90"></a><span id="l19.90">   MORK_ASSERT(outEnv);</span>
<a href="#l19.91"></a><span id="l19.91">   *outCell = cell;</span>
<a href="#l19.92"></a><span id="l19.92" class="difflineminus">-  </span>
<a href="#l19.93"></a><span id="l19.93" class="difflineplus">+</span>
<a href="#l19.94"></a><span id="l19.94">   return outEnv;</span>
<a href="#l19.95"></a><span id="l19.95"> }</span>
<a href="#l19.96"></a><span id="l19.96"> </span>
<a href="#l19.97"></a><span id="l19.97"> // { ----- begin attribute methods -----</span>
<a href="#l19.98"></a><span id="l19.98"> NS_IMETHODIMP morkCellObject::SetBlob(nsIMdbEnv* /* mev */,</span>
<a href="#l19.99"></a><span id="l19.99">   nsIMdbBlob* /* ioBlob */)</span>
<a href="#l19.100"></a><span id="l19.100"> {</span>
<a href="#l19.101"></a><span id="l19.101">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l19.102"></a><span id="l19.102" class="difflineat">@@ -285,19 +285,19 @@ NS_IMETHODIMP morkCellObject::ClearBlob(</span>
<a href="#l19.103"></a><span id="l19.103"> </span>
<a href="#l19.104"></a><span id="l19.104"> NS_IMETHODIMP morkCellObject::GetBlobFill(nsIMdbEnv* mev,</span>
<a href="#l19.105"></a><span id="l19.105">   mdb_fill* outFill)</span>
<a href="#l19.106"></a><span id="l19.106"> // Same value that would be put into mYarn_Fill, if one called GetYarn()</span>
<a href="#l19.107"></a><span id="l19.107"> // with a yarn instance that had mYarn_Buf==nil and mYarn_Size==0.</span>
<a href="#l19.108"></a><span id="l19.108"> {</span>
<a href="#l19.109"></a><span id="l19.109">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l19.110"></a><span id="l19.110">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l19.111"></a><span id="l19.111" class="difflineminus">-}  // size of blob </span>
<a href="#l19.112"></a><span id="l19.112" class="difflineplus">+}  // size of blob</span>
<a href="#l19.113"></a><span id="l19.113"> </span>
<a href="#l19.114"></a><span id="l19.114" class="difflineminus">-NS_IMETHODIMP morkCellObject::SetYarn(nsIMdbEnv* mev, </span>
<a href="#l19.115"></a><span id="l19.115" class="difflineplus">+NS_IMETHODIMP morkCellObject::SetYarn(nsIMdbEnv* mev,</span>
<a href="#l19.116"></a><span id="l19.116">   const mdbYarn* inYarn)</span>
<a href="#l19.117"></a><span id="l19.117"> {</span>
<a href="#l19.118"></a><span id="l19.118">   nsresult outErr = NS_OK;</span>
<a href="#l19.119"></a><span id="l19.119">   morkCell* cell = 0;</span>
<a href="#l19.120"></a><span id="l19.120">   morkEnv* ev = this-&gt;CanUseCell(mev, /*inMutable*/ morkBool_kTrue,</span>
<a href="#l19.121"></a><span id="l19.121">     &amp;outErr, &amp;cell);</span>
<a href="#l19.122"></a><span id="l19.122">   if ( ev )</span>
<a href="#l19.123"></a><span id="l19.123">   {</span>
<a href="#l19.124"></a><span id="l19.124" class="difflineat">@@ -312,40 +312,40 @@ NS_IMETHODIMP morkCellObject::SetYarn(ns</span>
<a href="#l19.125"></a><span id="l19.125">           row-&gt;MaybeDirtySpaceStoreAndRow();</span>
<a href="#l19.126"></a><span id="l19.126">       }</span>
<a href="#l19.127"></a><span id="l19.127">     }</span>
<a href="#l19.128"></a><span id="l19.128">     else</span>
<a href="#l19.129"></a><span id="l19.129">       ev-&gt;NilPointerError();</span>
<a href="#l19.130"></a><span id="l19.130"> </span>
<a href="#l19.131"></a><span id="l19.131">     outErr = ev-&gt;AsErr();</span>
<a href="#l19.132"></a><span id="l19.132">   }</span>
<a href="#l19.133"></a><span id="l19.133" class="difflineminus">-    </span>
<a href="#l19.134"></a><span id="l19.134" class="difflineplus">+</span>
<a href="#l19.135"></a><span id="l19.135">   return outErr;</span>
<a href="#l19.136"></a><span id="l19.136"> }   // reads from yarn slots</span>
<a href="#l19.137"></a><span id="l19.137"> // make this text object contain content from the yarn's buffer</span>
<a href="#l19.138"></a><span id="l19.138"> </span>
<a href="#l19.139"></a><span id="l19.139" class="difflineminus">-NS_IMETHODIMP morkCellObject::GetYarn(nsIMdbEnv* mev, </span>
<a href="#l19.140"></a><span id="l19.140" class="difflineplus">+NS_IMETHODIMP morkCellObject::GetYarn(nsIMdbEnv* mev,</span>
<a href="#l19.141"></a><span id="l19.141">   mdbYarn* outYarn)</span>
<a href="#l19.142"></a><span id="l19.142"> {</span>
<a href="#l19.143"></a><span id="l19.143">   nsresult outErr = NS_OK;</span>
<a href="#l19.144"></a><span id="l19.144">   morkCell* cell = 0;</span>
<a href="#l19.145"></a><span id="l19.145">   morkEnv* ev = this-&gt;CanUseCell(mev, /*inMutable*/ morkBool_kTrue,</span>
<a href="#l19.146"></a><span id="l19.146">     &amp;outErr, &amp;cell);</span>
<a href="#l19.147"></a><span id="l19.147">   if ( ev )</span>
<a href="#l19.148"></a><span id="l19.148">   {</span>
<a href="#l19.149"></a><span id="l19.149">     morkAtom* atom = cell-&gt;GetAtom();</span>
<a href="#l19.150"></a><span id="l19.150">     atom-&gt;GetYarn(outYarn);</span>
<a href="#l19.151"></a><span id="l19.151">     outErr = ev-&gt;AsErr();</span>
<a href="#l19.152"></a><span id="l19.152">   }</span>
<a href="#l19.153"></a><span id="l19.153" class="difflineminus">-    </span>
<a href="#l19.154"></a><span id="l19.154" class="difflineplus">+</span>
<a href="#l19.155"></a><span id="l19.155">   return outErr;</span>
<a href="#l19.156"></a><span id="l19.156" class="difflineminus">-}  // writes some yarn slots </span>
<a href="#l19.157"></a><span id="l19.157" class="difflineplus">+}  // writes some yarn slots</span>
<a href="#l19.158"></a><span id="l19.158"> // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l19.159"></a><span id="l19.159"> </span>
<a href="#l19.160"></a><span id="l19.160" class="difflineminus">-NS_IMETHODIMP morkCellObject::AliasYarn(nsIMdbEnv* mev, </span>
<a href="#l19.161"></a><span id="l19.161" class="difflineplus">+NS_IMETHODIMP morkCellObject::AliasYarn(nsIMdbEnv* mev,</span>
<a href="#l19.162"></a><span id="l19.162">   mdbYarn* outYarn)</span>
<a href="#l19.163"></a><span id="l19.163"> {</span>
<a href="#l19.164"></a><span id="l19.164">   nsresult outErr = NS_OK;</span>
<a href="#l19.165"></a><span id="l19.165">   morkCell* cell = 0;</span>
<a href="#l19.166"></a><span id="l19.166">   morkEnv* ev = this-&gt;CanUseCell(mev, /*inMutable*/ morkBool_kTrue,</span>
<a href="#l19.167"></a><span id="l19.167">     &amp;outErr, &amp;cell);</span>
<a href="#l19.168"></a><span id="l19.168">   if ( ev )</span>
<a href="#l19.169"></a><span id="l19.169">   {</span>
<a href="#l19.170"></a><span id="l19.170" class="difflineat">@@ -364,17 +364,17 @@ NS_IMETHODIMP morkCellObject::AliasYarn(</span>
<a href="#l19.171"></a><span id="l19.171"> // { ===== begin nsIMdbCell methods =====</span>
<a href="#l19.172"></a><span id="l19.172"> </span>
<a href="#l19.173"></a><span id="l19.173"> // { ----- begin attribute methods -----</span>
<a href="#l19.174"></a><span id="l19.174"> NS_IMETHODIMP morkCellObject::SetColumn(nsIMdbEnv* mev, mdb_column inColumn)</span>
<a href="#l19.175"></a><span id="l19.175"> {</span>
<a href="#l19.176"></a><span id="l19.176">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l19.177"></a><span id="l19.177">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l19.178"></a><span id="l19.178">   // remember row-&gt;MaybeDirtySpaceStoreAndRow();</span>
<a href="#l19.179"></a><span id="l19.179" class="difflineminus">-} </span>
<a href="#l19.180"></a><span id="l19.180" class="difflineplus">+}</span>
<a href="#l19.181"></a><span id="l19.181"> </span>
<a href="#l19.182"></a><span id="l19.182"> NS_IMETHODIMP morkCellObject::GetColumn(nsIMdbEnv* mev, mdb_column* outColumn)</span>
<a href="#l19.183"></a><span id="l19.183"> {</span>
<a href="#l19.184"></a><span id="l19.184">   nsresult outErr = NS_OK;</span>
<a href="#l19.185"></a><span id="l19.185">   mdb_column col = 0;</span>
<a href="#l19.186"></a><span id="l19.186">   morkCell* cell = 0;</span>
<a href="#l19.187"></a><span id="l19.187">   morkEnv* ev = this-&gt;CanUseCell(mev, /*inMutable*/ morkBool_kTrue,</span>
<a href="#l19.188"></a><span id="l19.188">     &amp;outErr, &amp;cell);</span>
<a href="#l19.189"></a><span id="l19.189" class="difflineat">@@ -384,17 +384,17 @@ NS_IMETHODIMP morkCellObject::GetColumn(</span>
<a href="#l19.190"></a><span id="l19.190">     outErr = ev-&gt;AsErr();</span>
<a href="#l19.191"></a><span id="l19.191">   }</span>
<a href="#l19.192"></a><span id="l19.192">   if ( outColumn )</span>
<a href="#l19.193"></a><span id="l19.193">     *outColumn = col;</span>
<a href="#l19.194"></a><span id="l19.194">   return outErr;</span>
<a href="#l19.195"></a><span id="l19.195"> }</span>
<a href="#l19.196"></a><span id="l19.196"> </span>
<a href="#l19.197"></a><span id="l19.197"> NS_IMETHODIMP morkCellObject::GetCellInfo(  // all cell metainfo except actual content</span>
<a href="#l19.198"></a><span id="l19.198" class="difflineminus">-  nsIMdbEnv* mev, </span>
<a href="#l19.199"></a><span id="l19.199" class="difflineplus">+  nsIMdbEnv* mev,</span>
<a href="#l19.200"></a><span id="l19.200">   mdb_column* outColumn,           // the column in the containing row</span>
<a href="#l19.201"></a><span id="l19.201">   mdb_fill*   outBlobFill,         // the size of text content in bytes</span>
<a href="#l19.202"></a><span id="l19.202">   mdbOid*     outChildOid,         // oid of possible row or table child</span>
<a href="#l19.203"></a><span id="l19.203">   mdb_bool*   outIsRowChild)  // nonzero if child, and a row child</span>
<a href="#l19.204"></a><span id="l19.204"> // Checking all cell metainfo is a good way to avoid forcing a large cell</span>
<a href="#l19.205"></a><span id="l19.205"> // in to memory when you don't actually want to use the content.</span>
<a href="#l19.206"></a><span id="l19.206"> {</span>
<a href="#l19.207"></a><span id="l19.207">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l19.208"></a><span id="l19.208" class="difflineat">@@ -408,17 +408,17 @@ NS_IMETHODIMP morkCellObject::GetRow(nsI</span>
<a href="#l19.209"></a><span id="l19.209">   nsresult outErr = NS_OK;</span>
<a href="#l19.210"></a><span id="l19.210">   nsIMdbRow* outRow = 0;</span>
<a href="#l19.211"></a><span id="l19.211">   morkCell* cell = 0;</span>
<a href="#l19.212"></a><span id="l19.212">   morkEnv* ev = this-&gt;CanUseCell(mev, /*inMutable*/ morkBool_kTrue,</span>
<a href="#l19.213"></a><span id="l19.213">     &amp;outErr, &amp;cell);</span>
<a href="#l19.214"></a><span id="l19.214">   if ( ev )</span>
<a href="#l19.215"></a><span id="l19.215">   {</span>
<a href="#l19.216"></a><span id="l19.216">     outRow = mCellObject_RowObject-&gt;AcquireRowHandle(ev);</span>
<a href="#l19.217"></a><span id="l19.217" class="difflineminus">-    </span>
<a href="#l19.218"></a><span id="l19.218" class="difflineplus">+</span>
<a href="#l19.219"></a><span id="l19.219">     outErr = ev-&gt;AsErr();</span>
<a href="#l19.220"></a><span id="l19.220">   }</span>
<a href="#l19.221"></a><span id="l19.221">   if ( acqRow )</span>
<a href="#l19.222"></a><span id="l19.222">     *acqRow = outRow;</span>
<a href="#l19.223"></a><span id="l19.223">   return outErr;</span>
<a href="#l19.224"></a><span id="l19.224"> }</span>
<a href="#l19.225"></a><span id="l19.225"> </span>
<a href="#l19.226"></a><span id="l19.226"> NS_IMETHODIMP morkCellObject::GetPort(nsIMdbEnv* mev, // port containing cell</span>
<a href="#l19.227"></a><span id="l19.227" class="difflineat">@@ -465,22 +465,22 @@ NS_IMETHODIMP morkCellObject::HasAnyChil</span>
<a href="#l19.228"></a><span id="l19.228">   {</span>
<a href="#l19.229"></a><span id="l19.229">     morkAtom* atom = GetCellAtom(ev);</span>
<a href="#l19.230"></a><span id="l19.230">     if ( atom )</span>
<a href="#l19.231"></a><span id="l19.231">     {</span>
<a href="#l19.232"></a><span id="l19.232">       isRow = atom-&gt;IsRowOid();</span>
<a href="#l19.233"></a><span id="l19.233">       if ( isRow || atom-&gt;IsTableOid() )</span>
<a href="#l19.234"></a><span id="l19.234">         *outOid = ((morkOidAtom*) atom)-&gt;mOidAtom_Oid;</span>
<a href="#l19.235"></a><span id="l19.235">     }</span>
<a href="#l19.236"></a><span id="l19.236" class="difflineminus">-      </span>
<a href="#l19.237"></a><span id="l19.237" class="difflineplus">+</span>
<a href="#l19.238"></a><span id="l19.238">     outErr = ev-&gt;AsErr();</span>
<a href="#l19.239"></a><span id="l19.239">   }</span>
<a href="#l19.240"></a><span id="l19.240">   if ( outIsRow )</span>
<a href="#l19.241"></a><span id="l19.241">     *outIsRow = isRow;</span>
<a href="#l19.242"></a><span id="l19.242" class="difflineminus">-    </span>
<a href="#l19.243"></a><span id="l19.243" class="difflineplus">+</span>
<a href="#l19.244"></a><span id="l19.244">   return outErr;</span>
<a href="#l19.245"></a><span id="l19.245"> }</span>
<a href="#l19.246"></a><span id="l19.246"> </span>
<a href="#l19.247"></a><span id="l19.247"> NS_IMETHODIMP morkCellObject::GetAnyChild( // access table of specific attribute</span>
<a href="#l19.248"></a><span id="l19.248">   nsIMdbEnv* mev, // context</span>
<a href="#l19.249"></a><span id="l19.249">   nsIMdbRow** acqRow, // child row (or null)</span>
<a href="#l19.250"></a><span id="l19.250">   nsIMdbTable** acqTable) // child table (or null)</span>
<a href="#l19.251"></a><span id="l19.251"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l20.1"></a><span id="l20.1" class="difflineminus">--- a/db/mork/src/morkCellObject.h</span>
<a href="#l20.2"></a><span id="l20.2" class="difflineplus">+++ b/db/mork/src/morkCellObject.h</span>
<a href="#l20.3"></a><span id="l20.3" class="difflineat">@@ -42,17 +42,17 @@ public: // state is public because the e</span>
<a href="#l20.4"></a><span id="l20.4">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l20.5"></a><span id="l20.5"> </span>
<a href="#l20.6"></a><span id="l20.6">   morkRowObject*  mCellObject_RowObject;  // strong ref to row's object</span>
<a href="#l20.7"></a><span id="l20.7">   morkRow*        mCellObject_Row;        // cell's row if still in row object</span>
<a href="#l20.8"></a><span id="l20.8">   morkCell*       mCellObject_Cell;       // cell in row if rowseed matches</span>
<a href="#l20.9"></a><span id="l20.9">   mork_column     mCellObject_Col;        // col of cell last living in pos</span>
<a href="#l20.10"></a><span id="l20.10">   mork_u2         mCellObject_RowSeed;    // copy of row's seed</span>
<a href="#l20.11"></a><span id="l20.11">   mork_u2         mCellObject_Pos;        // position of cell in row</span>
<a href="#l20.12"></a><span id="l20.12" class="difflineminus">-  </span>
<a href="#l20.13"></a><span id="l20.13" class="difflineplus">+</span>
<a href="#l20.14"></a><span id="l20.14"> // { ===== begin morkNode interface =====</span>
<a href="#l20.15"></a><span id="l20.15"> public: // morkNode virtual methods</span>
<a href="#l20.16"></a><span id="l20.16">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseCellObject() only if open</span>
<a href="#l20.17"></a><span id="l20.17"> </span>
<a href="#l20.18"></a><span id="l20.18"> public: // morkCellObject construction &amp; destruction</span>
<a href="#l20.19"></a><span id="l20.19">   morkCellObject(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l20.20"></a><span id="l20.20">     nsIMdbHeap* ioHeap, morkRow* ioRow, morkCell* ioCell,</span>
<a href="#l20.21"></a><span id="l20.21">     mork_column inCol, mork_pos inPos);</span>
<a href="#l20.22"></a><span id="l20.22" class="difflineat">@@ -157,17 +157,17 @@ public: // other cell node methods</span>
<a href="#l20.23"></a><span id="l20.23">   static void NonCellObjectTypeError(morkEnv* ev);</span>
<a href="#l20.24"></a><span id="l20.24"> </span>
<a href="#l20.25"></a><span id="l20.25">   nsIMdbCell* AcquireCellHandle(morkEnv* ev);</span>
<a href="#l20.26"></a><span id="l20.26"> </span>
<a href="#l20.27"></a><span id="l20.27"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l20.28"></a><span id="l20.28">   static void SlotWeakCellObject(morkCellObject* me,</span>
<a href="#l20.29"></a><span id="l20.29">     morkEnv* ev, morkCellObject** ioSlot)</span>
<a href="#l20.30"></a><span id="l20.30">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l20.31"></a><span id="l20.31" class="difflineminus">-  </span>
<a href="#l20.32"></a><span id="l20.32" class="difflineplus">+</span>
<a href="#l20.33"></a><span id="l20.33">   static void SlotStrongCellObject(morkCellObject* me,</span>
<a href="#l20.34"></a><span id="l20.34">     morkEnv* ev, morkCellObject** ioSlot)</span>
<a href="#l20.35"></a><span id="l20.35">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l20.36"></a><span id="l20.36"> };</span>
<a href="#l20.37"></a><span id="l20.37"> </span>
<a href="#l20.38"></a><span id="l20.38"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l20.39"></a><span id="l20.39"> </span>
<a href="#l20.40"></a><span id="l20.40"> #endif /* _MORKCELLOBJECT_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l21.1"></a><span id="l21.1" class="difflineminus">--- a/db/mork/src/morkCh.cpp</span>
<a href="#l21.2"></a><span id="l21.2" class="difflineplus">+++ b/db/mork/src/morkCh.cpp</span>
<a href="#l21.3"></a><span id="l21.3" class="difflineat">@@ -88,102 +88,102 @@ const mork_flags morkCh_Type[] = /* deri</span>
<a href="#l21.4"></a><span id="l21.4">   0,                /* 0x18 */</span>
<a href="#l21.5"></a><span id="l21.5">   0,                /* 0x19 */</span>
<a href="#l21.6"></a><span id="l21.6">   0,                /* 0x1A */</span>
<a href="#l21.7"></a><span id="l21.7">   0,                /* 0x1B */</span>
<a href="#l21.8"></a><span id="l21.8">   0,                /* 0x1C */</span>
<a href="#l21.9"></a><span id="l21.9">   0,                /* 0x1D */</span>
<a href="#l21.10"></a><span id="l21.10">   0,                /* 0x1E */</span>
<a href="#l21.11"></a><span id="l21.11">   0,                /* 0x1F */</span>
<a href="#l21.12"></a><span id="l21.12" class="difflineminus">-  </span>
<a href="#l21.13"></a><span id="l21.13" class="difflineplus">+</span>
<a href="#l21.14"></a><span id="l21.14">   morkCh_kV|morkCh_kW,     /* 0x20 space */</span>
<a href="#l21.15"></a><span id="l21.15">   morkCh_kV|morkCh_kM,     /* 0x21 ! */</span>
<a href="#l21.16"></a><span id="l21.16">   morkCh_kV,               /* 0x22 &quot; */</span>
<a href="#l21.17"></a><span id="l21.17">   morkCh_kV,               /* 0x23 # */</span>
<a href="#l21.18"></a><span id="l21.18">   0,                       /* 0x24 $ cannot be kV because needs escape */</span>
<a href="#l21.19"></a><span id="l21.19">   morkCh_kV,               /* 0x25 % */</span>
<a href="#l21.20"></a><span id="l21.20">   morkCh_kV,               /* 0x26 &amp; */</span>
<a href="#l21.21"></a><span id="l21.21">   morkCh_kV,               /* 0x27 ' */</span>
<a href="#l21.22"></a><span id="l21.22">   morkCh_kV,               /* 0x28 ( */</span>
<a href="#l21.23"></a><span id="l21.23">   0,                       /* 0x29 ) cannot be kV because needs escape */</span>
<a href="#l21.24"></a><span id="l21.24">   morkCh_kV,               /* 0x2A * */</span>
<a href="#l21.25"></a><span id="l21.25">   morkCh_kV|morkCh_kM,     /* 0x2B + */</span>
<a href="#l21.26"></a><span id="l21.26">   morkCh_kV,               /* 0x2C , */</span>
<a href="#l21.27"></a><span id="l21.27">   morkCh_kV|morkCh_kM,     /* 0x2D - */</span>
<a href="#l21.28"></a><span id="l21.28">   morkCh_kV,               /* 0x2E . */</span>
<a href="#l21.29"></a><span id="l21.29">   morkCh_kV,               /* 0x2F / */</span>
<a href="#l21.30"></a><span id="l21.30" class="difflineminus">-  </span>
<a href="#l21.31"></a><span id="l21.31" class="difflineplus">+</span>
<a href="#l21.32"></a><span id="l21.32">   morkCh_kV|morkCh_kD|morkCh_kX,  /* 0x30 0 */</span>
<a href="#l21.33"></a><span id="l21.33">   morkCh_kV|morkCh_kD|morkCh_kX,  /* 0x31 1 */</span>
<a href="#l21.34"></a><span id="l21.34">   morkCh_kV|morkCh_kD|morkCh_kX,  /* 0x32 2 */</span>
<a href="#l21.35"></a><span id="l21.35">   morkCh_kV|morkCh_kD|morkCh_kX,  /* 0x33 3 */</span>
<a href="#l21.36"></a><span id="l21.36">   morkCh_kV|morkCh_kD|morkCh_kX,  /* 0x34 4 */</span>
<a href="#l21.37"></a><span id="l21.37">   morkCh_kV|morkCh_kD|morkCh_kX,  /* 0x35 5 */</span>
<a href="#l21.38"></a><span id="l21.38">   morkCh_kV|morkCh_kD|morkCh_kX,  /* 0x36 6 */</span>
<a href="#l21.39"></a><span id="l21.39">   morkCh_kV|morkCh_kD|morkCh_kX,  /* 0x37 7 */</span>
<a href="#l21.40"></a><span id="l21.40">   morkCh_kV|morkCh_kD|morkCh_kX,  /* 0x38 8 */</span>
<a href="#l21.41"></a><span id="l21.41">   morkCh_kV|morkCh_kD|morkCh_kX,  /* 0x39 9 */</span>
<a href="#l21.42"></a><span id="l21.42">   morkCh_kV|morkCh_kN|morkCh_kM,        /* 0x3A : */</span>
<a href="#l21.43"></a><span id="l21.43">   morkCh_kV,                /* 0x3B ; */</span>
<a href="#l21.44"></a><span id="l21.44">   morkCh_kV,                /* 0x3C &lt; */</span>
<a href="#l21.45"></a><span id="l21.45">   morkCh_kV,                /* 0x3D = */</span>
<a href="#l21.46"></a><span id="l21.46">   morkCh_kV,                /* 0x3E &gt; */</span>
<a href="#l21.47"></a><span id="l21.47">   morkCh_kV|morkCh_kM,      /* 0x3F ? */</span>
<a href="#l21.48"></a><span id="l21.48" class="difflineminus">-  </span>
<a href="#l21.49"></a><span id="l21.49" class="difflineminus">-  morkCh_kV,                /* 0x40 @  */  </span>
<a href="#l21.50"></a><span id="l21.50" class="difflineplus">+</span>
<a href="#l21.51"></a><span id="l21.51" class="difflineplus">+  morkCh_kV,                /* 0x40 @  */</span>
<a href="#l21.52"></a><span id="l21.52">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU|morkCh_kX,  /* 0x41 A */</span>
<a href="#l21.53"></a><span id="l21.53">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU|morkCh_kX,  /* 0x42 B */</span>
<a href="#l21.54"></a><span id="l21.54">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU|morkCh_kX,  /* 0x43 C */</span>
<a href="#l21.55"></a><span id="l21.55">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU|morkCh_kX,  /* 0x44 D */</span>
<a href="#l21.56"></a><span id="l21.56">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU|morkCh_kX,  /* 0x45 E */</span>
<a href="#l21.57"></a><span id="l21.57">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU|morkCh_kX,  /* 0x46 F */</span>
<a href="#l21.58"></a><span id="l21.58">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x47 G */</span>
<a href="#l21.59"></a><span id="l21.59">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x48 H */</span>
<a href="#l21.60"></a><span id="l21.60">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x49 I */</span>
<a href="#l21.61"></a><span id="l21.61">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x4A J */</span>
<a href="#l21.62"></a><span id="l21.62">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x4B K */</span>
<a href="#l21.63"></a><span id="l21.63">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x4C L */</span>
<a href="#l21.64"></a><span id="l21.64">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x4D M */</span>
<a href="#l21.65"></a><span id="l21.65">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x4E N */</span>
<a href="#l21.66"></a><span id="l21.66">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x4F O */</span>
<a href="#l21.67"></a><span id="l21.67" class="difflineminus">-  </span>
<a href="#l21.68"></a><span id="l21.68" class="difflineplus">+</span>
<a href="#l21.69"></a><span id="l21.69">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x50 P */</span>
<a href="#l21.70"></a><span id="l21.70">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x51 Q */</span>
<a href="#l21.71"></a><span id="l21.71">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x52 R */</span>
<a href="#l21.72"></a><span id="l21.72">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x53 S */</span>
<a href="#l21.73"></a><span id="l21.73">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x54 T */</span>
<a href="#l21.74"></a><span id="l21.74">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x55 U */</span>
<a href="#l21.75"></a><span id="l21.75">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x56 V */</span>
<a href="#l21.76"></a><span id="l21.76">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x57 W */</span>
<a href="#l21.77"></a><span id="l21.77">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x58 X */</span>
<a href="#l21.78"></a><span id="l21.78">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x59 Y */</span>
<a href="#l21.79"></a><span id="l21.79">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kU,          /* 0x5A Z */</span>
<a href="#l21.80"></a><span id="l21.80">   morkCh_kV,                /* 0x5B [ */</span>
<a href="#l21.81"></a><span id="l21.81">   0,                /* 0x5C \ cannot be kV because needs escape */</span>
<a href="#l21.82"></a><span id="l21.82">   morkCh_kV,                /* 0x5D ] */</span>
<a href="#l21.83"></a><span id="l21.83">   morkCh_kV,          /* 0x5E ^ */</span>
<a href="#l21.84"></a><span id="l21.84">   morkCh_kV|morkCh_kN|morkCh_kM,          /* 0x5F _ */</span>
<a href="#l21.85"></a><span id="l21.85" class="difflineminus">-  </span>
<a href="#l21.86"></a><span id="l21.86" class="difflineplus">+</span>
<a href="#l21.87"></a><span id="l21.87">   morkCh_kV,                /* 0x60 ` */</span>
<a href="#l21.88"></a><span id="l21.88">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL|morkCh_kX,  /* 0x61 a */</span>
<a href="#l21.89"></a><span id="l21.89">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL|morkCh_kX,  /* 0x62 b */</span>
<a href="#l21.90"></a><span id="l21.90">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL|morkCh_kX,  /* 0x63 c */</span>
<a href="#l21.91"></a><span id="l21.91">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL|morkCh_kX,  /* 0x64 d */</span>
<a href="#l21.92"></a><span id="l21.92">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL|morkCh_kX,  /* 0x65 e */</span>
<a href="#l21.93"></a><span id="l21.93">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL|morkCh_kX,  /* 0x66 f */</span>
<a href="#l21.94"></a><span id="l21.94">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x67 g */</span>
<a href="#l21.95"></a><span id="l21.95">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x68 h */</span>
<a href="#l21.96"></a><span id="l21.96">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x69 i */</span>
<a href="#l21.97"></a><span id="l21.97">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x6A j */</span>
<a href="#l21.98"></a><span id="l21.98">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x6B k */</span>
<a href="#l21.99"></a><span id="l21.99">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x6C l */</span>
<a href="#l21.100"></a><span id="l21.100">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x6D m */</span>
<a href="#l21.101"></a><span id="l21.101">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x6E n */</span>
<a href="#l21.102"></a><span id="l21.102">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x6F o */</span>
<a href="#l21.103"></a><span id="l21.103" class="difflineminus">-  </span>
<a href="#l21.104"></a><span id="l21.104" class="difflineplus">+</span>
<a href="#l21.105"></a><span id="l21.105">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x70 p */</span>
<a href="#l21.106"></a><span id="l21.106">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x71 q */</span>
<a href="#l21.107"></a><span id="l21.107">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x72 r */</span>
<a href="#l21.108"></a><span id="l21.108">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x73 s */</span>
<a href="#l21.109"></a><span id="l21.109">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x74 t */</span>
<a href="#l21.110"></a><span id="l21.110">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x75 u */</span>
<a href="#l21.111"></a><span id="l21.111">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x76 v */</span>
<a href="#l21.112"></a><span id="l21.112">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x77 w */</span>
<a href="#l21.113"></a><span id="l21.113" class="difflineat">@@ -192,42 +192,42 @@ const mork_flags morkCh_Type[] = /* deri</span>
<a href="#l21.114"></a><span id="l21.114">   morkCh_kV|morkCh_kN|morkCh_kM|morkCh_kL,          /* 0x7A z */</span>
<a href="#l21.115"></a><span id="l21.115">   morkCh_kV,                /* 0x7B { */</span>
<a href="#l21.116"></a><span id="l21.116">   morkCh_kV,                /* 0x7C | */</span>
<a href="#l21.117"></a><span id="l21.117">   morkCh_kV,                /* 0x7D } */</span>
<a href="#l21.118"></a><span id="l21.118">   morkCh_kV,          /* 0x7E ~ */</span>
<a href="#l21.119"></a><span id="l21.119">   morkCh_kW,          /* 0x7F rubout */</span>
<a href="#l21.120"></a><span id="l21.120"> </span>
<a href="#l21.121"></a><span id="l21.121"> /* $&quot;80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F&quot;   */</span>
<a href="#l21.122"></a><span id="l21.122" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.123"></a><span id="l21.123" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.124"></a><span id="l21.124" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.125"></a><span id="l21.125" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.126"></a><span id="l21.126"> </span>
<a href="#l21.127"></a><span id="l21.127"> /* $&quot;90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F&quot;   */</span>
<a href="#l21.128"></a><span id="l21.128" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.129"></a><span id="l21.129" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.130"></a><span id="l21.130" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.131"></a><span id="l21.131" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.132"></a><span id="l21.132"> </span>
<a href="#l21.133"></a><span id="l21.133"> /* $&quot;A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF&quot;   */</span>
<a href="#l21.134"></a><span id="l21.134" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.135"></a><span id="l21.135" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.136"></a><span id="l21.136" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.137"></a><span id="l21.137" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.138"></a><span id="l21.138"> </span>
<a href="#l21.139"></a><span id="l21.139"> /* $&quot;B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF&quot;   */</span>
<a href="#l21.140"></a><span id="l21.140" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.141"></a><span id="l21.141" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.142"></a><span id="l21.142" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.143"></a><span id="l21.143" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.144"></a><span id="l21.144"> </span>
<a href="#l21.145"></a><span id="l21.145"> /* $&quot;C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF&quot;   */</span>
<a href="#l21.146"></a><span id="l21.146" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.147"></a><span id="l21.147" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.148"></a><span id="l21.148" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.149"></a><span id="l21.149" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.150"></a><span id="l21.150"> </span>
<a href="#l21.151"></a><span id="l21.151"> /* $&quot;D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF&quot;   */</span>
<a href="#l21.152"></a><span id="l21.152" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.153"></a><span id="l21.153" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.154"></a><span id="l21.154" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.155"></a><span id="l21.155" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.156"></a><span id="l21.156"> </span>
<a href="#l21.157"></a><span id="l21.157"> /* $&quot;E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF&quot;   */</span>
<a href="#l21.158"></a><span id="l21.158" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.159"></a><span id="l21.159" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.160"></a><span id="l21.160" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.161"></a><span id="l21.161" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.162"></a><span id="l21.162"> </span>
<a href="#l21.163"></a><span id="l21.163"> /* $&quot;F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF&quot;   */</span>
<a href="#l21.164"></a><span id="l21.164" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.165"></a><span id="l21.165" class="difflineminus">-  0,    0,    0,    0,    0,    0,    0,    0,  </span>
<a href="#l21.166"></a><span id="l21.166" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.167"></a><span id="l21.167" class="difflineplus">+  0,    0,    0,    0,    0,    0,    0,    0,</span>
<a href="#l21.168"></a><span id="l21.168"> };</span>
<a href="#l21.169"></a><span id="l21.169"> </span>
<a href="#l21.170"></a><span id="l21.170"> </span>
<a href="#l21.171"></a><span id="l21.171"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l22.1"></a><span id="l22.1" class="difflineminus">--- a/db/mork/src/morkCh.h</span>
<a href="#l22.2"></a><span id="l22.2" class="difflineplus">+++ b/db/mork/src/morkCh.h</span>
<a href="#l22.3"></a><span id="l22.3" class="difflineat">@@ -29,17 +29,17 @@</span>
<a href="#l22.4"></a><span id="l22.4">  * under the terms of either the GPL or the LGPL, and not to allow others to</span>
<a href="#l22.5"></a><span id="l22.5">  * use your version of this file under the terms of the MPL, indicate your</span>
<a href="#l22.6"></a><span id="l22.6">  * decision by deleting the provisions above and replace them with the notice</span>
<a href="#l22.7"></a><span id="l22.7">  * and other provisions required by the GPL or the LGPL. If you do not delete</span>
<a href="#l22.8"></a><span id="l22.8">  * the provisions above, a recipient may use your version of this file under</span>
<a href="#l22.9"></a><span id="l22.9">  * the terms of any one of the MPL, the GPL or the LGPL.</span>
<a href="#l22.10"></a><span id="l22.10">  *</span>
<a href="#l22.11"></a><span id="l22.11">  * ***** END LICENSE BLOCK ***** */</span>
<a href="#l22.12"></a><span id="l22.12" class="difflineminus">- </span>
<a href="#l22.13"></a><span id="l22.13" class="difflineplus">+</span>
<a href="#l22.14"></a><span id="l22.14"> #ifndef _MORKCH_</span>
<a href="#l22.15"></a><span id="l22.15"> #define _MORKCH_ 1</span>
<a href="#l22.16"></a><span id="l22.16"> </span>
<a href="#l22.17"></a><span id="l22.17"> #ifndef _MORK_</span>
<a href="#l22.18"></a><span id="l22.18"> #include &quot;mork.h&quot;</span>
<a href="#l22.19"></a><span id="l22.19"> #endif</span>
<a href="#l22.20"></a><span id="l22.20"> </span>
<a href="#l22.21"></a><span id="l22.21"> /* this byte char predicate header file derives from public domain Mithril */</span>
<a href="#l22.22"></a><span id="l22.22" class="difflineat">@@ -102,17 +102,17 @@ extern const mork_flags morkCh_Type[]; /</span>
<a href="#l22.23"></a><span id="l22.23"> #define morkFlags_IsAlpha(f)    ( (f) &amp; (morkCh_kL|morkCh_kU) )</span>
<a href="#l22.24"></a><span id="l22.24"> #define morkFlags_IsAlphaNum(f) ( (f) &amp; (morkCh_kL|morkCh_kU|morkCh_kD) )</span>
<a href="#l22.25"></a><span id="l22.25"> </span>
<a href="#l22.26"></a><span id="l22.26"> #define morkFlags_IsUpper(f)    ( (f) &amp; morkCh_kU )</span>
<a href="#l22.27"></a><span id="l22.27"> #define morkFlags_IsLower(f)    ( (f) &amp; morkCh_kL )</span>
<a href="#l22.28"></a><span id="l22.28"> </span>
<a href="#l22.29"></a><span id="l22.29"> /* ````` character case (e.g. for case insensitive operations) ````` */</span>
<a href="#l22.30"></a><span id="l22.30"> </span>
<a href="#l22.31"></a><span id="l22.31" class="difflineminus">-  </span>
<a href="#l22.32"></a><span id="l22.32" class="difflineplus">+</span>
<a href="#l22.33"></a><span id="l22.33"> #define morkCh_IsAscii(c)         ( ((mork_u1) c) &lt;= 0x7F )</span>
<a href="#l22.34"></a><span id="l22.34"> #define morkCh_IsSevenBitChar(c)  ( ((mork_u1) c) &lt;= 0x7F )</span>
<a href="#l22.35"></a><span id="l22.35"> </span>
<a href="#l22.36"></a><span id="l22.36"> /* ````` character case (e.g. for case insensitive operations) ````` */</span>
<a href="#l22.37"></a><span id="l22.37"> </span>
<a href="#l22.38"></a><span id="l22.38"> #define morkCh_ToLower(c)    ((c)-'A'+'a')</span>
<a href="#l22.39"></a><span id="l22.39"> #define morkCh_ToUpper(c)    ((c)-'a'+'A')</span>
<a href="#l22.40"></a><span id="l22.40"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l23.1"></a><span id="l23.1" class="difflineminus">--- a/db/mork/src/morkConfig.cpp</span>
<a href="#l23.2"></a><span id="l23.2" class="difflineplus">+++ b/db/mork/src/morkConfig.cpp</span>
<a href="#l23.3"></a><span id="l23.3" class="difflineat">@@ -29,17 +29,17 @@ void mork_assertion_signal(const char* i</span>
<a href="#l23.4"></a><span id="l23.4"> </span>
<a href="#l23.5"></a><span id="l23.5"> MORK_LIB_IMPL(mork_i4)</span>
<a href="#l23.6"></a><span id="l23.6"> mork_memcmp(const void* inOne, const void* inTwo, mork_size inSize)</span>
<a href="#l23.7"></a><span id="l23.7"> {</span>
<a href="#l23.8"></a><span id="l23.8">   const mork_u1* t = (const mork_u1*) inTwo;</span>
<a href="#l23.9"></a><span id="l23.9">   const mork_u1* s = (const mork_u1*) inOne;</span>
<a href="#l23.10"></a><span id="l23.10">   const mork_u1* end = s + inSize;</span>
<a href="#l23.11"></a><span id="l23.11">   mork_i4 delta;</span>
<a href="#l23.12"></a><span id="l23.12" class="difflineminus">-  </span>
<a href="#l23.13"></a><span id="l23.13" class="difflineplus">+</span>
<a href="#l23.14"></a><span id="l23.14">   while ( s &lt; end )</span>
<a href="#l23.15"></a><span id="l23.15">   {</span>
<a href="#l23.16"></a><span id="l23.16">     delta = ((mork_i4) *s) - ((mork_i4) *t);</span>
<a href="#l23.17"></a><span id="l23.17">     if ( delta )</span>
<a href="#l23.18"></a><span id="l23.18">       return delta;</span>
<a href="#l23.19"></a><span id="l23.19">     else</span>
<a href="#l23.20"></a><span id="l23.20">     {</span>
<a href="#l23.21"></a><span id="l23.21">       ++t;</span>
<a href="#l23.22"></a><span id="l23.22" class="difflineat">@@ -50,57 +50,57 @@ mork_memcmp(const void* inOne, const voi</span>
<a href="#l23.23"></a><span id="l23.23"> }</span>
<a href="#l23.24"></a><span id="l23.24"> </span>
<a href="#l23.25"></a><span id="l23.25"> MORK_LIB_IMPL(void)</span>
<a href="#l23.26"></a><span id="l23.26"> mork_memcpy(void* outDst, const void* inSrc, mork_size inSize)</span>
<a href="#l23.27"></a><span id="l23.27"> {</span>
<a href="#l23.28"></a><span id="l23.28">   mork_u1* d = (mork_u1*) outDst;</span>
<a href="#l23.29"></a><span id="l23.29">   mork_u1* end = d + inSize;</span>
<a href="#l23.30"></a><span id="l23.30">   const mork_u1* s = ((const mork_u1*) inSrc);</span>
<a href="#l23.31"></a><span id="l23.31" class="difflineminus">-  </span>
<a href="#l23.32"></a><span id="l23.32" class="difflineplus">+</span>
<a href="#l23.33"></a><span id="l23.33">   while ( inSize &gt;= 8 )</span>
<a href="#l23.34"></a><span id="l23.34">   {</span>
<a href="#l23.35"></a><span id="l23.35">     *d++ = *s++;</span>
<a href="#l23.36"></a><span id="l23.36">     *d++ = *s++;</span>
<a href="#l23.37"></a><span id="l23.37">     *d++ = *s++;</span>
<a href="#l23.38"></a><span id="l23.38">     *d++ = *s++;</span>
<a href="#l23.39"></a><span id="l23.39" class="difflineminus">-    </span>
<a href="#l23.40"></a><span id="l23.40" class="difflineplus">+</span>
<a href="#l23.41"></a><span id="l23.41">     *d++ = *s++;</span>
<a href="#l23.42"></a><span id="l23.42">     *d++ = *s++;</span>
<a href="#l23.43"></a><span id="l23.43">     *d++ = *s++;</span>
<a href="#l23.44"></a><span id="l23.44">     *d++ = *s++;</span>
<a href="#l23.45"></a><span id="l23.45" class="difflineminus">-    </span>
<a href="#l23.46"></a><span id="l23.46" class="difflineplus">+</span>
<a href="#l23.47"></a><span id="l23.47">     inSize -= 8;</span>
<a href="#l23.48"></a><span id="l23.48">   }</span>
<a href="#l23.49"></a><span id="l23.49" class="difflineminus">-  </span>
<a href="#l23.50"></a><span id="l23.50" class="difflineplus">+</span>
<a href="#l23.51"></a><span id="l23.51">   while ( d &lt; end )</span>
<a href="#l23.52"></a><span id="l23.52">     *d++ = *s++;</span>
<a href="#l23.53"></a><span id="l23.53"> }</span>
<a href="#l23.54"></a><span id="l23.54"> </span>
<a href="#l23.55"></a><span id="l23.55"> MORK_LIB_IMPL(void)</span>
<a href="#l23.56"></a><span id="l23.56"> mork_memmove(void* outDst, const void* inSrc, mork_size inSize)</span>
<a href="#l23.57"></a><span id="l23.57"> {</span>
<a href="#l23.58"></a><span id="l23.58">   mork_u1* d = (mork_u1*) outDst;</span>
<a href="#l23.59"></a><span id="l23.59">   const mork_u1* s = (const mork_u1*) inSrc;</span>
<a href="#l23.60"></a><span id="l23.60">   if ( d != s &amp;&amp; inSize ) // copy is necessary?</span>
<a href="#l23.61"></a><span id="l23.61">   {</span>
<a href="#l23.62"></a><span id="l23.62">     const mork_u1* srcEnd = s + inSize; // one past last source byte</span>
<a href="#l23.63"></a><span id="l23.63" class="difflineminus">-    </span>
<a href="#l23.64"></a><span id="l23.64" class="difflineplus">+</span>
<a href="#l23.65"></a><span id="l23.65">     if ( d &gt; s &amp;&amp; d &lt; srcEnd ) // overlap? need to copy backwards?</span>
<a href="#l23.66"></a><span id="l23.66">     {</span>
<a href="#l23.67"></a><span id="l23.67">       s = srcEnd; // start one past last source byte</span>
<a href="#l23.68"></a><span id="l23.68">       d += inSize; // start one past last dest byte</span>
<a href="#l23.69"></a><span id="l23.69">       mork_u1* dstBegin = d; // last byte to write is first in dest range</span>
<a href="#l23.70"></a><span id="l23.70">       while ( d - dstBegin &gt;= 8 )</span>
<a href="#l23.71"></a><span id="l23.71">       {</span>
<a href="#l23.72"></a><span id="l23.72">         *--d = *--s;</span>
<a href="#l23.73"></a><span id="l23.73">         *--d = *--s;</span>
<a href="#l23.74"></a><span id="l23.74">         *--d = *--s;</span>
<a href="#l23.75"></a><span id="l23.75">         *--d = *--s;</span>
<a href="#l23.76"></a><span id="l23.76" class="difflineminus">-        </span>
<a href="#l23.77"></a><span id="l23.77" class="difflineplus">+</span>
<a href="#l23.78"></a><span id="l23.78">         *--d = *--s;</span>
<a href="#l23.79"></a><span id="l23.79">         *--d = *--s;</span>
<a href="#l23.80"></a><span id="l23.80">         *--d = *--s;</span>
<a href="#l23.81"></a><span id="l23.81">         *--d = *--s;</span>
<a href="#l23.82"></a><span id="l23.82">       }</span>
<a href="#l23.83"></a><span id="l23.83">       while ( d &gt; dstBegin )</span>
<a href="#l23.84"></a><span id="l23.84">         *--d = *--s;</span>
<a href="#l23.85"></a><span id="l23.85">     }</span>
<a href="#l23.86"></a><span id="l23.86" class="difflineat">@@ -108,17 +108,17 @@ mork_memmove(void* outDst, const void* i</span>
<a href="#l23.87"></a><span id="l23.87">     {</span>
<a href="#l23.88"></a><span id="l23.88">       mork_u1* dstEnd = d + inSize;</span>
<a href="#l23.89"></a><span id="l23.89">       while ( dstEnd - d &gt;= 8 )</span>
<a href="#l23.90"></a><span id="l23.90">       {</span>
<a href="#l23.91"></a><span id="l23.91">         *d++ = *s++;</span>
<a href="#l23.92"></a><span id="l23.92">         *d++ = *s++;</span>
<a href="#l23.93"></a><span id="l23.93">         *d++ = *s++;</span>
<a href="#l23.94"></a><span id="l23.94">         *d++ = *s++;</span>
<a href="#l23.95"></a><span id="l23.95" class="difflineminus">-        </span>
<a href="#l23.96"></a><span id="l23.96" class="difflineplus">+</span>
<a href="#l23.97"></a><span id="l23.97">         *d++ = *s++;</span>
<a href="#l23.98"></a><span id="l23.98">         *d++ = *s++;</span>
<a href="#l23.99"></a><span id="l23.99">         *d++ = *s++;</span>
<a href="#l23.100"></a><span id="l23.100">         *d++ = *s++;</span>
<a href="#l23.101"></a><span id="l23.101">       }</span>
<a href="#l23.102"></a><span id="l23.102">       while ( d &lt; dstEnd )</span>
<a href="#l23.103"></a><span id="l23.103">         *d++ = *s++;</span>
<a href="#l23.104"></a><span id="l23.104">     }</span>
<a href="#l23.105"></a><span id="l23.105" class="difflineat">@@ -147,38 +147,38 @@ mork_strcpy(void* outDst, const void* in</span>
<a href="#l23.106"></a><span id="l23.106"> MORK_LIB_IMPL(mork_i4)</span>
<a href="#l23.107"></a><span id="l23.107"> mork_strcmp(const void* inOne, const void* inTwo)</span>
<a href="#l23.108"></a><span id="l23.108"> {</span>
<a href="#l23.109"></a><span id="l23.109">   const mork_u1* t = (const mork_u1*) inTwo;</span>
<a href="#l23.110"></a><span id="l23.110">   const mork_u1* s = ((const mork_u1*) inOne);</span>
<a href="#l23.111"></a><span id="l23.111">   mork_i4 a;</span>
<a href="#l23.112"></a><span id="l23.112">   mork_i4 b;</span>
<a href="#l23.113"></a><span id="l23.113">   mork_i4 delta;</span>
<a href="#l23.114"></a><span id="l23.114" class="difflineminus">-  </span>
<a href="#l23.115"></a><span id="l23.115" class="difflineplus">+</span>
<a href="#l23.116"></a><span id="l23.116">   do</span>
<a href="#l23.117"></a><span id="l23.117">   {</span>
<a href="#l23.118"></a><span id="l23.118">     a = (mork_i4) *s++;</span>
<a href="#l23.119"></a><span id="l23.119">     b = (mork_i4) *t++;</span>
<a href="#l23.120"></a><span id="l23.120">     delta = a - b;</span>
<a href="#l23.121"></a><span id="l23.121">   }</span>
<a href="#l23.122"></a><span id="l23.122">   while ( !delta &amp;&amp; a &amp;&amp; b );</span>
<a href="#l23.123"></a><span id="l23.123" class="difflineminus">-  </span>
<a href="#l23.124"></a><span id="l23.124" class="difflineplus">+</span>
<a href="#l23.125"></a><span id="l23.125">   return delta;</span>
<a href="#l23.126"></a><span id="l23.126"> }</span>
<a href="#l23.127"></a><span id="l23.127"> </span>
<a href="#l23.128"></a><span id="l23.128"> MORK_LIB_IMPL(mork_i4)</span>
<a href="#l23.129"></a><span id="l23.129"> mork_strncmp(const void* inOne, const void* inTwo, mork_size inSize)</span>
<a href="#l23.130"></a><span id="l23.130"> {</span>
<a href="#l23.131"></a><span id="l23.131">   const mork_u1* t = (const mork_u1*) inTwo;</span>
<a href="#l23.132"></a><span id="l23.132">   const mork_u1* s = (const mork_u1*) inOne;</span>
<a href="#l23.133"></a><span id="l23.133">   const mork_u1* end = s + inSize;</span>
<a href="#l23.134"></a><span id="l23.134">   mork_i4 delta;</span>
<a href="#l23.135"></a><span id="l23.135">   mork_i4 a;</span>
<a href="#l23.136"></a><span id="l23.136">   mork_i4 b;</span>
<a href="#l23.137"></a><span id="l23.137" class="difflineminus">-  </span>
<a href="#l23.138"></a><span id="l23.138" class="difflineplus">+</span>
<a href="#l23.139"></a><span id="l23.139">   while ( s &lt; end )</span>
<a href="#l23.140"></a><span id="l23.140">   {</span>
<a href="#l23.141"></a><span id="l23.141">     a = (mork_i4) *s++;</span>
<a href="#l23.142"></a><span id="l23.142">     b = (mork_i4) *t++;</span>
<a href="#l23.143"></a><span id="l23.143">     delta = a - b;</span>
<a href="#l23.144"></a><span id="l23.144">     if ( delta || !a || !b )</span>
<a href="#l23.145"></a><span id="l23.145">       return delta;</span>
<a href="#l23.146"></a><span id="l23.146">   }</span>
<a href="#l23.147"></a><span id="l23.147" class="difflineat">@@ -187,15 +187,15 @@ mork_strncmp(const void* inOne, const vo</span>
<a href="#l23.148"></a><span id="l23.148"> </span>
<a href="#l23.149"></a><span id="l23.149"> MORK_LIB_IMPL(mork_size)</span>
<a href="#l23.150"></a><span id="l23.150"> mork_strlen(const void* inString)</span>
<a href="#l23.151"></a><span id="l23.151"> {</span>
<a href="#l23.152"></a><span id="l23.152">   // back up one first to support preincrement</span>
<a href="#l23.153"></a><span id="l23.153">   const mork_u1* s = ((const mork_u1*) inString) - 1;</span>
<a href="#l23.154"></a><span id="l23.154">   while ( *++s ) // preincrement is cheapest</span>
<a href="#l23.155"></a><span id="l23.155">     /* empty */;</span>
<a href="#l23.156"></a><span id="l23.156" class="difflineminus">-  </span>
<a href="#l23.157"></a><span id="l23.157" class="difflineplus">+</span>
<a href="#l23.158"></a><span id="l23.158">   return s - ((const mork_u1*) inString); // distance from original address</span>
<a href="#l23.159"></a><span id="l23.159"> }</span>
<a href="#l23.160"></a><span id="l23.160"> </span>
<a href="#l23.161"></a><span id="l23.161"> #endif /*MORK_PROVIDE_STDLIB*/</span>
<a href="#l23.162"></a><span id="l23.162"> </span>
<a href="#l23.163"></a><span id="l23.163"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l24.1"></a><span id="l24.1" class="difflineminus">--- a/db/mork/src/morkConfig.h</span>
<a href="#l24.2"></a><span id="l24.2" class="difflineplus">+++ b/db/mork/src/morkConfig.h</span>
<a href="#l24.3"></a><span id="l24.3" class="difflineat">@@ -28,47 +28,47 @@</span>
<a href="#l24.4"></a><span id="l24.4"> </span>
<a href="#l24.5"></a><span id="l24.5"> #ifdef XP_UNIX</span>
<a href="#l24.6"></a><span id="l24.6"> #define MORK_UNIX 1</span>
<a href="#l24.7"></a><span id="l24.7"> #endif</span>
<a href="#l24.8"></a><span id="l24.8"> </span>
<a href="#l24.9"></a><span id="l24.9"> // } %%%%% end platform defs peculiar to Mork %%%%%</span>
<a href="#l24.10"></a><span id="l24.10"> </span>
<a href="#l24.11"></a><span id="l24.11"> #if defined(MORK_WIN) || defined(MORK_UNIX) || defined(MORK_MAC)</span>
<a href="#l24.12"></a><span id="l24.12" class="difflineminus">-#include &lt;stdio.h&gt; </span>
<a href="#l24.13"></a><span id="l24.13" class="difflineminus">-#include &lt;ctype.h&gt; </span>
<a href="#l24.14"></a><span id="l24.14" class="difflineminus">-#include &lt;errno.h&gt; </span>
<a href="#l24.15"></a><span id="l24.15" class="difflineminus">-#include &lt;string.h&gt; </span>
<a href="#l24.16"></a><span id="l24.16" class="difflineplus">+#include &lt;stdio.h&gt;</span>
<a href="#l24.17"></a><span id="l24.17" class="difflineplus">+#include &lt;ctype.h&gt;</span>
<a href="#l24.18"></a><span id="l24.18" class="difflineplus">+#include &lt;errno.h&gt;</span>
<a href="#l24.19"></a><span id="l24.19" class="difflineplus">+#include &lt;string.h&gt;</span>
<a href="#l24.20"></a><span id="l24.20"> #ifdef HAVE_MEMORY_H</span>
<a href="#l24.21"></a><span id="l24.21" class="difflineminus">-#include &lt;memory.h&gt; </span>
<a href="#l24.22"></a><span id="l24.22" class="difflineplus">+#include &lt;memory.h&gt;</span>
<a href="#l24.23"></a><span id="l24.23"> #endif</span>
<a href="#l24.24"></a><span id="l24.24"> #ifdef HAVE_UNISTD_H</span>
<a href="#l24.25"></a><span id="l24.25"> #include &lt;unistd.h&gt;  /* for SEEK_SET, SEEK_END */</span>
<a href="#l24.26"></a><span id="l24.26"> #endif</span>
<a href="#l24.27"></a><span id="l24.27"> </span>
<a href="#l24.28"></a><span id="l24.28" class="difflineminus">-#include &quot;nsDebug.h&quot; </span>
<a href="#l24.29"></a><span id="l24.29" class="difflineplus">+#include &quot;nsDebug.h&quot;</span>
<a href="#l24.30"></a><span id="l24.30"> </span>
<a href="#l24.31"></a><span id="l24.31" class="difflineminus">-#define MORK_ISPRINT(c) isprint(c) </span>
<a href="#l24.32"></a><span id="l24.32" class="difflineplus">+#define MORK_ISPRINT(c) isprint(c)</span>
<a href="#l24.33"></a><span id="l24.33"> </span>
<a href="#l24.34"></a><span id="l24.34" class="difflineminus">-#define MORK_FILETELL(file) ftell(file) </span>
<a href="#l24.35"></a><span id="l24.35" class="difflineminus">-#define MORK_FILESEEK(file, where, how) fseek(file, where, how) </span>
<a href="#l24.36"></a><span id="l24.36" class="difflineminus">-#define MORK_FILEREAD(outbuf, insize, file) fread(outbuf, 1, insize, file) </span>
<a href="#l24.37"></a><span id="l24.37" class="difflineplus">+#define MORK_FILETELL(file) ftell(file)</span>
<a href="#l24.38"></a><span id="l24.38" class="difflineplus">+#define MORK_FILESEEK(file, where, how) fseek(file, where, how)</span>
<a href="#l24.39"></a><span id="l24.39" class="difflineplus">+#define MORK_FILEREAD(outbuf, insize, file) fread(outbuf, 1, insize, file)</span>
<a href="#l24.40"></a><span id="l24.40"> #if defined(MORK_WIN)</span>
<a href="#l24.41"></a><span id="l24.41"> void mork_fileflush(FILE * file);</span>
<a href="#l24.42"></a><span id="l24.42" class="difflineminus">-#define MORK_FILEFLUSH(file) mork_fileflush(file) </span>
<a href="#l24.43"></a><span id="l24.43" class="difflineplus">+#define MORK_FILEFLUSH(file) mork_fileflush(file)</span>
<a href="#l24.44"></a><span id="l24.44"> #else</span>
<a href="#l24.45"></a><span id="l24.45" class="difflineminus">-#define MORK_FILEFLUSH(file) fflush(file) </span>
<a href="#l24.46"></a><span id="l24.46" class="difflineplus">+#define MORK_FILEFLUSH(file) fflush(file)</span>
<a href="#l24.47"></a><span id="l24.47"> #endif /*MORK_WIN*/</span>
<a href="#l24.48"></a><span id="l24.48"> </span>
<a href="#l24.49"></a><span id="l24.49"> #if defined(MORK_WIN)</span>
<a href="#l24.50"></a><span id="l24.50"> #define MORK_FILEOPEN(file, how) _wfopen(char16ptr_t(file), NS_ConvertASCIItoUTF16(how).get())</span>
<a href="#l24.51"></a><span id="l24.51"> #else</span>
<a href="#l24.52"></a><span id="l24.52"> #define MORK_FILEOPEN(file, how) fopen(file, how)</span>
<a href="#l24.53"></a><span id="l24.53"> #endif /*MORK_WIN*/</span>
<a href="#l24.54"></a><span id="l24.54" class="difflineminus">-#define MORK_FILECLOSE(file) fclose(file) </span>
<a href="#l24.55"></a><span id="l24.55" class="difflineplus">+#define MORK_FILECLOSE(file) fclose(file)</span>
<a href="#l24.56"></a><span id="l24.56"> #endif /*defined(MORK_WIN) || defined(MORK_UNIX) || defined(MORK_MAC)*/</span>
<a href="#l24.57"></a><span id="l24.57"> </span>
<a href="#l24.58"></a><span id="l24.58"> /* ===== separating switchable features ===== */</span>
<a href="#l24.59"></a><span id="l24.59"> </span>
<a href="#l24.60"></a><span id="l24.60"> #define MORK_ENABLE_ZONE_ARENAS 1 /* using morkZone for pooling */</span>
<a href="#l24.61"></a><span id="l24.61"> </span>
<a href="#l24.62"></a><span id="l24.62"> //#define MORK_ENABLE_PROBE_MAPS 1 /* use smaller hash tables */</span>
<a href="#l24.63"></a><span id="l24.63"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l25.1"></a><span id="l25.1" class="difflineminus">--- a/db/mork/src/morkCursor.cpp</span>
<a href="#l25.2"></a><span id="l25.2" class="difflineplus">+++ b/db/mork/src/morkCursor.cpp</span>
<a href="#l25.3"></a><span id="l25.3" class="difflineat">@@ -24,17 +24,17 @@</span>
<a href="#l25.4"></a><span id="l25.4"> #endif</span>
<a href="#l25.5"></a><span id="l25.5"> </span>
<a href="#l25.6"></a><span id="l25.6"> #ifndef _MORKCURSOR_</span>
<a href="#l25.7"></a><span id="l25.7"> #include &quot;morkCursor.h&quot;</span>
<a href="#l25.8"></a><span id="l25.8"> #endif</span>
<a href="#l25.9"></a><span id="l25.9"> </span>
<a href="#l25.10"></a><span id="l25.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l25.11"></a><span id="l25.11"> </span>
<a href="#l25.12"></a><span id="l25.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l25.13"></a><span id="l25.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l25.14"></a><span id="l25.14"> // { ===== begin morkNode interface =====</span>
<a href="#l25.15"></a><span id="l25.15"> </span>
<a href="#l25.16"></a><span id="l25.16"> /*public virtual*/ void</span>
<a href="#l25.17"></a><span id="l25.17"> morkCursor::CloseMorkNode(morkEnv* ev) // CloseCursor() only if open</span>
<a href="#l25.18"></a><span id="l25.18"> {</span>
<a href="#l25.19"></a><span id="l25.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l25.20"></a><span id="l25.20">   {</span>
<a href="#l25.21"></a><span id="l25.21">     this-&gt;MarkClosing();</span>
<a href="#l25.22"></a><span id="l25.22" class="difflineat">@@ -77,17 +77,17 @@ morkCursor::CloseCursor(morkEnv* ev) // </span>
<a href="#l25.23"></a><span id="l25.23"> </span>
<a href="#l25.24"></a><span id="l25.24"> // { ----- begin ref counting for well-behaved cyclic graphs -----</span>
<a href="#l25.25"></a><span id="l25.25"> NS_IMETHODIMP</span>
<a href="#l25.26"></a><span id="l25.26"> morkCursor::GetWeakRefCount(nsIMdbEnv* mev, // weak refs</span>
<a href="#l25.27"></a><span id="l25.27">   mdb_count* outCount)</span>
<a href="#l25.28"></a><span id="l25.28"> {</span>
<a href="#l25.29"></a><span id="l25.29">   *outCount = WeakRefsOnly();</span>
<a href="#l25.30"></a><span id="l25.30">   return NS_OK;</span>
<a href="#l25.31"></a><span id="l25.31" class="difflineminus">-}  </span>
<a href="#l25.32"></a><span id="l25.32" class="difflineplus">+}</span>
<a href="#l25.33"></a><span id="l25.33"> NS_IMETHODIMP</span>
<a href="#l25.34"></a><span id="l25.34"> morkCursor::GetStrongRefCount(nsIMdbEnv* mev, // strong refs</span>
<a href="#l25.35"></a><span id="l25.35">   mdb_count* outCount)</span>
<a href="#l25.36"></a><span id="l25.36"> {</span>
<a href="#l25.37"></a><span id="l25.37">   *outCount = StrongRefsOnly();</span>
<a href="#l25.38"></a><span id="l25.38">   return NS_OK;</span>
<a href="#l25.39"></a><span id="l25.39"> }</span>
<a href="#l25.40"></a><span id="l25.40"> // ### TODO - clean up this cast, if required</span>
<a href="#l25.41"></a><span id="l25.41" class="difflineat">@@ -148,17 +148,17 @@ morkCursor::IsOpenMdbObject(nsIMdbEnv* m</span>
<a href="#l25.42"></a><span id="l25.42"> }</span>
<a href="#l25.43"></a><span id="l25.43"> NS_IMETHODIMP</span>
<a href="#l25.44"></a><span id="l25.44"> morkCursor::IsFrozenMdbObject(nsIMdbEnv* mev, mdb_bool* outIsReadonly)</span>
<a href="#l25.45"></a><span id="l25.45"> {</span>
<a href="#l25.46"></a><span id="l25.46">   *outIsReadonly = IsFrozen();</span>
<a href="#l25.47"></a><span id="l25.47">   return NS_OK;</span>
<a href="#l25.48"></a><span id="l25.48"> }</span>
<a href="#l25.49"></a><span id="l25.49"> // } ===== end morkNode methods =====</span>
<a href="#l25.50"></a><span id="l25.50" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l25.51"></a><span id="l25.51" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l25.52"></a><span id="l25.52"> </span>
<a href="#l25.53"></a><span id="l25.53"> NS_IMETHODIMP</span>
<a href="#l25.54"></a><span id="l25.54"> morkCursor::GetCount(nsIMdbEnv* mev, mdb_count* outCount)</span>
<a href="#l25.55"></a><span id="l25.55"> {</span>
<a href="#l25.56"></a><span id="l25.56">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l25.57"></a><span id="l25.57">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l25.58"></a><span id="l25.58"> }</span>
<a href="#l25.59"></a><span id="l25.59"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l26.1"></a><span id="l26.1" class="difflineminus">--- a/db/mork/src/morkCursor.h</span>
<a href="#l26.2"></a><span id="l26.2" class="difflineplus">+++ b/db/mork/src/morkCursor.h</span>
<a href="#l26.3"></a><span id="l26.3" class="difflineat">@@ -60,45 +60,45 @@ public: // state is public because the e</span>
<a href="#l26.4"></a><span id="l26.4">   // The first declaration of CutStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l26.5"></a><span id="l26.5">   NS_IMETHOD_(mork_uses) CutStrongRef(morkEnv* ev) override;</span>
<a href="#l26.6"></a><span id="l26.6"> #endif</span>
<a href="#l26.7"></a><span id="l26.7">   NS_IMETHOD CutStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l26.8"></a><span id="l26.8"> </span>
<a href="#l26.9"></a><span id="l26.9">   NS_IMETHOD CloseMdbObject(nsIMdbEnv* ev) override; // called at strong refs zero</span>
<a href="#l26.10"></a><span id="l26.10">   NS_IMETHOD IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen) override;</span>
<a href="#l26.11"></a><span id="l26.11">   // } ----- end ref counting -----</span>
<a href="#l26.12"></a><span id="l26.12" class="difflineminus">-  </span>
<a href="#l26.13"></a><span id="l26.13" class="difflineplus">+</span>
<a href="#l26.14"></a><span id="l26.14"> // } ===== end nsIMdbObject methods =====</span>
<a href="#l26.15"></a><span id="l26.15"> </span>
<a href="#l26.16"></a><span id="l26.16"> // { ===== begin nsIMdbCursor methods =====</span>
<a href="#l26.17"></a><span id="l26.17"> </span>
<a href="#l26.18"></a><span id="l26.18">   // { ----- begin attribute methods -----</span>
<a href="#l26.19"></a><span id="l26.19">   NS_IMETHOD GetCount(nsIMdbEnv* ev, mdb_count* outCount) override; // readonly</span>
<a href="#l26.20"></a><span id="l26.20">   NS_IMETHOD GetSeed(nsIMdbEnv* ev, mdb_seed* outSeed) override;    // readonly</span>
<a href="#l26.21"></a><span id="l26.21"> </span>
<a href="#l26.22"></a><span id="l26.22">   NS_IMETHOD SetPos(nsIMdbEnv* ev, mdb_pos inPos) override;   // mutable</span>
<a href="#l26.23"></a><span id="l26.23">   NS_IMETHOD GetPos(nsIMdbEnv* ev, mdb_pos* outPos) override;</span>
<a href="#l26.24"></a><span id="l26.24"> </span>
<a href="#l26.25"></a><span id="l26.25">   NS_IMETHOD SetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool inFail) override;</span>
<a href="#l26.26"></a><span id="l26.26">   NS_IMETHOD GetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool* outFail) override;</span>
<a href="#l26.27"></a><span id="l26.27">   // } ----- end attribute methods -----</span>
<a href="#l26.28"></a><span id="l26.28"> </span>
<a href="#l26.29"></a><span id="l26.29"> // } ===== end nsIMdbCursor methods =====</span>
<a href="#l26.30"></a><span id="l26.30" class="difflineminus">-    </span>
<a href="#l26.31"></a><span id="l26.31" class="difflineplus">+</span>
<a href="#l26.32"></a><span id="l26.32">   // } ----- end attribute methods -----</span>
<a href="#l26.33"></a><span id="l26.33"> </span>
<a href="#l26.34"></a><span id="l26.34">   mork_seed  mCursor_Seed;</span>
<a href="#l26.35"></a><span id="l26.35">   mork_pos   mCursor_Pos;</span>
<a href="#l26.36"></a><span id="l26.36">   mork_bool  mCursor_DoFailOnSeedOutOfSync;</span>
<a href="#l26.37"></a><span id="l26.37">   mork_u1    mCursor_Pad[ 3 ]; // explicitly pad to u4 alignment</span>
<a href="#l26.38"></a><span id="l26.38" class="difflineminus">-  </span>
<a href="#l26.39"></a><span id="l26.39" class="difflineplus">+</span>
<a href="#l26.40"></a><span id="l26.40"> // { ===== begin morkNode interface =====</span>
<a href="#l26.41"></a><span id="l26.41"> public: // morkNode virtual methods</span>
<a href="#l26.42"></a><span id="l26.42">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseCursor() only if open</span>
<a href="#l26.43"></a><span id="l26.43" class="difflineminus">-  </span>
<a href="#l26.44"></a><span id="l26.44" class="difflineplus">+</span>
<a href="#l26.45"></a><span id="l26.45"> public: // morkCursor construction &amp; destruction</span>
<a href="#l26.46"></a><span id="l26.46">   morkCursor(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap);</span>
<a href="#l26.47"></a><span id="l26.47">   void CloseCursor(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l26.48"></a><span id="l26.48"> </span>
<a href="#l26.49"></a><span id="l26.49"> protected:</span>
<a href="#l26.50"></a><span id="l26.50">   virtual ~morkCursor(); // assert that CloseCursor() executed earlier</span>
<a href="#l26.51"></a><span id="l26.51"> </span>
<a href="#l26.52"></a><span id="l26.52"> private: // copying is not allowed</span>
<a href="#l26.53"></a><span id="l26.53" class="difflineat">@@ -111,17 +111,17 @@ public: // dynamic type identification</span>
<a href="#l26.54"></a><span id="l26.54"> // } ===== end morkNode methods =====</span>
<a href="#l26.55"></a><span id="l26.55"> </span>
<a href="#l26.56"></a><span id="l26.56"> public: // other cursor methods</span>
<a href="#l26.57"></a><span id="l26.57"> </span>
<a href="#l26.58"></a><span id="l26.58"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l26.59"></a><span id="l26.59">   static void SlotWeakCursor(morkCursor* me,</span>
<a href="#l26.60"></a><span id="l26.60">     morkEnv* ev, morkCursor** ioSlot)</span>
<a href="#l26.61"></a><span id="l26.61">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l26.62"></a><span id="l26.62" class="difflineminus">-  </span>
<a href="#l26.63"></a><span id="l26.63" class="difflineplus">+</span>
<a href="#l26.64"></a><span id="l26.64">   static void SlotStrongCursor(morkCursor* me,</span>
<a href="#l26.65"></a><span id="l26.65">     morkEnv* ev, morkCursor** ioSlot)</span>
<a href="#l26.66"></a><span id="l26.66">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l26.67"></a><span id="l26.67"> };</span>
<a href="#l26.68"></a><span id="l26.68"> </span>
<a href="#l26.69"></a><span id="l26.69"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l26.70"></a><span id="l26.70"> </span>
<a href="#l26.71"></a><span id="l26.71"> #endif /* _MORKCURSOR_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l27.1"></a><span id="l27.1" class="difflineminus">--- a/db/mork/src/morkDeque.cpp</span>
<a href="#l27.2"></a><span id="l27.2" class="difflineplus">+++ b/db/mork/src/morkDeque.cpp</span>
<a href="#l27.3"></a><span id="l27.3" class="difflineat">@@ -1,13 +1,13 @@</span>
<a href="#l27.4"></a><span id="l27.4"> /*************************************************************************</span>
<a href="#l27.5"></a><span id="l27.5"> This software is part of a public domain IronDoc source code distribution,</span>
<a href="#l27.6"></a><span id="l27.6"> and is provided on an &quot;AS IS&quot; basis, with all risks borne by the consumers</span>
<a href="#l27.7"></a><span id="l27.7"> or users of the IronDoc software.  There are no warranties, guarantees, or</span>
<a href="#l27.8"></a><span id="l27.8" class="difflineminus">-promises about quality of any kind; and no remedies for failure exist. </span>
<a href="#l27.9"></a><span id="l27.9" class="difflineplus">+promises about quality of any kind; and no remedies for failure exist.</span>
<a href="#l27.10"></a><span id="l27.10"> </span>
<a href="#l27.11"></a><span id="l27.11"> Permission is hereby granted to use this IronDoc software for any purpose</span>
<a href="#l27.12"></a><span id="l27.12"> at all, without need for written agreements, without royalty or license</span>
<a href="#l27.13"></a><span id="l27.13"> fees, and without fees or obligations of any other kind.  Anyone can use,</span>
<a href="#l27.14"></a><span id="l27.14"> copy, change and distribute this software for any purpose, and nothing is</span>
<a href="#l27.15"></a><span id="l27.15"> required, implicitly or otherwise, in exchange for this usage.</span>
<a href="#l27.16"></a><span id="l27.16"> </span>
<a href="#l27.17"></a><span id="l27.17"> You cannot apply your own copyright to this software, but otherwise you</span>
<a href="#l27.18"></a><span id="l27.18" class="difflineat">@@ -43,17 +43,17 @@ which are used interchangeably with the </span>
<a href="#l27.19"></a><span id="l27.19"> </span>
<a href="#l27.20"></a><span id="l27.20"> #ifndef _MORKENV_</span>
<a href="#l27.21"></a><span id="l27.21"> #include &quot;morkEnv.h&quot;</span>
<a href="#l27.22"></a><span id="l27.22"> #endif</span>
<a href="#l27.23"></a><span id="l27.23"> </span>
<a href="#l27.24"></a><span id="l27.24"> /*=============================================================================</span>
<a href="#l27.25"></a><span id="l27.25">  * morkNext: linked list node for very simple, singly-linked list</span>
<a href="#l27.26"></a><span id="l27.26">  */</span>
<a href="#l27.27"></a><span id="l27.27" class="difflineminus">- </span>
<a href="#l27.28"></a><span id="l27.28" class="difflineplus">+</span>
<a href="#l27.29"></a><span id="l27.29"> morkNext::morkNext() : mNext_Link( 0 )</span>
<a href="#l27.30"></a><span id="l27.30"> {</span>
<a href="#l27.31"></a><span id="l27.31"> }</span>
<a href="#l27.32"></a><span id="l27.32"> </span>
<a href="#l27.33"></a><span id="l27.33"> /*static*/ void*</span>
<a href="#l27.34"></a><span id="l27.34"> morkNext::MakeNewNext(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev)</span>
<a href="#l27.35"></a><span id="l27.35"> {</span>
<a href="#l27.36"></a><span id="l27.36">   void* next = 0;</span>
<a href="#l27.37"></a><span id="l27.37" class="difflineat">@@ -86,17 +86,17 @@ morkList::morkList() : mList_Head( 0 ), </span>
<a href="#l27.38"></a><span id="l27.38"> void morkList::CutAndZapAllListMembers(morkEnv* ev, nsIMdbHeap* ioHeap)</span>
<a href="#l27.39"></a><span id="l27.39"> // make empty list, zapping every member by calling ZapOldNext()</span>
<a href="#l27.40"></a><span id="l27.40"> {</span>
<a href="#l27.41"></a><span id="l27.41">   if ( ioHeap )</span>
<a href="#l27.42"></a><span id="l27.42">   {</span>
<a href="#l27.43"></a><span id="l27.43">     morkNext* next = 0;</span>
<a href="#l27.44"></a><span id="l27.44">     while ( (next = this-&gt;PopHead()) != 0 )</span>
<a href="#l27.45"></a><span id="l27.45">       next-&gt;ZapOldNext(ev, ioHeap);</span>
<a href="#l27.46"></a><span id="l27.46" class="difflineminus">-      </span>
<a href="#l27.47"></a><span id="l27.47" class="difflineplus">+</span>
<a href="#l27.48"></a><span id="l27.48">     mList_Head = 0;</span>
<a href="#l27.49"></a><span id="l27.49">     mList_Tail = 0;</span>
<a href="#l27.50"></a><span id="l27.50">   }</span>
<a href="#l27.51"></a><span id="l27.51">   else</span>
<a href="#l27.52"></a><span id="l27.52">     ev-&gt;NilPointerError();</span>
<a href="#l27.53"></a><span id="l27.53"> }</span>
<a href="#l27.54"></a><span id="l27.54"> </span>
<a href="#l27.55"></a><span id="l27.55"> void morkList::CutAllListMembers()</span>
<a href="#l27.56"></a><span id="l27.56" class="difflineat">@@ -113,58 +113,58 @@ morkNext* morkList::PopHead() // cut hea</span>
<a href="#l27.57"></a><span id="l27.57"> {</span>
<a href="#l27.58"></a><span id="l27.58">   morkNext* outHead = mList_Head;</span>
<a href="#l27.59"></a><span id="l27.59">   if ( outHead ) // anything to cut from list?</span>
<a href="#l27.60"></a><span id="l27.60">   {</span>
<a href="#l27.61"></a><span id="l27.61">     morkNext* next = outHead-&gt;mNext_Link;</span>
<a href="#l27.62"></a><span id="l27.62">     mList_Head = next;</span>
<a href="#l27.63"></a><span id="l27.63">     if ( !next ) // cut the last member, so tail no longer exists?</span>
<a href="#l27.64"></a><span id="l27.64">       mList_Tail = 0;</span>
<a href="#l27.65"></a><span id="l27.65" class="difflineminus">-      </span>
<a href="#l27.66"></a><span id="l27.66" class="difflineplus">+</span>
<a href="#l27.67"></a><span id="l27.67">     outHead-&gt;mNext_Link = 0; // nil outgoing node link; unnecessary, but tidy</span>
<a href="#l27.68"></a><span id="l27.68">   }</span>
<a href="#l27.69"></a><span id="l27.69">   return outHead;</span>
<a href="#l27.70"></a><span id="l27.70"> }</span>
<a href="#l27.71"></a><span id="l27.71"> </span>
<a href="#l27.72"></a><span id="l27.72"> </span>
<a href="#l27.73"></a><span id="l27.73"> void morkList::PushHead(morkNext* ioLink) // add to head of list</span>
<a href="#l27.74"></a><span id="l27.74"> {</span>
<a href="#l27.75"></a><span id="l27.75">   morkNext* head = mList_Head; // old head of list</span>
<a href="#l27.76"></a><span id="l27.76">   morkNext* tail = mList_Tail; // old tail of list</span>
<a href="#l27.77"></a><span id="l27.77" class="difflineminus">-  </span>
<a href="#l27.78"></a><span id="l27.78" class="difflineplus">+</span>
<a href="#l27.79"></a><span id="l27.79">   MORK_ASSERT( (head &amp;&amp; tail) || (!head &amp;&amp; !tail));</span>
<a href="#l27.80"></a><span id="l27.80" class="difflineminus">-  </span>
<a href="#l27.81"></a><span id="l27.81" class="difflineplus">+</span>
<a href="#l27.82"></a><span id="l27.82">   ioLink-&gt;mNext_Link = head; // make old head follow the new link</span>
<a href="#l27.83"></a><span id="l27.83">   if ( !head ) // list was previously empty?</span>
<a href="#l27.84"></a><span id="l27.84">     mList_Tail = ioLink; // head is also tail for first member added</span>
<a href="#l27.85"></a><span id="l27.85"> </span>
<a href="#l27.86"></a><span id="l27.86">   mList_Head = ioLink; // head of list is the new link</span>
<a href="#l27.87"></a><span id="l27.87"> }</span>
<a href="#l27.88"></a><span id="l27.88"> </span>
<a href="#l27.89"></a><span id="l27.89"> void morkList::PushTail(morkNext* ioLink) // add to tail of list</span>
<a href="#l27.90"></a><span id="l27.90"> {</span>
<a href="#l27.91"></a><span id="l27.91">   morkNext* head = mList_Head; // old head of list</span>
<a href="#l27.92"></a><span id="l27.92">   morkNext* tail = mList_Tail; // old tail of list</span>
<a href="#l27.93"></a><span id="l27.93" class="difflineminus">-  </span>
<a href="#l27.94"></a><span id="l27.94" class="difflineplus">+</span>
<a href="#l27.95"></a><span id="l27.95">   MORK_ASSERT( (head &amp;&amp; tail) || (!head &amp;&amp; !tail));</span>
<a href="#l27.96"></a><span id="l27.96" class="difflineminus">-  </span>
<a href="#l27.97"></a><span id="l27.97" class="difflineminus">-  ioLink-&gt;mNext_Link = 0; </span>
<a href="#l27.98"></a><span id="l27.98" class="difflineminus">-  if ( tail ) </span>
<a href="#l27.99"></a><span id="l27.99" class="difflineplus">+</span>
<a href="#l27.100"></a><span id="l27.100" class="difflineplus">+  ioLink-&gt;mNext_Link = 0;</span>
<a href="#l27.101"></a><span id="l27.101" class="difflineplus">+  if ( tail )</span>
<a href="#l27.102"></a><span id="l27.102">   {</span>
<a href="#l27.103"></a><span id="l27.103"> 	  tail-&gt;mNext_Link = ioLink;</span>
<a href="#l27.104"></a><span id="l27.104"> 	  mList_Tail = ioLink;</span>
<a href="#l27.105"></a><span id="l27.105">   }</span>
<a href="#l27.106"></a><span id="l27.106">   else // list was previously empty?</span>
<a href="#l27.107"></a><span id="l27.107"> 	  mList_Head = mList_Tail = ioLink; // tail is also head for first member added</span>
<a href="#l27.108"></a><span id="l27.108"> }</span>
<a href="#l27.109"></a><span id="l27.109"> </span>
<a href="#l27.110"></a><span id="l27.110"> /*=============================================================================</span>
<a href="#l27.111"></a><span id="l27.111">  * morkLink: linked list node embedded in objs to allow insertion in morkDeques</span>
<a href="#l27.112"></a><span id="l27.112">  */</span>
<a href="#l27.113"></a><span id="l27.113" class="difflineminus">- </span>
<a href="#l27.114"></a><span id="l27.114" class="difflineplus">+</span>
<a href="#l27.115"></a><span id="l27.115"> morkLink::morkLink() : mLink_Next( 0 ), mLink_Prev( 0 )</span>
<a href="#l27.116"></a><span id="l27.116"> {</span>
<a href="#l27.117"></a><span id="l27.117"> }</span>
<a href="#l27.118"></a><span id="l27.118"> </span>
<a href="#l27.119"></a><span id="l27.119"> /*static*/ void*</span>
<a href="#l27.120"></a><span id="l27.120"> morkLink::MakeNewLink(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev)</span>
<a href="#l27.121"></a><span id="l27.121"> {</span>
<a href="#l27.122"></a><span id="l27.122">   void* alink = 0;</span>
<a href="#l27.123"></a><span id="l27.123" class="difflineat">@@ -180,108 +180,108 @@ void morkLink::ZapOldLink(morkEnv* ev, n</span>
<a href="#l27.124"></a><span id="l27.124"> {</span>
<a href="#l27.125"></a><span id="l27.125">   if ( ioHeap )</span>
<a href="#l27.126"></a><span id="l27.126">   {</span>
<a href="#l27.127"></a><span id="l27.127">       ioHeap-&gt;Free(ev-&gt;AsMdbEnv(), this);</span>
<a href="#l27.128"></a><span id="l27.128">   }</span>
<a href="#l27.129"></a><span id="l27.129">   else</span>
<a href="#l27.130"></a><span id="l27.130">     ev-&gt;NilPointerError();</span>
<a href="#l27.131"></a><span id="l27.131"> }</span>
<a href="#l27.132"></a><span id="l27.132" class="difflineminus">-  </span>
<a href="#l27.133"></a><span id="l27.133" class="difflineplus">+</span>
<a href="#l27.134"></a><span id="l27.134"> /*=============================================================================</span>
<a href="#l27.135"></a><span id="l27.135">  * morkDeque: doubly linked list modeled after VAX queue instructions</span>
<a href="#l27.136"></a><span id="l27.136">  */</span>
<a href="#l27.137"></a><span id="l27.137"> </span>
<a href="#l27.138"></a><span id="l27.138"> morkDeque::morkDeque()</span>
<a href="#l27.139"></a><span id="l27.139"> {</span>
<a href="#l27.140"></a><span id="l27.140">   mDeque_Head.SelfRefer();</span>
<a href="#l27.141"></a><span id="l27.141"> }</span>
<a href="#l27.142"></a><span id="l27.142"> </span>
<a href="#l27.143"></a><span id="l27.143"> </span>
<a href="#l27.144"></a><span id="l27.144" class="difflineminus">-/*| RemoveFirst: </span>
<a href="#l27.145"></a><span id="l27.145" class="difflineplus">+/*| RemoveFirst:</span>
<a href="#l27.146"></a><span id="l27.146"> |*/</span>
<a href="#l27.147"></a><span id="l27.147"> morkLink*</span>
<a href="#l27.148"></a><span id="l27.148"> morkDeque::RemoveFirst() /*i*/</span>
<a href="#l27.149"></a><span id="l27.149"> {</span>
<a href="#l27.150"></a><span id="l27.150">   morkLink* alink = mDeque_Head.mLink_Next;</span>
<a href="#l27.151"></a><span id="l27.151">   if ( alink != &amp;mDeque_Head )</span>
<a href="#l27.152"></a><span id="l27.152">   {</span>
<a href="#l27.153"></a><span id="l27.153" class="difflineminus">-    (mDeque_Head.mLink_Next = alink-&gt;mLink_Next)-&gt;mLink_Prev = </span>
<a href="#l27.154"></a><span id="l27.154" class="difflineplus">+    (mDeque_Head.mLink_Next = alink-&gt;mLink_Next)-&gt;mLink_Prev =</span>
<a href="#l27.155"></a><span id="l27.155">       &amp;mDeque_Head;</span>
<a href="#l27.156"></a><span id="l27.156">     return alink;</span>
<a href="#l27.157"></a><span id="l27.157">   }</span>
<a href="#l27.158"></a><span id="l27.158">   return (morkLink*) 0;</span>
<a href="#l27.159"></a><span id="l27.159"> }</span>
<a href="#l27.160"></a><span id="l27.160"> </span>
<a href="#l27.161"></a><span id="l27.161" class="difflineminus">-/*| RemoveLast: </span>
<a href="#l27.162"></a><span id="l27.162" class="difflineplus">+/*| RemoveLast:</span>
<a href="#l27.163"></a><span id="l27.163"> |*/</span>
<a href="#l27.164"></a><span id="l27.164"> morkLink*</span>
<a href="#l27.165"></a><span id="l27.165"> morkDeque::RemoveLast() /*i*/</span>
<a href="#l27.166"></a><span id="l27.166"> {</span>
<a href="#l27.167"></a><span id="l27.167">   morkLink* alink = mDeque_Head.mLink_Prev;</span>
<a href="#l27.168"></a><span id="l27.168">   if ( alink != &amp;mDeque_Head )</span>
<a href="#l27.169"></a><span id="l27.169">   {</span>
<a href="#l27.170"></a><span id="l27.170" class="difflineminus">-    (mDeque_Head.mLink_Prev = alink-&gt;mLink_Prev)-&gt;mLink_Next = </span>
<a href="#l27.171"></a><span id="l27.171" class="difflineplus">+    (mDeque_Head.mLink_Prev = alink-&gt;mLink_Prev)-&gt;mLink_Next =</span>
<a href="#l27.172"></a><span id="l27.172">       &amp;mDeque_Head;</span>
<a href="#l27.173"></a><span id="l27.173">     return alink;</span>
<a href="#l27.174"></a><span id="l27.174">   }</span>
<a href="#l27.175"></a><span id="l27.175">   return (morkLink*) 0;</span>
<a href="#l27.176"></a><span id="l27.176"> }</span>
<a href="#l27.177"></a><span id="l27.177"> </span>
<a href="#l27.178"></a><span id="l27.178" class="difflineminus">-/*| At: </span>
<a href="#l27.179"></a><span id="l27.179" class="difflineplus">+/*| At:</span>
<a href="#l27.180"></a><span id="l27.180"> |*/</span>
<a href="#l27.181"></a><span id="l27.181"> morkLink*</span>
<a href="#l27.182"></a><span id="l27.182"> morkDeque::At(mork_pos index) const /*i*/</span>
<a href="#l27.183"></a><span id="l27.183">   /* indexes are one based (and not zero based) */</span>
<a href="#l27.184"></a><span id="l27.184" class="difflineminus">-{ </span>
<a href="#l27.185"></a><span id="l27.185" class="difflineplus">+{</span>
<a href="#l27.186"></a><span id="l27.186">   mork_num count = 0;</span>
<a href="#l27.187"></a><span id="l27.187">   morkLink* alink;</span>
<a href="#l27.188"></a><span id="l27.188">   for ( alink = this-&gt;First(); alink; alink = this-&gt;After(alink) )</span>
<a href="#l27.189"></a><span id="l27.189">   {</span>
<a href="#l27.190"></a><span id="l27.190">     if ( ++count == (mork_num) index )</span>
<a href="#l27.191"></a><span id="l27.191">       break;</span>
<a href="#l27.192"></a><span id="l27.192">   }</span>
<a href="#l27.193"></a><span id="l27.193">   return alink;</span>
<a href="#l27.194"></a><span id="l27.194"> }</span>
<a href="#l27.195"></a><span id="l27.195"> </span>
<a href="#l27.196"></a><span id="l27.196" class="difflineminus">-/*| IndexOf: </span>
<a href="#l27.197"></a><span id="l27.197" class="difflineplus">+/*| IndexOf:</span>
<a href="#l27.198"></a><span id="l27.198"> |*/</span>
<a href="#l27.199"></a><span id="l27.199"> mork_pos</span>
<a href="#l27.200"></a><span id="l27.200"> morkDeque::IndexOf(const morkLink* member) const /*i*/</span>
<a href="#l27.201"></a><span id="l27.201">   /* indexes are one based (and not zero based) */</span>
<a href="#l27.202"></a><span id="l27.202">   /* zero means member is not in deque */</span>
<a href="#l27.203"></a><span id="l27.203" class="difflineminus">-{ </span>
<a href="#l27.204"></a><span id="l27.204" class="difflineplus">+{</span>
<a href="#l27.205"></a><span id="l27.205">   mork_num count = 0;</span>
<a href="#l27.206"></a><span id="l27.206">   const morkLink* alink;</span>
<a href="#l27.207"></a><span id="l27.207">   for ( alink = this-&gt;First(); alink; alink = this-&gt;After(alink) )</span>
<a href="#l27.208"></a><span id="l27.208">   {</span>
<a href="#l27.209"></a><span id="l27.209">     ++count;</span>
<a href="#l27.210"></a><span id="l27.210">     if ( member == alink )</span>
<a href="#l27.211"></a><span id="l27.211">       return (mork_pos) count;</span>
<a href="#l27.212"></a><span id="l27.212">   }</span>
<a href="#l27.213"></a><span id="l27.213">   return 0;</span>
<a href="#l27.214"></a><span id="l27.214"> }</span>
<a href="#l27.215"></a><span id="l27.215"> </span>
<a href="#l27.216"></a><span id="l27.216" class="difflineminus">-/*| Length: </span>
<a href="#l27.217"></a><span id="l27.217" class="difflineplus">+/*| Length:</span>
<a href="#l27.218"></a><span id="l27.218"> |*/</span>
<a href="#l27.219"></a><span id="l27.219"> mork_num</span>
<a href="#l27.220"></a><span id="l27.220"> morkDeque::Length() const /*i*/</span>
<a href="#l27.221"></a><span id="l27.221" class="difflineminus">-{ </span>
<a href="#l27.222"></a><span id="l27.222" class="difflineplus">+{</span>
<a href="#l27.223"></a><span id="l27.223">   mork_num count = 0;</span>
<a href="#l27.224"></a><span id="l27.224">   morkLink* alink;</span>
<a href="#l27.225"></a><span id="l27.225">   for ( alink = this-&gt;First(); alink; alink = this-&gt;After(alink) )</span>
<a href="#l27.226"></a><span id="l27.226">     ++count;</span>
<a href="#l27.227"></a><span id="l27.227">   return count;</span>
<a href="#l27.228"></a><span id="l27.228"> }</span>
<a href="#l27.229"></a><span id="l27.229"> </span>
<a href="#l27.230"></a><span id="l27.230" class="difflineminus">-/*| LengthCompare: </span>
<a href="#l27.231"></a><span id="l27.231" class="difflineplus">+/*| LengthCompare:</span>
<a href="#l27.232"></a><span id="l27.232"> |*/</span>
<a href="#l27.233"></a><span id="l27.233"> int</span>
<a href="#l27.234"></a><span id="l27.234"> morkDeque::LengthCompare(mork_num c) const /*i*/</span>
<a href="#l27.235"></a><span id="l27.235" class="difflineminus">-{ </span>
<a href="#l27.236"></a><span id="l27.236" class="difflineplus">+{</span>
<a href="#l27.237"></a><span id="l27.237">   mork_num count = 0;</span>
<a href="#l27.238"></a><span id="l27.238">   const morkLink* alink;</span>
<a href="#l27.239"></a><span id="l27.239">   for ( alink = this-&gt;First(); alink; alink = this-&gt;After(alink) )</span>
<a href="#l27.240"></a><span id="l27.240">   {</span>
<a href="#l27.241"></a><span id="l27.241">     if ( ++count &gt; c )</span>
<a href="#l27.242"></a><span id="l27.242">       return 1;</span>
<a href="#l27.243"></a><span id="l27.243">   }</span>
<a href="#l27.244"></a><span id="l27.244">   return ( count == c )? 0 : -1;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l28.1"></a><span id="l28.1" class="difflineminus">--- a/db/mork/src/morkDeque.h</span>
<a href="#l28.2"></a><span id="l28.2" class="difflineplus">+++ b/db/mork/src/morkDeque.h</span>
<a href="#l28.3"></a><span id="l28.3" class="difflineat">@@ -1,28 +1,28 @@</span>
<a href="#l28.4"></a><span id="l28.4"> /*************************************************************************</span>
<a href="#l28.5"></a><span id="l28.5"> This software is part of a public domain IronDoc source code distribution,</span>
<a href="#l28.6"></a><span id="l28.6"> and is provided on an &quot;AS IS&quot; basis, with all risks borne by the consumers</span>
<a href="#l28.7"></a><span id="l28.7"> or users of the IronDoc software.  There are no warranties, guarantees, or</span>
<a href="#l28.8"></a><span id="l28.8" class="difflineminus">-promises about quality of any kind; and no remedies for failure exist. </span>
<a href="#l28.9"></a><span id="l28.9" class="difflineplus">+promises about quality of any kind; and no remedies for failure exist.</span>
<a href="#l28.10"></a><span id="l28.10"> </span>
<a href="#l28.11"></a><span id="l28.11"> Permission is hereby granted to use this IronDoc software for any purpose</span>
<a href="#l28.12"></a><span id="l28.12"> at all, without need for written agreements, without royalty or license</span>
<a href="#l28.13"></a><span id="l28.13"> fees, and without fees or obligations of any other kind.  Anyone can use,</span>
<a href="#l28.14"></a><span id="l28.14"> copy, change and distribute this software for any purpose, and nothing is</span>
<a href="#l28.15"></a><span id="l28.15"> required, implicitly or otherwise, in exchange for this usage.</span>
<a href="#l28.16"></a><span id="l28.16"> </span>
<a href="#l28.17"></a><span id="l28.17"> You cannot apply your own copyright to this software, but otherwise you</span>
<a href="#l28.18"></a><span id="l28.18"> are encouraged to enjoy the use of this software in any way you see fit.</span>
<a href="#l28.19"></a><span id="l28.19"> However, it would be rude to remove names of developers from the code.</span>
<a href="#l28.20"></a><span id="l28.20"> (IronDoc is also known by the short name &quot;Fe&quot; and a longer name &quot;Ferrum&quot;,</span>
<a href="#l28.21"></a><span id="l28.21"> which are used interchangeably with the name IronDoc in the sources.)</span>
<a href="#l28.22"></a><span id="l28.22"> *************************************************************************/</span>
<a href="#l28.23"></a><span id="l28.23"> /*</span>
<a href="#l28.24"></a><span id="l28.24" class="difflineminus">- * File:      morkDeque.h </span>
<a href="#l28.25"></a><span id="l28.25" class="difflineplus">+ * File:      morkDeque.h</span>
<a href="#l28.26"></a><span id="l28.26">  * Contains:  Ferrum deque (double ended queue (linked list))</span>
<a href="#l28.27"></a><span id="l28.27">  *</span>
<a href="#l28.28"></a><span id="l28.28">  * Copied directly from public domain IronDoc, with minor naming tweaks:</span>
<a href="#l28.29"></a><span id="l28.29">  * Designed and written by David McCusker, but all this code is public domain.</span>
<a href="#l28.30"></a><span id="l28.30">  * There are no warranties, no guarantees, no promises, and no remedies.</span>
<a href="#l28.31"></a><span id="l28.31">  */</span>
<a href="#l28.32"></a><span id="l28.32"> </span>
<a href="#l28.33"></a><span id="l28.33"> #ifndef _MORKDEQUE_</span>
<a href="#l28.34"></a><span id="l28.34" class="difflineat">@@ -31,38 +31,38 @@ which are used interchangeably with the </span>
<a href="#l28.35"></a><span id="l28.35"> #ifndef _MORK_</span>
<a href="#l28.36"></a><span id="l28.36"> #include &quot;mork.h&quot;</span>
<a href="#l28.37"></a><span id="l28.37"> #endif</span>
<a href="#l28.38"></a><span id="l28.38"> </span>
<a href="#l28.39"></a><span id="l28.39"> /*=============================================================================</span>
<a href="#l28.40"></a><span id="l28.40">  * morkNext: linked list node for very simple, singly-linked list</span>
<a href="#l28.41"></a><span id="l28.41">  */</span>
<a href="#l28.42"></a><span id="l28.42"> </span>
<a href="#l28.43"></a><span id="l28.43" class="difflineminus">-class morkNext /*d*/ {  </span>
<a href="#l28.44"></a><span id="l28.44" class="difflineplus">+class morkNext /*d*/ {</span>
<a href="#l28.45"></a><span id="l28.45"> public:</span>
<a href="#l28.46"></a><span id="l28.46">   morkNext*  mNext_Link;</span>
<a href="#l28.47"></a><span id="l28.47" class="difflineminus">-  </span>
<a href="#l28.48"></a><span id="l28.48" class="difflineplus">+</span>
<a href="#l28.49"></a><span id="l28.49"> public:</span>
<a href="#l28.50"></a><span id="l28.50">   morkNext(int inZero) : mNext_Link( 0 ) { }</span>
<a href="#l28.51"></a><span id="l28.51" class="difflineminus">-  </span>
<a href="#l28.52"></a><span id="l28.52" class="difflineplus">+</span>
<a href="#l28.53"></a><span id="l28.53">   morkNext(morkNext* ioLink) : mNext_Link( ioLink ) { }</span>
<a href="#l28.54"></a><span id="l28.54" class="difflineminus">-  </span>
<a href="#l28.55"></a><span id="l28.55" class="difflineplus">+</span>
<a href="#l28.56"></a><span id="l28.56">   morkNext(); // mNext_Link( 0 ), { }</span>
<a href="#l28.57"></a><span id="l28.57" class="difflineminus">-  </span>
<a href="#l28.58"></a><span id="l28.58" class="difflineplus">+</span>
<a href="#l28.59"></a><span id="l28.59"> public:</span>
<a href="#l28.60"></a><span id="l28.60">   morkNext*  GetNextLink() const { return mNext_Link; }</span>
<a href="#l28.61"></a><span id="l28.61" class="difflineminus">-  </span>
<a href="#l28.62"></a><span id="l28.62" class="difflineplus">+</span>
<a href="#l28.63"></a><span id="l28.63"> public: // link memory management methods</span>
<a href="#l28.64"></a><span id="l28.64">   static void* MakeNewNext(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev);</span>
<a href="#l28.65"></a><span id="l28.65">   void ZapOldNext(morkEnv* ev, nsIMdbHeap* ioHeap);</span>
<a href="#l28.66"></a><span id="l28.66"> </span>
<a href="#l28.67"></a><span id="l28.67"> public: // link memory management operators</span>
<a href="#l28.68"></a><span id="l28.68">   void* operator new(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev) CPP_THROW_NEW</span>
<a href="#l28.69"></a><span id="l28.69">   { return morkNext::MakeNewNext(inSize, ioHeap, ev); }</span>
<a href="#l28.70"></a><span id="l28.70" class="difflineminus">-  </span>
<a href="#l28.71"></a><span id="l28.71" class="difflineplus">+</span>
<a href="#l28.72"></a><span id="l28.72">   void operator delete(void* ioAddress) // DO NOT CALL THIS, hope to crash:</span>
<a href="#l28.73"></a><span id="l28.73">   { ((morkNext*) 0)-&gt;ZapOldNext((morkEnv*) 0, (nsIMdbHeap*) 0); } // boom</span>
<a href="#l28.74"></a><span id="l28.74"> };</span>
<a href="#l28.75"></a><span id="l28.75"> </span>
<a href="#l28.76"></a><span id="l28.76"> /*=============================================================================</span>
<a href="#l28.77"></a><span id="l28.77">  * morkList: simple, singly-linked list</span>
<a href="#l28.78"></a><span id="l28.78">  */</span>
<a href="#l28.79"></a><span id="l28.79"> </span>
<a href="#l28.80"></a><span id="l28.80" class="difflineat">@@ -73,92 +73,92 @@ public: // link memory management operat</span>
<a href="#l28.81"></a><span id="l28.81"> **|| morkList is intended to support lists of changes in morkTable, where we</span>
<a href="#l28.82"></a><span id="l28.82"> **| are worried about the space cost of representing such changes. (Later we</span>
<a href="#l28.83"></a><span id="l28.83"> **| can use an array instead, when we get even more worried, to avoid cost</span>
<a href="#l28.84"></a><span id="l28.84"> **| of link slots at all, per member).</span>
<a href="#l28.85"></a><span id="l28.85"> **|</span>
<a href="#l28.86"></a><span id="l28.86"> **|| Do NOT create cycles in links using this list class, since we do not</span>
<a href="#l28.87"></a><span id="l28.87"> **| deal with them very nicely.</span>
<a href="#l28.88"></a><span id="l28.88"> |*/</span>
<a href="#l28.89"></a><span id="l28.89" class="difflineminus">-class morkList /*d*/  {  </span>
<a href="#l28.90"></a><span id="l28.90" class="difflineplus">+class morkList /*d*/  {</span>
<a href="#l28.91"></a><span id="l28.91"> public:</span>
<a href="#l28.92"></a><span id="l28.92">   morkNext*  mList_Head; // first link in the list</span>
<a href="#l28.93"></a><span id="l28.93">   morkNext*  mList_Tail; // last link in the list</span>
<a href="#l28.94"></a><span id="l28.94" class="difflineminus">-  </span>
<a href="#l28.95"></a><span id="l28.95" class="difflineplus">+</span>
<a href="#l28.96"></a><span id="l28.96"> public:</span>
<a href="#l28.97"></a><span id="l28.97">   morkNext*  GetListHead() const { return mList_Head; }</span>
<a href="#l28.98"></a><span id="l28.98">   morkNext*  GetListTail() const { return mList_Tail; }</span>
<a href="#l28.99"></a><span id="l28.99"> </span>
<a href="#l28.100"></a><span id="l28.100">   mork_bool IsListEmpty() const { return ( mList_Head == 0 ); }</span>
<a href="#l28.101"></a><span id="l28.101">   mork_bool HasListMembers() const { return ( mList_Head != 0 ); }</span>
<a href="#l28.102"></a><span id="l28.102" class="difflineminus">-  </span>
<a href="#l28.103"></a><span id="l28.103" class="difflineplus">+</span>
<a href="#l28.104"></a><span id="l28.104"> public:</span>
<a href="#l28.105"></a><span id="l28.105">   morkList(); // : mList_Head( 0 ), mList_Tail( 0 ) { }</span>
<a href="#l28.106"></a><span id="l28.106" class="difflineminus">-  </span>
<a href="#l28.107"></a><span id="l28.107" class="difflineplus">+</span>
<a href="#l28.108"></a><span id="l28.108">   void CutAndZapAllListMembers(morkEnv* ev, nsIMdbHeap* ioHeap);</span>
<a href="#l28.109"></a><span id="l28.109">   // make empty list, zapping every member by calling ZapOldNext()</span>
<a href="#l28.110"></a><span id="l28.110"> </span>
<a href="#l28.111"></a><span id="l28.111">   void CutAllListMembers();</span>
<a href="#l28.112"></a><span id="l28.112">   // just make list empty, dropping members without zapping</span>
<a href="#l28.113"></a><span id="l28.113"> </span>
<a href="#l28.114"></a><span id="l28.114"> public:</span>
<a href="#l28.115"></a><span id="l28.115">   morkNext* PopHead(); // cut head of list</span>
<a href="#l28.116"></a><span id="l28.116" class="difflineminus">-  </span>
<a href="#l28.117"></a><span id="l28.117" class="difflineplus">+</span>
<a href="#l28.118"></a><span id="l28.118">   // Note we don't support PopTail(), so use morkDeque if you need that.</span>
<a href="#l28.119"></a><span id="l28.119" class="difflineminus">-  </span>
<a href="#l28.120"></a><span id="l28.120" class="difflineplus">+</span>
<a href="#l28.121"></a><span id="l28.121">   void PushHead(morkNext* ioLink); // add to head of list</span>
<a href="#l28.122"></a><span id="l28.122">   void PushTail(morkNext* ioLink); // add to tail of list</span>
<a href="#l28.123"></a><span id="l28.123"> };</span>
<a href="#l28.124"></a><span id="l28.124"> </span>
<a href="#l28.125"></a><span id="l28.125"> /*=============================================================================</span>
<a href="#l28.126"></a><span id="l28.126">  * morkLink: linked list node embedded in objs to allow insertion in morkDeques</span>
<a href="#l28.127"></a><span id="l28.127">  */</span>
<a href="#l28.128"></a><span id="l28.128"> </span>
<a href="#l28.129"></a><span id="l28.129" class="difflineminus">-class morkLink /*d*/ {  </span>
<a href="#l28.130"></a><span id="l28.130" class="difflineplus">+class morkLink /*d*/ {</span>
<a href="#l28.131"></a><span id="l28.131"> public:</span>
<a href="#l28.132"></a><span id="l28.132">   morkLink*  mLink_Next;</span>
<a href="#l28.133"></a><span id="l28.133">   morkLink*  mLink_Prev;</span>
<a href="#l28.134"></a><span id="l28.134" class="difflineminus">-  </span>
<a href="#l28.135"></a><span id="l28.135" class="difflineplus">+</span>
<a href="#l28.136"></a><span id="l28.136"> public:</span>
<a href="#l28.137"></a><span id="l28.137">   morkLink(int inZero) : mLink_Next( 0 ), mLink_Prev( 0 ) { }</span>
<a href="#l28.138"></a><span id="l28.138" class="difflineminus">-  </span>
<a href="#l28.139"></a><span id="l28.139" class="difflineplus">+</span>
<a href="#l28.140"></a><span id="l28.140">   morkLink(); // mLink_Next( 0 ), mLink_Prev( 0 ) { }</span>
<a href="#l28.141"></a><span id="l28.141" class="difflineminus">-  </span>
<a href="#l28.142"></a><span id="l28.142" class="difflineplus">+</span>
<a href="#l28.143"></a><span id="l28.143"> public:</span>
<a href="#l28.144"></a><span id="l28.144">   morkLink*  Next() const { return mLink_Next; }</span>
<a href="#l28.145"></a><span id="l28.145">   morkLink*  Prev() const { return mLink_Prev; }</span>
<a href="#l28.146"></a><span id="l28.146" class="difflineminus">-  </span>
<a href="#l28.147"></a><span id="l28.147" class="difflineplus">+</span>
<a href="#l28.148"></a><span id="l28.148">   void SelfRefer() { mLink_Next = mLink_Prev = this; }</span>
<a href="#l28.149"></a><span id="l28.149">   void Clear() { mLink_Next = mLink_Prev = 0; }</span>
<a href="#l28.150"></a><span id="l28.150" class="difflineminus">-  </span>
<a href="#l28.151"></a><span id="l28.151" class="difflineplus">+</span>
<a href="#l28.152"></a><span id="l28.152">   void AddBefore(morkLink* old)</span>
<a href="#l28.153"></a><span id="l28.153">   {</span>
<a href="#l28.154"></a><span id="l28.154">     ((old)-&gt;mLink_Prev-&gt;mLink_Next = (this))-&gt;mLink_Prev = (old)-&gt;mLink_Prev;</span>
<a href="#l28.155"></a><span id="l28.155">     ((this)-&gt;mLink_Next = (old))-&gt;mLink_Prev = this;</span>
<a href="#l28.156"></a><span id="l28.156">   }</span>
<a href="#l28.157"></a><span id="l28.157" class="difflineminus">-  </span>
<a href="#l28.158"></a><span id="l28.158" class="difflineplus">+</span>
<a href="#l28.159"></a><span id="l28.159">   void AddAfter(morkLink* old)</span>
<a href="#l28.160"></a><span id="l28.160">   {</span>
<a href="#l28.161"></a><span id="l28.161">     ((old)-&gt;mLink_Next-&gt;mLink_Prev = (this))-&gt;mLink_Next = (old)-&gt;mLink_Next;</span>
<a href="#l28.162"></a><span id="l28.162">     ((this)-&gt;mLink_Prev = (old))-&gt;mLink_Next = this;</span>
<a href="#l28.163"></a><span id="l28.163">   }</span>
<a href="#l28.164"></a><span id="l28.164" class="difflineminus">-  </span>
<a href="#l28.165"></a><span id="l28.165" class="difflineplus">+</span>
<a href="#l28.166"></a><span id="l28.166">   void Remove()</span>
<a href="#l28.167"></a><span id="l28.167">   {</span>
<a href="#l28.168"></a><span id="l28.168">     (mLink_Prev-&gt;mLink_Next = mLink_Next)-&gt;mLink_Prev = mLink_Prev;</span>
<a href="#l28.169"></a><span id="l28.169">   }</span>
<a href="#l28.170"></a><span id="l28.170" class="difflineminus">-  </span>
<a href="#l28.171"></a><span id="l28.171" class="difflineplus">+</span>
<a href="#l28.172"></a><span id="l28.172"> public: // link memory management methods</span>
<a href="#l28.173"></a><span id="l28.173">   static void* MakeNewLink(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev);</span>
<a href="#l28.174"></a><span id="l28.174">   void ZapOldLink(morkEnv* ev, nsIMdbHeap* ioHeap);</span>
<a href="#l28.175"></a><span id="l28.175"> </span>
<a href="#l28.176"></a><span id="l28.176"> public: // link memory management operators</span>
<a href="#l28.177"></a><span id="l28.177">   void* operator new(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev) CPP_THROW_NEW</span>
<a href="#l28.178"></a><span id="l28.178">   { return morkLink::MakeNewLink(inSize, ioHeap, ev); }</span>
<a href="#l28.179"></a><span id="l28.179" class="difflineminus">-  </span>
<a href="#l28.180"></a><span id="l28.180" class="difflineplus">+</span>
<a href="#l28.181"></a><span id="l28.181"> };</span>
<a href="#l28.182"></a><span id="l28.182"> </span>
<a href="#l28.183"></a><span id="l28.183"> /*=============================================================================</span>
<a href="#l28.184"></a><span id="l28.184">  * morkDeque: doubly linked list modeled after VAX queue instructions</span>
<a href="#l28.185"></a><span id="l28.185">  */</span>
<a href="#l28.186"></a><span id="l28.186"> </span>
<a href="#l28.187"></a><span id="l28.187"> class morkDeque /*d*/ {</span>
<a href="#l28.188"></a><span id="l28.188"> public:</span>
<a href="#l28.189"></a><span id="l28.189" class="difflineat">@@ -169,28 +169,28 @@ public: // construction</span>
<a href="#l28.190"></a><span id="l28.190"> </span>
<a href="#l28.191"></a><span id="l28.191"> public:// methods</span>
<a href="#l28.192"></a><span id="l28.192">   morkLink* RemoveFirst();</span>
<a href="#l28.193"></a><span id="l28.193"> </span>
<a href="#l28.194"></a><span id="l28.194">   morkLink* RemoveLast();</span>
<a href="#l28.195"></a><span id="l28.195"> </span>
<a href="#l28.196"></a><span id="l28.196">   morkLink* At(mork_pos index) const ; /* one-based, not zero-based */</span>
<a href="#l28.197"></a><span id="l28.197"> </span>
<a href="#l28.198"></a><span id="l28.198" class="difflineminus">-  mork_pos IndexOf(const morkLink* inMember) const; </span>
<a href="#l28.199"></a><span id="l28.199" class="difflineplus">+  mork_pos IndexOf(const morkLink* inMember) const;</span>
<a href="#l28.200"></a><span id="l28.200">     /* one-based index ; zero means member is not in deque */</span>
<a href="#l28.201"></a><span id="l28.201"> </span>
<a href="#l28.202"></a><span id="l28.202">   mork_num Length() const;</span>
<a href="#l28.203"></a><span id="l28.203"> </span>
<a href="#l28.204"></a><span id="l28.204">   /* the following method is more efficient for long lists: */</span>
<a href="#l28.205"></a><span id="l28.205">   int LengthCompare(mork_num inCount) const;</span>
<a href="#l28.206"></a><span id="l28.206">   /* -1: length &lt; count, 0: length == count,  1: length &gt; count */</span>
<a href="#l28.207"></a><span id="l28.207"> </span>
<a href="#l28.208"></a><span id="l28.208"> public: // inlines</span>
<a href="#l28.209"></a><span id="l28.209"> </span>
<a href="#l28.210"></a><span id="l28.210" class="difflineminus">-  mork_bool IsEmpty()const </span>
<a href="#l28.211"></a><span id="l28.211" class="difflineplus">+  mork_bool IsEmpty()const</span>
<a href="#l28.212"></a><span id="l28.212">   { return (mDeque_Head.mLink_Next == (morkLink*) &amp;mDeque_Head); }</span>
<a href="#l28.213"></a><span id="l28.213"> </span>
<a href="#l28.214"></a><span id="l28.214">   morkLink* After(const morkLink* old) const</span>
<a href="#l28.215"></a><span id="l28.215">   { return (((old)-&gt;mLink_Next != &amp;mDeque_Head)?</span>
<a href="#l28.216"></a><span id="l28.216">             (old)-&gt;mLink_Next : (morkLink*) 0); }</span>
<a href="#l28.217"></a><span id="l28.217"> </span>
<a href="#l28.218"></a><span id="l28.218">   morkLink* Before(const morkLink* old) const</span>
<a href="#l28.219"></a><span id="l28.219">   { return (((old)-&gt;mLink_Prev != &amp;mDeque_Head)?</span>
<a href="#l28.220"></a><span id="l28.220" class="difflineat">@@ -198,27 +198,27 @@ public: // inlines</span>
<a href="#l28.221"></a><span id="l28.221"> </span>
<a href="#l28.222"></a><span id="l28.222">   morkLink*  First() const</span>
<a href="#l28.223"></a><span id="l28.223">   { return ((mDeque_Head.mLink_Next != &amp;mDeque_Head)?</span>
<a href="#l28.224"></a><span id="l28.224">     mDeque_Head.mLink_Next : (morkLink*) 0); }</span>
<a href="#l28.225"></a><span id="l28.225"> </span>
<a href="#l28.226"></a><span id="l28.226">   morkLink*  Last() const</span>
<a href="#l28.227"></a><span id="l28.227">   { return ((mDeque_Head.mLink_Prev != &amp;mDeque_Head)?</span>
<a href="#l28.228"></a><span id="l28.228">     mDeque_Head.mLink_Prev : (morkLink*) 0); }</span>
<a href="#l28.229"></a><span id="l28.229" class="difflineminus">-    </span>
<a href="#l28.230"></a><span id="l28.230" class="difflineplus">+</span>
<a href="#l28.231"></a><span id="l28.231"> /*</span>
<a href="#l28.232"></a><span id="l28.232"> From IronDoc documentation for AddFirst:</span>
<a href="#l28.233"></a><span id="l28.233"> +--------+   +--------+      +--------+   +--------+   +--------+</span>
<a href="#l28.234"></a><span id="l28.234"> | h.next |--&gt;| b.next |      | h.next |--&gt;| a.next |--&gt;| b.next |</span>
<a href="#l28.235"></a><span id="l28.235"> +--------+   +--------+  ==&gt; +--------+   +--------+   +--------+</span>
<a href="#l28.236"></a><span id="l28.236"> | h.prev |&lt;--| b.prev |      | h.prev |&lt;--| a.prev |&lt;--| b.prev |</span>
<a href="#l28.237"></a><span id="l28.237"> +--------+   +--------+      +--------+   +--------+   +--------+</span>
<a href="#l28.238"></a><span id="l28.238"> */</span>
<a href="#l28.239"></a><span id="l28.239"> </span>
<a href="#l28.240"></a><span id="l28.240" class="difflineminus">-  void AddFirst(morkLink* in) /*i*/ </span>
<a href="#l28.241"></a><span id="l28.241" class="difflineplus">+  void AddFirst(morkLink* in) /*i*/</span>
<a href="#l28.242"></a><span id="l28.242">   {</span>
<a href="#l28.243"></a><span id="l28.243">     (mDeque_Head.mLink_Next-&gt;mLink_Prev = in)-&gt;mLink_Next =</span>
<a href="#l28.244"></a><span id="l28.244">       mDeque_Head.mLink_Next;</span>
<a href="#l28.245"></a><span id="l28.245">     (in-&gt;mLink_Prev = &amp;mDeque_Head)-&gt;mLink_Next = in;</span>
<a href="#l28.246"></a><span id="l28.246">   }</span>
<a href="#l28.247"></a><span id="l28.247"> /*</span>
<a href="#l28.248"></a><span id="l28.248"> From IronDoc documentation for AddLast:</span>
<a href="#l28.249"></a><span id="l28.249"> +--------+   +--------+      +--------+   +--------+   +--------+</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l29.1"></a><span id="l29.1" class="difflineminus">--- a/db/mork/src/morkEnv.cpp</span>
<a href="#l29.2"></a><span id="l29.2" class="difflineplus">+++ b/db/mork/src/morkEnv.cpp</span>
<a href="#l29.3"></a><span id="l29.3" class="difflineat">@@ -26,17 +26,17 @@</span>
<a href="#l29.4"></a><span id="l29.4"> #ifndef _MORKFACTORY_</span>
<a href="#l29.5"></a><span id="l29.5"> #include &quot;morkFactory.h&quot;</span>
<a href="#l29.6"></a><span id="l29.6"> #endif</span>
<a href="#l29.7"></a><span id="l29.7"> </span>
<a href="#l29.8"></a><span id="l29.8"> #include &quot;mozilla/Char16.h&quot;</span>
<a href="#l29.9"></a><span id="l29.9"> </span>
<a href="#l29.10"></a><span id="l29.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l29.11"></a><span id="l29.11"> </span>
<a href="#l29.12"></a><span id="l29.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l29.13"></a><span id="l29.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l29.14"></a><span id="l29.14"> // { ===== begin morkNode interface =====</span>
<a href="#l29.15"></a><span id="l29.15"> </span>
<a href="#l29.16"></a><span id="l29.16"> /*public virtual*/ void</span>
<a href="#l29.17"></a><span id="l29.17"> morkEnv::CloseMorkNode(morkEnv* ev) /*i*/ // CloseEnv() only if open</span>
<a href="#l29.18"></a><span id="l29.18"> {</span>
<a href="#l29.19"></a><span id="l29.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l29.20"></a><span id="l29.20">   {</span>
<a href="#l29.21"></a><span id="l29.21">     this-&gt;MarkClosing();</span>
<a href="#l29.22"></a><span id="l29.22" class="difflineat">@@ -82,37 +82,37 @@ morkEnv::morkEnv(const morkUsage&amp; inUsag</span>
<a href="#l29.23"></a><span id="l29.23">   morkFactory* ioFactory, nsIMdbHeap* ioSlotHeap)</span>
<a href="#l29.24"></a><span id="l29.24"> : morkObject(inUsage, ioHeap, morkColor_kNone)</span>
<a href="#l29.25"></a><span id="l29.25"> , mEnv_Factory( ioFactory )</span>
<a href="#l29.26"></a><span id="l29.26"> , mEnv_Heap( ioSlotHeap )</span>
<a href="#l29.27"></a><span id="l29.27"> </span>
<a href="#l29.28"></a><span id="l29.28"> , mEnv_SelfAsMdbEnv( 0 )</span>
<a href="#l29.29"></a><span id="l29.29"> , mEnv_ErrorHook( 0 )</span>
<a href="#l29.30"></a><span id="l29.30"> , mEnv_HandlePool( 0 )</span>
<a href="#l29.31"></a><span id="l29.31" class="difflineminus">-  </span>
<a href="#l29.32"></a><span id="l29.32" class="difflineminus">-, mEnv_ErrorCount( 0 ) </span>
<a href="#l29.33"></a><span id="l29.33" class="difflineminus">-, mEnv_WarningCount( 0 ) </span>
<a href="#l29.34"></a><span id="l29.34" class="difflineplus">+</span>
<a href="#l29.35"></a><span id="l29.35" class="difflineplus">+, mEnv_ErrorCount( 0 )</span>
<a href="#l29.36"></a><span id="l29.36" class="difflineplus">+, mEnv_WarningCount( 0 )</span>
<a href="#l29.37"></a><span id="l29.37"> </span>
<a href="#l29.38"></a><span id="l29.38"> , mEnv_ErrorCode(NS_OK)</span>
<a href="#l29.39"></a><span id="l29.39"> </span>
<a href="#l29.40"></a><span id="l29.40"> , mEnv_DoTrace( morkBool_kFalse )</span>
<a href="#l29.41"></a><span id="l29.41"> , mEnv_AutoClear( morkAble_kDisabled )</span>
<a href="#l29.42"></a><span id="l29.42"> , mEnv_ShouldAbort( morkBool_kFalse )</span>
<a href="#l29.43"></a><span id="l29.43"> , mEnv_BeVerbose( morkEnv_kBeVerbose )</span>
<a href="#l29.44"></a><span id="l29.44"> , mEnv_OwnsHeap ( morkBool_kFalse )</span>
<a href="#l29.45"></a><span id="l29.45"> {</span>
<a href="#l29.46"></a><span id="l29.46">   MORK_ASSERT(ioSlotHeap &amp;&amp; ioFactory );</span>
<a href="#l29.47"></a><span id="l29.47">   if ( ioSlotHeap )</span>
<a href="#l29.48"></a><span id="l29.48">   {</span>
<a href="#l29.49"></a><span id="l29.49">     // mEnv_Heap is NOT refcounted:</span>
<a href="#l29.50"></a><span id="l29.50">     // nsIMdbHeap_SlotStrongHeap(ioSlotHeap, this, &amp;mEnv_Heap);</span>
<a href="#l29.51"></a><span id="l29.51" class="difflineminus">-    </span>
<a href="#l29.52"></a><span id="l29.52" class="difflineplus">+</span>
<a href="#l29.53"></a><span id="l29.53">     mEnv_HandlePool = new morkPool(morkUsage::kGlobal,</span>
<a href="#l29.54"></a><span id="l29.54">       (nsIMdbHeap*) 0, ioSlotHeap);</span>
<a href="#l29.55"></a><span id="l29.55" class="difflineminus">-      </span>
<a href="#l29.56"></a><span id="l29.56" class="difflineplus">+</span>
<a href="#l29.57"></a><span id="l29.57">     MORK_ASSERT(mEnv_HandlePool);</span>
<a href="#l29.58"></a><span id="l29.58">     if ( mEnv_HandlePool &amp;&amp; this-&gt;Good() )</span>
<a href="#l29.59"></a><span id="l29.59">     {</span>
<a href="#l29.60"></a><span id="l29.60">       mNode_Derived = morkDerived_kEnv;</span>
<a href="#l29.61"></a><span id="l29.61">       mNode_Refs += morkEnv_kWeakRefCountEnvBonus;</span>
<a href="#l29.62"></a><span id="l29.62">     }</span>
<a href="#l29.63"></a><span id="l29.63">   }</span>
<a href="#l29.64"></a><span id="l29.64"> }</span>
<a href="#l29.65"></a><span id="l29.65" class="difflineat">@@ -123,38 +123,38 @@ morkEnv::morkEnv(morkEnv* ev, /*i*/</span>
<a href="#l29.66"></a><span id="l29.66">   morkFactory* ioFactory, nsIMdbHeap* ioSlotHeap)</span>
<a href="#l29.67"></a><span id="l29.67"> : morkObject(ev, inUsage, ioHeap, morkColor_kNone, (morkHandle*) 0)</span>
<a href="#l29.68"></a><span id="l29.68"> , mEnv_Factory( ioFactory )</span>
<a href="#l29.69"></a><span id="l29.69"> , mEnv_Heap( ioSlotHeap )</span>
<a href="#l29.70"></a><span id="l29.70"> </span>
<a href="#l29.71"></a><span id="l29.71"> , mEnv_SelfAsMdbEnv( inSelfAsMdbEnv )</span>
<a href="#l29.72"></a><span id="l29.72"> , mEnv_ErrorHook( 0 )</span>
<a href="#l29.73"></a><span id="l29.73"> , mEnv_HandlePool( 0 )</span>
<a href="#l29.74"></a><span id="l29.74" class="difflineminus">-  </span>
<a href="#l29.75"></a><span id="l29.75" class="difflineminus">-, mEnv_ErrorCount( 0 ) </span>
<a href="#l29.76"></a><span id="l29.76" class="difflineminus">-, mEnv_WarningCount( 0 ) </span>
<a href="#l29.77"></a><span id="l29.77" class="difflineplus">+</span>
<a href="#l29.78"></a><span id="l29.78" class="difflineplus">+, mEnv_ErrorCount( 0 )</span>
<a href="#l29.79"></a><span id="l29.79" class="difflineplus">+, mEnv_WarningCount( 0 )</span>
<a href="#l29.80"></a><span id="l29.80"> </span>
<a href="#l29.81"></a><span id="l29.81"> , mEnv_ErrorCode(NS_OK)</span>
<a href="#l29.82"></a><span id="l29.82"> </span>
<a href="#l29.83"></a><span id="l29.83"> , mEnv_DoTrace( morkBool_kFalse )</span>
<a href="#l29.84"></a><span id="l29.84"> , mEnv_AutoClear( morkAble_kDisabled )</span>
<a href="#l29.85"></a><span id="l29.85"> , mEnv_ShouldAbort( morkBool_kFalse )</span>
<a href="#l29.86"></a><span id="l29.86"> , mEnv_BeVerbose( morkEnv_kBeVerbose )</span>
<a href="#l29.87"></a><span id="l29.87"> , mEnv_OwnsHeap ( morkBool_kFalse )</span>
<a href="#l29.88"></a><span id="l29.88"> {</span>
<a href="#l29.89"></a><span id="l29.89">   // $$$ do we need to refcount the inSelfAsMdbEnv nsIMdbEnv??</span>
<a href="#l29.90"></a><span id="l29.90" class="difflineminus">-  </span>
<a href="#l29.91"></a><span id="l29.91" class="difflineplus">+</span>
<a href="#l29.92"></a><span id="l29.92">   if ( ioFactory &amp;&amp; inSelfAsMdbEnv &amp;&amp; ioSlotHeap)</span>
<a href="#l29.93"></a><span id="l29.93">   {</span>
<a href="#l29.94"></a><span id="l29.94">     // mEnv_Heap is NOT refcounted:</span>
<a href="#l29.95"></a><span id="l29.95">     // nsIMdbHeap_SlotStrongHeap(ioSlotHeap, ev, &amp;mEnv_Heap);</span>
<a href="#l29.96"></a><span id="l29.96"> </span>
<a href="#l29.97"></a><span id="l29.97" class="difflineminus">-    mEnv_HandlePool = new(*ioSlotHeap, ev) morkPool(ev, </span>
<a href="#l29.98"></a><span id="l29.98" class="difflineplus">+    mEnv_HandlePool = new(*ioSlotHeap, ev) morkPool(ev,</span>
<a href="#l29.99"></a><span id="l29.99">       morkUsage::kHeap, ioSlotHeap, ioSlotHeap);</span>
<a href="#l29.100"></a><span id="l29.100" class="difflineminus">-      </span>
<a href="#l29.101"></a><span id="l29.101" class="difflineplus">+</span>
<a href="#l29.102"></a><span id="l29.102">     MORK_ASSERT(mEnv_HandlePool);</span>
<a href="#l29.103"></a><span id="l29.103">     if ( mEnv_HandlePool &amp;&amp; ev-&gt;Good() )</span>
<a href="#l29.104"></a><span id="l29.104">     {</span>
<a href="#l29.105"></a><span id="l29.105">       mNode_Derived = morkDerived_kEnv;</span>
<a href="#l29.106"></a><span id="l29.106">       mNode_Refs += morkEnv_kWeakRefCountEnvBonus;</span>
<a href="#l29.107"></a><span id="l29.107">     }</span>
<a href="#l29.108"></a><span id="l29.108">   }</span>
<a href="#l29.109"></a><span id="l29.109">   else</span>
<a href="#l29.110"></a><span id="l29.110" class="difflineat">@@ -164,20 +164,20 @@ morkEnv::morkEnv(morkEnv* ev, /*i*/</span>
<a href="#l29.111"></a><span id="l29.111"> NS_IMPL_ISUPPORTS_INHERITED(morkEnv, morkObject, nsIMdbEnv)</span>
<a href="#l29.112"></a><span id="l29.112"> /*public non-poly*/ void</span>
<a href="#l29.113"></a><span id="l29.113"> morkEnv::CloseEnv(morkEnv* ev) /*i*/ // called by CloseMorkNode();</span>
<a href="#l29.114"></a><span id="l29.114"> {</span>
<a href="#l29.115"></a><span id="l29.115">     if ( this-&gt;IsNode() )</span>
<a href="#l29.116"></a><span id="l29.116">     {</span>
<a href="#l29.117"></a><span id="l29.117">       // $$$ release mEnv_SelfAsMdbEnv??</span>
<a href="#l29.118"></a><span id="l29.118">       // $$$ release mEnv_ErrorHook??</span>
<a href="#l29.119"></a><span id="l29.119" class="difflineminus">-      </span>
<a href="#l29.120"></a><span id="l29.120" class="difflineplus">+</span>
<a href="#l29.121"></a><span id="l29.121">       mEnv_SelfAsMdbEnv = 0;</span>
<a href="#l29.122"></a><span id="l29.122">       mEnv_ErrorHook = 0;</span>
<a href="#l29.123"></a><span id="l29.123" class="difflineminus">-      </span>
<a href="#l29.124"></a><span id="l29.124" class="difflineplus">+</span>
<a href="#l29.125"></a><span id="l29.125">       morkPool* savePool = mEnv_HandlePool;</span>
<a href="#l29.126"></a><span id="l29.126">       morkPool::SlotStrongPool((morkPool*) 0, ev, &amp;mEnv_HandlePool);</span>
<a href="#l29.127"></a><span id="l29.127">       // free the pool</span>
<a href="#l29.128"></a><span id="l29.128">       if (mEnv_SelfAsMdbEnv)</span>
<a href="#l29.129"></a><span id="l29.129">       {</span>
<a href="#l29.130"></a><span id="l29.130">         if (savePool &amp;&amp; mEnv_Heap)</span>
<a href="#l29.131"></a><span id="l29.131">           mEnv_Heap-&gt;Free(this-&gt;AsMdbEnv(), savePool);</span>
<a href="#l29.132"></a><span id="l29.132">       }</span>
<a href="#l29.133"></a><span id="l29.133" class="difflineat">@@ -187,35 +187,35 @@ morkEnv::CloseEnv(morkEnv* ev) /*i*/ // </span>
<a href="#l29.134"></a><span id="l29.134">         {</span>
<a href="#l29.135"></a><span id="l29.135">           if (savePool-&gt;IsOpenNode())</span>
<a href="#l29.136"></a><span id="l29.136">             savePool-&gt;CloseMorkNode(ev);</span>
<a href="#l29.137"></a><span id="l29.137">           delete savePool;</span>
<a href="#l29.138"></a><span id="l29.138">         }</span>
<a href="#l29.139"></a><span id="l29.139">         // how do we free this? might need to get rid of asserts.</span>
<a href="#l29.140"></a><span id="l29.140">       }</span>
<a href="#l29.141"></a><span id="l29.141">       // mEnv_Factory is NOT refcounted</span>
<a href="#l29.142"></a><span id="l29.142" class="difflineminus">-      </span>
<a href="#l29.143"></a><span id="l29.143" class="difflineplus">+</span>
<a href="#l29.144"></a><span id="l29.144">       this-&gt;MarkShut();</span>
<a href="#l29.145"></a><span id="l29.145">     }</span>
<a href="#l29.146"></a><span id="l29.146">     else</span>
<a href="#l29.147"></a><span id="l29.147">       this-&gt;NonNodeError(ev);</span>
<a href="#l29.148"></a><span id="l29.148"> }</span>
<a href="#l29.149"></a><span id="l29.149"> </span>
<a href="#l29.150"></a><span id="l29.150"> // } ===== end morkNode methods =====</span>
<a href="#l29.151"></a><span id="l29.151" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l29.152"></a><span id="l29.152" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l29.153"></a><span id="l29.153"> </span>
<a href="#l29.154"></a><span id="l29.154"> mork_size</span>
<a href="#l29.155"></a><span id="l29.155"> morkEnv::OidAsHex(void* outBuf, const mdbOid&amp; inOid)</span>
<a href="#l29.156"></a><span id="l29.156"> // sprintf(buf, &quot;%lX:^%lX&quot;, (long) inOid.mOid_Id, (long) inOid.mOid_Scope);</span>
<a href="#l29.157"></a><span id="l29.157"> {</span>
<a href="#l29.158"></a><span id="l29.158">   mork_u1* p = (mork_u1*) outBuf;</span>
<a href="#l29.159"></a><span id="l29.159">   mork_size outSize = this-&gt;TokenAsHex(p, inOid.mOid_Id);</span>
<a href="#l29.160"></a><span id="l29.160">   p += outSize;</span>
<a href="#l29.161"></a><span id="l29.161">   *p++ = ':';</span>
<a href="#l29.162"></a><span id="l29.162" class="difflineminus">-  </span>
<a href="#l29.163"></a><span id="l29.163" class="difflineplus">+</span>
<a href="#l29.164"></a><span id="l29.164">   mork_scope scope = inOid.mOid_Scope;</span>
<a href="#l29.165"></a><span id="l29.165">   if ( scope &lt; 0x80 &amp;&amp; morkCh_IsName((mork_ch) scope) )</span>
<a href="#l29.166"></a><span id="l29.166">   {</span>
<a href="#l29.167"></a><span id="l29.167">     *p++ = (mork_u1) scope;</span>
<a href="#l29.168"></a><span id="l29.168">     *p = 0; // null termination</span>
<a href="#l29.169"></a><span id="l29.169">     outSize += 2;</span>
<a href="#l29.170"></a><span id="l29.170">   }</span>
<a href="#l29.171"></a><span id="l29.171">   else</span>
<a href="#l29.172"></a><span id="l29.172" class="difflineat">@@ -234,26 +234,26 @@ morkEnv::HexToByte(mork_ch inFirstHex, m</span>
<a href="#l29.173"></a><span id="l29.173">   mork_u1 hi = 0; // high four hex bits</span>
<a href="#l29.174"></a><span id="l29.174">   mork_flags f = morkCh_GetFlags(inFirstHex);</span>
<a href="#l29.175"></a><span id="l29.175">   if ( morkFlags_IsDigit(f) )</span>
<a href="#l29.176"></a><span id="l29.176">     hi = (mork_u1) (inFirstHex - (mork_ch) '0');</span>
<a href="#l29.177"></a><span id="l29.177">   else if ( morkFlags_IsUpper(f) )</span>
<a href="#l29.178"></a><span id="l29.178">     hi = (mork_u1) ((inFirstHex - (mork_ch) 'A') + 10);</span>
<a href="#l29.179"></a><span id="l29.179">   else if ( morkFlags_IsLower(f) )</span>
<a href="#l29.180"></a><span id="l29.180">     hi = (mork_u1) ((inFirstHex - (mork_ch) 'a') + 10);</span>
<a href="#l29.181"></a><span id="l29.181" class="difflineminus">-  </span>
<a href="#l29.182"></a><span id="l29.182" class="difflineplus">+</span>
<a href="#l29.183"></a><span id="l29.183">   mork_u1 lo = 0; // low four hex bits</span>
<a href="#l29.184"></a><span id="l29.184">   f = morkCh_GetFlags(inSecondHex);</span>
<a href="#l29.185"></a><span id="l29.185">   if ( morkFlags_IsDigit(f) )</span>
<a href="#l29.186"></a><span id="l29.186">     lo = (mork_u1) (inSecondHex - (mork_ch) '0');</span>
<a href="#l29.187"></a><span id="l29.187">   else if ( morkFlags_IsUpper(f) )</span>
<a href="#l29.188"></a><span id="l29.188">     lo = (mork_u1) ((inSecondHex - (mork_ch) 'A') + 10);</span>
<a href="#l29.189"></a><span id="l29.189">   else if ( morkFlags_IsLower(f) )</span>
<a href="#l29.190"></a><span id="l29.190">     lo = (mork_u1) ((inSecondHex - (mork_ch) 'a') + 10);</span>
<a href="#l29.191"></a><span id="l29.191" class="difflineminus">-    </span>
<a href="#l29.192"></a><span id="l29.192" class="difflineplus">+</span>
<a href="#l29.193"></a><span id="l29.193">   return (mork_u1) ((hi &lt;&lt; 4) | lo);</span>
<a href="#l29.194"></a><span id="l29.194"> }</span>
<a href="#l29.195"></a><span id="l29.195"> </span>
<a href="#l29.196"></a><span id="l29.196"> mork_size</span>
<a href="#l29.197"></a><span id="l29.197"> morkEnv::TokenAsHex(void* outBuf, mork_token inToken)</span>
<a href="#l29.198"></a><span id="l29.198">   // TokenAsHex() is the same as sprintf(outBuf, &quot;%lX&quot;, (long) inToken);</span>
<a href="#l29.199"></a><span id="l29.199"> {</span>
<a href="#l29.200"></a><span id="l29.200">   static const char morkEnv_kHexDigits[] = &quot;0123456789ABCDEF&quot;;</span>
<a href="#l29.201"></a><span id="l29.201" class="difflineat">@@ -289,33 +289,33 @@ morkEnv::TokenAsHex(void* outBuf, mork_t</span>
<a href="#l29.202"></a><span id="l29.202">   }</span>
<a href="#l29.203"></a><span id="l29.203"> }</span>
<a href="#l29.204"></a><span id="l29.204"> </span>
<a href="#l29.205"></a><span id="l29.205"> void</span>
<a href="#l29.206"></a><span id="l29.206"> morkEnv::StringToYarn(const PathChar* inString, mdbYarn* outYarn)</span>
<a href="#l29.207"></a><span id="l29.207"> {</span>
<a href="#l29.208"></a><span id="l29.208">   if ( outYarn )</span>
<a href="#l29.209"></a><span id="l29.209">   {</span>
<a href="#l29.210"></a><span id="l29.210" class="difflineminus">-    mdb_fill fill = ( inString )? (mdb_fill) MORK_STRLEN(inString) * sizeof(PathChar) : 0; </span>
<a href="#l29.211"></a><span id="l29.211" class="difflineminus">-      </span>
<a href="#l29.212"></a><span id="l29.212" class="difflineplus">+    mdb_fill fill = ( inString )? (mdb_fill) MORK_STRLEN(inString) * sizeof(PathChar) : 0;</span>
<a href="#l29.213"></a><span id="l29.213" class="difflineplus">+</span>
<a href="#l29.214"></a><span id="l29.214">     if ( fill ) // have nonempty content?</span>
<a href="#l29.215"></a><span id="l29.215">     {</span>
<a href="#l29.216"></a><span id="l29.216">       mdb_size size = outYarn-&gt;mYarn_Size; // max dest size</span>
<a href="#l29.217"></a><span id="l29.217">       if ( fill &gt; size ) // too much string content?</span>
<a href="#l29.218"></a><span id="l29.218">       {</span>
<a href="#l29.219"></a><span id="l29.219">         outYarn-&gt;mYarn_More = fill - size; // extra string bytes omitted</span>
<a href="#l29.220"></a><span id="l29.220">         fill = size; // copy no more bytes than size of yarn buffer</span>
<a href="#l29.221"></a><span id="l29.221">       }</span>
<a href="#l29.222"></a><span id="l29.222">       void* dest = outYarn-&gt;mYarn_Buf; // where bytes are going</span>
<a href="#l29.223"></a><span id="l29.223">       if ( !dest ) // nil destination address buffer?</span>
<a href="#l29.224"></a><span id="l29.224">         fill = 0; // we can't write any content at all</span>
<a href="#l29.225"></a><span id="l29.225" class="difflineminus">-        </span>
<a href="#l29.226"></a><span id="l29.226" class="difflineplus">+</span>
<a href="#l29.227"></a><span id="l29.227">       if ( fill ) // anything to copy?</span>
<a href="#l29.228"></a><span id="l29.228">         MORK_MEMCPY(dest, inString, fill); // copy fill bytes to yarn</span>
<a href="#l29.229"></a><span id="l29.229" class="difflineminus">-        </span>
<a href="#l29.230"></a><span id="l29.230" class="difflineplus">+</span>
<a href="#l29.231"></a><span id="l29.231">       outYarn-&gt;mYarn_Fill = fill; // tell yarn size of copied content</span>
<a href="#l29.232"></a><span id="l29.232">     }</span>
<a href="#l29.233"></a><span id="l29.233">     else // no content to put into the yarn</span>
<a href="#l29.234"></a><span id="l29.234">     {</span>
<a href="#l29.235"></a><span id="l29.235">       outYarn-&gt;mYarn_Fill = 0; // tell yarn that string has no bytes</span>
<a href="#l29.236"></a><span id="l29.236">     }</span>
<a href="#l29.237"></a><span id="l29.237">     outYarn-&gt;mYarn_Form = 0; // always update the form slot</span>
<a href="#l29.238"></a><span id="l29.238">   }</span>
<a href="#l29.239"></a><span id="l29.239" class="difflineat">@@ -362,17 +362,17 @@ morkEnv::NewError(const char* inString)</span>
<a href="#l29.240"></a><span id="l29.240">   if ( mEnv_ErrorHook )</span>
<a href="#l29.241"></a><span id="l29.241">     mEnv_ErrorHook-&gt;OnErrorString(this-&gt;AsMdbEnv(), inString);</span>
<a href="#l29.242"></a><span id="l29.242"> }</span>
<a href="#l29.243"></a><span id="l29.243"> </span>
<a href="#l29.244"></a><span id="l29.244"> void</span>
<a href="#l29.245"></a><span id="l29.245"> morkEnv::NewWarning(const char* inString)</span>
<a href="#l29.246"></a><span id="l29.246"> {</span>
<a href="#l29.247"></a><span id="l29.247">   MORK_ASSERT(morkBool_kFalse); // get developer's attention</span>
<a href="#l29.248"></a><span id="l29.248" class="difflineminus">-  </span>
<a href="#l29.249"></a><span id="l29.249" class="difflineplus">+</span>
<a href="#l29.250"></a><span id="l29.250">   ++mEnv_WarningCount;</span>
<a href="#l29.251"></a><span id="l29.251">   if ( mEnv_ErrorHook )</span>
<a href="#l29.252"></a><span id="l29.252">     mEnv_ErrorHook-&gt;OnWarningString(this-&gt;AsMdbEnv(), inString);</span>
<a href="#l29.253"></a><span id="l29.253"> }</span>
<a href="#l29.254"></a><span id="l29.254"> </span>
<a href="#l29.255"></a><span id="l29.255"> void</span>
<a href="#l29.256"></a><span id="l29.256"> morkEnv::StubMethodOnlyError()</span>
<a href="#l29.257"></a><span id="l29.257"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l30.1"></a><span id="l30.1" class="difflineminus">--- a/db/mork/src/morkEnv.h</span>
<a href="#l30.2"></a><span id="l30.2" class="difflineplus">+++ b/db/mork/src/morkEnv.h</span>
<a href="#l30.3"></a><span id="l30.3" class="difflineat">@@ -21,116 +21,116 @@</span>
<a href="#l30.4"></a><span id="l30.4"> // sean was here</span>
<a href="#l30.5"></a><span id="l30.5"> #include &quot;mozilla/Path.h&quot;</span>
<a href="#l30.6"></a><span id="l30.6"> #include &quot;nsError.h&quot;</span>
<a href="#l30.7"></a><span id="l30.7"> </span>
<a href="#l30.8"></a><span id="l30.8"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l30.9"></a><span id="l30.9"> </span>
<a href="#l30.10"></a><span id="l30.10"> #define morkDerived_kEnv     /*i*/ 0x4576 /* ascii 'Ev' */</span>
<a href="#l30.11"></a><span id="l30.11"> </span>
<a href="#l30.12"></a><span id="l30.12" class="difflineminus">-// use NS error codes to make Mork easier to use with the rest of mozilla </span>
<a href="#l30.13"></a><span id="l30.13" class="difflineplus">+// use NS error codes to make Mork easier to use with the rest of mozilla</span>
<a href="#l30.14"></a><span id="l30.14"> #define morkEnv_kNoError         NS_SUCCEEDED /* no error has happened */</span>
<a href="#l30.15"></a><span id="l30.15"> #define morkEnv_kNonEnvTypeError NS_ERROR_FAILURE /* morkEnv::IsEnv() is false */</span>
<a href="#l30.16"></a><span id="l30.16"> </span>
<a href="#l30.17"></a><span id="l30.17"> #define morkEnv_kStubMethodOnlyError NS_ERROR_NO_INTERFACE</span>
<a href="#l30.18"></a><span id="l30.18"> #define morkEnv_kOutOfMemoryError    NS_ERROR_OUT_OF_MEMORY</span>
<a href="#l30.19"></a><span id="l30.19"> #define morkEnv_kNilPointerError     NS_ERROR_NULL_POINTER</span>
<a href="#l30.20"></a><span id="l30.20" class="difflineminus">-#define morkEnv_kNewNonEnvError      NS_ERROR_FAILURE </span>
<a href="#l30.21"></a><span id="l30.21" class="difflineplus">+#define morkEnv_kNewNonEnvError      NS_ERROR_FAILURE</span>
<a href="#l30.22"></a><span id="l30.22"> #define morkEnv_kNilEnvSlotError     NS_ERROR_FAILURE</span>
<a href="#l30.23"></a><span id="l30.23"> </span>
<a href="#l30.24"></a><span id="l30.24"> #define morkEnv_kBadFactoryError     NS_ERROR_FACTORY_NOT_LOADED</span>
<a href="#l30.25"></a><span id="l30.25"> #define morkEnv_kBadFactoryEnvError  NS_ERROR_FACTORY_NOT_LOADED</span>
<a href="#l30.26"></a><span id="l30.26"> #define morkEnv_kBadEnvError         NS_ERROR_FAILURE</span>
<a href="#l30.27"></a><span id="l30.27"> </span>
<a href="#l30.28"></a><span id="l30.28"> #define morkEnv_kNonHandleTypeError  NS_ERROR_FAILURE</span>
<a href="#l30.29"></a><span id="l30.29" class="difflineminus">-#define morkEnv_kNonOpenNodeError    NS_ERROR_FAILURE </span>
<a href="#l30.30"></a><span id="l30.30" class="difflineplus">+#define morkEnv_kNonOpenNodeError    NS_ERROR_FAILURE</span>
<a href="#l30.31"></a><span id="l30.31"> </span>
<a href="#l30.32"></a><span id="l30.32"> </span>
<a href="#l30.33"></a><span id="l30.33"> #define morkEnv_kWeakRefCountEnvBonus 0 /* try NOT to leak all env instances */</span>
<a href="#l30.34"></a><span id="l30.34"> </span>
<a href="#l30.35"></a><span id="l30.35"> /*| morkEnv:</span>
<a href="#l30.36"></a><span id="l30.36"> |*/</span>
<a href="#l30.37"></a><span id="l30.37"> class morkEnv : public morkObject, public nsIMdbEnv {</span>
<a href="#l30.38"></a><span id="l30.38">   using PathChar = mozilla::filesystem::Path::value_type;</span>
<a href="#l30.39"></a><span id="l30.39">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l30.40"></a><span id="l30.40"> </span>
<a href="#l30.41"></a><span id="l30.41"> // public: // slots inherited from morkObject (meant to inform only)</span>
<a href="#l30.42"></a><span id="l30.42">   // nsIMdbHeap*       mNode_Heap;</span>
<a href="#l30.43"></a><span id="l30.43"> </span>
<a href="#l30.44"></a><span id="l30.44">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l30.45"></a><span id="l30.45">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l30.46"></a><span id="l30.46" class="difflineminus">-  </span>
<a href="#l30.47"></a><span id="l30.47" class="difflineplus">+</span>
<a href="#l30.48"></a><span id="l30.48">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l30.49"></a><span id="l30.49">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l30.50"></a><span id="l30.50">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l30.51"></a><span id="l30.51">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l30.52"></a><span id="l30.52" class="difflineminus">-  </span>
<a href="#l30.53"></a><span id="l30.53" class="difflineplus">+</span>
<a href="#l30.54"></a><span id="l30.54">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l30.55"></a><span id="l30.55">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l30.56"></a><span id="l30.56"> </span>
<a href="#l30.57"></a><span id="l30.57">   // mork_color   mBead_Color;   // ID for this bead</span>
<a href="#l30.58"></a><span id="l30.58">   // morkHandle*  mObject_Handle;  // weak ref to handle for this object</span>
<a href="#l30.59"></a><span id="l30.59"> </span>
<a href="#l30.60"></a><span id="l30.60"> public: // state is public because the entire Mork system is private</span>
<a href="#l30.61"></a><span id="l30.61" class="difflineminus">-  </span>
<a href="#l30.62"></a><span id="l30.62" class="difflineplus">+</span>
<a href="#l30.63"></a><span id="l30.63">   morkFactory*      mEnv_Factory;  // NON-refcounted factory</span>
<a href="#l30.64"></a><span id="l30.64">   nsIMdbHeap*       mEnv_Heap;     // NON-refcounted heap</span>
<a href="#l30.65"></a><span id="l30.65"> </span>
<a href="#l30.66"></a><span id="l30.66">   nsIMdbEnv*        mEnv_SelfAsMdbEnv;</span>
<a href="#l30.67"></a><span id="l30.67">   nsIMdbErrorHook*  mEnv_ErrorHook;</span>
<a href="#l30.68"></a><span id="l30.68" class="difflineminus">-  </span>
<a href="#l30.69"></a><span id="l30.69" class="difflineplus">+</span>
<a href="#l30.70"></a><span id="l30.70">   morkPool*         mEnv_HandlePool; // pool for re-using handles</span>
<a href="#l30.71"></a><span id="l30.71" class="difflineminus">-    </span>
<a href="#l30.72"></a><span id="l30.72" class="difflineminus">-  mork_u2           mEnv_ErrorCount; </span>
<a href="#l30.73"></a><span id="l30.73" class="difflineminus">-  mork_u2           mEnv_WarningCount; </span>
<a href="#l30.74"></a><span id="l30.74" class="difflineplus">+</span>
<a href="#l30.75"></a><span id="l30.75" class="difflineplus">+  mork_u2           mEnv_ErrorCount;</span>
<a href="#l30.76"></a><span id="l30.76" class="difflineplus">+  mork_u2           mEnv_WarningCount;</span>
<a href="#l30.77"></a><span id="l30.77"> </span>
<a href="#l30.78"></a><span id="l30.78">   nsresult          mEnv_ErrorCode;</span>
<a href="#l30.79"></a><span id="l30.79"> </span>
<a href="#l30.80"></a><span id="l30.80">   mork_bool         mEnv_DoTrace;</span>
<a href="#l30.81"></a><span id="l30.81">   mork_able         mEnv_AutoClear;</span>
<a href="#l30.82"></a><span id="l30.82">   mork_bool         mEnv_ShouldAbort;</span>
<a href="#l30.83"></a><span id="l30.83">   mork_bool         mEnv_BeVerbose;</span>
<a href="#l30.84"></a><span id="l30.84">   mork_bool         mEnv_OwnsHeap;</span>
<a href="#l30.85"></a><span id="l30.85" class="difflineminus">-  </span>
<a href="#l30.86"></a><span id="l30.86" class="difflineplus">+</span>
<a href="#l30.87"></a><span id="l30.87"> // { ===== begin morkNode interface =====</span>
<a href="#l30.88"></a><span id="l30.88"> public: // morkNode virtual methods</span>
<a href="#l30.89"></a><span id="l30.89">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseEnv() only if open</span>
<a href="#l30.90"></a><span id="l30.90">   virtual ~morkEnv(); // assert that CloseEnv() executed earlier</span>
<a href="#l30.91"></a><span id="l30.91" class="difflineminus">-  </span>
<a href="#l30.92"></a><span id="l30.92" class="difflineplus">+</span>
<a href="#l30.93"></a><span id="l30.93">   // { ----- begin attribute methods -----</span>
<a href="#l30.94"></a><span id="l30.94">   NS_IMETHOD GetErrorCount(mdb_count* outCount,</span>
<a href="#l30.95"></a><span id="l30.95">     mdb_bool* outShouldAbort) override;</span>
<a href="#l30.96"></a><span id="l30.96">   NS_IMETHOD GetWarningCount(mdb_count* outCount,</span>
<a href="#l30.97"></a><span id="l30.97">     mdb_bool* outShouldAbort) override;</span>
<a href="#l30.98"></a><span id="l30.98" class="difflineminus">-  </span>
<a href="#l30.99"></a><span id="l30.99" class="difflineplus">+</span>
<a href="#l30.100"></a><span id="l30.100">   NS_IMETHOD GetEnvBeVerbose(mdb_bool* outBeVerbose) override;</span>
<a href="#l30.101"></a><span id="l30.101">   NS_IMETHOD SetEnvBeVerbose(mdb_bool inBeVerbose) override;</span>
<a href="#l30.102"></a><span id="l30.102" class="difflineminus">-  </span>
<a href="#l30.103"></a><span id="l30.103" class="difflineplus">+</span>
<a href="#l30.104"></a><span id="l30.104">   NS_IMETHOD GetDoTrace(mdb_bool* outDoTrace) override;</span>
<a href="#l30.105"></a><span id="l30.105">   NS_IMETHOD SetDoTrace(mdb_bool inDoTrace) override;</span>
<a href="#l30.106"></a><span id="l30.106" class="difflineminus">-  </span>
<a href="#l30.107"></a><span id="l30.107" class="difflineplus">+</span>
<a href="#l30.108"></a><span id="l30.108">   NS_IMETHOD GetAutoClear(mdb_bool* outAutoClear) override;</span>
<a href="#l30.109"></a><span id="l30.109">   NS_IMETHOD SetAutoClear(mdb_bool inAutoClear) override;</span>
<a href="#l30.110"></a><span id="l30.110" class="difflineminus">-  </span>
<a href="#l30.111"></a><span id="l30.111" class="difflineplus">+</span>
<a href="#l30.112"></a><span id="l30.112">   NS_IMETHOD GetErrorHook(nsIMdbErrorHook** acqErrorHook) override;</span>
<a href="#l30.113"></a><span id="l30.113">   NS_IMETHOD SetErrorHook(</span>
<a href="#l30.114"></a><span id="l30.114">     nsIMdbErrorHook* ioErrorHook) override; // becomes referenced</span>
<a href="#l30.115"></a><span id="l30.115" class="difflineminus">-  </span>
<a href="#l30.116"></a><span id="l30.116" class="difflineplus">+</span>
<a href="#l30.117"></a><span id="l30.117">   NS_IMETHOD GetHeap(nsIMdbHeap** acqHeap) override;</span>
<a href="#l30.118"></a><span id="l30.118">   NS_IMETHOD SetHeap(nsIMdbHeap* ioHeap) override; // becomes referenced</span>
<a href="#l30.119"></a><span id="l30.119">   // } ----- end attribute methods -----</span>
<a href="#l30.120"></a><span id="l30.120" class="difflineminus">-  </span>
<a href="#l30.121"></a><span id="l30.121" class="difflineplus">+</span>
<a href="#l30.122"></a><span id="l30.122">   NS_IMETHOD ClearErrors() override; // clear errors beore re-entering db API</span>
<a href="#l30.123"></a><span id="l30.123">   NS_IMETHOD ClearWarnings() override; // clear warnings</span>
<a href="#l30.124"></a><span id="l30.124">   NS_IMETHOD ClearErrorsAndWarnings() override; // clear both errors &amp; warnings</span>
<a href="#l30.125"></a><span id="l30.125"> // } ===== end nsIMdbEnv methods =====</span>
<a href="#l30.126"></a><span id="l30.126"> public: // morkEnv construction &amp; destruction</span>
<a href="#l30.127"></a><span id="l30.127">   morkEnv(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l30.128"></a><span id="l30.128">     morkFactory* ioFactory, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l30.129"></a><span id="l30.129" class="difflineminus">-  morkEnv(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, </span>
<a href="#l30.130"></a><span id="l30.130" class="difflineplus">+  morkEnv(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l30.131"></a><span id="l30.131">      nsIMdbEnv* inSelfAsMdbEnv, morkFactory* ioFactory,</span>
<a href="#l30.132"></a><span id="l30.132">      nsIMdbHeap* ioSlotHeap);</span>
<a href="#l30.133"></a><span id="l30.133">   void CloseEnv(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l30.134"></a><span id="l30.134"> </span>
<a href="#l30.135"></a><span id="l30.135"> private: // copying is not allowed</span>
<a href="#l30.136"></a><span id="l30.136">   morkEnv(const morkEnv&amp; other);</span>
<a href="#l30.137"></a><span id="l30.137">   morkEnv&amp; operator=(const morkEnv&amp; other);</span>
<a href="#l30.138"></a><span id="l30.138"> </span>
<a href="#l30.139"></a><span id="l30.139" class="difflineat">@@ -140,68 +140,68 @@ public: // dynamic type identification</span>
<a href="#l30.140"></a><span id="l30.140"> // } ===== end morkNode methods =====</span>
<a href="#l30.141"></a><span id="l30.141"> </span>
<a href="#l30.142"></a><span id="l30.142"> public: // utility env methods</span>
<a href="#l30.143"></a><span id="l30.143"> </span>
<a href="#l30.144"></a><span id="l30.144">   mork_u1 HexToByte(mork_ch inFirstHex, mork_ch inSecondHex);</span>
<a href="#l30.145"></a><span id="l30.145"> </span>
<a href="#l30.146"></a><span id="l30.146">   mork_size TokenAsHex(void* outBuf, mork_token inToken);</span>
<a href="#l30.147"></a><span id="l30.147">   // TokenAsHex() is the same as sprintf(outBuf, &quot;%lX&quot;, (long) inToken);</span>
<a href="#l30.148"></a><span id="l30.148" class="difflineminus">- </span>
<a href="#l30.149"></a><span id="l30.149" class="difflineplus">+</span>
<a href="#l30.150"></a><span id="l30.150">   mork_size OidAsHex(void* outBuf, const mdbOid&amp; inOid);</span>
<a href="#l30.151"></a><span id="l30.151">   // sprintf(buf, &quot;%lX:^%lX&quot;, (long) inOid.mOid_Id, (long) inOid.mOid_Scope);</span>
<a href="#l30.152"></a><span id="l30.152" class="difflineminus">- </span>
<a href="#l30.153"></a><span id="l30.153" class="difflineplus">+</span>
<a href="#l30.154"></a><span id="l30.154">   PathChar* CopyString(nsIMdbHeap* ioHeap, const PathChar* inString);</span>
<a href="#l30.155"></a><span id="l30.155">   void  FreeString(nsIMdbHeap* ioHeap, PathChar* ioString);</span>
<a href="#l30.156"></a><span id="l30.156">   void  StringToYarn(const PathChar* inString, mdbYarn* outYarn);</span>
<a href="#l30.157"></a><span id="l30.157"> </span>
<a href="#l30.158"></a><span id="l30.158"> public: // other env methods</span>
<a href="#l30.159"></a><span id="l30.159"> </span>
<a href="#l30.160"></a><span id="l30.160">   morkHandleFace*  NewHandle(mork_size inSize)</span>
<a href="#l30.161"></a><span id="l30.161">   { return mEnv_HandlePool-&gt;NewHandle(this, inSize, (morkZone*) 0); }</span>
<a href="#l30.162"></a><span id="l30.162" class="difflineminus">-  </span>
<a href="#l30.163"></a><span id="l30.163" class="difflineplus">+</span>
<a href="#l30.164"></a><span id="l30.164">   void ZapHandle(morkHandleFace* ioHandle)</span>
<a href="#l30.165"></a><span id="l30.165">   { mEnv_HandlePool-&gt;ZapHandle(this, ioHandle); }</span>
<a href="#l30.166"></a><span id="l30.166"> </span>
<a href="#l30.167"></a><span id="l30.167">   void EnableAutoClear() { mEnv_AutoClear = morkAble_kEnabled; }</span>
<a href="#l30.168"></a><span id="l30.168">   void DisableAutoClear() { mEnv_AutoClear = morkAble_kDisabled; }</span>
<a href="#l30.169"></a><span id="l30.169" class="difflineminus">-  </span>
<a href="#l30.170"></a><span id="l30.170" class="difflineplus">+</span>
<a href="#l30.171"></a><span id="l30.171">   mork_bool DoAutoClear() const</span>
<a href="#l30.172"></a><span id="l30.172">   { return mEnv_AutoClear == morkAble_kEnabled; }</span>
<a href="#l30.173"></a><span id="l30.173"> </span>
<a href="#l30.174"></a><span id="l30.174">   void NewError(const char* inString);</span>
<a href="#l30.175"></a><span id="l30.175">   void NewWarning(const char* inString);</span>
<a href="#l30.176"></a><span id="l30.176"> </span>
<a href="#l30.177"></a><span id="l30.177">   void ClearMorkErrorsAndWarnings(); // clear both errors &amp; warnings</span>
<a href="#l30.178"></a><span id="l30.178">   void AutoClearMorkErrorsAndWarnings(); // clear if auto is enabled</span>
<a href="#l30.179"></a><span id="l30.179" class="difflineminus">-  </span>
<a href="#l30.180"></a><span id="l30.180" class="difflineplus">+</span>
<a href="#l30.181"></a><span id="l30.181">   void StubMethodOnlyError();</span>
<a href="#l30.182"></a><span id="l30.182">   void OutOfMemoryError();</span>
<a href="#l30.183"></a><span id="l30.183">   void NilPointerError();</span>
<a href="#l30.184"></a><span id="l30.184">   void NilPointerWarning();</span>
<a href="#l30.185"></a><span id="l30.185">   void CantMakeWhenBadError();</span>
<a href="#l30.186"></a><span id="l30.186">   void NewNonEnvError();</span>
<a href="#l30.187"></a><span id="l30.187">   void NilEnvSlotError();</span>
<a href="#l30.188"></a><span id="l30.188" class="difflineminus">-    </span>
<a href="#l30.189"></a><span id="l30.189" class="difflineplus">+</span>
<a href="#l30.190"></a><span id="l30.190">   void NonEnvTypeError(morkEnv* ev);</span>
<a href="#l30.191"></a><span id="l30.191" class="difflineminus">-  </span>
<a href="#l30.192"></a><span id="l30.192" class="difflineplus">+</span>
<a href="#l30.193"></a><span id="l30.193">   // canonical env convenience methods to check for presence of errors:</span>
<a href="#l30.194"></a><span id="l30.194">   mork_bool Good() const { return ( mEnv_ErrorCount == 0 ); }</span>
<a href="#l30.195"></a><span id="l30.195">   mork_bool Bad() const { return ( mEnv_ErrorCount != 0 ); }</span>
<a href="#l30.196"></a><span id="l30.196" class="difflineminus">-  </span>
<a href="#l30.197"></a><span id="l30.197" class="difflineplus">+</span>
<a href="#l30.198"></a><span id="l30.198">   nsIMdbEnv* AsMdbEnv() { return (nsIMdbEnv *) this; }</span>
<a href="#l30.199"></a><span id="l30.199">   static morkEnv* FromMdbEnv(nsIMdbEnv* ioEnv); // dynamic type checking</span>
<a href="#l30.200"></a><span id="l30.200"> </span>
<a href="#l30.201"></a><span id="l30.201">   nsresult AsErr() const { return mEnv_ErrorCode; }</span>
<a href="#l30.202"></a><span id="l30.202"> </span>
<a href="#l30.203"></a><span id="l30.203"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l30.204"></a><span id="l30.204">   static void SlotWeakEnv(morkEnv* me,</span>
<a href="#l30.205"></a><span id="l30.205">     morkEnv* ev, morkEnv** ioSlot)</span>
<a href="#l30.206"></a><span id="l30.206">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l30.207"></a><span id="l30.207" class="difflineminus">-  </span>
<a href="#l30.208"></a><span id="l30.208" class="difflineplus">+</span>
<a href="#l30.209"></a><span id="l30.209">   static void SlotStrongEnv(morkEnv* me,</span>
<a href="#l30.210"></a><span id="l30.210">     morkEnv* ev, morkEnv** ioSlot)</span>
<a href="#l30.211"></a><span id="l30.211">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l30.212"></a><span id="l30.212"> };</span>
<a href="#l30.213"></a><span id="l30.213"> </span>
<a href="#l30.214"></a><span id="l30.214"> #undef MOZ_ASSERT_TYPE_OK_FOR_REFCOUNTING</span>
<a href="#l30.215"></a><span id="l30.215"> #ifdef MOZ_IS_DESTRUCTIBLE</span>
<a href="#l30.216"></a><span id="l30.216"> #define MOZ_ASSERT_TYPE_OK_FOR_REFCOUNTING(X) \</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l31.1"></a><span id="l31.1" class="difflineminus">--- a/db/mork/src/morkFactory.cpp</span>
<a href="#l31.2"></a><span id="l31.2" class="difflineplus">+++ b/db/mork/src/morkFactory.cpp</span>
<a href="#l31.3"></a><span id="l31.3" class="difflineat">@@ -43,17 +43,17 @@</span>
<a href="#l31.4"></a><span id="l31.4"> #include &quot;morkThumb.h&quot;</span>
<a href="#l31.5"></a><span id="l31.5"> #endif</span>
<a href="#l31.6"></a><span id="l31.6"> </span>
<a href="#l31.7"></a><span id="l31.7"> #ifndef _MORKWRITER_</span>
<a href="#l31.8"></a><span id="l31.8"> #include &quot;morkWriter.h&quot;</span>
<a href="#l31.9"></a><span id="l31.9"> #endif</span>
<a href="#l31.10"></a><span id="l31.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l31.11"></a><span id="l31.11"> </span>
<a href="#l31.12"></a><span id="l31.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l31.13"></a><span id="l31.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l31.14"></a><span id="l31.14"> // { ===== begin morkNode interface =====</span>
<a href="#l31.15"></a><span id="l31.15"> </span>
<a href="#l31.16"></a><span id="l31.16"> /*public virtual*/ void</span>
<a href="#l31.17"></a><span id="l31.17"> morkFactory::CloseMorkNode(morkEnv* ev) /*i*/ // CloseFactory() only if open</span>
<a href="#l31.18"></a><span id="l31.18"> {</span>
<a href="#l31.19"></a><span id="l31.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l31.20"></a><span id="l31.20">   {</span>
<a href="#l31.21"></a><span id="l31.21">     this-&gt;MarkClosing();</span>
<a href="#l31.22"></a><span id="l31.22" class="difflineat">@@ -108,17 +108,17 @@ morkFactory::morkFactory(morkEnv* ev, /*</span>
<a href="#l31.23"></a><span id="l31.23">   {</span>
<a href="#l31.24"></a><span id="l31.24">     mNode_Derived = morkDerived_kFactory;</span>
<a href="#l31.25"></a><span id="l31.25">     mNode_Refs += morkFactory_kWeakRefCountBonus;</span>
<a href="#l31.26"></a><span id="l31.26">   }</span>
<a href="#l31.27"></a><span id="l31.27"> }</span>
<a href="#l31.28"></a><span id="l31.28"> </span>
<a href="#l31.29"></a><span id="l31.29"> NS_IMPL_ISUPPORTS_INHERITED(morkFactory, morkObject, nsIMdbFactory)</span>
<a href="#l31.30"></a><span id="l31.30"> </span>
<a href="#l31.31"></a><span id="l31.31" class="difflineminus">-extern &quot;C&quot; nsIMdbFactory* MakeMdbFactory() </span>
<a href="#l31.32"></a><span id="l31.32" class="difflineplus">+extern &quot;C&quot; nsIMdbFactory* MakeMdbFactory()</span>
<a href="#l31.33"></a><span id="l31.33"> {</span>
<a href="#l31.34"></a><span id="l31.34">   return new morkFactory(new orkinHeap());</span>
<a href="#l31.35"></a><span id="l31.35"> }</span>
<a href="#l31.36"></a><span id="l31.36"> </span>
<a href="#l31.37"></a><span id="l31.37"> </span>
<a href="#l31.38"></a><span id="l31.38"> /*public non-poly*/ void</span>
<a href="#l31.39"></a><span id="l31.39"> morkFactory::CloseFactory(morkEnv* ev) /*i*/ // called by CloseMorkNode();</span>
<a href="#l31.40"></a><span id="l31.40"> {</span>
<a href="#l31.41"></a><span id="l31.41" class="difflineat">@@ -128,17 +128,17 @@ morkFactory::CloseFactory(morkEnv* ev) /</span>
<a href="#l31.42"></a><span id="l31.42">       this-&gt;CloseObject(ev);</span>
<a href="#l31.43"></a><span id="l31.43">       this-&gt;MarkShut();</span>
<a href="#l31.44"></a><span id="l31.44">     }</span>
<a href="#l31.45"></a><span id="l31.45">     else</span>
<a href="#l31.46"></a><span id="l31.46">       this-&gt;NonNodeError(ev);</span>
<a href="#l31.47"></a><span id="l31.47"> }</span>
<a href="#l31.48"></a><span id="l31.48"> </span>
<a href="#l31.49"></a><span id="l31.49"> // } ===== end morkNode methods =====</span>
<a href="#l31.50"></a><span id="l31.50" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l31.51"></a><span id="l31.51" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l31.52"></a><span id="l31.52"> </span>
<a href="#l31.53"></a><span id="l31.53"> morkEnv* morkFactory::GetInternalFactoryEnv(nsresult* outErr)</span>
<a href="#l31.54"></a><span id="l31.54"> {</span>
<a href="#l31.55"></a><span id="l31.55">   morkEnv* outEnv = 0;</span>
<a href="#l31.56"></a><span id="l31.56">   if (IsNode() &amp;&amp; IsOpenNode() &amp;&amp; IsFactory() )</span>
<a href="#l31.57"></a><span id="l31.57">   {</span>
<a href="#l31.58"></a><span id="l31.58">     morkEnv* fenv = &amp;mFactory_Env;</span>
<a href="#l31.59"></a><span id="l31.59">     if ( fenv &amp;&amp; fenv-&gt;IsNode() &amp;&amp; fenv-&gt;IsOpenNode() &amp;&amp; fenv-&gt;IsEnv() )</span>
<a href="#l31.60"></a><span id="l31.60" class="difflineat">@@ -146,17 +146,17 @@ morkEnv* morkFactory::GetInternalFactory</span>
<a href="#l31.61"></a><span id="l31.61">       fenv-&gt;ClearMorkErrorsAndWarnings(); // drop any earlier errors</span>
<a href="#l31.62"></a><span id="l31.62">       outEnv = fenv;</span>
<a href="#l31.63"></a><span id="l31.63">     }</span>
<a href="#l31.64"></a><span id="l31.64">     else</span>
<a href="#l31.65"></a><span id="l31.65">       *outErr = morkEnv_kBadFactoryEnvError;</span>
<a href="#l31.66"></a><span id="l31.66">   }</span>
<a href="#l31.67"></a><span id="l31.67">   else</span>
<a href="#l31.68"></a><span id="l31.68">     *outErr = morkEnv_kBadFactoryError;</span>
<a href="#l31.69"></a><span id="l31.69" class="difflineminus">-    </span>
<a href="#l31.70"></a><span id="l31.70" class="difflineplus">+</span>
<a href="#l31.71"></a><span id="l31.71">   return outEnv;</span>
<a href="#l31.72"></a><span id="l31.72"> }</span>
<a href="#l31.73"></a><span id="l31.73"> </span>
<a href="#l31.74"></a><span id="l31.74"> </span>
<a href="#l31.75"></a><span id="l31.75"> void</span>
<a href="#l31.76"></a><span id="l31.76"> morkFactory::NonFactoryTypeError(morkEnv* ev)</span>
<a href="#l31.77"></a><span id="l31.77"> {</span>
<a href="#l31.78"></a><span id="l31.78">   ev-&gt;NewError(&quot;non morkFactory&quot;);</span>
<a href="#l31.79"></a><span id="l31.79" class="difflineat">@@ -176,25 +176,25 @@ morkFactory::OpenOldFile(nsIMdbEnv* mev,</span>
<a href="#l31.80"></a><span id="l31.80"> {</span>
<a href="#l31.81"></a><span id="l31.81">   nsresult outErr = NS_OK;</span>
<a href="#l31.82"></a><span id="l31.82">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l31.83"></a><span id="l31.83">   morkFile* file = nullptr;</span>
<a href="#l31.84"></a><span id="l31.84">   if ( ev )</span>
<a href="#l31.85"></a><span id="l31.85">   {</span>
<a href="#l31.86"></a><span id="l31.86">     if ( !ioHeap )</span>
<a href="#l31.87"></a><span id="l31.87">       ioHeap = &amp;mFactory_Heap;</span>
<a href="#l31.88"></a><span id="l31.88" class="difflineminus">-      </span>
<a href="#l31.89"></a><span id="l31.89" class="difflineplus">+</span>
<a href="#l31.90"></a><span id="l31.90">     file = morkFile::OpenOldFile(ev, ioHeap, inFilePath, inFrozen);</span>
<a href="#l31.91"></a><span id="l31.91">     NS_IF_ADDREF( file );</span>
<a href="#l31.92"></a><span id="l31.92" class="difflineminus">-      </span>
<a href="#l31.93"></a><span id="l31.93" class="difflineplus">+</span>
<a href="#l31.94"></a><span id="l31.94">     outErr = ev-&gt;AsErr();</span>
<a href="#l31.95"></a><span id="l31.95">   }</span>
<a href="#l31.96"></a><span id="l31.96">   if ( acqFile )</span>
<a href="#l31.97"></a><span id="l31.97">     *acqFile = file;</span>
<a href="#l31.98"></a><span id="l31.98" class="difflineminus">-    </span>
<a href="#l31.99"></a><span id="l31.99" class="difflineplus">+</span>
<a href="#l31.100"></a><span id="l31.100">   return outErr;</span>
<a href="#l31.101"></a><span id="l31.101"> }</span>
<a href="#l31.102"></a><span id="l31.102"> </span>
<a href="#l31.103"></a><span id="l31.103"> NS_IMETHODIMP</span>
<a href="#l31.104"></a><span id="l31.104"> morkFactory::CreateNewFile(nsIMdbEnv* mev, nsIMdbHeap* ioHeap,</span>
<a href="#l31.105"></a><span id="l31.105">   const PathChar* inFilePath, nsIMdbFile** acqFile)</span>
<a href="#l31.106"></a><span id="l31.106">   // Choose some subclass of nsIMdbFile to instantiate, in order to read</span>
<a href="#l31.107"></a><span id="l31.107">   // (and write if not frozen) the file known by inFilePath.  The file</span>
<a href="#l31.108"></a><span id="l31.108" class="difflineat">@@ -205,26 +205,26 @@ morkFactory::CreateNewFile(nsIMdbEnv* me</span>
<a href="#l31.109"></a><span id="l31.109"> {</span>
<a href="#l31.110"></a><span id="l31.110">   nsresult outErr = NS_OK;</span>
<a href="#l31.111"></a><span id="l31.111">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l31.112"></a><span id="l31.112">   morkFile* file = nullptr;</span>
<a href="#l31.113"></a><span id="l31.113">   if ( ev )</span>
<a href="#l31.114"></a><span id="l31.114">   {</span>
<a href="#l31.115"></a><span id="l31.115">     if ( !ioHeap )</span>
<a href="#l31.116"></a><span id="l31.116">       ioHeap = &amp;mFactory_Heap;</span>
<a href="#l31.117"></a><span id="l31.117" class="difflineminus">-      </span>
<a href="#l31.118"></a><span id="l31.118" class="difflineplus">+</span>
<a href="#l31.119"></a><span id="l31.119">     file = morkFile::CreateNewFile(ev, ioHeap, inFilePath);</span>
<a href="#l31.120"></a><span id="l31.120">     if ( file )</span>
<a href="#l31.121"></a><span id="l31.121">       NS_ADDREF(file);</span>
<a href="#l31.122"></a><span id="l31.122" class="difflineminus">-      </span>
<a href="#l31.123"></a><span id="l31.123" class="difflineplus">+</span>
<a href="#l31.124"></a><span id="l31.124">     outErr = ev-&gt;AsErr();</span>
<a href="#l31.125"></a><span id="l31.125">   }</span>
<a href="#l31.126"></a><span id="l31.126">   if ( acqFile )</span>
<a href="#l31.127"></a><span id="l31.127">     *acqFile = file;</span>
<a href="#l31.128"></a><span id="l31.128" class="difflineminus">-    </span>
<a href="#l31.129"></a><span id="l31.129" class="difflineplus">+</span>
<a href="#l31.130"></a><span id="l31.130">   return outErr;</span>
<a href="#l31.131"></a><span id="l31.131"> }</span>
<a href="#l31.132"></a><span id="l31.132"> // } ----- end file methods -----</span>
<a href="#l31.133"></a><span id="l31.133"> </span>
<a href="#l31.134"></a><span id="l31.134"> // { ----- begin env methods -----</span>
<a href="#l31.135"></a><span id="l31.135"> NS_IMETHODIMP</span>
<a href="#l31.136"></a><span id="l31.136"> morkFactory::MakeEnv(nsIMdbHeap* ioHeap, nsIMdbEnv** acqEnv)</span>
<a href="#l31.137"></a><span id="l31.137"> // ioHeap can be nil, causing a MakeHeap() style heap instance to be used</span>
<a href="#l31.138"></a><span id="l31.138" class="difflineat">@@ -249,22 +249,22 @@ morkFactory::MakeEnv(nsIMdbHeap* ioHeap,</span>
<a href="#l31.139"></a><span id="l31.139">         newEnv-&gt;mNode_Refs += morkEnv_kWeakRefCountEnvBonus;</span>
<a href="#l31.140"></a><span id="l31.140">         NS_ADDREF(newEnv);</span>
<a href="#l31.141"></a><span id="l31.141">         newEnv-&gt;mEnv_SelfAsMdbEnv = newEnv;</span>
<a href="#l31.142"></a><span id="l31.142">         outEnv = newEnv;</span>
<a href="#l31.143"></a><span id="l31.143">       }</span>
<a href="#l31.144"></a><span id="l31.144">       else</span>
<a href="#l31.145"></a><span id="l31.145">         outErr = morkEnv_kOutOfMemoryError;</span>
<a href="#l31.146"></a><span id="l31.146">     }</span>
<a href="#l31.147"></a><span id="l31.147" class="difflineminus">-    </span>
<a href="#l31.148"></a><span id="l31.148" class="difflineplus">+</span>
<a href="#l31.149"></a><span id="l31.149">     *acqEnv = outEnv;</span>
<a href="#l31.150"></a><span id="l31.150">   }</span>
<a href="#l31.151"></a><span id="l31.151">   else</span>
<a href="#l31.152"></a><span id="l31.152">     outErr = morkEnv_kNilPointerError;</span>
<a href="#l31.153"></a><span id="l31.153" class="difflineminus">-    </span>
<a href="#l31.154"></a><span id="l31.154" class="difflineplus">+</span>
<a href="#l31.155"></a><span id="l31.155">   return outErr;</span>
<a href="#l31.156"></a><span id="l31.156"> }</span>
<a href="#l31.157"></a><span id="l31.157"> // } ----- end env methods -----</span>
<a href="#l31.158"></a><span id="l31.158"> </span>
<a href="#l31.159"></a><span id="l31.159"> // { ----- begin heap methods -----</span>
<a href="#l31.160"></a><span id="l31.160"> NS_IMETHODIMP</span>
<a href="#l31.161"></a><span id="l31.161"> morkFactory::MakeHeap(nsIMdbEnv* mev, nsIMdbHeap** acqHeap)</span>
<a href="#l31.162"></a><span id="l31.162"> {</span>
<a href="#l31.163"></a><span id="l31.163" class="difflineat">@@ -315,26 +315,26 @@ morkFactory::CanOpenFilePort(</span>
<a href="#l31.164"></a><span id="l31.164">   if ( ev )</span>
<a href="#l31.165"></a><span id="l31.165">   {</span>
<a href="#l31.166"></a><span id="l31.166">     if ( ioFile &amp;&amp; outCanOpen )</span>
<a href="#l31.167"></a><span id="l31.167">     {</span>
<a href="#l31.168"></a><span id="l31.168">       canOpenAsPort = this-&gt;CanOpenMorkTextFile(ev, ioFile);</span>
<a href="#l31.169"></a><span id="l31.169">     }</span>
<a href="#l31.170"></a><span id="l31.170">     else</span>
<a href="#l31.171"></a><span id="l31.171">       ev-&gt;NilPointerError();</span>
<a href="#l31.172"></a><span id="l31.172" class="difflineminus">-    </span>
<a href="#l31.173"></a><span id="l31.173" class="difflineplus">+</span>
<a href="#l31.174"></a><span id="l31.174">     outErr = ev-&gt;AsErr();</span>
<a href="#l31.175"></a><span id="l31.175">   }</span>
<a href="#l31.176"></a><span id="l31.176" class="difflineminus">-    </span>
<a href="#l31.177"></a><span id="l31.177" class="difflineplus">+</span>
<a href="#l31.178"></a><span id="l31.178">   if ( outCanOpen )</span>
<a href="#l31.179"></a><span id="l31.179">     *outCanOpen = canOpenAsPort;</span>
<a href="#l31.180"></a><span id="l31.180" class="difflineminus">-    </span>
<a href="#l31.181"></a><span id="l31.181" class="difflineplus">+</span>
<a href="#l31.182"></a><span id="l31.182">   return outErr;</span>
<a href="#l31.183"></a><span id="l31.183"> }</span>
<a href="#l31.184"></a><span id="l31.184" class="difflineminus">-  </span>
<a href="#l31.185"></a><span id="l31.185" class="difflineplus">+</span>
<a href="#l31.186"></a><span id="l31.186"> NS_IMETHODIMP</span>
<a href="#l31.187"></a><span id="l31.187"> morkFactory::OpenFilePort(</span>
<a href="#l31.188"></a><span id="l31.188">   nsIMdbEnv* mev, // context</span>
<a href="#l31.189"></a><span id="l31.189">   nsIMdbHeap* ioHeap, // can be nil to cause ev's heap attribute to be used</span>
<a href="#l31.190"></a><span id="l31.190">   // const char* inFilePath, // the file to open for readonly import</span>
<a href="#l31.191"></a><span id="l31.191">   nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l31.192"></a><span id="l31.192">   const mdbOpenPolicy* inOpenPolicy, // runtime policies for using db</span>
<a href="#l31.193"></a><span id="l31.193">   nsIMdbThumb** acqThumb)</span>
<a href="#l31.194"></a><span id="l31.194" class="difflineat">@@ -346,17 +346,17 @@ morkFactory::OpenFilePort(</span>
<a href="#l31.195"></a><span id="l31.195">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l31.196"></a><span id="l31.196">    if ( ev )</span>
<a href="#l31.197"></a><span id="l31.197">   {</span>
<a href="#l31.198"></a><span id="l31.198">     if ( ioFile &amp;&amp; inOpenPolicy &amp;&amp; acqThumb )</span>
<a href="#l31.199"></a><span id="l31.199">     {</span>
<a href="#l31.200"></a><span id="l31.200">     }</span>
<a href="#l31.201"></a><span id="l31.201">     else</span>
<a href="#l31.202"></a><span id="l31.202">       ev-&gt;NilPointerError();</span>
<a href="#l31.203"></a><span id="l31.203" class="difflineminus">-    </span>
<a href="#l31.204"></a><span id="l31.204" class="difflineplus">+</span>
<a href="#l31.205"></a><span id="l31.205">     outErr = ev-&gt;AsErr();</span>
<a href="#l31.206"></a><span id="l31.206">   }</span>
<a href="#l31.207"></a><span id="l31.207">   if ( acqThumb )</span>
<a href="#l31.208"></a><span id="l31.208">     *acqThumb = outThumb;</span>
<a href="#l31.209"></a><span id="l31.209">   return outErr;</span>
<a href="#l31.210"></a><span id="l31.210"> }</span>
<a href="#l31.211"></a><span id="l31.211"> // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l31.212"></a><span id="l31.212"> // then call nsIMdbFactory::ThumbToOpenPort() to get the port instance.</span>
<a href="#l31.213"></a><span id="l31.213" class="difflineat">@@ -376,58 +376,58 @@ morkFactory::ThumbToOpenPort( // redeemi</span>
<a href="#l31.214"></a><span id="l31.214">     {</span>
<a href="#l31.215"></a><span id="l31.215">       morkThumb* thumb = (morkThumb*) ioThumb;</span>
<a href="#l31.216"></a><span id="l31.216">       morkStore* store = thumb-&gt;ThumbToOpenStore(ev);</span>
<a href="#l31.217"></a><span id="l31.217">       if ( store )</span>
<a href="#l31.218"></a><span id="l31.218">       {</span>
<a href="#l31.219"></a><span id="l31.219">         store-&gt;mStore_CanAutoAssignAtomIdentity = morkBool_kTrue;</span>
<a href="#l31.220"></a><span id="l31.220">         store-&gt;mStore_CanDirty = morkBool_kTrue;</span>
<a href="#l31.221"></a><span id="l31.221">         store-&gt;SetStoreAndAllSpacesCanDirty(ev, morkBool_kTrue);</span>
<a href="#l31.222"></a><span id="l31.222" class="difflineminus">-        </span>
<a href="#l31.223"></a><span id="l31.223" class="difflineplus">+</span>
<a href="#l31.224"></a><span id="l31.224">         NS_ADDREF(store);</span>
<a href="#l31.225"></a><span id="l31.225">         outPort = store;</span>
<a href="#l31.226"></a><span id="l31.226">       }</span>
<a href="#l31.227"></a><span id="l31.227">     }</span>
<a href="#l31.228"></a><span id="l31.228">     else</span>
<a href="#l31.229"></a><span id="l31.229">       ev-&gt;NilPointerError();</span>
<a href="#l31.230"></a><span id="l31.230" class="difflineminus">-    </span>
<a href="#l31.231"></a><span id="l31.231" class="difflineplus">+</span>
<a href="#l31.232"></a><span id="l31.232">     outErr = ev-&gt;AsErr();</span>
<a href="#l31.233"></a><span id="l31.233">   }</span>
<a href="#l31.234"></a><span id="l31.234">   if ( acqPort )</span>
<a href="#l31.235"></a><span id="l31.235">     *acqPort = outPort;</span>
<a href="#l31.236"></a><span id="l31.236">   return outErr;</span>
<a href="#l31.237"></a><span id="l31.237"> }</span>
<a href="#l31.238"></a><span id="l31.238"> // } ----- end port methods -----</span>
<a href="#l31.239"></a><span id="l31.239"> </span>
<a href="#l31.240"></a><span id="l31.240"> mork_bool</span>
<a href="#l31.241"></a><span id="l31.241"> morkFactory::CanOpenMorkTextFile(morkEnv* ev,</span>
<a href="#l31.242"></a><span id="l31.242">   // const mdbYarn* inFirst512Bytes,</span>
<a href="#l31.243"></a><span id="l31.243">   nsIMdbFile* ioFile)</span>
<a href="#l31.244"></a><span id="l31.244"> {</span>
<a href="#l31.245"></a><span id="l31.245">   MORK_USED_1(ev);</span>
<a href="#l31.246"></a><span id="l31.246">   mork_bool outBool = morkBool_kFalse;</span>
<a href="#l31.247"></a><span id="l31.247">   mork_size headSize = strlen(morkWriter_kFileHeader);</span>
<a href="#l31.248"></a><span id="l31.248" class="difflineminus">-  </span>
<a href="#l31.249"></a><span id="l31.249" class="difflineplus">+</span>
<a href="#l31.250"></a><span id="l31.250">   char localBuf[ 256 + 4 ]; // for extra for sloppy safety</span>
<a href="#l31.251"></a><span id="l31.251">   mdbYarn localYarn;</span>
<a href="#l31.252"></a><span id="l31.252">   mdbYarn* y = &amp;localYarn;</span>
<a href="#l31.253"></a><span id="l31.253">   y-&gt;mYarn_Buf = localBuf; // space to hold content</span>
<a href="#l31.254"></a><span id="l31.254">   y-&gt;mYarn_Fill = 0;       // no logical content yet</span>
<a href="#l31.255"></a><span id="l31.255">   y-&gt;mYarn_Size = 256;     // physical capacity is 256 bytes</span>
<a href="#l31.256"></a><span id="l31.256">   y-&gt;mYarn_More = 0;</span>
<a href="#l31.257"></a><span id="l31.257">   y-&gt;mYarn_Form = 0;</span>
<a href="#l31.258"></a><span id="l31.258">   y-&gt;mYarn_Grow = 0;</span>
<a href="#l31.259"></a><span id="l31.259" class="difflineminus">-  </span>
<a href="#l31.260"></a><span id="l31.260" class="difflineplus">+</span>
<a href="#l31.261"></a><span id="l31.261">   if ( ioFile )</span>
<a href="#l31.262"></a><span id="l31.262">   {</span>
<a href="#l31.263"></a><span id="l31.263">     nsIMdbEnv* menv = ev-&gt;AsMdbEnv();</span>
<a href="#l31.264"></a><span id="l31.264">     mdb_size actualSize = 0;</span>
<a href="#l31.265"></a><span id="l31.265">     ioFile-&gt;Get(menv, y-&gt;mYarn_Buf, y-&gt;mYarn_Size, /*pos*/ 0, &amp;actualSize);</span>
<a href="#l31.266"></a><span id="l31.266">     y-&gt;mYarn_Fill = actualSize;</span>
<a href="#l31.267"></a><span id="l31.267" class="difflineminus">-    </span>
<a href="#l31.268"></a><span id="l31.268" class="difflineplus">+</span>
<a href="#l31.269"></a><span id="l31.269">     if ( y-&gt;mYarn_Buf &amp;&amp; actualSize &gt;= headSize &amp;&amp; ev-&gt;Good() )</span>
<a href="#l31.270"></a><span id="l31.270">     {</span>
<a href="#l31.271"></a><span id="l31.271">       mork_u1* buf = (mork_u1*) y-&gt;mYarn_Buf;</span>
<a href="#l31.272"></a><span id="l31.272">       outBool = ( MORK_MEMCMP(morkWriter_kFileHeader, buf, headSize) == 0 );</span>
<a href="#l31.273"></a><span id="l31.273">     }</span>
<a href="#l31.274"></a><span id="l31.274">   }</span>
<a href="#l31.275"></a><span id="l31.275">   else</span>
<a href="#l31.276"></a><span id="l31.276">     ev-&gt;NilPointerError();</span>
<a href="#l31.277"></a><span id="l31.277" class="difflineat">@@ -459,50 +459,50 @@ morkFactory::CanOpenFileStore(</span>
<a href="#l31.278"></a><span id="l31.278">     if ( ioFile &amp;&amp; outCanOpenAsStore )</span>
<a href="#l31.279"></a><span id="l31.279">     {</span>
<a href="#l31.280"></a><span id="l31.280">       // right now always say true; later we should look for magic patterns</span>
<a href="#l31.281"></a><span id="l31.281">       canOpenAsStore = this-&gt;CanOpenMorkTextFile(ev, ioFile);</span>
<a href="#l31.282"></a><span id="l31.282">       canOpenAsPort = canOpenAsStore;</span>
<a href="#l31.283"></a><span id="l31.283">     }</span>
<a href="#l31.284"></a><span id="l31.284">     else</span>
<a href="#l31.285"></a><span id="l31.285">       ev-&gt;NilPointerError();</span>
<a href="#l31.286"></a><span id="l31.286" class="difflineminus">-    </span>
<a href="#l31.287"></a><span id="l31.287" class="difflineplus">+</span>
<a href="#l31.288"></a><span id="l31.288">     outErr = ev-&gt;AsErr();</span>
<a href="#l31.289"></a><span id="l31.289">   }</span>
<a href="#l31.290"></a><span id="l31.290">   if ( outCanOpenAsStore )</span>
<a href="#l31.291"></a><span id="l31.291">     *outCanOpenAsStore = canOpenAsStore;</span>
<a href="#l31.292"></a><span id="l31.292" class="difflineminus">-    </span>
<a href="#l31.293"></a><span id="l31.293" class="difflineplus">+</span>
<a href="#l31.294"></a><span id="l31.294">   if ( outCanOpenAsPort )</span>
<a href="#l31.295"></a><span id="l31.295">     *outCanOpenAsPort = canOpenAsPort;</span>
<a href="#l31.296"></a><span id="l31.296" class="difflineminus">-    </span>
<a href="#l31.297"></a><span id="l31.297" class="difflineplus">+</span>
<a href="#l31.298"></a><span id="l31.298">   return outErr;</span>
<a href="#l31.299"></a><span id="l31.299"> }</span>
<a href="#l31.300"></a><span id="l31.300" class="difflineminus">-  </span>
<a href="#l31.301"></a><span id="l31.301" class="difflineplus">+</span>
<a href="#l31.302"></a><span id="l31.302"> NS_IMETHODIMP</span>
<a href="#l31.303"></a><span id="l31.303"> morkFactory::OpenFileStore( // open an existing database</span>
<a href="#l31.304"></a><span id="l31.304">   nsIMdbEnv* mev, // context</span>
<a href="#l31.305"></a><span id="l31.305">   nsIMdbHeap* ioHeap, // can be nil to cause ev's heap attribute to be used</span>
<a href="#l31.306"></a><span id="l31.306">   // const char* inFilePath, // the file to open for general db usage</span>
<a href="#l31.307"></a><span id="l31.307">   nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l31.308"></a><span id="l31.308">   const mdbOpenPolicy* inOpenPolicy, // runtime policies for using db</span>
<a href="#l31.309"></a><span id="l31.309">   nsIMdbThumb** acqThumb)</span>
<a href="#l31.310"></a><span id="l31.310"> {</span>
<a href="#l31.311"></a><span id="l31.311">   nsresult outErr = NS_OK;</span>
<a href="#l31.312"></a><span id="l31.312">   nsIMdbThumb* outThumb = 0;</span>
<a href="#l31.313"></a><span id="l31.313">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l31.314"></a><span id="l31.314">   if ( ev )</span>
<a href="#l31.315"></a><span id="l31.315">   {</span>
<a href="#l31.316"></a><span id="l31.316">     if ( !ioHeap ) // need to use heap from env?</span>
<a href="#l31.317"></a><span id="l31.317">       ioHeap = ev-&gt;mEnv_Heap;</span>
<a href="#l31.318"></a><span id="l31.318" class="difflineminus">-    </span>
<a href="#l31.319"></a><span id="l31.319" class="difflineplus">+</span>
<a href="#l31.320"></a><span id="l31.320">     if ( ioFile &amp;&amp; inOpenPolicy &amp;&amp; acqThumb )</span>
<a href="#l31.321"></a><span id="l31.321">     {</span>
<a href="#l31.322"></a><span id="l31.322">       morkStore* store = new(*ioHeap, ev)</span>
<a href="#l31.323"></a><span id="l31.323">         morkStore(ev, morkUsage::kHeap, ioHeap, this, ioHeap);</span>
<a href="#l31.324"></a><span id="l31.324" class="difflineminus">-        </span>
<a href="#l31.325"></a><span id="l31.325" class="difflineplus">+</span>
<a href="#l31.326"></a><span id="l31.326">       if ( store )</span>
<a href="#l31.327"></a><span id="l31.327">       {</span>
<a href="#l31.328"></a><span id="l31.328">         mork_bool frozen = morkBool_kFalse; // open store mutable access</span>
<a href="#l31.329"></a><span id="l31.329">         if ( store-&gt;OpenStoreFile(ev, frozen, ioFile, inOpenPolicy) )</span>
<a href="#l31.330"></a><span id="l31.330">         {</span>
<a href="#l31.331"></a><span id="l31.331">           morkThumb* thumb = morkThumb::Make_OpenFileStore(ev, ioHeap, store);</span>
<a href="#l31.332"></a><span id="l31.332">           if ( thumb )</span>
<a href="#l31.333"></a><span id="l31.333">           {</span>
<a href="#l31.334"></a><span id="l31.334" class="difflineat">@@ -510,26 +510,26 @@ morkFactory::OpenFileStore( // open an e</span>
<a href="#l31.335"></a><span id="l31.335">             thumb-&gt;AddRef();</span>
<a href="#l31.336"></a><span id="l31.336">           }</span>
<a href="#l31.337"></a><span id="l31.337">         }</span>
<a href="#l31.338"></a><span id="l31.338"> //        store-&gt;CutStrongRef(mev); // always cut ref (handle has its own ref)</span>
<a href="#l31.339"></a><span id="l31.339">       }</span>
<a href="#l31.340"></a><span id="l31.340">     }</span>
<a href="#l31.341"></a><span id="l31.341">     else</span>
<a href="#l31.342"></a><span id="l31.342">       ev-&gt;NilPointerError();</span>
<a href="#l31.343"></a><span id="l31.343" class="difflineminus">-    </span>
<a href="#l31.344"></a><span id="l31.344" class="difflineplus">+</span>
<a href="#l31.345"></a><span id="l31.345">     outErr = ev-&gt;AsErr();</span>
<a href="#l31.346"></a><span id="l31.346">   }</span>
<a href="#l31.347"></a><span id="l31.347">   if ( acqThumb )</span>
<a href="#l31.348"></a><span id="l31.348">     *acqThumb = outThumb;</span>
<a href="#l31.349"></a><span id="l31.349">   return outErr;</span>
<a href="#l31.350"></a><span id="l31.350"> }</span>
<a href="#l31.351"></a><span id="l31.351"> // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l31.352"></a><span id="l31.352"> // then call nsIMdbFactory::ThumbToOpenStore() to get the store instance.</span>
<a href="#l31.353"></a><span id="l31.353" class="difflineminus">-  </span>
<a href="#l31.354"></a><span id="l31.354" class="difflineplus">+</span>
<a href="#l31.355"></a><span id="l31.355"> NS_IMETHODIMP</span>
<a href="#l31.356"></a><span id="l31.356"> morkFactory::ThumbToOpenStore( // redeem completed thumb from OpenFileStore()</span>
<a href="#l31.357"></a><span id="l31.357">   nsIMdbEnv* mev, // context</span>
<a href="#l31.358"></a><span id="l31.358">   nsIMdbThumb* ioThumb, // thumb from OpenFileStore() with done status</span>
<a href="#l31.359"></a><span id="l31.359">   nsIMdbStore** acqStore)</span>
<a href="#l31.360"></a><span id="l31.360"> {</span>
<a href="#l31.361"></a><span id="l31.361">   nsresult outErr = NS_OK;</span>
<a href="#l31.362"></a><span id="l31.362">   nsIMdbStore* outStore = 0;</span>
<a href="#l31.363"></a><span id="l31.363" class="difflineat">@@ -540,24 +540,24 @@ morkFactory::ThumbToOpenStore( // redeem</span>
<a href="#l31.364"></a><span id="l31.364">     {</span>
<a href="#l31.365"></a><span id="l31.365">       morkThumb* thumb = (morkThumb*) ioThumb;</span>
<a href="#l31.366"></a><span id="l31.366">       morkStore* store = thumb-&gt;ThumbToOpenStore(ev);</span>
<a href="#l31.367"></a><span id="l31.367">       if ( store )</span>
<a href="#l31.368"></a><span id="l31.368">       {</span>
<a href="#l31.369"></a><span id="l31.369">         store-&gt;mStore_CanAutoAssignAtomIdentity = morkBool_kTrue;</span>
<a href="#l31.370"></a><span id="l31.370">         store-&gt;mStore_CanDirty = morkBool_kTrue;</span>
<a href="#l31.371"></a><span id="l31.371">         store-&gt;SetStoreAndAllSpacesCanDirty(ev, morkBool_kTrue);</span>
<a href="#l31.372"></a><span id="l31.372" class="difflineminus">-        </span>
<a href="#l31.373"></a><span id="l31.373" class="difflineplus">+</span>
<a href="#l31.374"></a><span id="l31.374">         outStore = store;</span>
<a href="#l31.375"></a><span id="l31.375">         NS_ADDREF(store);</span>
<a href="#l31.376"></a><span id="l31.376">       }</span>
<a href="#l31.377"></a><span id="l31.377">     }</span>
<a href="#l31.378"></a><span id="l31.378">     else</span>
<a href="#l31.379"></a><span id="l31.379">       ev-&gt;NilPointerError();</span>
<a href="#l31.380"></a><span id="l31.380" class="difflineminus">-    </span>
<a href="#l31.381"></a><span id="l31.381" class="difflineplus">+</span>
<a href="#l31.382"></a><span id="l31.382">     outErr = ev-&gt;AsErr();</span>
<a href="#l31.383"></a><span id="l31.383">   }</span>
<a href="#l31.384"></a><span id="l31.384">   if ( acqStore )</span>
<a href="#l31.385"></a><span id="l31.385">     *acqStore = outStore;</span>
<a href="#l31.386"></a><span id="l31.386">   return outErr;</span>
<a href="#l31.387"></a><span id="l31.387"> }</span>
<a href="#l31.388"></a><span id="l31.388"> </span>
<a href="#l31.389"></a><span id="l31.389"> NS_IMETHODIMP</span>
<a href="#l31.390"></a><span id="l31.390" class="difflineat">@@ -571,36 +571,36 @@ morkFactory::CreateNewFileStore( // crea</span>
<a href="#l31.391"></a><span id="l31.391"> {</span>
<a href="#l31.392"></a><span id="l31.392">   nsresult outErr = NS_OK;</span>
<a href="#l31.393"></a><span id="l31.393">   nsIMdbStore* outStore = 0;</span>
<a href="#l31.394"></a><span id="l31.394">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l31.395"></a><span id="l31.395">   if ( ev )</span>
<a href="#l31.396"></a><span id="l31.396">   {</span>
<a href="#l31.397"></a><span id="l31.397">     if ( !ioHeap ) // need to use heap from env?</span>
<a href="#l31.398"></a><span id="l31.398">       ioHeap = ev-&gt;mEnv_Heap;</span>
<a href="#l31.399"></a><span id="l31.399" class="difflineminus">-    </span>
<a href="#l31.400"></a><span id="l31.400" class="difflineplus">+</span>
<a href="#l31.401"></a><span id="l31.401">     if ( ioFile &amp;&amp; inOpenPolicy &amp;&amp; acqStore &amp;&amp; ioHeap )</span>
<a href="#l31.402"></a><span id="l31.402">     {</span>
<a href="#l31.403"></a><span id="l31.403">       morkStore* store = new(*ioHeap, ev)</span>
<a href="#l31.404"></a><span id="l31.404">         morkStore(ev, morkUsage::kHeap, ioHeap, this, ioHeap);</span>
<a href="#l31.405"></a><span id="l31.405" class="difflineminus">-        </span>
<a href="#l31.406"></a><span id="l31.406" class="difflineplus">+</span>
<a href="#l31.407"></a><span id="l31.407">       if ( store )</span>
<a href="#l31.408"></a><span id="l31.408">       {</span>
<a href="#l31.409"></a><span id="l31.409">         store-&gt;mStore_CanAutoAssignAtomIdentity = morkBool_kTrue;</span>
<a href="#l31.410"></a><span id="l31.410">         store-&gt;mStore_CanDirty = morkBool_kTrue;</span>
<a href="#l31.411"></a><span id="l31.411">         store-&gt;SetStoreAndAllSpacesCanDirty(ev, morkBool_kTrue);</span>
<a href="#l31.412"></a><span id="l31.412"> </span>
<a href="#l31.413"></a><span id="l31.413">         if ( store-&gt;CreateStoreFile(ev, ioFile, inOpenPolicy) )</span>
<a href="#l31.414"></a><span id="l31.414">           outStore = store;</span>
<a href="#l31.415"></a><span id="l31.415" class="difflineminus">-        NS_ADDREF(store);          </span>
<a href="#l31.416"></a><span id="l31.416" class="difflineplus">+        NS_ADDREF(store);</span>
<a href="#l31.417"></a><span id="l31.417">       }</span>
<a href="#l31.418"></a><span id="l31.418">     }</span>
<a href="#l31.419"></a><span id="l31.419">     else</span>
<a href="#l31.420"></a><span id="l31.420">       ev-&gt;NilPointerError();</span>
<a href="#l31.421"></a><span id="l31.421" class="difflineminus">-    </span>
<a href="#l31.422"></a><span id="l31.422" class="difflineplus">+</span>
<a href="#l31.423"></a><span id="l31.423">     outErr = ev-&gt;AsErr();</span>
<a href="#l31.424"></a><span id="l31.424">   }</span>
<a href="#l31.425"></a><span id="l31.425">   if ( acqStore )</span>
<a href="#l31.426"></a><span id="l31.426">     *acqStore = outStore;</span>
<a href="#l31.427"></a><span id="l31.427">   return outErr;</span>
<a href="#l31.428"></a><span id="l31.428"> }</span>
<a href="#l31.429"></a><span id="l31.429"> // } ----- end store methods -----</span>
<a href="#l31.430"></a><span id="l31.430"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l32.1"></a><span id="l32.1" class="difflineminus">--- a/db/mork/src/morkFactory.h</span>
<a href="#l32.2"></a><span id="l32.2" class="difflineplus">+++ b/db/mork/src/morkFactory.h</span>
<a href="#l32.3"></a><span id="l32.3" class="difflineat">@@ -24,17 +24,17 @@</span>
<a href="#l32.4"></a><span id="l32.4"> </span>
<a href="#l32.5"></a><span id="l32.5"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l32.6"></a><span id="l32.6"> </span>
<a href="#l32.7"></a><span id="l32.7"> class nsIMdbFactory;</span>
<a href="#l32.8"></a><span id="l32.8"> </span>
<a href="#l32.9"></a><span id="l32.9"> #define morkDerived_kFactory  /*i*/ 0x4663 /* ascii 'Fc' */</span>
<a href="#l32.10"></a><span id="l32.10"> #define morkFactory_kWeakRefCountBonus 0 /* try NOT to leak all factories */</span>
<a href="#l32.11"></a><span id="l32.11"> </span>
<a href="#l32.12"></a><span id="l32.12" class="difflineminus">-/*| morkFactory: </span>
<a href="#l32.13"></a><span id="l32.13" class="difflineplus">+/*| morkFactory:</span>
<a href="#l32.14"></a><span id="l32.14"> |*/</span>
<a href="#l32.15"></a><span id="l32.15"> class morkFactory : public morkObject, public nsIMdbFactory { // nsIMdbObject</span>
<a href="#l32.16"></a><span id="l32.16">   using PathChar = mozilla::filesystem::Path::value_type;</span>
<a href="#l32.17"></a><span id="l32.17"> </span>
<a href="#l32.18"></a><span id="l32.18"> // public: // slots inherited from morkObject (meant to inform only)</span>
<a href="#l32.19"></a><span id="l32.19">   // nsIMdbHeap*     mNode_Heap;</span>
<a href="#l32.20"></a><span id="l32.20">   // mork_able    mNode_Mutable; // can this node be modified?</span>
<a href="#l32.21"></a><span id="l32.21">   // mork_load    mNode_Load;    // is this node clean or dirty?</span>
<a href="#l32.22"></a><span id="l32.22" class="difflineat">@@ -153,52 +153,52 @@ public: // morkFactory virtual methods</span>
<a href="#l32.23"></a><span id="l32.23">     nsIMdbHeap* ioHeap, // can be nil to cause ev's heap attribute to be used</span>
<a href="#l32.24"></a><span id="l32.24">     // const char* inFilePath, // name of file which should not yet exist</span>
<a href="#l32.25"></a><span id="l32.25">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l32.26"></a><span id="l32.26">     const mdbOpenPolicy* inOpenPolicy, // runtime policies for using db</span>
<a href="#l32.27"></a><span id="l32.27">     nsIMdbStore** acqStore) override; // acquire new db store object</span>
<a href="#l32.28"></a><span id="l32.28">   // } ----- end store methods -----</span>
<a href="#l32.29"></a><span id="l32.29"> </span>
<a href="#l32.30"></a><span id="l32.30"> // } ===== end nsIMdbFactory methods =====</span>
<a href="#l32.31"></a><span id="l32.31" class="difflineminus">-  </span>
<a href="#l32.32"></a><span id="l32.32" class="difflineplus">+</span>
<a href="#l32.33"></a><span id="l32.33"> public: // morkYarn construction &amp; destruction</span>
<a href="#l32.34"></a><span id="l32.34">   morkFactory(); // uses orkinHeap</span>
<a href="#l32.35"></a><span id="l32.35">   morkFactory(nsIMdbHeap* ioHeap); // caller supplied heap</span>
<a href="#l32.36"></a><span id="l32.36">   morkFactory(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap);</span>
<a href="#l32.37"></a><span id="l32.37">   void CloseFactory(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l32.38"></a><span id="l32.38" class="difflineminus">-  </span>
<a href="#l32.39"></a><span id="l32.39" class="difflineminus">-  </span>
<a href="#l32.40"></a><span id="l32.40" class="difflineplus">+</span>
<a href="#l32.41"></a><span id="l32.41" class="difflineplus">+</span>
<a href="#l32.42"></a><span id="l32.42"> public: // morkNode memory management operators</span>
<a href="#l32.43"></a><span id="l32.43">   void* operator new(size_t inSize) CPP_THROW_NEW</span>
<a href="#l32.44"></a><span id="l32.44">   { return ::operator new(inSize); }</span>
<a href="#l32.45"></a><span id="l32.45" class="difflineminus">-  </span>
<a href="#l32.46"></a><span id="l32.46" class="difflineplus">+</span>
<a href="#l32.47"></a><span id="l32.47">   void* operator new(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev) CPP_THROW_NEW</span>
<a href="#l32.48"></a><span id="l32.48">   { return morkNode::MakeNew(inSize, ioHeap, ev); }</span>
<a href="#l32.49"></a><span id="l32.49" class="difflineminus">-  </span>
<a href="#l32.50"></a><span id="l32.50" class="difflineplus">+</span>
<a href="#l32.51"></a><span id="l32.51"> private: // copying is not allowed</span>
<a href="#l32.52"></a><span id="l32.52">   morkFactory(const morkFactory&amp; other);</span>
<a href="#l32.53"></a><span id="l32.53">   morkFactory&amp; operator=(const morkFactory&amp; other);</span>
<a href="#l32.54"></a><span id="l32.54">   virtual ~morkFactory(); // assert that CloseFactory() executed earlier</span>
<a href="#l32.55"></a><span id="l32.55"> </span>
<a href="#l32.56"></a><span id="l32.56"> public: // dynamic type identification</span>
<a href="#l32.57"></a><span id="l32.57">   mork_bool IsFactory() const</span>
<a href="#l32.58"></a><span id="l32.58">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kFactory; }</span>
<a href="#l32.59"></a><span id="l32.59"> // } ===== end morkNode methods =====</span>
<a href="#l32.60"></a><span id="l32.60"> </span>
<a href="#l32.61"></a><span id="l32.61"> public: // other factory methods</span>
<a href="#l32.62"></a><span id="l32.62"> </span>
<a href="#l32.63"></a><span id="l32.63">   void NonFactoryTypeError(morkEnv* ev);</span>
<a href="#l32.64"></a><span id="l32.64">   morkEnv* GetInternalFactoryEnv(nsresult* outErr);</span>
<a href="#l32.65"></a><span id="l32.65">   mork_bool CanOpenMorkTextFile(morkEnv* ev, nsIMdbFile* ioFile);</span>
<a href="#l32.66"></a><span id="l32.66" class="difflineminus">-  </span>
<a href="#l32.67"></a><span id="l32.67" class="difflineplus">+</span>
<a href="#l32.68"></a><span id="l32.68"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l32.69"></a><span id="l32.69">   static void SlotWeakFactory(morkFactory* me,</span>
<a href="#l32.70"></a><span id="l32.70">     morkEnv* ev, morkFactory** ioSlot)</span>
<a href="#l32.71"></a><span id="l32.71">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l32.72"></a><span id="l32.72" class="difflineminus">-  </span>
<a href="#l32.73"></a><span id="l32.73" class="difflineplus">+</span>
<a href="#l32.74"></a><span id="l32.74">   static void SlotStrongFactory(morkFactory* me,</span>
<a href="#l32.75"></a><span id="l32.75">     morkEnv* ev, morkFactory** ioSlot)</span>
<a href="#l32.76"></a><span id="l32.76">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l32.77"></a><span id="l32.77"> };</span>
<a href="#l32.78"></a><span id="l32.78"> </span>
<a href="#l32.79"></a><span id="l32.79"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l32.80"></a><span id="l32.80"> </span>
<a href="#l32.81"></a><span id="l32.81"> #endif /* _MORKFACTORY_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l33.1"></a><span id="l33.1" class="difflineminus">--- a/db/mork/src/morkFile.cpp</span>
<a href="#l33.2"></a><span id="l33.2" class="difflineplus">+++ b/db/mork/src/morkFile.cpp</span>
<a href="#l33.3"></a><span id="l33.3" class="difflineat">@@ -29,17 +29,17 @@</span>
<a href="#l33.4"></a><span id="l33.4"> #endif</span>
<a href="#l33.5"></a><span id="l33.5"> </span>
<a href="#l33.6"></a><span id="l33.6"> #include &quot;mozilla/Unused.h&quot;</span>
<a href="#l33.7"></a><span id="l33.7"> #include &quot;nsString.h&quot;</span>
<a href="#l33.8"></a><span id="l33.8"> </span>
<a href="#l33.9"></a><span id="l33.9"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l33.10"></a><span id="l33.10"> </span>
<a href="#l33.11"></a><span id="l33.11"> </span>
<a href="#l33.12"></a><span id="l33.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l33.13"></a><span id="l33.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l33.14"></a><span id="l33.14"> // { ===== begin morkNode interface =====</span>
<a href="#l33.15"></a><span id="l33.15"> </span>
<a href="#l33.16"></a><span id="l33.16"> /*public virtual*/ void</span>
<a href="#l33.17"></a><span id="l33.17"> morkFile::CloseMorkNode(morkEnv* ev) // CloseFile() only if open</span>
<a href="#l33.18"></a><span id="l33.18"> {</span>
<a href="#l33.19"></a><span id="l33.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l33.20"></a><span id="l33.20">   {</span>
<a href="#l33.21"></a><span id="l33.21">     this-&gt;MarkClosing();</span>
<a href="#l33.22"></a><span id="l33.22" class="difflineat">@@ -53,17 +53,17 @@ morkFile::~morkFile() // assert CloseFil</span>
<a href="#l33.23"></a><span id="l33.23"> {</span>
<a href="#l33.24"></a><span id="l33.24">   MORK_ASSERT(mFile_Frozen==0);</span>
<a href="#l33.25"></a><span id="l33.25">   MORK_ASSERT(mFile_DoTrace==0);</span>
<a href="#l33.26"></a><span id="l33.26">   MORK_ASSERT(mFile_IoOpen==0);</span>
<a href="#l33.27"></a><span id="l33.27">   MORK_ASSERT(mFile_Active==0);</span>
<a href="#l33.28"></a><span id="l33.28"> }</span>
<a href="#l33.29"></a><span id="l33.29"> </span>
<a href="#l33.30"></a><span id="l33.30"> /*public non-poly*/</span>
<a href="#l33.31"></a><span id="l33.31" class="difflineminus">-morkFile::morkFile(morkEnv* ev, const morkUsage&amp; inUsage, </span>
<a href="#l33.32"></a><span id="l33.32" class="difflineplus">+morkFile::morkFile(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l33.33"></a><span id="l33.33">   nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap)</span>
<a href="#l33.34"></a><span id="l33.34"> : morkObject(ev, inUsage, ioHeap, morkColor_kNone, (morkHandle*) 0)</span>
<a href="#l33.35"></a><span id="l33.35"> , mFile_Frozen( 0 )</span>
<a href="#l33.36"></a><span id="l33.36"> , mFile_DoTrace( 0 )</span>
<a href="#l33.37"></a><span id="l33.37"> , mFile_IoOpen( 0 )</span>
<a href="#l33.38"></a><span id="l33.38"> , mFile_Active( 0 )</span>
<a href="#l33.39"></a><span id="l33.39"> </span>
<a href="#l33.40"></a><span id="l33.40"> , mFile_SlotHeap( 0 )</span>
<a href="#l33.41"></a><span id="l33.41" class="difflineat">@@ -88,31 +88,31 @@ NS_IMPL_ISUPPORTS_INHERITED(morkFile, mo</span>
<a href="#l33.42"></a><span id="l33.42"> morkFile::CloseFile(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l33.43"></a><span id="l33.43"> {</span>
<a href="#l33.44"></a><span id="l33.44">     if ( this-&gt;IsNode() )</span>
<a href="#l33.45"></a><span id="l33.45">     {</span>
<a href="#l33.46"></a><span id="l33.46">       mFile_Frozen = 0;</span>
<a href="#l33.47"></a><span id="l33.47">       mFile_DoTrace = 0;</span>
<a href="#l33.48"></a><span id="l33.48">       mFile_IoOpen = 0;</span>
<a href="#l33.49"></a><span id="l33.49">       mFile_Active = 0;</span>
<a href="#l33.50"></a><span id="l33.50" class="difflineminus">-      </span>
<a href="#l33.51"></a><span id="l33.51" class="difflineplus">+</span>
<a href="#l33.52"></a><span id="l33.52">       if ( mFile_Name )</span>
<a href="#l33.53"></a><span id="l33.53">         this-&gt;SetFileName(ev, nullptr);</span>
<a href="#l33.54"></a><span id="l33.54"> </span>
<a href="#l33.55"></a><span id="l33.55">       nsIMdbHeap_SlotStrongHeap((nsIMdbHeap*) 0, ev, &amp;mFile_SlotHeap);</span>
<a href="#l33.56"></a><span id="l33.56">       nsIMdbFile_SlotStrongFile((nsIMdbFile*) 0, ev, &amp;mFile_Thief);</span>
<a href="#l33.57"></a><span id="l33.57"> </span>
<a href="#l33.58"></a><span id="l33.58">       this-&gt;MarkShut();</span>
<a href="#l33.59"></a><span id="l33.59">     }</span>
<a href="#l33.60"></a><span id="l33.60">     else</span>
<a href="#l33.61"></a><span id="l33.61">       this-&gt;NonNodeError(ev);</span>
<a href="#l33.62"></a><span id="l33.62"> }</span>
<a href="#l33.63"></a><span id="l33.63"> </span>
<a href="#l33.64"></a><span id="l33.64"> // } ===== end morkNode methods =====</span>
<a href="#l33.65"></a><span id="l33.65" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l33.66"></a><span id="l33.66" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l33.67"></a><span id="l33.67"> </span>
<a href="#l33.68"></a><span id="l33.68"> /*static*/ morkFile*</span>
<a href="#l33.69"></a><span id="l33.69"> morkFile::OpenOldFile(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l33.70"></a><span id="l33.70">   const PathChar* inFilePath, mork_bool inFrozen)</span>
<a href="#l33.71"></a><span id="l33.71">   // Choose some subclass of morkFile to instantiate, in order to read</span>
<a href="#l33.72"></a><span id="l33.72">   // (and write if not frozen) the file known by inFilePath.  The file</span>
<a href="#l33.73"></a><span id="l33.73">   // returned should be open and ready for use, and presumably positioned</span>
<a href="#l33.74"></a><span id="l33.74">   // at the first byte position of the file.  The exact manner in which</span>
<a href="#l33.75"></a><span id="l33.75" class="difflineat">@@ -210,30 +210,30 @@ morkFile::NewFileDownError(morkEnv* ev) </span>
<a href="#l33.76"></a><span id="l33.76"> void</span>
<a href="#l33.77"></a><span id="l33.77"> morkFile::NewFileErrnoError(morkEnv* ev) const</span>
<a href="#l33.78"></a><span id="l33.78"> // call NewFileErrnoError() to convert std C errno into AB fault</span>
<a href="#l33.79"></a><span id="l33.79"> {</span>
<a href="#l33.80"></a><span id="l33.80">   const char* errnoString = strerror(errno);</span>
<a href="#l33.81"></a><span id="l33.81">   ev-&gt;NewError(errnoString); // maybe pass value of strerror() instead</span>
<a href="#l33.82"></a><span id="l33.82"> }</span>
<a href="#l33.83"></a><span id="l33.83"> </span>
<a href="#l33.84"></a><span id="l33.84" class="difflineminus">-// ````` ````` ````` ````` newlines ````` ````` ````` `````  </span>
<a href="#l33.85"></a><span id="l33.85" class="difflineplus">+// ````` ````` ````` ````` newlines ````` ````` ````` `````</span>
<a href="#l33.86"></a><span id="l33.86"> </span>
<a href="#l33.87"></a><span id="l33.87"> #if defined(MORK_MAC)</span>
<a href="#l33.88"></a><span id="l33.88" class="difflineminus">-       static const char morkFile_kNewlines[] = </span>
<a href="#l33.89"></a><span id="l33.89" class="difflineplus">+       static const char morkFile_kNewlines[] =</span>
<a href="#l33.90"></a><span id="l33.90">        &quot;\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015&quot;;</span>
<a href="#l33.91"></a><span id="l33.91"> #      define morkFile_kNewlinesCount 16</span>
<a href="#l33.92"></a><span id="l33.92"> #else</span>
<a href="#l33.93"></a><span id="l33.93"> #  if defined(MORK_WIN)</span>
<a href="#l33.94"></a><span id="l33.94" class="difflineminus">-       static const char morkFile_kNewlines[] = </span>
<a href="#l33.95"></a><span id="l33.95" class="difflineplus">+       static const char morkFile_kNewlines[] =</span>
<a href="#l33.96"></a><span id="l33.96">        &quot;\015\012\015\012\015\012\015\012\015\012\015\012\015\012\015\012&quot;;</span>
<a href="#l33.97"></a><span id="l33.97"> #    define morkFile_kNewlinesCount 8</span>
<a href="#l33.98"></a><span id="l33.98"> #  else</span>
<a href="#l33.99"></a><span id="l33.99"> #    ifdef MORK_UNIX</span>
<a href="#l33.100"></a><span id="l33.100" class="difflineminus">-       static const char morkFile_kNewlines[] = </span>
<a href="#l33.101"></a><span id="l33.101" class="difflineplus">+       static const char morkFile_kNewlines[] =</span>
<a href="#l33.102"></a><span id="l33.102">        &quot;\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012&quot;;</span>
<a href="#l33.103"></a><span id="l33.103"> #      define morkFile_kNewlinesCount 16</span>
<a href="#l33.104"></a><span id="l33.104"> #    endif /* MORK_UNIX */</span>
<a href="#l33.105"></a><span id="l33.105"> #  endif /* MORK_WIN */</span>
<a href="#l33.106"></a><span id="l33.106"> #endif /* MORK_MAC */</span>
<a href="#l33.107"></a><span id="l33.107"> </span>
<a href="#l33.108"></a><span id="l33.108"> mork_size</span>
<a href="#l33.109"></a><span id="l33.109"> morkFile::WriteNewlines(morkEnv* ev, mork_count inNewlines)</span>
<a href="#l33.110"></a><span id="l33.110" class="difflineat">@@ -315,17 +315,17 @@ morkFile::Path(nsIMdbEnv* mev, mdbYarn* </span>
<a href="#l33.111"></a><span id="l33.111">   {</span>
<a href="#l33.112"></a><span id="l33.112">     ev-&gt;StringToYarn(GetFileNameString(), outFilePath);</span>
<a href="#l33.113"></a><span id="l33.113">     outErr = ev-&gt;AsErr();</span>
<a href="#l33.114"></a><span id="l33.114">   }</span>
<a href="#l33.115"></a><span id="l33.115">   return outErr;</span>
<a href="#l33.116"></a><span id="l33.116"> }</span>
<a href="#l33.117"></a><span id="l33.117"> </span>
<a href="#l33.118"></a><span id="l33.118"> // } ----- end path methods -----</span>
<a href="#l33.119"></a><span id="l33.119" class="difflineminus">-  </span>
<a href="#l33.120"></a><span id="l33.120" class="difflineplus">+</span>
<a href="#l33.121"></a><span id="l33.121"> // { ----- begin replacement methods -----</span>
<a href="#l33.122"></a><span id="l33.122"> </span>
<a href="#l33.123"></a><span id="l33.123"> </span>
<a href="#l33.124"></a><span id="l33.124"> NS_IMETHODIMP</span>
<a href="#l33.125"></a><span id="l33.125"> morkFile::Thief(nsIMdbEnv* mev, nsIMdbFile** acqThief)</span>
<a href="#l33.126"></a><span id="l33.126"> {</span>
<a href="#l33.127"></a><span id="l33.127">   nsresult outErr = NS_OK;</span>
<a href="#l33.128"></a><span id="l33.128">   nsIMdbFile* outThief = 0;</span>
<a href="#l33.129"></a><span id="l33.129" class="difflineat">@@ -340,17 +340,17 @@ morkFile::Thief(nsIMdbEnv* mev, nsIMdbFi</span>
<a href="#l33.130"></a><span id="l33.130">     *acqThief = outThief;</span>
<a href="#l33.131"></a><span id="l33.131">   return outErr;</span>
<a href="#l33.132"></a><span id="l33.132"> }</span>
<a href="#l33.133"></a><span id="l33.133"> </span>
<a href="#l33.134"></a><span id="l33.134"> // } ----- end replacement methods -----</span>
<a href="#l33.135"></a><span id="l33.135"> </span>
<a href="#l33.136"></a><span id="l33.136"> // { ----- begin versioning methods -----</span>
<a href="#l33.137"></a><span id="l33.137"> </span>
<a href="#l33.138"></a><span id="l33.138" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l33.139"></a><span id="l33.139" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l33.140"></a><span id="l33.140"> // { ===== begin morkNode interface =====</span>
<a href="#l33.141"></a><span id="l33.141"> </span>
<a href="#l33.142"></a><span id="l33.142"> /*public virtual*/ void</span>
<a href="#l33.143"></a><span id="l33.143"> morkStdioFile::CloseMorkNode(morkEnv* ev) // CloseStdioFile() only if open</span>
<a href="#l33.144"></a><span id="l33.144"> {</span>
<a href="#l33.145"></a><span id="l33.145">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l33.146"></a><span id="l33.146">   {</span>
<a href="#l33.147"></a><span id="l33.147">     this-&gt;MarkClosing();</span>
<a href="#l33.148"></a><span id="l33.148" class="difflineat">@@ -371,63 +371,63 @@ morkStdioFile::~morkStdioFile() // asser</span>
<a href="#l33.149"></a><span id="l33.149"> morkStdioFile::CloseStdioFile(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l33.150"></a><span id="l33.150"> {</span>
<a href="#l33.151"></a><span id="l33.151">     if ( this-&gt;IsNode() )</span>
<a href="#l33.152"></a><span id="l33.152">     {</span>
<a href="#l33.153"></a><span id="l33.153">       if ( mStdioFile_File &amp;&amp; this-&gt;FileActive() &amp;&amp; this-&gt;FileIoOpen() )</span>
<a href="#l33.154"></a><span id="l33.154">       {</span>
<a href="#l33.155"></a><span id="l33.155">         this-&gt;CloseStdio(ev);</span>
<a href="#l33.156"></a><span id="l33.156">       }</span>
<a href="#l33.157"></a><span id="l33.157" class="difflineminus">-      </span>
<a href="#l33.158"></a><span id="l33.158" class="difflineplus">+</span>
<a href="#l33.159"></a><span id="l33.159">       mStdioFile_File = 0;</span>
<a href="#l33.160"></a><span id="l33.160" class="difflineminus">-      </span>
<a href="#l33.161"></a><span id="l33.161" class="difflineplus">+</span>
<a href="#l33.162"></a><span id="l33.162">       this-&gt;CloseFile(ev);</span>
<a href="#l33.163"></a><span id="l33.163">       this-&gt;MarkShut();</span>
<a href="#l33.164"></a><span id="l33.164">     }</span>
<a href="#l33.165"></a><span id="l33.165">     else</span>
<a href="#l33.166"></a><span id="l33.166">       this-&gt;NonNodeError(ev);</span>
<a href="#l33.167"></a><span id="l33.167"> }</span>
<a href="#l33.168"></a><span id="l33.168"> </span>
<a href="#l33.169"></a><span id="l33.169"> // } ===== end morkNode methods =====</span>
<a href="#l33.170"></a><span id="l33.170" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l33.171"></a><span id="l33.171" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l33.172"></a><span id="l33.172"> </span>
<a href="#l33.173"></a><span id="l33.173"> // compatible with the morkFile::MakeFile() entry point</span>
<a href="#l33.174"></a><span id="l33.174"> </span>
<a href="#l33.175"></a><span id="l33.175" class="difflineminus">-/*static*/ morkStdioFile* </span>
<a href="#l33.176"></a><span id="l33.176" class="difflineplus">+/*static*/ morkStdioFile*</span>
<a href="#l33.177"></a><span id="l33.177"> morkStdioFile::OpenOldStdioFile(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l33.178"></a><span id="l33.178">   const PathChar* inFilePath, mork_bool inFrozen)</span>
<a href="#l33.179"></a><span id="l33.179"> {</span>
<a href="#l33.180"></a><span id="l33.180">   morkStdioFile* outFile = 0;</span>
<a href="#l33.181"></a><span id="l33.181">   if ( ioHeap &amp;&amp; inFilePath )</span>
<a href="#l33.182"></a><span id="l33.182">   {</span>
<a href="#l33.183"></a><span id="l33.183">     const char* mode = (inFrozen)? &quot;rb&quot; : &quot;rb+&quot;;</span>
<a href="#l33.184"></a><span id="l33.184">     outFile = new(*ioHeap, ev)</span>
<a href="#l33.185"></a><span id="l33.185" class="difflineminus">-      morkStdioFile(ev, morkUsage::kHeap, ioHeap, ioHeap, inFilePath, mode); </span>
<a href="#l33.186"></a><span id="l33.186" class="difflineminus">-      </span>
<a href="#l33.187"></a><span id="l33.187" class="difflineplus">+      morkStdioFile(ev, morkUsage::kHeap, ioHeap, ioHeap, inFilePath, mode);</span>
<a href="#l33.188"></a><span id="l33.188" class="difflineplus">+</span>
<a href="#l33.189"></a><span id="l33.189">     if ( outFile )</span>
<a href="#l33.190"></a><span id="l33.190">     {</span>
<a href="#l33.191"></a><span id="l33.191">       outFile-&gt;SetFileFrozen(inFrozen);</span>
<a href="#l33.192"></a><span id="l33.192">     }</span>
<a href="#l33.193"></a><span id="l33.193">   }</span>
<a href="#l33.194"></a><span id="l33.194">   else</span>
<a href="#l33.195"></a><span id="l33.195">     ev-&gt;NilPointerError();</span>
<a href="#l33.196"></a><span id="l33.196" class="difflineminus">-  </span>
<a href="#l33.197"></a><span id="l33.197" class="difflineplus">+</span>
<a href="#l33.198"></a><span id="l33.198">   return outFile;</span>
<a href="#l33.199"></a><span id="l33.199"> }</span>
<a href="#l33.200"></a><span id="l33.200"> </span>
<a href="#l33.201"></a><span id="l33.201" class="difflineminus">-/*static*/ morkStdioFile* </span>
<a href="#l33.202"></a><span id="l33.202" class="difflineplus">+/*static*/ morkStdioFile*</span>
<a href="#l33.203"></a><span id="l33.203"> morkStdioFile::CreateNewStdioFile(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l33.204"></a><span id="l33.204">   const PathChar* inFilePath)</span>
<a href="#l33.205"></a><span id="l33.205"> {</span>
<a href="#l33.206"></a><span id="l33.206">   morkStdioFile* outFile = 0;</span>
<a href="#l33.207"></a><span id="l33.207">   if ( ioHeap &amp;&amp; inFilePath )</span>
<a href="#l33.208"></a><span id="l33.208">   {</span>
<a href="#l33.209"></a><span id="l33.209">     const char* mode = &quot;wb+&quot;;</span>
<a href="#l33.210"></a><span id="l33.210">     outFile = new(*ioHeap, ev)</span>
<a href="#l33.211"></a><span id="l33.211" class="difflineminus">-      morkStdioFile(ev, morkUsage::kHeap, ioHeap, ioHeap, inFilePath, mode); </span>
<a href="#l33.212"></a><span id="l33.212" class="difflineplus">+      morkStdioFile(ev, morkUsage::kHeap, ioHeap, ioHeap, inFilePath, mode);</span>
<a href="#l33.213"></a><span id="l33.213">   }</span>
<a href="#l33.214"></a><span id="l33.214">   else</span>
<a href="#l33.215"></a><span id="l33.215">     ev-&gt;NilPointerError();</span>
<a href="#l33.216"></a><span id="l33.216"> </span>
<a href="#l33.217"></a><span id="l33.217">   return outFile;</span>
<a href="#l33.218"></a><span id="l33.218"> }</span>
<a href="#l33.219"></a><span id="l33.219"> </span>
<a href="#l33.220"></a><span id="l33.220"> </span>
<a href="#l33.221"></a><span id="l33.221" class="difflineat">@@ -436,17 +436,17 @@ NS_IMETHODIMP</span>
<a href="#l33.222"></a><span id="l33.222"> morkStdioFile::BecomeTrunk(nsIMdbEnv* ev)</span>
<a href="#l33.223"></a><span id="l33.223">   // If this file is a file version branch created by calling AcquireBud(),</span>
<a href="#l33.224"></a><span id="l33.224">   // BecomeTrunk() causes this file's content to replace the original</span>
<a href="#l33.225"></a><span id="l33.225">   // file's content, typically by assuming the original file's identity.</span>
<a href="#l33.226"></a><span id="l33.226"> {</span>
<a href="#l33.227"></a><span id="l33.227">   return Flush(ev);</span>
<a href="#l33.228"></a><span id="l33.228"> }</span>
<a href="#l33.229"></a><span id="l33.229"> </span>
<a href="#l33.230"></a><span id="l33.230" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l33.231"></a><span id="l33.231" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l33.232"></a><span id="l33.232"> morkStdioFile::AcquireBud(nsIMdbEnv * mdbev, nsIMdbHeap* ioHeap, nsIMdbFile **acquiredFile)</span>
<a href="#l33.233"></a><span id="l33.233">   // AcquireBud() starts a new &quot;branch&quot; version of the file, empty of content,</span>
<a href="#l33.234"></a><span id="l33.234">   // so that a new version of the file can be written.  This new file</span>
<a href="#l33.235"></a><span id="l33.235">   // can later be told to BecomeTrunk() the original file, so the branch</span>
<a href="#l33.236"></a><span id="l33.236">   // created by budding the file will replace the original file.  Some</span>
<a href="#l33.237"></a><span id="l33.237">   // file subclasses might initially take the unsafe but expedient</span>
<a href="#l33.238"></a><span id="l33.238">   // approach of simply truncating this file down to zero length, and</span>
<a href="#l33.239"></a><span id="l33.239">   // then returning the same morkFile pointer as this, with an extra</span>
<a href="#l33.240"></a><span id="l33.240" class="difflineat">@@ -475,60 +475,60 @@ morkStdioFile::AcquireBud(nsIMdbEnv * md</span>
<a href="#l33.241"></a><span id="l33.241">       PathChar* name = mFile_Name;</span>
<a href="#l33.242"></a><span id="l33.242">       if ( name )</span>
<a href="#l33.243"></a><span id="l33.243">       {</span>
<a href="#l33.244"></a><span id="l33.244">         if ( MORK_FILECLOSE(file) &gt;= 0 )</span>
<a href="#l33.245"></a><span id="l33.245">         {</span>
<a href="#l33.246"></a><span id="l33.246">           this-&gt;SetFileActive(morkBool_kFalse);</span>
<a href="#l33.247"></a><span id="l33.247">           this-&gt;SetFileIoOpen(morkBool_kFalse);</span>
<a href="#l33.248"></a><span id="l33.248">           mStdioFile_File = 0;</span>
<a href="#l33.249"></a><span id="l33.249" class="difflineminus">-          </span>
<a href="#l33.250"></a><span id="l33.250" class="difflineplus">+</span>
<a href="#l33.251"></a><span id="l33.251">           file = MORK_FILEOPEN(name, &quot;wb+&quot;); // open for write, discarding old content</span>
<a href="#l33.252"></a><span id="l33.252">           if ( file )</span>
<a href="#l33.253"></a><span id="l33.253">           {</span>
<a href="#l33.254"></a><span id="l33.254">             mStdioFile_File = file;</span>
<a href="#l33.255"></a><span id="l33.255">             this-&gt;SetFileActive(morkBool_kTrue);</span>
<a href="#l33.256"></a><span id="l33.256">             this-&gt;SetFileIoOpen(morkBool_kTrue);</span>
<a href="#l33.257"></a><span id="l33.257">             this-&gt;SetFileFrozen(morkBool_kFalse);</span>
<a href="#l33.258"></a><span id="l33.258">           }</span>
<a href="#l33.259"></a><span id="l33.259">           else</span>
<a href="#l33.260"></a><span id="l33.260">             this-&gt;new_stdio_file_fault(ev);</span>
<a href="#l33.261"></a><span id="l33.261">         }</span>
<a href="#l33.262"></a><span id="l33.262">         else</span>
<a href="#l33.263"></a><span id="l33.263">           this-&gt;new_stdio_file_fault(ev);</span>
<a href="#l33.264"></a><span id="l33.264">       }</span>
<a href="#l33.265"></a><span id="l33.265">       else</span>
<a href="#l33.266"></a><span id="l33.266">         this-&gt;NilFileNameError(ev);</span>
<a href="#l33.267"></a><span id="l33.267" class="difflineminus">-      </span>
<a href="#l33.268"></a><span id="l33.268" class="difflineplus">+</span>
<a href="#l33.269"></a><span id="l33.269"> //#endif /*MORK_WIN*/</span>
<a href="#l33.270"></a><span id="l33.270"> </span>
<a href="#l33.271"></a><span id="l33.271">       if ( ev-&gt;Good() &amp;&amp; this-&gt;AddStrongRef(ev-&gt;AsMdbEnv()) )</span>
<a href="#l33.272"></a><span id="l33.272">       {</span>
<a href="#l33.273"></a><span id="l33.273">         outFile = this;</span>
<a href="#l33.274"></a><span id="l33.274">         AddRef();</span>
<a href="#l33.275"></a><span id="l33.275">       }</span>
<a href="#l33.276"></a><span id="l33.276">     }</span>
<a href="#l33.277"></a><span id="l33.277">     else if ( mFile_Thief )</span>
<a href="#l33.278"></a><span id="l33.278">     {</span>
<a href="#l33.279"></a><span id="l33.279">       rv = mFile_Thief-&gt;AcquireBud(ev-&gt;AsMdbEnv(), ioHeap, acquiredFile);</span>
<a href="#l33.280"></a><span id="l33.280">     }</span>
<a href="#l33.281"></a><span id="l33.281">     else</span>
<a href="#l33.282"></a><span id="l33.282">       this-&gt;NewMissingIoError(ev);</span>
<a href="#l33.283"></a><span id="l33.283">   }</span>
<a href="#l33.284"></a><span id="l33.284">   else this-&gt;NewFileDownError(ev);</span>
<a href="#l33.285"></a><span id="l33.285" class="difflineminus">-  </span>
<a href="#l33.286"></a><span id="l33.286" class="difflineplus">+</span>
<a href="#l33.287"></a><span id="l33.287">   *acquiredFile = outFile;</span>
<a href="#l33.288"></a><span id="l33.288">   return rv;</span>
<a href="#l33.289"></a><span id="l33.289"> }</span>
<a href="#l33.290"></a><span id="l33.290"> </span>
<a href="#l33.291"></a><span id="l33.291" class="difflineminus">-mork_pos </span>
<a href="#l33.292"></a><span id="l33.292" class="difflineplus">+mork_pos</span>
<a href="#l33.293"></a><span id="l33.293"> morkStdioFile::Length(morkEnv * ev) const</span>
<a href="#l33.294"></a><span id="l33.294"> {</span>
<a href="#l33.295"></a><span id="l33.295">   mork_pos outPos = 0;</span>
<a href="#l33.296"></a><span id="l33.296" class="difflineminus">-  </span>
<a href="#l33.297"></a><span id="l33.297" class="difflineplus">+</span>
<a href="#l33.298"></a><span id="l33.298">   if ( this-&gt;IsOpenAndActiveFile() )</span>
<a href="#l33.299"></a><span id="l33.299">   {</span>
<a href="#l33.300"></a><span id="l33.300">     FILE* file = (FILE*) mStdioFile_File;</span>
<a href="#l33.301"></a><span id="l33.301">     if ( file )</span>
<a href="#l33.302"></a><span id="l33.302">     {</span>
<a href="#l33.303"></a><span id="l33.303">       long start = MORK_FILETELL(file);</span>
<a href="#l33.304"></a><span id="l33.304">       if ( start &gt;= 0 )</span>
<a href="#l33.305"></a><span id="l33.305">       {</span>
<a href="#l33.306"></a><span id="l33.306" class="difflineat">@@ -559,17 +559,17 @@ morkStdioFile::Length(morkEnv * ev) cons</span>
<a href="#l33.307"></a><span id="l33.307"> </span>
<a href="#l33.308"></a><span id="l33.308">   return outPos;</span>
<a href="#l33.309"></a><span id="l33.309"> }</span>
<a href="#l33.310"></a><span id="l33.310"> </span>
<a href="#l33.311"></a><span id="l33.311"> NS_IMETHODIMP</span>
<a href="#l33.312"></a><span id="l33.312"> morkStdioFile::Tell(nsIMdbEnv* ev, mork_pos *outPos) const</span>
<a href="#l33.313"></a><span id="l33.313"> {</span>
<a href="#l33.314"></a><span id="l33.314">   nsresult rv = NS_OK;</span>
<a href="#l33.315"></a><span id="l33.315" class="difflineminus">-  NS_ENSURE_ARG(outPos);  </span>
<a href="#l33.316"></a><span id="l33.316" class="difflineplus">+  NS_ENSURE_ARG(outPos);</span>
<a href="#l33.317"></a><span id="l33.317">   morkEnv* mev = morkEnv::FromMdbEnv(ev);</span>
<a href="#l33.318"></a><span id="l33.318">   if ( this-&gt;IsOpenAndActiveFile() )</span>
<a href="#l33.319"></a><span id="l33.319">   {</span>
<a href="#l33.320"></a><span id="l33.320">     FILE* file = (FILE*) mStdioFile_File;</span>
<a href="#l33.321"></a><span id="l33.321">     if ( file )</span>
<a href="#l33.322"></a><span id="l33.322">     {</span>
<a href="#l33.323"></a><span id="l33.323">       long where = MORK_FILETELL(file);</span>
<a href="#l33.324"></a><span id="l33.324">       if ( where &gt;= 0 )</span>
<a href="#l33.325"></a><span id="l33.325" class="difflineat">@@ -609,17 +609,17 @@ morkStdioFile::Read(nsIMdbEnv* ev, void*</span>
<a href="#l33.326"></a><span id="l33.326">     else</span>
<a href="#l33.327"></a><span id="l33.327">       this-&gt;NewMissingIoError(mev);</span>
<a href="#l33.328"></a><span id="l33.328">   }</span>
<a href="#l33.329"></a><span id="l33.329">   else this-&gt;NewFileDownError(mev);</span>
<a href="#l33.330"></a><span id="l33.330"> </span>
<a href="#l33.331"></a><span id="l33.331">   return rv;</span>
<a href="#l33.332"></a><span id="l33.332"> }</span>
<a href="#l33.333"></a><span id="l33.333"> </span>
<a href="#l33.334"></a><span id="l33.334" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l33.335"></a><span id="l33.335" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l33.336"></a><span id="l33.336"> morkStdioFile::Seek(nsIMdbEnv* mdbev, mork_pos inPos, mork_pos *aOutPos)</span>
<a href="#l33.337"></a><span id="l33.337"> {</span>
<a href="#l33.338"></a><span id="l33.338">   mork_pos outPos = 0;</span>
<a href="#l33.339"></a><span id="l33.339">   nsresult rv = NS_OK;</span>
<a href="#l33.340"></a><span id="l33.340">   morkEnv *ev = morkEnv::FromMdbEnv(mdbev);</span>
<a href="#l33.341"></a><span id="l33.341"> </span>
<a href="#l33.342"></a><span id="l33.342">   if ( this-&gt;IsOpenOrClosingNode() &amp;&amp; this-&gt;FileActive() )</span>
<a href="#l33.343"></a><span id="l33.343">   {</span>
<a href="#l33.344"></a><span id="l33.344" class="difflineat">@@ -638,17 +638,17 @@ morkStdioFile::Seek(nsIMdbEnv* mdbev, mo</span>
<a href="#l33.345"></a><span id="l33.345">       this-&gt;NewMissingIoError(ev);</span>
<a href="#l33.346"></a><span id="l33.346">   }</span>
<a href="#l33.347"></a><span id="l33.347">   else this-&gt;NewFileDownError(ev);</span>
<a href="#l33.348"></a><span id="l33.348"> </span>
<a href="#l33.349"></a><span id="l33.349">   *aOutPos = outPos;</span>
<a href="#l33.350"></a><span id="l33.350">   return rv;</span>
<a href="#l33.351"></a><span id="l33.351"> }</span>
<a href="#l33.352"></a><span id="l33.352"> </span>
<a href="#l33.353"></a><span id="l33.353" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l33.354"></a><span id="l33.354" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l33.355"></a><span id="l33.355"> morkStdioFile::Write(nsIMdbEnv* mdbev, const void* inBuf, mork_size inSize, mork_size *aOutSize)</span>
<a href="#l33.356"></a><span id="l33.356"> {</span>
<a href="#l33.357"></a><span id="l33.357">   mork_num outCount = 0;</span>
<a href="#l33.358"></a><span id="l33.358">   nsresult rv = NS_OK;</span>
<a href="#l33.359"></a><span id="l33.359">   morkEnv *ev = morkEnv::FromMdbEnv(mdbev);</span>
<a href="#l33.360"></a><span id="l33.360">   if ( this-&gt;IsOpenActiveAndMutableFile() )</span>
<a href="#l33.361"></a><span id="l33.361">   {</span>
<a href="#l33.362"></a><span id="l33.362">     FILE* file = (FILE*) mStdioFile_File;</span>
<a href="#l33.363"></a><span id="l33.363" class="difflineat">@@ -687,37 +687,37 @@ morkStdioFile::Flush(nsIMdbEnv* mdbev)</span>
<a href="#l33.364"></a><span id="l33.364">       mFile_Thief-&gt;Flush(mdbev);</span>
<a href="#l33.365"></a><span id="l33.365">     else</span>
<a href="#l33.366"></a><span id="l33.366">       this-&gt;NewMissingIoError(ev);</span>
<a href="#l33.367"></a><span id="l33.367">   }</span>
<a href="#l33.368"></a><span id="l33.368">   else this-&gt;NewFileDownError(ev);</span>
<a href="#l33.369"></a><span id="l33.369">   return NS_OK;</span>
<a href="#l33.370"></a><span id="l33.370"> }</span>
<a href="#l33.371"></a><span id="l33.371"> </span>
<a href="#l33.372"></a><span id="l33.372" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l33.373"></a><span id="l33.373" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l33.374"></a><span id="l33.374"> //protected: // protected non-poly morkStdioFile methods</span>
<a href="#l33.375"></a><span id="l33.375"> </span>
<a href="#l33.376"></a><span id="l33.376"> void</span>
<a href="#l33.377"></a><span id="l33.377"> morkStdioFile::new_stdio_file_fault(morkEnv* ev) const</span>
<a href="#l33.378"></a><span id="l33.378"> {</span>
<a href="#l33.379"></a><span id="l33.379">   FILE* file = (FILE*) mStdioFile_File;</span>
<a href="#l33.380"></a><span id="l33.380"> </span>
<a href="#l33.381"></a><span id="l33.381">   int copyErrno = errno; // facilitate seeing error in debugger</span>
<a href="#l33.382"></a><span id="l33.382" class="difflineminus">-  </span>
<a href="#l33.383"></a><span id="l33.383" class="difflineplus">+</span>
<a href="#l33.384"></a><span id="l33.384">   //  bunch of stuff not ported here</span>
<a href="#l33.385"></a><span id="l33.385">   if ( !copyErrno &amp;&amp; file )</span>
<a href="#l33.386"></a><span id="l33.386">   {</span>
<a href="#l33.387"></a><span id="l33.387">     copyErrno = ferror(file);</span>
<a href="#l33.388"></a><span id="l33.388">     errno = copyErrno;</span>
<a href="#l33.389"></a><span id="l33.389">   }</span>
<a href="#l33.390"></a><span id="l33.390"> </span>
<a href="#l33.391"></a><span id="l33.391">   this-&gt;NewFileErrnoError(ev);</span>
<a href="#l33.392"></a><span id="l33.392"> }</span>
<a href="#l33.393"></a><span id="l33.393"> </span>
<a href="#l33.394"></a><span id="l33.394" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l33.395"></a><span id="l33.395" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l33.396"></a><span id="l33.396"> //public: // public non-poly morkStdioFile methods</span>
<a href="#l33.397"></a><span id="l33.397"> </span>
<a href="#l33.398"></a><span id="l33.398"> </span>
<a href="#l33.399"></a><span id="l33.399"> /*public non-poly*/</span>
<a href="#l33.400"></a><span id="l33.400"> morkStdioFile::morkStdioFile(morkEnv* ev,</span>
<a href="#l33.401"></a><span id="l33.401">   const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap)</span>
<a href="#l33.402"></a><span id="l33.402"> : morkFile(ev, inUsage, ioHeap, ioSlotHeap)</span>
<a href="#l33.403"></a><span id="l33.403"> , mStdioFile_File( 0 )</span>
<a href="#l33.404"></a><span id="l33.404" class="difflineat">@@ -751,19 +751,19 @@ morkStdioFile::morkStdioFile(morkEnv* ev</span>
<a href="#l33.405"></a><span id="l33.405"> void</span>
<a href="#l33.406"></a><span id="l33.406"> morkStdioFile::OpenStdio(morkEnv* ev, const PathChar* inName, const char* inMode)</span>
<a href="#l33.407"></a><span id="l33.407">   // Open a new FILE with name inName, using mode flags from inMode.</span>
<a href="#l33.408"></a><span id="l33.408"> {</span>
<a href="#l33.409"></a><span id="l33.409">   if ( ev-&gt;Good() )</span>
<a href="#l33.410"></a><span id="l33.410">   {</span>
<a href="#l33.411"></a><span id="l33.411">     if ( !inMode )</span>
<a href="#l33.412"></a><span id="l33.412">       inMode = &quot;&quot;;</span>
<a href="#l33.413"></a><span id="l33.413" class="difflineminus">-    </span>
<a href="#l33.414"></a><span id="l33.414" class="difflineplus">+</span>
<a href="#l33.415"></a><span id="l33.415">     mork_bool frozen = (*inMode == 'r'); // cursory attempt to note readonly</span>
<a href="#l33.416"></a><span id="l33.416" class="difflineminus">-    </span>
<a href="#l33.417"></a><span id="l33.417" class="difflineplus">+</span>
<a href="#l33.418"></a><span id="l33.418">     if ( this-&gt;IsOpenNode() )</span>
<a href="#l33.419"></a><span id="l33.419">     {</span>
<a href="#l33.420"></a><span id="l33.420">       if ( !this-&gt;FileActive() )</span>
<a href="#l33.421"></a><span id="l33.421">       {</span>
<a href="#l33.422"></a><span id="l33.422">         this-&gt;SetFileIoOpen(morkBool_kFalse);</span>
<a href="#l33.423"></a><span id="l33.423">         if ( inName &amp;&amp; *inName )</span>
<a href="#l33.424"></a><span id="l33.424">         {</span>
<a href="#l33.425"></a><span id="l33.425">           this-&gt;SetFileName(ev, inName);</span>
<a href="#l33.426"></a><span id="l33.426" class="difflineat">@@ -831,17 +831,17 @@ morkStdioFile::CloseStdio(morkEnv* ev)</span>
<a href="#l33.427"></a><span id="l33.427">   // then this method does little beyond marking the stream inactive</span>
<a href="#l33.428"></a><span id="l33.428">   // because FileIoOpen() is false.</span>
<a href="#l33.429"></a><span id="l33.429"> {</span>
<a href="#l33.430"></a><span id="l33.430">   if ( mStdioFile_File &amp;&amp; this-&gt;FileActive() &amp;&amp; this-&gt;FileIoOpen() )</span>
<a href="#l33.431"></a><span id="l33.431">   {</span>
<a href="#l33.432"></a><span id="l33.432">     FILE* file = (FILE*) mStdioFile_File;</span>
<a href="#l33.433"></a><span id="l33.433">     if ( MORK_FILECLOSE(file) &lt; 0 )</span>
<a href="#l33.434"></a><span id="l33.434">       this-&gt;new_stdio_file_fault(ev);</span>
<a href="#l33.435"></a><span id="l33.435" class="difflineminus">-    </span>
<a href="#l33.436"></a><span id="l33.436" class="difflineplus">+</span>
<a href="#l33.437"></a><span id="l33.437">     mStdioFile_File = 0;</span>
<a href="#l33.438"></a><span id="l33.438">     this-&gt;SetFileActive(morkBool_kFalse);</span>
<a href="#l33.439"></a><span id="l33.439">     this-&gt;SetFileIoOpen(morkBool_kFalse);</span>
<a href="#l33.440"></a><span id="l33.440">   }</span>
<a href="#l33.441"></a><span id="l33.441"> }</span>
<a href="#l33.442"></a><span id="l33.442"> </span>
<a href="#l33.443"></a><span id="l33.443"> </span>
<a href="#l33.444"></a><span id="l33.444"> NS_IMETHODIMP</span>
<a href="#l33.445"></a><span id="l33.445" class="difflineat">@@ -851,17 +851,17 @@ morkStdioFile::Steal(nsIMdbEnv* ev, nsIM</span>
<a href="#l33.446"></a><span id="l33.446">   // file's content, typically by assuming the original file's identity.</span>
<a href="#l33.447"></a><span id="l33.447"> {</span>
<a href="#l33.448"></a><span id="l33.448">   morkEnv *mev = morkEnv::FromMdbEnv(ev);</span>
<a href="#l33.449"></a><span id="l33.449">   if ( mStdioFile_File &amp;&amp; FileActive() &amp;&amp; FileIoOpen() )</span>
<a href="#l33.450"></a><span id="l33.450">   {</span>
<a href="#l33.451"></a><span id="l33.451">     FILE* file = (FILE*) mStdioFile_File;</span>
<a href="#l33.452"></a><span id="l33.452">     if ( MORK_FILECLOSE(file) &lt; 0 )</span>
<a href="#l33.453"></a><span id="l33.453">       new_stdio_file_fault(mev);</span>
<a href="#l33.454"></a><span id="l33.454" class="difflineminus">-    </span>
<a href="#l33.455"></a><span id="l33.455" class="difflineplus">+</span>
<a href="#l33.456"></a><span id="l33.456">     mStdioFile_File = 0;</span>
<a href="#l33.457"></a><span id="l33.457">   }</span>
<a href="#l33.458"></a><span id="l33.458">   SetThief(mev, ioThief);</span>
<a href="#l33.459"></a><span id="l33.459">   return NS_OK;</span>
<a href="#l33.460"></a><span id="l33.460"> }</span>
<a href="#l33.461"></a><span id="l33.461"> </span>
<a href="#l33.462"></a><span id="l33.462"> </span>
<a href="#l33.463"></a><span id="l33.463"> #if defined(MORK_WIN)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l34.1"></a><span id="l34.1" class="difflineminus">--- a/db/mork/src/morkFile.h</span>
<a href="#l34.2"></a><span id="l34.2" class="difflineplus">+++ b/db/mork/src/morkFile.h</span>
<a href="#l34.3"></a><span id="l34.3" class="difflineat">@@ -63,45 +63,45 @@</span>
<a href="#l34.4"></a><span id="l34.4"> class morkFile /*d*/ : public morkObject, public nsIMdbFile { /* ````` simple file API ````` */</span>
<a href="#l34.5"></a><span id="l34.5">   using PathChar = mozilla::filesystem::Path::value_type;</span>
<a href="#l34.6"></a><span id="l34.6"> </span>
<a href="#l34.7"></a><span id="l34.7"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l34.8"></a><span id="l34.8">   // nsIMdbHeap*    mNode_Heap;</span>
<a href="#l34.9"></a><span id="l34.9"> </span>
<a href="#l34.10"></a><span id="l34.10">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l34.11"></a><span id="l34.11">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l34.12"></a><span id="l34.12" class="difflineminus">-  </span>
<a href="#l34.13"></a><span id="l34.13" class="difflineplus">+</span>
<a href="#l34.14"></a><span id="l34.14">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l34.15"></a><span id="l34.15">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l34.16"></a><span id="l34.16">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l34.17"></a><span id="l34.17">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l34.18"></a><span id="l34.18" class="difflineminus">-  </span>
<a href="#l34.19"></a><span id="l34.19" class="difflineplus">+</span>
<a href="#l34.20"></a><span id="l34.20">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l34.21"></a><span id="l34.21">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l34.22"></a><span id="l34.22" class="difflineminus">-  </span>
<a href="#l34.23"></a><span id="l34.23" class="difflineplus">+</span>
<a href="#l34.24"></a><span id="l34.24"> // public: // slots inherited from morkObject (meant to inform only)</span>
<a href="#l34.25"></a><span id="l34.25"> </span>
<a href="#l34.26"></a><span id="l34.26">   // mork_color   mBead_Color;   // ID for this bead</span>
<a href="#l34.27"></a><span id="l34.27">   // morkHandle*  mObject_Handle;  // weak ref to handle for this object</span>
<a href="#l34.28"></a><span id="l34.28"> </span>
<a href="#l34.29"></a><span id="l34.29" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l34.30"></a><span id="l34.30" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l34.31"></a><span id="l34.31"> protected: // protected morkFile members (similar to public domain IronDoc)</span>
<a href="#l34.32"></a><span id="l34.32">   virtual ~morkFile(); // assert that CloseFile() executed earlier</span>
<a href="#l34.33"></a><span id="l34.33"> </span>
<a href="#l34.34"></a><span id="l34.34">   mork_u1     mFile_Frozen;   // 'F' =&gt; file allows only read access</span>
<a href="#l34.35"></a><span id="l34.35">   mork_u1     mFile_DoTrace;  // 'T' trace if ev-&gt;DoTrace()</span>
<a href="#l34.36"></a><span id="l34.36">   mork_u1     mFile_IoOpen;   // 'O' =&gt; io stream is open (&amp; needs a close)</span>
<a href="#l34.37"></a><span id="l34.37">   mork_u1     mFile_Active;   // 'A' =&gt; file is active and usable</span>
<a href="#l34.38"></a><span id="l34.38" class="difflineminus">-  </span>
<a href="#l34.39"></a><span id="l34.39" class="difflineplus">+</span>
<a href="#l34.40"></a><span id="l34.40">   nsIMdbHeap* mFile_SlotHeap; // heap for Name and other allocated slots</span>
<a href="#l34.41"></a><span id="l34.41">   PathChar*   mFile_Name; // can be nil if SetFileName() is never called</span>
<a href="#l34.42"></a><span id="l34.42">   // mFile_Name convention: managed with morkEnv::CopyString()/FreeString()</span>
<a href="#l34.43"></a><span id="l34.43"> </span>
<a href="#l34.44"></a><span id="l34.44">   nsIMdbFile* mFile_Thief; // from a call to orkinFile::Steal()</span>
<a href="#l34.45"></a><span id="l34.45" class="difflineminus">-  </span>
<a href="#l34.46"></a><span id="l34.46" class="difflineplus">+</span>
<a href="#l34.47"></a><span id="l34.47"> // { ===== begin morkNode interface =====</span>
<a href="#l34.48"></a><span id="l34.48"> public: // morkNode virtual methods</span>
<a href="#l34.49"></a><span id="l34.49">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l34.50"></a><span id="l34.50">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseFile() only if open</span>
<a href="#l34.51"></a><span id="l34.51"> </span>
<a href="#l34.52"></a><span id="l34.52"> public: // morkFile construction &amp; destruction</span>
<a href="#l34.53"></a><span id="l34.53">   morkFile(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l34.54"></a><span id="l34.54">     nsIMdbHeap* ioSlotHeap);</span>
<a href="#l34.55"></a><span id="l34.55" class="difflineat">@@ -110,18 +110,18 @@ public: // morkFile construction &amp; destr</span>
<a href="#l34.56"></a><span id="l34.56"> private: // copying is not allowed</span>
<a href="#l34.57"></a><span id="l34.57">   morkFile(const morkFile&amp; other);</span>
<a href="#l34.58"></a><span id="l34.58">   morkFile&amp; operator=(const morkFile&amp; other);</span>
<a href="#l34.59"></a><span id="l34.59"> </span>
<a href="#l34.60"></a><span id="l34.60"> public: // dynamic type identification</span>
<a href="#l34.61"></a><span id="l34.61">   mork_bool IsFile() const</span>
<a href="#l34.62"></a><span id="l34.62">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kFile; }</span>
<a href="#l34.63"></a><span id="l34.63"> // } ===== end morkNode methods =====</span>
<a href="#l34.64"></a><span id="l34.64" class="difflineminus">-    </span>
<a href="#l34.65"></a><span id="l34.65" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l34.66"></a><span id="l34.66" class="difflineplus">+</span>
<a href="#l34.67"></a><span id="l34.67" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l34.68"></a><span id="l34.68"> public: // public static standard file creation entry point</span>
<a href="#l34.69"></a><span id="l34.69"> </span>
<a href="#l34.70"></a><span id="l34.70">   static morkFile* OpenOldFile(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l34.71"></a><span id="l34.71">     const PathChar* inFilePath, mork_bool inFrozen);</span>
<a href="#l34.72"></a><span id="l34.72">   // Choose some subclass of morkFile to instantiate, in order to read</span>
<a href="#l34.73"></a><span id="l34.73">   // (and write if not frozen) the file known by inFilePath.  The file</span>
<a href="#l34.74"></a><span id="l34.74">   // returned should be open and ready for use, and presumably positioned</span>
<a href="#l34.75"></a><span id="l34.75">   // at the first byte position of the file.  The exact manner in which</span>
<a href="#l34.76"></a><span id="l34.76" class="difflineat">@@ -131,65 +131,65 @@ public: // public static standard file c</span>
<a href="#l34.77"></a><span id="l34.77">   static morkFile* CreateNewFile(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l34.78"></a><span id="l34.78">     const PathChar* inFilePath);</span>
<a href="#l34.79"></a><span id="l34.79">   // Choose some subclass of morkFile to instantiate, in order to read</span>
<a href="#l34.80"></a><span id="l34.80">   // (and write if not frozen) the file known by inFilePath.  The file</span>
<a href="#l34.81"></a><span id="l34.81">   // returned should be created and ready for use, and presumably positioned</span>
<a href="#l34.82"></a><span id="l34.82">   // at the first byte position of the file.  The exact manner in which</span>
<a href="#l34.83"></a><span id="l34.83">   // files must be opened is considered a subclass specific detail, and</span>
<a href="#l34.84"></a><span id="l34.84">   // other portions or Mork source code don't want to know how it's done.</span>
<a href="#l34.85"></a><span id="l34.85" class="difflineminus">-  </span>
<a href="#l34.86"></a><span id="l34.86" class="difflineplus">+</span>
<a href="#l34.87"></a><span id="l34.87"> public: // non-poly morkFile methods</span>
<a href="#l34.88"></a><span id="l34.88"> </span>
<a href="#l34.89"></a><span id="l34.89">   mork_bool FileFrozen() const  { return mFile_Frozen == 'F'; }</span>
<a href="#l34.90"></a><span id="l34.90">   mork_bool FileDoTrace() const { return mFile_DoTrace == 'T'; }</span>
<a href="#l34.91"></a><span id="l34.91">   mork_bool FileIoOpen() const  { return mFile_IoOpen == 'O'; }</span>
<a href="#l34.92"></a><span id="l34.92">   mork_bool FileActive() const  { return mFile_Active == 'A'; }</span>
<a href="#l34.93"></a><span id="l34.93"> </span>
<a href="#l34.94"></a><span id="l34.94">   void SetFileFrozen(mork_bool b)  { mFile_Frozen = (mork_u1) ((b)? 'F' : 0); }</span>
<a href="#l34.95"></a><span id="l34.95">   void SetFileDoTrace(mork_bool b) { mFile_DoTrace = (mork_u1) ((b)? 'T' : 0); }</span>
<a href="#l34.96"></a><span id="l34.96">   void SetFileIoOpen(mork_bool b)  { mFile_IoOpen = (mork_u1) ((b)? 'O' : 0); }</span>
<a href="#l34.97"></a><span id="l34.97">   void SetFileActive(mork_bool b)  { mFile_Active = (mork_u1) ((b)? 'A' : 0); }</span>
<a href="#l34.98"></a><span id="l34.98"> </span>
<a href="#l34.99"></a><span id="l34.99" class="difflineminus">-  </span>
<a href="#l34.100"></a><span id="l34.100" class="difflineplus">+</span>
<a href="#l34.101"></a><span id="l34.101">   mork_bool IsOpenActiveAndMutableFile() const</span>
<a href="#l34.102"></a><span id="l34.102">   { return ( IsOpenNode() &amp;&amp; FileActive() &amp;&amp; !FileFrozen() ); }</span>
<a href="#l34.103"></a><span id="l34.103">     // call IsOpenActiveAndMutableFile() before writing a file</span>
<a href="#l34.104"></a><span id="l34.104" class="difflineminus">-  </span>
<a href="#l34.105"></a><span id="l34.105" class="difflineplus">+</span>
<a href="#l34.106"></a><span id="l34.106">   mork_bool IsOpenAndActiveFile() const</span>
<a href="#l34.107"></a><span id="l34.107">   { return ( this-&gt;IsOpenNode() &amp;&amp; this-&gt;FileActive() ); }</span>
<a href="#l34.108"></a><span id="l34.108">     // call IsOpenAndActiveFile() before using a file</span>
<a href="#l34.109"></a><span id="l34.109" class="difflineminus">-    </span>
<a href="#l34.110"></a><span id="l34.110" class="difflineplus">+</span>
<a href="#l34.111"></a><span id="l34.111"> </span>
<a href="#l34.112"></a><span id="l34.112">   nsIMdbFile* GetThief() const { return mFile_Thief; }</span>
<a href="#l34.113"></a><span id="l34.113">   void SetThief(morkEnv* ev, nsIMdbFile* ioThief); // ioThief can be nil</span>
<a href="#l34.114"></a><span id="l34.114" class="difflineminus">-    </span>
<a href="#l34.115"></a><span id="l34.115" class="difflineplus">+</span>
<a href="#l34.116"></a><span id="l34.116">   const PathChar* GetFileNameString() const { return mFile_Name; }</span>
<a href="#l34.117"></a><span id="l34.117">   void SetFileName(morkEnv* ev, const PathChar* inName); // inName can be nil</span>
<a href="#l34.118"></a><span id="l34.118">   static void NilSlotHeapError(morkEnv* ev);</span>
<a href="#l34.119"></a><span id="l34.119">   static void NilFileNameError(morkEnv* ev);</span>
<a href="#l34.120"></a><span id="l34.120">   static void NonFileTypeError(morkEnv* ev);</span>
<a href="#l34.121"></a><span id="l34.121" class="difflineminus">-    </span>
<a href="#l34.122"></a><span id="l34.122" class="difflineplus">+</span>
<a href="#l34.123"></a><span id="l34.123">   void NewMissingIoError(morkEnv* ev) const;</span>
<a href="#l34.124"></a><span id="l34.124" class="difflineminus">-    </span>
<a href="#l34.125"></a><span id="l34.125" class="difflineplus">+</span>
<a href="#l34.126"></a><span id="l34.126">   void NewFileDownError(morkEnv* ev) const;</span>
<a href="#l34.127"></a><span id="l34.127">     // call NewFileDownError() when either IsOpenAndActiveFile()</span>
<a href="#l34.128"></a><span id="l34.128">     // is false, or when IsOpenActiveAndMutableFile() is false.</span>
<a href="#l34.129"></a><span id="l34.129" class="difflineminus">- </span>
<a href="#l34.130"></a><span id="l34.130" class="difflineplus">+</span>
<a href="#l34.131"></a><span id="l34.131">    void NewFileErrnoError(morkEnv* ev) const;</span>
<a href="#l34.132"></a><span id="l34.132">        // call NewFileErrnoError() to convert std C errno into AB fault</span>
<a href="#l34.133"></a><span id="l34.133"> </span>
<a href="#l34.134"></a><span id="l34.134">   mork_size WriteNewlines(morkEnv* ev, mork_count inNewlines);</span>
<a href="#l34.135"></a><span id="l34.135">   // WriteNewlines() returns the number of bytes written.</span>
<a href="#l34.136"></a><span id="l34.136" class="difflineminus">-         </span>
<a href="#l34.137"></a><span id="l34.137" class="difflineplus">+</span>
<a href="#l34.138"></a><span id="l34.138"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l34.139"></a><span id="l34.139">   static void SlotWeakFile(morkFile* me,</span>
<a href="#l34.140"></a><span id="l34.140">     morkEnv* ev, morkFile** ioSlot)</span>
<a href="#l34.141"></a><span id="l34.141">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l34.142"></a><span id="l34.142" class="difflineminus">-  </span>
<a href="#l34.143"></a><span id="l34.143" class="difflineplus">+</span>
<a href="#l34.144"></a><span id="l34.144">   static void SlotStrongFile(morkFile* me,</span>
<a href="#l34.145"></a><span id="l34.145">     morkEnv* ev, morkFile** ioSlot)</span>
<a href="#l34.146"></a><span id="l34.146">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l34.147"></a><span id="l34.147"> public:</span>
<a href="#l34.148"></a><span id="l34.148">   virtual mork_pos   Length(morkEnv* ev) const = 0; // eof</span>
<a href="#l34.149"></a><span id="l34.149">   // nsIMdbFile methods</span>
<a href="#l34.150"></a><span id="l34.150">   NS_IMETHOD Tell(nsIMdbEnv* ev, mdb_pos* outPos) const override = 0;</span>
<a href="#l34.151"></a><span id="l34.151">   NS_IMETHOD Seek(nsIMdbEnv* ev, mdb_pos inPos, mdb_pos *outPos) override =  0;</span>
<a href="#l34.152"></a><span id="l34.152" class="difflineat">@@ -197,29 +197,29 @@ public:</span>
<a href="#l34.153"></a><span id="l34.153">   // } ----- end pos methods -----</span>
<a href="#l34.154"></a><span id="l34.154"> </span>
<a href="#l34.155"></a><span id="l34.155">   // { ----- begin read methods -----</span>
<a href="#l34.156"></a><span id="l34.156">   NS_IMETHOD Read(nsIMdbEnv* ev, void* outBuf, mdb_size inSize,</span>
<a href="#l34.157"></a><span id="l34.157">     mdb_size* outActualSize) override = 0;</span>
<a href="#l34.158"></a><span id="l34.158">   NS_IMETHOD Get(nsIMdbEnv* ev, void* outBuf, mdb_size inSize,</span>
<a href="#l34.159"></a><span id="l34.159">     mdb_pos inPos, mdb_size* outActualSize) override;</span>
<a href="#l34.160"></a><span id="l34.160">   // } ----- end read methods -----</span>
<a href="#l34.161"></a><span id="l34.161" class="difflineminus">-    </span>
<a href="#l34.162"></a><span id="l34.162" class="difflineplus">+</span>
<a href="#l34.163"></a><span id="l34.163">   // { ----- begin write methods -----</span>
<a href="#l34.164"></a><span id="l34.164">   NS_IMETHOD  Write(nsIMdbEnv* ev, const void* inBuf, mdb_size inSize,</span>
<a href="#l34.165"></a><span id="l34.165">     mdb_size* outActualSize) override = 0;</span>
<a href="#l34.166"></a><span id="l34.166">   NS_IMETHOD  Put(nsIMdbEnv* ev, const void* inBuf, mdb_size inSize,</span>
<a href="#l34.167"></a><span id="l34.167">     mdb_pos inPos, mdb_size* outActualSize) override;</span>
<a href="#l34.168"></a><span id="l34.168">   NS_IMETHOD  Flush(nsIMdbEnv* ev) override = 0;</span>
<a href="#l34.169"></a><span id="l34.169">   // } ----- end attribute methods -----</span>
<a href="#l34.170"></a><span id="l34.170" class="difflineminus">-    </span>
<a href="#l34.171"></a><span id="l34.171" class="difflineplus">+</span>
<a href="#l34.172"></a><span id="l34.172">   // { ----- begin path methods -----</span>
<a href="#l34.173"></a><span id="l34.173">   NS_IMETHOD  Path(nsIMdbEnv* ev, mdbYarn* outFilePath) override ;</span>
<a href="#l34.174"></a><span id="l34.174">   // } ----- end path methods -----</span>
<a href="#l34.175"></a><span id="l34.175" class="difflineminus">-    </span>
<a href="#l34.176"></a><span id="l34.176" class="difflineplus">+</span>
<a href="#l34.177"></a><span id="l34.177">   // { ----- begin replacement methods -----</span>
<a href="#l34.178"></a><span id="l34.178">   NS_IMETHOD  Steal(nsIMdbEnv* ev, nsIMdbFile* ioThief) override = 0;</span>
<a href="#l34.179"></a><span id="l34.179">   NS_IMETHOD  Thief(nsIMdbEnv* ev, nsIMdbFile** acqThief) override;</span>
<a href="#l34.180"></a><span id="l34.180">   // } ----- end replacement methods -----</span>
<a href="#l34.181"></a><span id="l34.181"> </span>
<a href="#l34.182"></a><span id="l34.182">   // { ----- begin versioning methods -----</span>
<a href="#l34.183"></a><span id="l34.183">   NS_IMETHOD BecomeTrunk(nsIMdbEnv* ev) override = 0;</span>
<a href="#l34.184"></a><span id="l34.184"> </span>
<a href="#l34.185"></a><span id="l34.185" class="difflineat">@@ -235,17 +235,17 @@ public:</span>
<a href="#l34.186"></a><span id="l34.186">  * morkStdioFile: concrete file using standard C file io</span>
<a href="#l34.187"></a><span id="l34.187">  */</span>
<a href="#l34.188"></a><span id="l34.188"> </span>
<a href="#l34.189"></a><span id="l34.189"> #define morkDerived_kStdioFile     /*i*/ 0x7346 /* ascii 'sF' */</span>
<a href="#l34.190"></a><span id="l34.190"> </span>
<a href="#l34.191"></a><span id="l34.191"> class morkStdioFile /*d*/ : public morkFile { /* `` copied from IronDoc `` */</span>
<a href="#l34.192"></a><span id="l34.192">   using PathChar = mozilla::filesystem::Path::value_type;</span>
<a href="#l34.193"></a><span id="l34.193"> </span>
<a href="#l34.194"></a><span id="l34.194" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l34.195"></a><span id="l34.195" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l34.196"></a><span id="l34.196"> protected: // protected morkStdioFile members</span>
<a href="#l34.197"></a><span id="l34.197"> </span>
<a href="#l34.198"></a><span id="l34.198">   void* mStdioFile_File;</span>
<a href="#l34.199"></a><span id="l34.199">   // actually type FILE*, but using opaque void* type</span>
<a href="#l34.200"></a><span id="l34.200"> </span>
<a href="#l34.201"></a><span id="l34.201"> // { ===== begin morkNode interface =====</span>
<a href="#l34.202"></a><span id="l34.202"> public: // morkNode virtual methods</span>
<a href="#l34.203"></a><span id="l34.203">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseStdioFile() only if open</span>
<a href="#l34.204"></a><span id="l34.204" class="difflineat">@@ -262,18 +262,18 @@ private: // copying is not allowed</span>
<a href="#l34.205"></a><span id="l34.205"> </span>
<a href="#l34.206"></a><span id="l34.206"> public: // dynamic type identification</span>
<a href="#l34.207"></a><span id="l34.207">   mork_bool IsStdioFile() const</span>
<a href="#l34.208"></a><span id="l34.208">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kStdioFile; }</span>
<a href="#l34.209"></a><span id="l34.209"> // } ===== end morkNode methods =====</span>
<a href="#l34.210"></a><span id="l34.210"> </span>
<a href="#l34.211"></a><span id="l34.211"> public: // typing</span>
<a href="#l34.212"></a><span id="l34.212">   static void NonStdioFileTypeError(morkEnv* ev);</span>
<a href="#l34.213"></a><span id="l34.213" class="difflineminus">-    </span>
<a href="#l34.214"></a><span id="l34.214" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l34.215"></a><span id="l34.215" class="difflineplus">+</span>
<a href="#l34.216"></a><span id="l34.216" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l34.217"></a><span id="l34.217"> public: // compatible with the morkFile::OpenOldFile() entry point</span>
<a href="#l34.218"></a><span id="l34.218"> </span>
<a href="#l34.219"></a><span id="l34.219">   static morkStdioFile* OpenOldStdioFile(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l34.220"></a><span id="l34.220">     const PathChar* inFilePath, mork_bool inFrozen);</span>
<a href="#l34.221"></a><span id="l34.221"> </span>
<a href="#l34.222"></a><span id="l34.222">   static morkStdioFile* CreateNewStdioFile(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l34.223"></a><span id="l34.223">     const PathChar* inFilePath);</span>
<a href="#l34.224"></a><span id="l34.224"> </span>
<a href="#l34.225"></a><span id="l34.225" class="difflineat">@@ -302,58 +302,58 @@ public: // compatible with the morkFile:</span>
<a href="#l34.226"></a><span id="l34.226">   NS_IMETHOD BecomeTrunk(nsIMdbEnv* ev) override;</span>
<a href="#l34.227"></a><span id="l34.227"> </span>
<a href="#l34.228"></a><span id="l34.228">   NS_IMETHOD AcquireBud(nsIMdbEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l34.229"></a><span id="l34.229">     nsIMdbFile** acqBud) override;</span>
<a href="#l34.230"></a><span id="l34.230">   // } ----- end versioning methods -----</span>
<a href="#l34.231"></a><span id="l34.231"> </span>
<a href="#l34.232"></a><span id="l34.232"> // } ===== end nsIMdbFile methods =====</span>
<a href="#l34.233"></a><span id="l34.233"> </span>
<a href="#l34.234"></a><span id="l34.234" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l34.235"></a><span id="l34.235" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l34.236"></a><span id="l34.236"> </span>
<a href="#l34.237"></a><span id="l34.237" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l34.238"></a><span id="l34.238" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l34.239"></a><span id="l34.239"> protected: // protected non-poly morkStdioFile methods</span>
<a href="#l34.240"></a><span id="l34.240"> </span>
<a href="#l34.241"></a><span id="l34.241">   void new_stdio_file_fault(morkEnv* ev) const;</span>
<a href="#l34.242"></a><span id="l34.242" class="difflineminus">-    </span>
<a href="#l34.243"></a><span id="l34.243" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l34.244"></a><span id="l34.244" class="difflineplus">+</span>
<a href="#l34.245"></a><span id="l34.245" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l34.246"></a><span id="l34.246"> public: // public non-poly morkStdioFile methods</span>
<a href="#l34.247"></a><span id="l34.247" class="difflineminus">-    </span>
<a href="#l34.248"></a><span id="l34.248" class="difflineminus">-  morkStdioFile(morkEnv* ev, const morkUsage&amp; inUsage, </span>
<a href="#l34.249"></a><span id="l34.249" class="difflineplus">+</span>
<a href="#l34.250"></a><span id="l34.250" class="difflineplus">+  morkStdioFile(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l34.251"></a><span id="l34.251">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap,</span>
<a href="#l34.252"></a><span id="l34.252">     const PathChar* inName, const char* inMode);</span>
<a href="#l34.253"></a><span id="l34.253">     // calls OpenStdio() after construction</span>
<a href="#l34.254"></a><span id="l34.254"> </span>
<a href="#l34.255"></a><span id="l34.255">   morkStdioFile(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l34.256"></a><span id="l34.256">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap,</span>
<a href="#l34.257"></a><span id="l34.257">      void* ioFile, const PathChar* inName, mork_bool inFrozen);</span>
<a href="#l34.258"></a><span id="l34.258">     // calls UseStdio() after construction</span>
<a href="#l34.259"></a><span id="l34.259" class="difflineminus">-  </span>
<a href="#l34.260"></a><span id="l34.260" class="difflineplus">+</span>
<a href="#l34.261"></a><span id="l34.261">   void OpenStdio(morkEnv* ev, const PathChar* inName, const char* inMode);</span>
<a href="#l34.262"></a><span id="l34.262">     // Open a new FILE with name inName, using mode flags from inMode.</span>
<a href="#l34.263"></a><span id="l34.263" class="difflineminus">-  </span>
<a href="#l34.264"></a><span id="l34.264" class="difflineplus">+</span>
<a href="#l34.265"></a><span id="l34.265">   void UseStdio(morkEnv* ev, void* ioFile, const PathChar* inName,</span>
<a href="#l34.266"></a><span id="l34.266">     mork_bool inFrozen);</span>
<a href="#l34.267"></a><span id="l34.267">     // Use an existing file, like stdin/stdout/stderr, which should not</span>
<a href="#l34.268"></a><span id="l34.268">     // have the io stream closed when the file is closed.  The ioFile</span>
<a href="#l34.269"></a><span id="l34.269">     // parameter must actually be of type FILE (but we don't want to make</span>
<a href="#l34.270"></a><span id="l34.270">     // this header file include the stdio.h header file).</span>
<a href="#l34.271"></a><span id="l34.271" class="difflineminus">-    </span>
<a href="#l34.272"></a><span id="l34.272" class="difflineplus">+</span>
<a href="#l34.273"></a><span id="l34.273">   void CloseStdio(morkEnv* ev);</span>
<a href="#l34.274"></a><span id="l34.274">     // Close the stream io if both and FileActive() and FileIoOpen(), but</span>
<a href="#l34.275"></a><span id="l34.275">     // this does not close this instances (like CloseStdioFile() does).</span>
<a href="#l34.276"></a><span id="l34.276">     // If stream io was made active by means of calling UseStdio(),</span>
<a href="#l34.277"></a><span id="l34.277">     // then this method does little beyond marking the stream inactive</span>
<a href="#l34.278"></a><span id="l34.278">     // because FileIoOpen() is false.</span>
<a href="#l34.279"></a><span id="l34.279" class="difflineminus">-    </span>
<a href="#l34.280"></a><span id="l34.280" class="difflineplus">+</span>
<a href="#l34.281"></a><span id="l34.281"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l34.282"></a><span id="l34.282">   static void SlotWeakStdioFile(morkStdioFile* me,</span>
<a href="#l34.283"></a><span id="l34.283">     morkEnv* ev, morkStdioFile** ioSlot)</span>
<a href="#l34.284"></a><span id="l34.284">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l34.285"></a><span id="l34.285" class="difflineminus">-  </span>
<a href="#l34.286"></a><span id="l34.286" class="difflineplus">+</span>
<a href="#l34.287"></a><span id="l34.287">   static void SlotStrongStdioFile(morkStdioFile* me,</span>
<a href="#l34.288"></a><span id="l34.288">     morkEnv* ev, morkStdioFile** ioSlot)</span>
<a href="#l34.289"></a><span id="l34.289">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l34.290"></a><span id="l34.290"> };</span>
<a href="#l34.291"></a><span id="l34.291"> </span>
<a href="#l34.292"></a><span id="l34.292"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l34.293"></a><span id="l34.293"> </span>
<a href="#l34.294"></a><span id="l34.294"> #endif /* _MORKFILE_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l35.1"></a><span id="l35.1" class="difflineminus">--- a/db/mork/src/morkHandle.cpp</span>
<a href="#l35.2"></a><span id="l35.2" class="difflineplus">+++ b/db/mork/src/morkHandle.cpp</span>
<a href="#l35.3"></a><span id="l35.3" class="difflineat">@@ -24,17 +24,17 @@</span>
<a href="#l35.4"></a><span id="l35.4"> #endif</span>
<a href="#l35.5"></a><span id="l35.5"> </span>
<a href="#l35.6"></a><span id="l35.6"> #ifndef _MORKHANDLE_</span>
<a href="#l35.7"></a><span id="l35.7"> #include &quot;morkHandle.h&quot;</span>
<a href="#l35.8"></a><span id="l35.8"> #endif</span>
<a href="#l35.9"></a><span id="l35.9"> </span>
<a href="#l35.10"></a><span id="l35.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l35.11"></a><span id="l35.11"> </span>
<a href="#l35.12"></a><span id="l35.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l35.13"></a><span id="l35.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l35.14"></a><span id="l35.14"> // { ===== begin morkNode interface =====</span>
<a href="#l35.15"></a><span id="l35.15"> </span>
<a href="#l35.16"></a><span id="l35.16"> /*public virtual*/ void</span>
<a href="#l35.17"></a><span id="l35.17"> morkHandle::CloseMorkNode(morkEnv* ev) // CloseHandle() only if open</span>
<a href="#l35.18"></a><span id="l35.18"> {</span>
<a href="#l35.19"></a><span id="l35.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l35.20"></a><span id="l35.20">   {</span>
<a href="#l35.21"></a><span id="l35.21">     this-&gt;MarkClosing();</span>
<a href="#l35.22"></a><span id="l35.22" class="difflineat">@@ -89,52 +89,52 @@ morkHandle::morkHandle(morkEnv* ev, // n</span>
<a href="#l35.23"></a><span id="l35.23"> morkHandle::CloseHandle(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l35.24"></a><span id="l35.24"> {</span>
<a href="#l35.25"></a><span id="l35.25">     if ( this-&gt;IsNode() )</span>
<a href="#l35.26"></a><span id="l35.26">     {</span>
<a href="#l35.27"></a><span id="l35.27">       morkObject* obj = mHandle_Object;</span>
<a href="#l35.28"></a><span id="l35.28">       mork_bool objDidRefSelf = ( obj &amp;&amp; obj-&gt;mObject_Handle == this );</span>
<a href="#l35.29"></a><span id="l35.29">       if ( objDidRefSelf )</span>
<a href="#l35.30"></a><span id="l35.30">         obj-&gt;mObject_Handle = 0; // drop the reference</span>
<a href="#l35.31"></a><span id="l35.31" class="difflineminus">-      </span>
<a href="#l35.32"></a><span id="l35.32" class="difflineplus">+</span>
<a href="#l35.33"></a><span id="l35.33">       morkObject::SlotStrongObject((morkObject*) 0, ev, &amp;mHandle_Object);</span>
<a href="#l35.34"></a><span id="l35.34">       mHandle_Magic = 0;</span>
<a href="#l35.35"></a><span id="l35.35">       // note mHandle_Tag MUST stay morkHandle_kTag for morkNode::ZapOld()</span>
<a href="#l35.36"></a><span id="l35.36">       this-&gt;MarkShut();</span>
<a href="#l35.37"></a><span id="l35.37"> </span>
<a href="#l35.38"></a><span id="l35.38">       if ( objDidRefSelf )</span>
<a href="#l35.39"></a><span id="l35.39">         this-&gt;CutWeakRef(ev); // do last, because it might self destroy</span>
<a href="#l35.40"></a><span id="l35.40">     }</span>
<a href="#l35.41"></a><span id="l35.41">     else</span>
<a href="#l35.42"></a><span id="l35.42">       this-&gt;NonNodeError(ev);</span>
<a href="#l35.43"></a><span id="l35.43"> }</span>
<a href="#l35.44"></a><span id="l35.44"> </span>
<a href="#l35.45"></a><span id="l35.45"> // } ===== end morkNode methods =====</span>
<a href="#l35.46"></a><span id="l35.46" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l35.47"></a><span id="l35.47" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l35.48"></a><span id="l35.48"> </span>
<a href="#l35.49"></a><span id="l35.49"> void morkHandle::NilFactoryError(morkEnv* ev) const</span>
<a href="#l35.50"></a><span id="l35.50"> {</span>
<a href="#l35.51"></a><span id="l35.51">   ev-&gt;NewError(&quot;nil mHandle_Factory&quot;);</span>
<a href="#l35.52"></a><span id="l35.52"> }</span>
<a href="#l35.53"></a><span id="l35.53" class="difflineminus">-  </span>
<a href="#l35.54"></a><span id="l35.54" class="difflineplus">+</span>
<a href="#l35.55"></a><span id="l35.55"> void morkHandle::NilHandleObjectError(morkEnv* ev) const</span>
<a href="#l35.56"></a><span id="l35.56"> {</span>
<a href="#l35.57"></a><span id="l35.57">   ev-&gt;NewError(&quot;nil mHandle_Object&quot;);</span>
<a href="#l35.58"></a><span id="l35.58"> }</span>
<a href="#l35.59"></a><span id="l35.59" class="difflineminus">-  </span>
<a href="#l35.60"></a><span id="l35.60" class="difflineplus">+</span>
<a href="#l35.61"></a><span id="l35.61"> void morkHandle::NonNodeObjectError(morkEnv* ev) const</span>
<a href="#l35.62"></a><span id="l35.62"> {</span>
<a href="#l35.63"></a><span id="l35.63">   ev-&gt;NewError(&quot;non-node mHandle_Object&quot;);</span>
<a href="#l35.64"></a><span id="l35.64"> }</span>
<a href="#l35.65"></a><span id="l35.65" class="difflineminus">-  </span>
<a href="#l35.66"></a><span id="l35.66" class="difflineplus">+</span>
<a href="#l35.67"></a><span id="l35.67"> void morkHandle::NonOpenObjectError(morkEnv* ev) const</span>
<a href="#l35.68"></a><span id="l35.68"> {</span>
<a href="#l35.69"></a><span id="l35.69">   ev-&gt;NewError(&quot;non-open mHandle_Object&quot;);</span>
<a href="#l35.70"></a><span id="l35.70"> }</span>
<a href="#l35.71"></a><span id="l35.71" class="difflineminus">-  </span>
<a href="#l35.72"></a><span id="l35.72" class="difflineplus">+</span>
<a href="#l35.73"></a><span id="l35.73"> void morkHandle::NewBadMagicHandleError(morkEnv* ev, mork_magic inMagic) const</span>
<a href="#l35.74"></a><span id="l35.74"> {</span>
<a href="#l35.75"></a><span id="l35.75">   MORK_USED_1(inMagic);</span>
<a href="#l35.76"></a><span id="l35.76">   ev-&gt;NewError(&quot;wrong mHandle_Magic&quot;);</span>
<a href="#l35.77"></a><span id="l35.77"> }</span>
<a href="#l35.78"></a><span id="l35.78"> </span>
<a href="#l35.79"></a><span id="l35.79"> void morkHandle::NewDownHandleError(morkEnv* ev) const</span>
<a href="#l35.80"></a><span id="l35.80"> {</span>
<a href="#l35.81"></a><span id="l35.81" class="difflineat">@@ -184,17 +184,17 @@ morkObject* morkHandle::GetGoodHandleObj</span>
<a href="#l35.82"></a><span id="l35.82">       else if ( !inClosedOkay )</span>
<a href="#l35.83"></a><span id="l35.83">         this-&gt;NilHandleObjectError(ev);</span>
<a href="#l35.84"></a><span id="l35.84">     }</span>
<a href="#l35.85"></a><span id="l35.85">     else</span>
<a href="#l35.86"></a><span id="l35.86">       this-&gt;NewBadMagicHandleError(ev, inMagicType);</span>
<a href="#l35.87"></a><span id="l35.87">   }</span>
<a href="#l35.88"></a><span id="l35.88">   else</span>
<a href="#l35.89"></a><span id="l35.89">     this-&gt;NewDownHandleError(ev);</span>
<a href="#l35.90"></a><span id="l35.90" class="difflineminus">-  </span>
<a href="#l35.91"></a><span id="l35.91" class="difflineplus">+</span>
<a href="#l35.92"></a><span id="l35.92">   MORK_ASSERT(outObject || inClosedOkay);</span>
<a href="#l35.93"></a><span id="l35.93">   return outObject;</span>
<a href="#l35.94"></a><span id="l35.94"> }</span>
<a href="#l35.95"></a><span id="l35.95"> </span>
<a href="#l35.96"></a><span id="l35.96"> </span>
<a href="#l35.97"></a><span id="l35.97"> morkEnv*</span>
<a href="#l35.98"></a><span id="l35.98"> morkHandle::CanUseHandle(nsIMdbEnv* mev, mork_bool inMutable,</span>
<a href="#l35.99"></a><span id="l35.99">                          mork_bool inClosedOkay, nsresult* outErr) const</span>
<a href="#l35.100"></a><span id="l35.100" class="difflineat">@@ -218,23 +218,23 @@ morkHandle::CanUseHandle(nsIMdbEnv* mev,</span>
<a href="#l35.101"></a><span id="l35.101"> // { ===== begin nsIMdbObject methods =====</span>
<a href="#l35.102"></a><span id="l35.102"> </span>
<a href="#l35.103"></a><span id="l35.103"> // { ----- begin attribute methods -----</span>
<a href="#l35.104"></a><span id="l35.104"> /*virtual*/ nsresult</span>
<a href="#l35.105"></a><span id="l35.105"> morkHandle::Handle_IsFrozenMdbObject(nsIMdbEnv* mev, mdb_bool* outIsReadonly)</span>
<a href="#l35.106"></a><span id="l35.106"> {</span>
<a href="#l35.107"></a><span id="l35.107">   nsresult outErr = NS_OK;</span>
<a href="#l35.108"></a><span id="l35.108">   mdb_bool readOnly = mdbBool_kTrue;</span>
<a href="#l35.109"></a><span id="l35.109" class="difflineminus">-  </span>
<a href="#l35.110"></a><span id="l35.110" class="difflineplus">+</span>
<a href="#l35.111"></a><span id="l35.111">   morkEnv* ev = CanUseHandle(mev, /*inMutable*/ morkBool_kFalse,</span>
<a href="#l35.112"></a><span id="l35.112">     /*inClosedOkay*/ morkBool_kTrue, &amp;outErr);</span>
<a href="#l35.113"></a><span id="l35.113">   if ( ev )</span>
<a href="#l35.114"></a><span id="l35.114">   {</span>
<a href="#l35.115"></a><span id="l35.115">     readOnly = mHandle_Object-&gt;IsFrozen();</span>
<a href="#l35.116"></a><span id="l35.116" class="difflineminus">-    </span>
<a href="#l35.117"></a><span id="l35.117" class="difflineplus">+</span>
<a href="#l35.118"></a><span id="l35.118">     outErr = ev-&gt;AsErr();</span>
<a href="#l35.119"></a><span id="l35.119">   }</span>
<a href="#l35.120"></a><span id="l35.120">   MORK_ASSERT(outIsReadonly);</span>
<a href="#l35.121"></a><span id="l35.121">   if ( outIsReadonly )</span>
<a href="#l35.122"></a><span id="l35.122">     *outIsReadonly = readOnly;</span>
<a href="#l35.123"></a><span id="l35.123"> </span>
<a href="#l35.124"></a><span id="l35.124">   return outErr;</span>
<a href="#l35.125"></a><span id="l35.125"> }</span>
<a href="#l35.126"></a><span id="l35.126" class="difflineat">@@ -242,129 +242,129 @@ morkHandle::Handle_IsFrozenMdbObject(nsI</span>
<a href="#l35.127"></a><span id="l35.127"> // } ----- end attribute methods -----</span>
<a href="#l35.128"></a><span id="l35.128"> </span>
<a href="#l35.129"></a><span id="l35.129"> // { ----- begin factory methods -----</span>
<a href="#l35.130"></a><span id="l35.130"> /*virtual*/ nsresult</span>
<a href="#l35.131"></a><span id="l35.131"> morkHandle::Handle_GetMdbFactory(nsIMdbEnv* mev, nsIMdbFactory** acqFactory)</span>
<a href="#l35.132"></a><span id="l35.132"> {</span>
<a href="#l35.133"></a><span id="l35.133">   nsresult outErr = NS_OK;</span>
<a href="#l35.134"></a><span id="l35.134">   nsIMdbFactory* handle = 0;</span>
<a href="#l35.135"></a><span id="l35.135" class="difflineminus">-  </span>
<a href="#l35.136"></a><span id="l35.136" class="difflineplus">+</span>
<a href="#l35.137"></a><span id="l35.137">   morkEnv* ev = CanUseHandle(mev, /*inMutable*/ morkBool_kFalse,</span>
<a href="#l35.138"></a><span id="l35.138">     /*inClosedOkay*/ morkBool_kTrue, &amp;outErr);</span>
<a href="#l35.139"></a><span id="l35.139">   if ( ev )</span>
<a href="#l35.140"></a><span id="l35.140">   {</span>
<a href="#l35.141"></a><span id="l35.141">     morkFactory* factory = ev-&gt;mEnv_Factory;</span>
<a href="#l35.142"></a><span id="l35.142">     if ( factory )</span>
<a href="#l35.143"></a><span id="l35.143">     {</span>
<a href="#l35.144"></a><span id="l35.144">       handle = factory;</span>
<a href="#l35.145"></a><span id="l35.145">       NS_ADDREF(handle);</span>
<a href="#l35.146"></a><span id="l35.146">     }</span>
<a href="#l35.147"></a><span id="l35.147">     else</span>
<a href="#l35.148"></a><span id="l35.148">       this-&gt;NilFactoryError(ev);</span>
<a href="#l35.149"></a><span id="l35.149" class="difflineminus">-      </span>
<a href="#l35.150"></a><span id="l35.150" class="difflineplus">+</span>
<a href="#l35.151"></a><span id="l35.151">     outErr = ev-&gt;AsErr();</span>
<a href="#l35.152"></a><span id="l35.152">   }</span>
<a href="#l35.153"></a><span id="l35.153"> </span>
<a href="#l35.154"></a><span id="l35.154">   MORK_ASSERT(acqFactory);</span>
<a href="#l35.155"></a><span id="l35.155">   if ( acqFactory )</span>
<a href="#l35.156"></a><span id="l35.156">     *acqFactory = handle;</span>
<a href="#l35.157"></a><span id="l35.157"> </span>
<a href="#l35.158"></a><span id="l35.158">   return outErr;</span>
<a href="#l35.159"></a><span id="l35.159" class="difflineminus">-} </span>
<a href="#l35.160"></a><span id="l35.160" class="difflineplus">+}</span>
<a href="#l35.161"></a><span id="l35.161"> // } ----- end factory methods -----</span>
<a href="#l35.162"></a><span id="l35.162"> </span>
<a href="#l35.163"></a><span id="l35.163"> // { ----- begin ref counting for well-behaved cyclic graphs -----</span>
<a href="#l35.164"></a><span id="l35.164"> /*virtual*/ nsresult</span>
<a href="#l35.165"></a><span id="l35.165"> morkHandle::Handle_GetWeakRefCount(nsIMdbEnv* mev, // weak refs</span>
<a href="#l35.166"></a><span id="l35.166">   mdb_count* outCount)</span>
<a href="#l35.167"></a><span id="l35.167"> {</span>
<a href="#l35.168"></a><span id="l35.168">   nsresult outErr = NS_OK;</span>
<a href="#l35.169"></a><span id="l35.169">   mdb_count count = 0;</span>
<a href="#l35.170"></a><span id="l35.170" class="difflineminus">-  </span>
<a href="#l35.171"></a><span id="l35.171" class="difflineplus">+</span>
<a href="#l35.172"></a><span id="l35.172">   morkEnv* ev = CanUseHandle(mev, /*inMutable*/ morkBool_kFalse,</span>
<a href="#l35.173"></a><span id="l35.173">     /*inClosedOkay*/ morkBool_kTrue, &amp;outErr);</span>
<a href="#l35.174"></a><span id="l35.174">   if ( ev )</span>
<a href="#l35.175"></a><span id="l35.175">   {</span>
<a href="#l35.176"></a><span id="l35.176">     count = this-&gt;WeakRefsOnly();</span>
<a href="#l35.177"></a><span id="l35.177" class="difflineminus">-    </span>
<a href="#l35.178"></a><span id="l35.178" class="difflineplus">+</span>
<a href="#l35.179"></a><span id="l35.179">     outErr = ev-&gt;AsErr();</span>
<a href="#l35.180"></a><span id="l35.180">   }</span>
<a href="#l35.181"></a><span id="l35.181">   MORK_ASSERT(outCount);</span>
<a href="#l35.182"></a><span id="l35.182">   if ( outCount )</span>
<a href="#l35.183"></a><span id="l35.183">     *outCount = count;</span>
<a href="#l35.184"></a><span id="l35.184" class="difflineminus">-    </span>
<a href="#l35.185"></a><span id="l35.185" class="difflineplus">+</span>
<a href="#l35.186"></a><span id="l35.186">   return outErr;</span>
<a href="#l35.187"></a><span id="l35.187" class="difflineminus">-}  </span>
<a href="#l35.188"></a><span id="l35.188" class="difflineplus">+}</span>
<a href="#l35.189"></a><span id="l35.189"> /*virtual*/ nsresult</span>
<a href="#l35.190"></a><span id="l35.190"> morkHandle::Handle_GetStrongRefCount(nsIMdbEnv* mev, // strong refs</span>
<a href="#l35.191"></a><span id="l35.191">   mdb_count* outCount)</span>
<a href="#l35.192"></a><span id="l35.192"> {</span>
<a href="#l35.193"></a><span id="l35.193">   nsresult outErr = NS_OK;</span>
<a href="#l35.194"></a><span id="l35.194">   mdb_count count = 0;</span>
<a href="#l35.195"></a><span id="l35.195" class="difflineminus">-  </span>
<a href="#l35.196"></a><span id="l35.196" class="difflineplus">+</span>
<a href="#l35.197"></a><span id="l35.197">   morkEnv* ev = CanUseHandle(mev, /*inMutable*/ morkBool_kFalse,</span>
<a href="#l35.198"></a><span id="l35.198">     /*inClosedOkay*/ morkBool_kTrue, &amp;outErr);</span>
<a href="#l35.199"></a><span id="l35.199">   if ( ev )</span>
<a href="#l35.200"></a><span id="l35.200">   {</span>
<a href="#l35.201"></a><span id="l35.201">     count = this-&gt;StrongRefsOnly();</span>
<a href="#l35.202"></a><span id="l35.202" class="difflineminus">-    </span>
<a href="#l35.203"></a><span id="l35.203" class="difflineplus">+</span>
<a href="#l35.204"></a><span id="l35.204">     outErr = ev-&gt;AsErr();</span>
<a href="#l35.205"></a><span id="l35.205">   }</span>
<a href="#l35.206"></a><span id="l35.206">   MORK_ASSERT(outCount);</span>
<a href="#l35.207"></a><span id="l35.207">   if ( outCount )</span>
<a href="#l35.208"></a><span id="l35.208">     *outCount = count;</span>
<a href="#l35.209"></a><span id="l35.209" class="difflineminus">-    </span>
<a href="#l35.210"></a><span id="l35.210" class="difflineplus">+</span>
<a href="#l35.211"></a><span id="l35.211">   return outErr;</span>
<a href="#l35.212"></a><span id="l35.212"> }</span>
<a href="#l35.213"></a><span id="l35.213"> </span>
<a href="#l35.214"></a><span id="l35.214"> /*virtual*/ nsresult</span>
<a href="#l35.215"></a><span id="l35.215"> morkHandle::Handle_AddWeakRef(nsIMdbEnv* mev)</span>
<a href="#l35.216"></a><span id="l35.216"> {</span>
<a href="#l35.217"></a><span id="l35.217">   nsresult outErr = NS_OK;</span>
<a href="#l35.218"></a><span id="l35.218"> </span>
<a href="#l35.219"></a><span id="l35.219">   morkEnv* ev = CanUseHandle(mev, /*inMutable*/ morkBool_kFalse,</span>
<a href="#l35.220"></a><span id="l35.220">     /*inClosedOkay*/ morkBool_kTrue, &amp;outErr);</span>
<a href="#l35.221"></a><span id="l35.221">   if ( ev )</span>
<a href="#l35.222"></a><span id="l35.222">   {</span>
<a href="#l35.223"></a><span id="l35.223">     this-&gt;AddWeakRef(ev);</span>
<a href="#l35.224"></a><span id="l35.224">     outErr = ev-&gt;AsErr();</span>
<a href="#l35.225"></a><span id="l35.225">   }</span>
<a href="#l35.226"></a><span id="l35.226" class="difflineminus">-    </span>
<a href="#l35.227"></a><span id="l35.227" class="difflineplus">+</span>
<a href="#l35.228"></a><span id="l35.228">   return outErr;</span>
<a href="#l35.229"></a><span id="l35.229"> }</span>
<a href="#l35.230"></a><span id="l35.230"> /*virtual*/ nsresult</span>
<a href="#l35.231"></a><span id="l35.231"> morkHandle::Handle_AddStrongRef(nsIMdbEnv* mev)</span>
<a href="#l35.232"></a><span id="l35.232"> {</span>
<a href="#l35.233"></a><span id="l35.233">   nsresult outErr = NS_OK;</span>
<a href="#l35.234"></a><span id="l35.234"> </span>
<a href="#l35.235"></a><span id="l35.235">   morkEnv* ev = CanUseHandle(mev, /*inMutable*/ morkBool_kFalse,</span>
<a href="#l35.236"></a><span id="l35.236">     /*inClosedOkay*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l35.237"></a><span id="l35.237">   if ( ev )</span>
<a href="#l35.238"></a><span id="l35.238">   {</span>
<a href="#l35.239"></a><span id="l35.239">     this-&gt;AddStrongRef(ev);</span>
<a href="#l35.240"></a><span id="l35.240">     outErr = ev-&gt;AsErr();</span>
<a href="#l35.241"></a><span id="l35.241">   }</span>
<a href="#l35.242"></a><span id="l35.242" class="difflineminus">-    </span>
<a href="#l35.243"></a><span id="l35.243" class="difflineplus">+</span>
<a href="#l35.244"></a><span id="l35.244">   return outErr;</span>
<a href="#l35.245"></a><span id="l35.245"> }</span>
<a href="#l35.246"></a><span id="l35.246"> </span>
<a href="#l35.247"></a><span id="l35.247"> /*virtual*/ nsresult</span>
<a href="#l35.248"></a><span id="l35.248"> morkHandle::Handle_CutWeakRef(nsIMdbEnv* mev)</span>
<a href="#l35.249"></a><span id="l35.249"> {</span>
<a href="#l35.250"></a><span id="l35.250">   nsresult outErr = NS_OK;</span>
<a href="#l35.251"></a><span id="l35.251"> </span>
<a href="#l35.252"></a><span id="l35.252">   morkEnv* ev = CanUseHandle(mev, /*inMutable*/ morkBool_kFalse,</span>
<a href="#l35.253"></a><span id="l35.253">     /*inClosedOkay*/ morkBool_kTrue, &amp;outErr);</span>
<a href="#l35.254"></a><span id="l35.254">   if ( ev )</span>
<a href="#l35.255"></a><span id="l35.255">   {</span>
<a href="#l35.256"></a><span id="l35.256">     this-&gt;CutWeakRef(ev);</span>
<a href="#l35.257"></a><span id="l35.257">     outErr = ev-&gt;AsErr();</span>
<a href="#l35.258"></a><span id="l35.258">   }</span>
<a href="#l35.259"></a><span id="l35.259" class="difflineminus">-    </span>
<a href="#l35.260"></a><span id="l35.260" class="difflineplus">+</span>
<a href="#l35.261"></a><span id="l35.261">   return outErr;</span>
<a href="#l35.262"></a><span id="l35.262"> }</span>
<a href="#l35.263"></a><span id="l35.263"> /*virtual*/ nsresult</span>
<a href="#l35.264"></a><span id="l35.264"> morkHandle::Handle_CutStrongRef(nsIMdbEnv* mev)</span>
<a href="#l35.265"></a><span id="l35.265"> {</span>
<a href="#l35.266"></a><span id="l35.266">   nsresult outErr = NS_OK;</span>
<a href="#l35.267"></a><span id="l35.267">   morkEnv* ev = CanUseHandle(mev, /*inMutable*/ morkBool_kFalse,</span>
<a href="#l35.268"></a><span id="l35.268">     /*inClosedOkay*/ morkBool_kTrue, &amp;outErr);</span>
<a href="#l35.269"></a><span id="l35.269" class="difflineat">@@ -390,34 +390,34 @@ morkHandle::Handle_CloseMdbObject(nsIMdb</span>
<a href="#l35.270"></a><span id="l35.270">   {</span>
<a href="#l35.271"></a><span id="l35.271">     morkEnv* ev = CanUseHandle(mev, /*inMutable*/ morkBool_kFalse,</span>
<a href="#l35.272"></a><span id="l35.272">     /*inClosedOkay*/ morkBool_kTrue, &amp;outErr);</span>
<a href="#l35.273"></a><span id="l35.273">     if ( ev )</span>
<a href="#l35.274"></a><span id="l35.274">     {</span>
<a href="#l35.275"></a><span id="l35.275">       morkObject* object = mHandle_Object;</span>
<a href="#l35.276"></a><span id="l35.276">       if ( object &amp;&amp; object-&gt;IsNode() &amp;&amp; object-&gt;IsOpenNode() )</span>
<a href="#l35.277"></a><span id="l35.277">         object-&gt;CloseMorkNode(ev);</span>
<a href="#l35.278"></a><span id="l35.278" class="difflineminus">-        </span>
<a href="#l35.279"></a><span id="l35.279" class="difflineplus">+</span>
<a href="#l35.280"></a><span id="l35.280">       this-&gt;CloseMorkNode(ev);</span>
<a href="#l35.281"></a><span id="l35.281">       outErr = ev-&gt;AsErr();</span>
<a href="#l35.282"></a><span id="l35.282">     }</span>
<a href="#l35.283"></a><span id="l35.283">   }</span>
<a href="#l35.284"></a><span id="l35.284">   return outErr;</span>
<a href="#l35.285"></a><span id="l35.285"> }</span>
<a href="#l35.286"></a><span id="l35.286"> </span>
<a href="#l35.287"></a><span id="l35.287"> /*virtual*/ nsresult</span>
<a href="#l35.288"></a><span id="l35.288"> morkHandle::Handle_IsOpenMdbObject(nsIMdbEnv* mev, mdb_bool* outOpen)</span>
<a href="#l35.289"></a><span id="l35.289"> {</span>
<a href="#l35.290"></a><span id="l35.290">   MORK_USED_1(mev);</span>
<a href="#l35.291"></a><span id="l35.291">   nsresult outErr = NS_OK;</span>
<a href="#l35.292"></a><span id="l35.292"> </span>
<a href="#l35.293"></a><span id="l35.293">   MORK_ASSERT(outOpen);</span>
<a href="#l35.294"></a><span id="l35.294">   if ( outOpen )</span>
<a href="#l35.295"></a><span id="l35.295">     *outOpen = this-&gt;IsOpenNode();</span>
<a href="#l35.296"></a><span id="l35.296" class="difflineminus">-      </span>
<a href="#l35.297"></a><span id="l35.297" class="difflineplus">+</span>
<a href="#l35.298"></a><span id="l35.298">   return outErr;</span>
<a href="#l35.299"></a><span id="l35.299"> }</span>
<a href="#l35.300"></a><span id="l35.300"> // } ----- end ref counting -----</span>
<a href="#l35.301"></a><span id="l35.301"> </span>
<a href="#l35.302"></a><span id="l35.302"> // } ===== end nsIMdbObject methods =====</span>
<a href="#l35.303"></a><span id="l35.303"> </span>
<a href="#l35.304"></a><span id="l35.304"> </span>
<a href="#l35.305"></a><span id="l35.305"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l36.1"></a><span id="l36.1" class="difflineminus">--- a/db/mork/src/morkHandle.h</span>
<a href="#l36.2"></a><span id="l36.2" class="difflineplus">+++ b/db/mork/src/morkHandle.h</span>
<a href="#l36.3"></a><span id="l36.3" class="difflineat">@@ -26,97 +26,97 @@</span>
<a href="#l36.4"></a><span id="l36.4"> </span>
<a href="#l36.5"></a><span id="l36.5"> class morkPool;</span>
<a href="#l36.6"></a><span id="l36.6"> class morkObject;</span>
<a href="#l36.7"></a><span id="l36.7"> class morkFactory;</span>
<a href="#l36.8"></a><span id="l36.8"> </span>
<a href="#l36.9"></a><span id="l36.9"> #define morkDerived_kHandle     /*i*/ 0x486E /* ascii 'Hn' */</span>
<a href="#l36.10"></a><span id="l36.10"> #define morkHandle_kTag   0x68416E44 /* ascii 'hAnD' */</span>
<a href="#l36.11"></a><span id="l36.11"> </span>
<a href="#l36.12"></a><span id="l36.12" class="difflineminus">-/*| morkHandle: </span>
<a href="#l36.13"></a><span id="l36.13" class="difflineplus">+/*| morkHandle:</span>
<a href="#l36.14"></a><span id="l36.14"> |*/</span>
<a href="#l36.15"></a><span id="l36.15"> class morkHandle : public morkNode {</span>
<a href="#l36.16"></a><span id="l36.16" class="difflineminus">-  </span>
<a href="#l36.17"></a><span id="l36.17" class="difflineplus">+</span>
<a href="#l36.18"></a><span id="l36.18"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l36.19"></a><span id="l36.19">   // nsIMdbHeap*    mNode_Heap;</span>
<a href="#l36.20"></a><span id="l36.20"> </span>
<a href="#l36.21"></a><span id="l36.21">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l36.22"></a><span id="l36.22">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l36.23"></a><span id="l36.23" class="difflineminus">-  </span>
<a href="#l36.24"></a><span id="l36.24" class="difflineplus">+</span>
<a href="#l36.25"></a><span id="l36.25">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l36.26"></a><span id="l36.26">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l36.27"></a><span id="l36.27">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l36.28"></a><span id="l36.28">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l36.29"></a><span id="l36.29" class="difflineminus">-  </span>
<a href="#l36.30"></a><span id="l36.30" class="difflineplus">+</span>
<a href="#l36.31"></a><span id="l36.31">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l36.32"></a><span id="l36.32">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l36.33"></a><span id="l36.33"> </span>
<a href="#l36.34"></a><span id="l36.34"> public: // state is public because the entire Mork system is private</span>
<a href="#l36.35"></a><span id="l36.35"> </span>
<a href="#l36.36"></a><span id="l36.36">   mork_u4         mHandle_Tag;     // must equal morkHandle_kTag</span>
<a href="#l36.37"></a><span id="l36.37">   morkEnv*        mHandle_Env;     // pool that allocated this handle</span>
<a href="#l36.38"></a><span id="l36.38">   morkHandleFace* mHandle_Face;    // cookie from pool containing this</span>
<a href="#l36.39"></a><span id="l36.39">   morkObject*     mHandle_Object;  // object this handle wraps for MDB API</span>
<a href="#l36.40"></a><span id="l36.40">   mork_magic      mHandle_Magic;   // magic sig different in each subclass</span>
<a href="#l36.41"></a><span id="l36.41" class="difflineminus">-  </span>
<a href="#l36.42"></a><span id="l36.42" class="difflineplus">+</span>
<a href="#l36.43"></a><span id="l36.43"> // { ===== begin morkNode interface =====</span>
<a href="#l36.44"></a><span id="l36.44"> public: // morkNode virtual methods</span>
<a href="#l36.45"></a><span id="l36.45">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseHandle() only if open</span>
<a href="#l36.46"></a><span id="l36.46">   virtual ~morkHandle(); // assert that CloseHandle() executed earlier</span>
<a href="#l36.47"></a><span id="l36.47" class="difflineminus">-  </span>
<a href="#l36.48"></a><span id="l36.48" class="difflineplus">+</span>
<a href="#l36.49"></a><span id="l36.49"> public: // morkHandle construction &amp; destruction</span>
<a href="#l36.50"></a><span id="l36.50">   morkHandle(morkEnv* ev, // note morkUsage is always morkUsage_kPool</span>
<a href="#l36.51"></a><span id="l36.51">     morkHandleFace* ioFace,  // must not be nil, cookie for this handle</span>
<a href="#l36.52"></a><span id="l36.52">     morkObject* ioObject,    // must not be nil, the object for this handle</span>
<a href="#l36.53"></a><span id="l36.53">     mork_magic inMagic);     // magic sig to denote specific subclass</span>
<a href="#l36.54"></a><span id="l36.54">   void CloseHandle(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l36.55"></a><span id="l36.55"> </span>
<a href="#l36.56"></a><span id="l36.56"> private: // copying is not allowed</span>
<a href="#l36.57"></a><span id="l36.57">   morkHandle(const morkHandle&amp; other);</span>
<a href="#l36.58"></a><span id="l36.58">   morkHandle&amp; operator=(const morkHandle&amp; other);</span>
<a href="#l36.59"></a><span id="l36.59" class="difflineminus">-  </span>
<a href="#l36.60"></a><span id="l36.60" class="difflineplus">+</span>
<a href="#l36.61"></a><span id="l36.61"> protected: // special case empty construction for morkHandleFrame</span>
<a href="#l36.62"></a><span id="l36.62">   friend class morkHandleFrame;</span>
<a href="#l36.63"></a><span id="l36.63">   morkHandle() { }</span>
<a href="#l36.64"></a><span id="l36.64"> </span>
<a href="#l36.65"></a><span id="l36.65"> public: // dynamic type identification</span>
<a href="#l36.66"></a><span id="l36.66">   mork_bool IsHandle() const</span>
<a href="#l36.67"></a><span id="l36.67">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kHandle; }</span>
<a href="#l36.68"></a><span id="l36.68"> // } ===== end morkNode methods =====</span>
<a href="#l36.69"></a><span id="l36.69"> </span>
<a href="#l36.70"></a><span id="l36.70"> public: // morkHandle memory management operators</span>
<a href="#l36.71"></a><span id="l36.71">   void* operator new(size_t inSize, morkPool&amp; ioPool, morkZone&amp; ioZone, morkEnv* ev) CPP_THROW_NEW</span>
<a href="#l36.72"></a><span id="l36.72">   { return ioPool.NewHandle(ev, inSize, &amp;ioZone); }</span>
<a href="#l36.73"></a><span id="l36.73" class="difflineminus">-  </span>
<a href="#l36.74"></a><span id="l36.74" class="difflineplus">+</span>
<a href="#l36.75"></a><span id="l36.75">   void* operator new(size_t inSize, morkPool&amp; ioPool, morkEnv* ev) CPP_THROW_NEW</span>
<a href="#l36.76"></a><span id="l36.76">   { return ioPool.NewHandle(ev, inSize, (morkZone*) 0); }</span>
<a href="#l36.77"></a><span id="l36.77" class="difflineminus">-  </span>
<a href="#l36.78"></a><span id="l36.78" class="difflineplus">+</span>
<a href="#l36.79"></a><span id="l36.79">   void* operator new(size_t inSize, morkHandleFace* ioFace) CPP_THROW_NEW</span>
<a href="#l36.80"></a><span id="l36.80">   { MORK_USED_1(inSize); return ioFace; }</span>
<a href="#l36.81"></a><span id="l36.81" class="difflineminus">-  </span>
<a href="#l36.82"></a><span id="l36.82" class="difflineplus">+</span>
<a href="#l36.83"></a><span id="l36.83"> </span>
<a href="#l36.84"></a><span id="l36.84"> public: // other handle methods</span>
<a href="#l36.85"></a><span id="l36.85">   mork_bool GoodHandleTag() const</span>
<a href="#l36.86"></a><span id="l36.86">   { return mHandle_Tag == morkHandle_kTag; }</span>
<a href="#l36.87"></a><span id="l36.87" class="difflineminus">-  </span>
<a href="#l36.88"></a><span id="l36.88" class="difflineplus">+</span>
<a href="#l36.89"></a><span id="l36.89">   void NewBadMagicHandleError(morkEnv* ev, mork_magic inMagic) const;</span>
<a href="#l36.90"></a><span id="l36.90">   void NewDownHandleError(morkEnv* ev) const;</span>
<a href="#l36.91"></a><span id="l36.91">   void NilFactoryError(morkEnv* ev) const;</span>
<a href="#l36.92"></a><span id="l36.92">   void NilHandleObjectError(morkEnv* ev) const;</span>
<a href="#l36.93"></a><span id="l36.93">   void NonNodeObjectError(morkEnv* ev) const;</span>
<a href="#l36.94"></a><span id="l36.94">   void NonOpenObjectError(morkEnv* ev) const;</span>
<a href="#l36.95"></a><span id="l36.95" class="difflineminus">-  </span>
<a href="#l36.96"></a><span id="l36.96" class="difflineplus">+</span>
<a href="#l36.97"></a><span id="l36.97">   morkObject* GetGoodHandleObject(morkEnv* ev,</span>
<a href="#l36.98"></a><span id="l36.98">     mork_bool inMutable, mork_magic inMagicType, mork_bool inClosedOkay) const;</span>
<a href="#l36.99"></a><span id="l36.99"> </span>
<a href="#l36.100"></a><span id="l36.100"> public: // interface supporting mdbObject methods</span>
<a href="#l36.101"></a><span id="l36.101"> </span>
<a href="#l36.102"></a><span id="l36.102">   morkEnv* CanUseHandle(nsIMdbEnv* mev, mork_bool inMutable,</span>
<a href="#l36.103"></a><span id="l36.103">                         mork_bool inClosedOkay, nsresult* outErr) const;</span>
<a href="#l36.104"></a><span id="l36.104" class="difflineminus">-    </span>
<a href="#l36.105"></a><span id="l36.105" class="difflineplus">+</span>
<a href="#l36.106"></a><span id="l36.106">   // { ----- begin mdbObject style methods -----</span>
<a href="#l36.107"></a><span id="l36.107">   nsresult Handle_IsFrozenMdbObject(nsIMdbEnv* ev, mdb_bool* outIsReadonly);</span>
<a href="#l36.108"></a><span id="l36.108"> </span>
<a href="#l36.109"></a><span id="l36.109">   nsresult Handle_GetMdbFactory(nsIMdbEnv* ev, nsIMdbFactory** acqFactory);</span>
<a href="#l36.110"></a><span id="l36.110">   nsresult Handle_GetWeakRefCount(nsIMdbEnv* ev,  mdb_count* outCount);</span>
<a href="#l36.111"></a><span id="l36.111">   nsresult Handle_GetStrongRefCount(nsIMdbEnv* ev, mdb_count* outCount);</span>
<a href="#l36.112"></a><span id="l36.112"> </span>
<a href="#l36.113"></a><span id="l36.113">   nsresult Handle_AddWeakRef(nsIMdbEnv* ev);</span>
<a href="#l36.114"></a><span id="l36.114" class="difflineat">@@ -128,17 +128,17 @@ public: // interface supporting mdbObjec</span>
<a href="#l36.115"></a><span id="l36.115">   nsresult Handle_CloseMdbObject(nsIMdbEnv* ev);</span>
<a href="#l36.116"></a><span id="l36.116">   nsresult Handle_IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen);</span>
<a href="#l36.117"></a><span id="l36.117">   // } ----- end mdbObject style methods -----</span>
<a href="#l36.118"></a><span id="l36.118"> </span>
<a href="#l36.119"></a><span id="l36.119"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l36.120"></a><span id="l36.120">   static void SlotWeakHandle(morkHandle* me,</span>
<a href="#l36.121"></a><span id="l36.121">     morkEnv* ev, morkHandle** ioSlot)</span>
<a href="#l36.122"></a><span id="l36.122">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l36.123"></a><span id="l36.123" class="difflineminus">-  </span>
<a href="#l36.124"></a><span id="l36.124" class="difflineplus">+</span>
<a href="#l36.125"></a><span id="l36.125">   static void SlotStrongHandle(morkHandle* me,</span>
<a href="#l36.126"></a><span id="l36.126">     morkEnv* ev, morkHandle** ioSlot)</span>
<a href="#l36.127"></a><span id="l36.127">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l36.128"></a><span id="l36.128"> };</span>
<a href="#l36.129"></a><span id="l36.129"> </span>
<a href="#l36.130"></a><span id="l36.130"> #define morkHandleFrame_kPadSlotCount 4</span>
<a href="#l36.131"></a><span id="l36.131"> </span>
<a href="#l36.132"></a><span id="l36.132"> /*| morkHandleFrame: an object format used for allocating and maintaining</span>
<a href="#l36.133"></a><span id="l36.133" class="difflineat">@@ -149,28 +149,28 @@ public: // typesafe refcounting inlines </span>
<a href="#l36.134"></a><span id="l36.134"> **| to multiply inherit from another base class that has only abstact methods</span>
<a href="#l36.135"></a><span id="l36.135"> **| for space overhead related only to some vtable representation).</span>
<a href="#l36.136"></a><span id="l36.136"> |*/</span>
<a href="#l36.137"></a><span id="l36.137"> class morkHandleFrame {</span>
<a href="#l36.138"></a><span id="l36.138"> public:</span>
<a href="#l36.139"></a><span id="l36.139">   morkLink    mHandleFrame_Link;    // list storage without trampling Handle</span>
<a href="#l36.140"></a><span id="l36.140">   morkHandle  mHandleFrame_Handle;</span>
<a href="#l36.141"></a><span id="l36.141">   mork_ip     mHandleFrame_Padding[ morkHandleFrame_kPadSlotCount ];</span>
<a href="#l36.142"></a><span id="l36.142" class="difflineminus">-  </span>
<a href="#l36.143"></a><span id="l36.143" class="difflineplus">+</span>
<a href="#l36.144"></a><span id="l36.144"> public:</span>
<a href="#l36.145"></a><span id="l36.145">   morkHandle*  AsHandle() { return &amp;mHandleFrame_Handle; }</span>
<a href="#l36.146"></a><span id="l36.146" class="difflineminus">-  </span>
<a href="#l36.147"></a><span id="l36.147" class="difflineplus">+</span>
<a href="#l36.148"></a><span id="l36.148">   morkHandleFrame() {}  // actually, morkHandleFrame never gets constructed</span>
<a href="#l36.149"></a><span id="l36.149"> </span>
<a href="#l36.150"></a><span id="l36.150"> private: // copying is not allowed</span>
<a href="#l36.151"></a><span id="l36.151">   morkHandleFrame(const morkHandleFrame&amp; other);</span>
<a href="#l36.152"></a><span id="l36.152">   morkHandleFrame&amp; operator=(const morkHandleFrame&amp; other);</span>
<a href="#l36.153"></a><span id="l36.153"> };</span>
<a href="#l36.154"></a><span id="l36.154"> </span>
<a href="#l36.155"></a><span id="l36.155"> #define morkHandleFrame_kHandleOffset \</span>
<a href="#l36.156"></a><span id="l36.156">   mork_OffsetOf(morkHandleFrame,mHandleFrame_Handle)</span>
<a href="#l36.157"></a><span id="l36.157" class="difflineminus">-  </span>
<a href="#l36.158"></a><span id="l36.158" class="difflineplus">+</span>
<a href="#l36.159"></a><span id="l36.159"> #define morkHandle_AsHandleFrame(h) ((h)-&gt;mHandle_Block , \</span>
<a href="#l36.160"></a><span id="l36.160">  ((morkHandleFrame*) (((mork_u1*)(h)) - morkHandleFrame_kHandleOffset)))</span>
<a href="#l36.161"></a><span id="l36.161"> </span>
<a href="#l36.162"></a><span id="l36.162"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l36.163"></a><span id="l36.163"> </span>
<a href="#l36.164"></a><span id="l36.164"> #endif /* _MORKHANDLE_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l37.1"></a><span id="l37.1" class="difflineminus">--- a/db/mork/src/morkIntMap.cpp</span>
<a href="#l37.2"></a><span id="l37.2" class="difflineplus">+++ b/db/mork/src/morkIntMap.cpp</span>
<a href="#l37.3"></a><span id="l37.3" class="difflineat">@@ -24,17 +24,17 @@</span>
<a href="#l37.4"></a><span id="l37.4"> #endif</span>
<a href="#l37.5"></a><span id="l37.5"> </span>
<a href="#l37.6"></a><span id="l37.6"> #ifndef _MORKINTMAP_</span>
<a href="#l37.7"></a><span id="l37.7"> #include &quot;morkIntMap.h&quot;</span>
<a href="#l37.8"></a><span id="l37.8"> #endif</span>
<a href="#l37.9"></a><span id="l37.9"> </span>
<a href="#l37.10"></a><span id="l37.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l37.11"></a><span id="l37.11"> </span>
<a href="#l37.12"></a><span id="l37.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l37.13"></a><span id="l37.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l37.14"></a><span id="l37.14"> // { ===== begin morkNode interface =====</span>
<a href="#l37.15"></a><span id="l37.15"> </span>
<a href="#l37.16"></a><span id="l37.16"> /*public virtual*/ void</span>
<a href="#l37.17"></a><span id="l37.17"> morkIntMap::CloseMorkNode(morkEnv* ev) // CloseIntMap() only if open</span>
<a href="#l37.18"></a><span id="l37.18"> {</span>
<a href="#l37.19"></a><span id="l37.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l37.20"></a><span id="l37.20">   {</span>
<a href="#l37.21"></a><span id="l37.21">     this-&gt;MarkClosing();</span>
<a href="#l37.22"></a><span id="l37.22" class="difflineat">@@ -68,17 +68,17 @@ morkIntMap::CloseIntMap(morkEnv* ev) // </span>
<a href="#l37.23"></a><span id="l37.23">       this-&gt;CloseMap(ev);</span>
<a href="#l37.24"></a><span id="l37.24">       this-&gt;MarkShut();</span>
<a href="#l37.25"></a><span id="l37.25">     }</span>
<a href="#l37.26"></a><span id="l37.26">     else</span>
<a href="#l37.27"></a><span id="l37.27">       this-&gt;NonNodeError(ev);</span>
<a href="#l37.28"></a><span id="l37.28"> }</span>
<a href="#l37.29"></a><span id="l37.29"> </span>
<a href="#l37.30"></a><span id="l37.30"> // } ===== end morkNode methods =====</span>
<a href="#l37.31"></a><span id="l37.31" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l37.32"></a><span id="l37.32" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l37.33"></a><span id="l37.33"> </span>
<a href="#l37.34"></a><span id="l37.34"> // { ===== begin morkMap poly interface =====</span>
<a href="#l37.35"></a><span id="l37.35"> /*virtual*/ mork_bool // *((mork_u4*) inKeyA) == *((mork_u4*) inKeyB)</span>
<a href="#l37.36"></a><span id="l37.36"> morkIntMap::Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const</span>
<a href="#l37.37"></a><span id="l37.37"> {</span>
<a href="#l37.38"></a><span id="l37.38">   MORK_USED_1(ev);</span>
<a href="#l37.39"></a><span id="l37.39">   return *((const mork_u4*) inKeyA) == *((const mork_u4*) inKeyB);</span>
<a href="#l37.40"></a><span id="l37.40"> }</span>
<a href="#l37.41"></a><span id="l37.41" class="difflineat">@@ -92,53 +92,53 @@ morkIntMap::Hash(morkEnv* ev, const void</span>
<a href="#l37.42"></a><span id="l37.42"> // } ===== end morkMap poly interface =====</span>
<a href="#l37.43"></a><span id="l37.43"> </span>
<a href="#l37.44"></a><span id="l37.44"> mork_bool</span>
<a href="#l37.45"></a><span id="l37.45"> morkIntMap::AddInt(morkEnv* ev, mork_u4 inKey, void* ioAddress)</span>
<a href="#l37.46"></a><span id="l37.46">   // the AddInt() method return value equals ev-&gt;Good().</span>
<a href="#l37.47"></a><span id="l37.47"> {</span>
<a href="#l37.48"></a><span id="l37.48">   if ( ev-&gt;Good() )</span>
<a href="#l37.49"></a><span id="l37.49">   {</span>
<a href="#l37.50"></a><span id="l37.50" class="difflineminus">-    this-&gt;Put(ev, &amp;inKey, &amp;ioAddress, </span>
<a href="#l37.51"></a><span id="l37.51" class="difflineplus">+    this-&gt;Put(ev, &amp;inKey, &amp;ioAddress,</span>
<a href="#l37.52"></a><span id="l37.52">       /*key*/ (void*) 0, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l37.53"></a><span id="l37.53">   }</span>
<a href="#l37.54"></a><span id="l37.54" class="difflineminus">-    </span>
<a href="#l37.55"></a><span id="l37.55" class="difflineplus">+</span>
<a href="#l37.56"></a><span id="l37.56">   return ev-&gt;Good();</span>
<a href="#l37.57"></a><span id="l37.57"> }</span>
<a href="#l37.58"></a><span id="l37.58"> </span>
<a href="#l37.59"></a><span id="l37.59"> mork_bool</span>
<a href="#l37.60"></a><span id="l37.60"> morkIntMap::CutInt(morkEnv* ev, mork_u4 inKey)</span>
<a href="#l37.61"></a><span id="l37.61"> {</span>
<a href="#l37.62"></a><span id="l37.62">   return this-&gt;Cut(ev, &amp;inKey, /*key*/ (void*) 0, /*val*/ (void*) 0,</span>
<a href="#l37.63"></a><span id="l37.63">     (mork_change**) 0);</span>
<a href="#l37.64"></a><span id="l37.64"> }</span>
<a href="#l37.65"></a><span id="l37.65"> </span>
<a href="#l37.66"></a><span id="l37.66"> void*</span>
<a href="#l37.67"></a><span id="l37.67"> morkIntMap::GetInt(morkEnv* ev, mork_u4 inKey)</span>
<a href="#l37.68"></a><span id="l37.68">   // Note the returned val does NOT have an increase in refcount for this.</span>
<a href="#l37.69"></a><span id="l37.69"> {</span>
<a href="#l37.70"></a><span id="l37.70">   void* val = 0; // old val in the map</span>
<a href="#l37.71"></a><span id="l37.71">   this-&gt;Get(ev, &amp;inKey, /*key*/ (void*) 0, &amp;val, (mork_change**) 0);</span>
<a href="#l37.72"></a><span id="l37.72" class="difflineminus">-  </span>
<a href="#l37.73"></a><span id="l37.73" class="difflineplus">+</span>
<a href="#l37.74"></a><span id="l37.74">   return val;</span>
<a href="#l37.75"></a><span id="l37.75"> }</span>
<a href="#l37.76"></a><span id="l37.76"> </span>
<a href="#l37.77"></a><span id="l37.77"> mork_bool</span>
<a href="#l37.78"></a><span id="l37.78"> morkIntMap::HasInt(morkEnv* ev, mork_u4 inKey)</span>
<a href="#l37.79"></a><span id="l37.79">   // Note the returned val does NOT have an increase in refcount for this.</span>
<a href="#l37.80"></a><span id="l37.80"> {</span>
<a href="#l37.81"></a><span id="l37.81" class="difflineminus">-  return this-&gt;Get(ev, &amp;inKey, /*key*/ (void*) 0, /*val*/ (void*) 0, </span>
<a href="#l37.82"></a><span id="l37.82" class="difflineplus">+  return this-&gt;Get(ev, &amp;inKey, /*key*/ (void*) 0, /*val*/ (void*) 0,</span>
<a href="#l37.83"></a><span id="l37.83">     (mork_change**) 0);</span>
<a href="#l37.84"></a><span id="l37.84"> }</span>
<a href="#l37.85"></a><span id="l37.85"> </span>
<a href="#l37.86"></a><span id="l37.86"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l37.87"></a><span id="l37.87"> </span>
<a href="#l37.88"></a><span id="l37.88"> #ifdef MORK_POINTER_MAP_IMPL</span>
<a href="#l37.89"></a><span id="l37.89"> </span>
<a href="#l37.90"></a><span id="l37.90" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l37.91"></a><span id="l37.91" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l37.92"></a><span id="l37.92"> // { ===== begin morkNode interface =====</span>
<a href="#l37.93"></a><span id="l37.93"> </span>
<a href="#l37.94"></a><span id="l37.94"> /*public virtual*/ void</span>
<a href="#l37.95"></a><span id="l37.95"> morkPointerMap::CloseMorkNode(morkEnv* ev) // ClosePointerMap() only if open</span>
<a href="#l37.96"></a><span id="l37.96"> {</span>
<a href="#l37.97"></a><span id="l37.97">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l37.98"></a><span id="l37.98">   {</span>
<a href="#l37.99"></a><span id="l37.99">     this-&gt;MarkClosing();</span>
<a href="#l37.100"></a><span id="l37.100" class="difflineat">@@ -172,17 +172,17 @@ morkPointerMap::ClosePointerMap(morkEnv*</span>
<a href="#l37.101"></a><span id="l37.101">       this-&gt;CloseMap(ev);</span>
<a href="#l37.102"></a><span id="l37.102">       this-&gt;MarkShut();</span>
<a href="#l37.103"></a><span id="l37.103">     }</span>
<a href="#l37.104"></a><span id="l37.104">     else</span>
<a href="#l37.105"></a><span id="l37.105">       this-&gt;NonNodeError(ev);</span>
<a href="#l37.106"></a><span id="l37.106"> }</span>
<a href="#l37.107"></a><span id="l37.107"> </span>
<a href="#l37.108"></a><span id="l37.108"> // } ===== end morkNode methods =====</span>
<a href="#l37.109"></a><span id="l37.109" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l37.110"></a><span id="l37.110" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l37.111"></a><span id="l37.111"> </span>
<a href="#l37.112"></a><span id="l37.112"> // { ===== begin morkMap poly interface =====</span>
<a href="#l37.113"></a><span id="l37.113"> /*virtual*/ mork_bool // *((void**) inKeyA) == *((void**) inKeyB)</span>
<a href="#l37.114"></a><span id="l37.114"> morkPointerMap::Equal(morkEnv* ev, const void* inKeyA, const void* inKeyB) const</span>
<a href="#l37.115"></a><span id="l37.115"> {</span>
<a href="#l37.116"></a><span id="l37.116">   MORK_USED_1(ev);</span>
<a href="#l37.117"></a><span id="l37.117">   return *((const void**) inKeyA) == *((const void**) inKeyB);</span>
<a href="#l37.118"></a><span id="l37.118"> }</span>
<a href="#l37.119"></a><span id="l37.119" class="difflineat">@@ -196,43 +196,43 @@ morkPointerMap::Hash(morkEnv* ev, const </span>
<a href="#l37.120"></a><span id="l37.120"> // } ===== end morkMap poly interface =====</span>
<a href="#l37.121"></a><span id="l37.121"> </span>
<a href="#l37.122"></a><span id="l37.122"> mork_bool</span>
<a href="#l37.123"></a><span id="l37.123"> morkPointerMap::AddPointer(morkEnv* ev, void* inKey, void* ioAddress)</span>
<a href="#l37.124"></a><span id="l37.124">   // the AddPointer() method return value equals ev-&gt;Good().</span>
<a href="#l37.125"></a><span id="l37.125"> {</span>
<a href="#l37.126"></a><span id="l37.126">   if ( ev-&gt;Good() )</span>
<a href="#l37.127"></a><span id="l37.127">   {</span>
<a href="#l37.128"></a><span id="l37.128" class="difflineminus">-    this-&gt;Put(ev, &amp;inKey, &amp;ioAddress, </span>
<a href="#l37.129"></a><span id="l37.129" class="difflineplus">+    this-&gt;Put(ev, &amp;inKey, &amp;ioAddress,</span>
<a href="#l37.130"></a><span id="l37.130">       /*key*/ (void*) 0, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l37.131"></a><span id="l37.131">   }</span>
<a href="#l37.132"></a><span id="l37.132" class="difflineminus">-    </span>
<a href="#l37.133"></a><span id="l37.133" class="difflineplus">+</span>
<a href="#l37.134"></a><span id="l37.134">   return ev-&gt;Good();</span>
<a href="#l37.135"></a><span id="l37.135"> }</span>
<a href="#l37.136"></a><span id="l37.136"> </span>
<a href="#l37.137"></a><span id="l37.137"> mork_bool</span>
<a href="#l37.138"></a><span id="l37.138"> morkPointerMap::CutPointer(morkEnv* ev, void* inKey)</span>
<a href="#l37.139"></a><span id="l37.139"> {</span>
<a href="#l37.140"></a><span id="l37.140">   return this-&gt;Cut(ev, &amp;inKey, /*key*/ (void*) 0, /*val*/ (void*) 0,</span>
<a href="#l37.141"></a><span id="l37.141">     (mork_change**) 0);</span>
<a href="#l37.142"></a><span id="l37.142"> }</span>
<a href="#l37.143"></a><span id="l37.143"> </span>
<a href="#l37.144"></a><span id="l37.144"> void*</span>
<a href="#l37.145"></a><span id="l37.145"> morkPointerMap::GetPointer(morkEnv* ev, void* inKey)</span>
<a href="#l37.146"></a><span id="l37.146">   // Note the returned val does NOT have an increase in refcount for this.</span>
<a href="#l37.147"></a><span id="l37.147"> {</span>
<a href="#l37.148"></a><span id="l37.148">   void* val = 0; // old val in the map</span>
<a href="#l37.149"></a><span id="l37.149">   this-&gt;Get(ev, &amp;inKey, /*key*/ (void*) 0, &amp;val, (mork_change**) 0);</span>
<a href="#l37.150"></a><span id="l37.150" class="difflineminus">-  </span>
<a href="#l37.151"></a><span id="l37.151" class="difflineplus">+</span>
<a href="#l37.152"></a><span id="l37.152">   return val;</span>
<a href="#l37.153"></a><span id="l37.153"> }</span>
<a href="#l37.154"></a><span id="l37.154"> </span>
<a href="#l37.155"></a><span id="l37.155"> mork_bool</span>
<a href="#l37.156"></a><span id="l37.156"> morkPointerMap::HasPointer(morkEnv* ev, void* inKey)</span>
<a href="#l37.157"></a><span id="l37.157">   // Note the returned val does NOT have an increase in refcount for this.</span>
<a href="#l37.158"></a><span id="l37.158"> {</span>
<a href="#l37.159"></a><span id="l37.159" class="difflineminus">-  return this-&gt;Get(ev, &amp;inKey, /*key*/ (void*) 0, /*val*/ (void*) 0, </span>
<a href="#l37.160"></a><span id="l37.160" class="difflineplus">+  return this-&gt;Get(ev, &amp;inKey, /*key*/ (void*) 0, /*val*/ (void*) 0,</span>
<a href="#l37.161"></a><span id="l37.161">     (mork_change**) 0);</span>
<a href="#l37.162"></a><span id="l37.162"> }</span>
<a href="#l37.163"></a><span id="l37.163"> #endif /*MORK_POINTER_MAP_IMPL*/</span>
<a href="#l37.164"></a><span id="l37.164"> </span>
<a href="#l37.165"></a><span id="l37.165"> </span>
<a href="#l37.166"></a><span id="l37.166"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l38.1"></a><span id="l38.1" class="difflineminus">--- a/db/mork/src/morkIntMap.h</span>
<a href="#l38.2"></a><span id="l38.2" class="difflineplus">+++ b/db/mork/src/morkIntMap.h</span>
<a href="#l38.3"></a><span id="l38.3" class="difflineat">@@ -27,17 +27,17 @@</span>
<a href="#l38.4"></a><span id="l38.4"> /*| morkIntMap: maps mork_token -&gt; morkNode</span>
<a href="#l38.5"></a><span id="l38.5"> |*/</span>
<a href="#l38.6"></a><span id="l38.6"> class morkIntMap : public morkMap { // for mapping tokens to maps</span>
<a href="#l38.7"></a><span id="l38.7"> </span>
<a href="#l38.8"></a><span id="l38.8"> // { ===== begin morkNode interface =====</span>
<a href="#l38.9"></a><span id="l38.9"> public: // morkNode virtual methods</span>
<a href="#l38.10"></a><span id="l38.10">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseIntMap() only if open</span>
<a href="#l38.11"></a><span id="l38.11">   virtual ~morkIntMap(); // assert that CloseIntMap() executed earlier</span>
<a href="#l38.12"></a><span id="l38.12" class="difflineminus">-  </span>
<a href="#l38.13"></a><span id="l38.13" class="difflineplus">+</span>
<a href="#l38.14"></a><span id="l38.14"> public: // morkMap construction &amp; destruction</span>
<a href="#l38.15"></a><span id="l38.15"> </span>
<a href="#l38.16"></a><span id="l38.16">   // keySize for morkIntMap equals sizeof(mork_u4)</span>
<a href="#l38.17"></a><span id="l38.17">   morkIntMap(morkEnv* ev, const morkUsage&amp; inUsage, mork_size inValSize,</span>
<a href="#l38.18"></a><span id="l38.18">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap, mork_bool inHoldChanges);</span>
<a href="#l38.19"></a><span id="l38.19">   void CloseIntMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l38.20"></a><span id="l38.20"> </span>
<a href="#l38.21"></a><span id="l38.21"> public: // dynamic type identification</span>
<a href="#l38.22"></a><span id="l38.22" class="difflineat">@@ -54,21 +54,21 @@ public: // dynamic type identification</span>
<a href="#l38.23"></a><span id="l38.23"> // } ===== end morkMap poly interface =====</span>
<a href="#l38.24"></a><span id="l38.24"> </span>
<a href="#l38.25"></a><span id="l38.25"> public: // other map methods</span>
<a href="#l38.26"></a><span id="l38.26"> </span>
<a href="#l38.27"></a><span id="l38.27">   mork_bool  AddInt(morkEnv* ev, mork_u4 inKey, void* ioAddress);</span>
<a href="#l38.28"></a><span id="l38.28">   // the AddInt() boolean return equals ev-&gt;Good().</span>
<a href="#l38.29"></a><span id="l38.29"> </span>
<a href="#l38.30"></a><span id="l38.30">   mork_bool  CutInt(morkEnv* ev, mork_u4 inKey);</span>
<a href="#l38.31"></a><span id="l38.31" class="difflineminus">-  // The CutInt() boolean return indicates whether removal happened. </span>
<a href="#l38.32"></a><span id="l38.32" class="difflineminus">-  </span>
<a href="#l38.33"></a><span id="l38.33" class="difflineplus">+  // The CutInt() boolean return indicates whether removal happened.</span>
<a href="#l38.34"></a><span id="l38.34" class="difflineplus">+</span>
<a href="#l38.35"></a><span id="l38.35">   void*      GetInt(morkEnv* ev, mork_u4 inKey);</span>
<a href="#l38.36"></a><span id="l38.36">   // Note the returned node does NOT have an increase in refcount for this.</span>
<a href="#l38.37"></a><span id="l38.37" class="difflineminus">-  </span>
<a href="#l38.38"></a><span id="l38.38" class="difflineplus">+</span>
<a href="#l38.39"></a><span id="l38.39">   mork_bool  HasInt(morkEnv* ev, mork_u4 inKey);</span>
<a href="#l38.40"></a><span id="l38.40">   // Note the returned node does NOT have an increase in refcount for this.</span>
<a href="#l38.41"></a><span id="l38.41"> </span>
<a href="#l38.42"></a><span id="l38.42"> };</span>
<a href="#l38.43"></a><span id="l38.43"> </span>
<a href="#l38.44"></a><span id="l38.44"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l38.45"></a><span id="l38.45"> </span>
<a href="#l38.46"></a><span id="l38.46"> #ifdef MORK_POINTER_MAP_IMPL</span>
<a href="#l38.47"></a><span id="l38.47" class="difflineat">@@ -87,17 +87,17 @@ public: // other map methods</span>
<a href="#l38.48"></a><span id="l38.48"> **| morkPointerMap for hash tables using pointer key types.</span>
<a href="#l38.49"></a><span id="l38.49"> |*/</span>
<a href="#l38.50"></a><span id="l38.50"> class morkPointerMap : public morkMap { // for mapping tokens to maps</span>
<a href="#l38.51"></a><span id="l38.51"> </span>
<a href="#l38.52"></a><span id="l38.52"> // { ===== begin morkNode interface =====</span>
<a href="#l38.53"></a><span id="l38.53"> public: // morkNode virtual methods</span>
<a href="#l38.54"></a><span id="l38.54">   virtual void CloseMorkNode(morkEnv* ev) override; // ClosePointerMap() only if open</span>
<a href="#l38.55"></a><span id="l38.55">   virtual ~morkPointerMap(); // assert that ClosePointerMap() executed earlier</span>
<a href="#l38.56"></a><span id="l38.56" class="difflineminus">-  </span>
<a href="#l38.57"></a><span id="l38.57" class="difflineplus">+</span>
<a href="#l38.58"></a><span id="l38.58"> public: // morkMap construction &amp; destruction</span>
<a href="#l38.59"></a><span id="l38.59"> </span>
<a href="#l38.60"></a><span id="l38.60">   // keySize for morkPointerMap equals sizeof(mork_u4)</span>
<a href="#l38.61"></a><span id="l38.61">   morkPointerMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l38.62"></a><span id="l38.62">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l38.63"></a><span id="l38.63">   void ClosePointerMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l38.64"></a><span id="l38.64"> </span>
<a href="#l38.65"></a><span id="l38.65"> public: // dynamic type identification</span>
<a href="#l38.66"></a><span id="l38.66" class="difflineat">@@ -114,29 +114,29 @@ public: // dynamic type identification</span>
<a href="#l38.67"></a><span id="l38.67"> // } ===== end morkMap poly interface =====</span>
<a href="#l38.68"></a><span id="l38.68"> </span>
<a href="#l38.69"></a><span id="l38.69"> public: // other map methods</span>
<a href="#l38.70"></a><span id="l38.70"> </span>
<a href="#l38.71"></a><span id="l38.71">   mork_bool  AddPointer(morkEnv* ev, void* inKey, void* ioAddress);</span>
<a href="#l38.72"></a><span id="l38.72">   // the AddPointer() boolean return equals ev-&gt;Good().</span>
<a href="#l38.73"></a><span id="l38.73"> </span>
<a href="#l38.74"></a><span id="l38.74">   mork_bool  CutPointer(morkEnv* ev, void* inKey);</span>
<a href="#l38.75"></a><span id="l38.75" class="difflineminus">-  // The CutPointer() boolean return indicates whether removal happened. </span>
<a href="#l38.76"></a><span id="l38.76" class="difflineminus">-  </span>
<a href="#l38.77"></a><span id="l38.77" class="difflineplus">+  // The CutPointer() boolean return indicates whether removal happened.</span>
<a href="#l38.78"></a><span id="l38.78" class="difflineplus">+</span>
<a href="#l38.79"></a><span id="l38.79">   void*      GetPointer(morkEnv* ev, void* inKey);</span>
<a href="#l38.80"></a><span id="l38.80">   // Note the returned node does NOT have an increase in refcount for this.</span>
<a href="#l38.81"></a><span id="l38.81" class="difflineminus">-  </span>
<a href="#l38.82"></a><span id="l38.82" class="difflineplus">+</span>
<a href="#l38.83"></a><span id="l38.83">   mork_bool  HasPointer(morkEnv* ev, void* inKey);</span>
<a href="#l38.84"></a><span id="l38.84">   // Note the returned node does NOT have an increase in refcount for this.</span>
<a href="#l38.85"></a><span id="l38.85"> </span>
<a href="#l38.86"></a><span id="l38.86"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l38.87"></a><span id="l38.87">   static void SlotWeakIntMap(morkIntMap* me,</span>
<a href="#l38.88"></a><span id="l38.88">     morkEnv* ev, morkIntMap** ioSlot)</span>
<a href="#l38.89"></a><span id="l38.89">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l38.90"></a><span id="l38.90" class="difflineminus">-  </span>
<a href="#l38.91"></a><span id="l38.91" class="difflineplus">+</span>
<a href="#l38.92"></a><span id="l38.92">   static void SlotStrongIntMap(morkIntMap* me,</span>
<a href="#l38.93"></a><span id="l38.93">     morkEnv* ev, morkIntMap** ioSlot)</span>
<a href="#l38.94"></a><span id="l38.94">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l38.95"></a><span id="l38.95"> </span>
<a href="#l38.96"></a><span id="l38.96"> };</span>
<a href="#l38.97"></a><span id="l38.97"> #endif /*MORK_POINTER_MAP_IMPL*/</span>
<a href="#l38.98"></a><span id="l38.98"> </span>
<a href="#l38.99"></a><span id="l38.99"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l39.1"></a><span id="l39.1" class="difflineminus">--- a/db/mork/src/morkMap.cpp</span>
<a href="#l39.2"></a><span id="l39.2" class="difflineplus">+++ b/db/mork/src/morkMap.cpp</span>
<a href="#l39.3"></a><span id="l39.3" class="difflineat">@@ -58,33 +58,33 @@</span>
<a href="#l39.4"></a><span id="l39.4"> #include &quot;morkEnv.h&quot;</span>
<a href="#l39.5"></a><span id="l39.5"> #endif</span>
<a href="#l39.6"></a><span id="l39.6"> </span>
<a href="#l39.7"></a><span id="l39.7"> </span>
<a href="#l39.8"></a><span id="l39.8"> class morkHashArrays {</span>
<a href="#l39.9"></a><span id="l39.9"> public:</span>
<a href="#l39.10"></a><span id="l39.10">   nsIMdbHeap*   mHashArrays_Heap;     // copy of mMap_Heap</span>
<a href="#l39.11"></a><span id="l39.11">   mork_count    mHashArrays_Slots;    // copy of mMap_Slots</span>
<a href="#l39.12"></a><span id="l39.12" class="difflineminus">-  </span>
<a href="#l39.13"></a><span id="l39.13" class="difflineplus">+</span>
<a href="#l39.14"></a><span id="l39.14">   mork_u1*      mHashArrays_Keys;     // copy of mMap_Keys</span>
<a href="#l39.15"></a><span id="l39.15">   mork_u1*      mHashArrays_Vals;     // copy of mMap_Vals</span>
<a href="#l39.16"></a><span id="l39.16">   morkAssoc*    mHashArrays_Assocs;   // copy of mMap_Assocs</span>
<a href="#l39.17"></a><span id="l39.17">   mork_change*  mHashArrays_Changes;  // copy of mMap_Changes</span>
<a href="#l39.18"></a><span id="l39.18">   morkAssoc**   mHashArrays_Buckets;  // copy of mMap_Buckets</span>
<a href="#l39.19"></a><span id="l39.19">   morkAssoc*    mHashArrays_FreeList; // copy of mMap_FreeList</span>
<a href="#l39.20"></a><span id="l39.20" class="difflineminus">-  </span>
<a href="#l39.21"></a><span id="l39.21" class="difflineplus">+</span>
<a href="#l39.22"></a><span id="l39.22"> public:</span>
<a href="#l39.23"></a><span id="l39.23">   void finalize(morkEnv* ev);</span>
<a href="#l39.24"></a><span id="l39.24"> };</span>
<a href="#l39.25"></a><span id="l39.25"> </span>
<a href="#l39.26"></a><span id="l39.26"> void morkHashArrays::finalize(morkEnv* ev)</span>
<a href="#l39.27"></a><span id="l39.27"> {</span>
<a href="#l39.28"></a><span id="l39.28">   nsIMdbEnv* menv = ev-&gt;AsMdbEnv();</span>
<a href="#l39.29"></a><span id="l39.29">   nsIMdbHeap* heap = mHashArrays_Heap;</span>
<a href="#l39.30"></a><span id="l39.30" class="difflineminus">-  </span>
<a href="#l39.31"></a><span id="l39.31" class="difflineplus">+</span>
<a href="#l39.32"></a><span id="l39.32">   if ( heap )</span>
<a href="#l39.33"></a><span id="l39.33">   {</span>
<a href="#l39.34"></a><span id="l39.34">     if ( mHashArrays_Keys )</span>
<a href="#l39.35"></a><span id="l39.35">       heap-&gt;Free(menv, mHashArrays_Keys);</span>
<a href="#l39.36"></a><span id="l39.36">     if ( mHashArrays_Vals )</span>
<a href="#l39.37"></a><span id="l39.37">       heap-&gt;Free(menv, mHashArrays_Vals);</span>
<a href="#l39.38"></a><span id="l39.38">     if ( mHashArrays_Assocs )</span>
<a href="#l39.39"></a><span id="l39.39">       heap-&gt;Free(menv, mHashArrays_Assocs);</span>
<a href="#l39.40"></a><span id="l39.40" class="difflineat">@@ -92,17 +92,17 @@ void morkHashArrays::finalize(morkEnv* e</span>
<a href="#l39.41"></a><span id="l39.41">       heap-&gt;Free(menv, mHashArrays_Changes);</span>
<a href="#l39.42"></a><span id="l39.42">     if ( mHashArrays_Buckets )</span>
<a href="#l39.43"></a><span id="l39.43">       heap-&gt;Free(menv, mHashArrays_Buckets);</span>
<a href="#l39.44"></a><span id="l39.44">   }</span>
<a href="#l39.45"></a><span id="l39.45"> }</span>
<a href="#l39.46"></a><span id="l39.46"> </span>
<a href="#l39.47"></a><span id="l39.47"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l39.48"></a><span id="l39.48"> </span>
<a href="#l39.49"></a><span id="l39.49" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l39.50"></a><span id="l39.50" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l39.51"></a><span id="l39.51"> // { ===== begin morkNode interface =====</span>
<a href="#l39.52"></a><span id="l39.52"> </span>
<a href="#l39.53"></a><span id="l39.53"> /*public virtual*/ void</span>
<a href="#l39.54"></a><span id="l39.54"> morkMap::CloseMorkNode(morkEnv* ev) // CloseMap() only if open</span>
<a href="#l39.55"></a><span id="l39.55"> {</span>
<a href="#l39.56"></a><span id="l39.56">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l39.57"></a><span id="l39.57">   {</span>
<a href="#l39.58"></a><span id="l39.58">     this-&gt;MarkClosing();</span>
<a href="#l39.59"></a><span id="l39.59" class="difflineat">@@ -126,29 +126,29 @@ morkMap::~morkMap() // assert CloseMap()</span>
<a href="#l39.60"></a><span id="l39.60"> morkMap::CloseMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l39.61"></a><span id="l39.61"> {</span>
<a href="#l39.62"></a><span id="l39.62">     if ( this-&gt;IsNode() )</span>
<a href="#l39.63"></a><span id="l39.63">     {</span>
<a href="#l39.64"></a><span id="l39.64">       nsIMdbHeap* heap = mMap_Heap;</span>
<a href="#l39.65"></a><span id="l39.65">       if ( heap ) /* need to free the arrays? */</span>
<a href="#l39.66"></a><span id="l39.66">       {</span>
<a href="#l39.67"></a><span id="l39.67">         nsIMdbEnv* menv = ev-&gt;AsMdbEnv();</span>
<a href="#l39.68"></a><span id="l39.68" class="difflineminus">-        </span>
<a href="#l39.69"></a><span id="l39.69" class="difflineplus">+</span>
<a href="#l39.70"></a><span id="l39.70">         if ( mMap_Keys )</span>
<a href="#l39.71"></a><span id="l39.71">           heap-&gt;Free(menv, mMap_Keys);</span>
<a href="#l39.72"></a><span id="l39.72" class="difflineminus">-          </span>
<a href="#l39.73"></a><span id="l39.73" class="difflineplus">+</span>
<a href="#l39.74"></a><span id="l39.74">         if ( mMap_Vals )</span>
<a href="#l39.75"></a><span id="l39.75">           heap-&gt;Free(menv, mMap_Vals);</span>
<a href="#l39.76"></a><span id="l39.76" class="difflineminus">-          </span>
<a href="#l39.77"></a><span id="l39.77" class="difflineplus">+</span>
<a href="#l39.78"></a><span id="l39.78">         if ( mMap_Assocs )</span>
<a href="#l39.79"></a><span id="l39.79">           heap-&gt;Free(menv, mMap_Assocs);</span>
<a href="#l39.80"></a><span id="l39.80" class="difflineminus">-          </span>
<a href="#l39.81"></a><span id="l39.81" class="difflineplus">+</span>
<a href="#l39.82"></a><span id="l39.82">         if ( mMap_Buckets )</span>
<a href="#l39.83"></a><span id="l39.83">           heap-&gt;Free(menv, mMap_Buckets);</span>
<a href="#l39.84"></a><span id="l39.84" class="difflineminus">-          </span>
<a href="#l39.85"></a><span id="l39.85" class="difflineplus">+</span>
<a href="#l39.86"></a><span id="l39.86">         if ( mMap_Changes )</span>
<a href="#l39.87"></a><span id="l39.87">           heap-&gt;Free(menv, mMap_Changes);</span>
<a href="#l39.88"></a><span id="l39.88">       }</span>
<a href="#l39.89"></a><span id="l39.89">       mMap_Keys = 0;</span>
<a href="#l39.90"></a><span id="l39.90">       mMap_Vals = 0;</span>
<a href="#l39.91"></a><span id="l39.91">       mMap_Buckets = 0;</span>
<a href="#l39.92"></a><span id="l39.92">       mMap_Assocs = 0;</span>
<a href="#l39.93"></a><span id="l39.93">       mMap_Changes = 0;</span>
<a href="#l39.94"></a><span id="l39.94" class="difflineat">@@ -156,60 +156,60 @@ morkMap::CloseMap(morkEnv* ev) // called</span>
<a href="#l39.95"></a><span id="l39.95">       MORK_MEMSET(&amp;mMap_Form, 0, sizeof(morkMapForm));</span>
<a href="#l39.96"></a><span id="l39.96">       this-&gt;MarkShut();</span>
<a href="#l39.97"></a><span id="l39.97">     }</span>
<a href="#l39.98"></a><span id="l39.98">     else</span>
<a href="#l39.99"></a><span id="l39.99">       this-&gt;NonNodeError(ev);</span>
<a href="#l39.100"></a><span id="l39.100"> }</span>
<a href="#l39.101"></a><span id="l39.101"> </span>
<a href="#l39.102"></a><span id="l39.102"> // } ===== end morkNode methods =====</span>
<a href="#l39.103"></a><span id="l39.103" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l39.104"></a><span id="l39.104" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l39.105"></a><span id="l39.105"> </span>
<a href="#l39.106"></a><span id="l39.106"> void</span>
<a href="#l39.107"></a><span id="l39.107"> morkMap::clear_map(morkEnv* ev, nsIMdbHeap* ioSlotHeap)</span>
<a href="#l39.108"></a><span id="l39.108"> {</span>
<a href="#l39.109"></a><span id="l39.109">   mMap_Tag = 0;</span>
<a href="#l39.110"></a><span id="l39.110">   mMap_Seed = 0;</span>
<a href="#l39.111"></a><span id="l39.111">   mMap_Slots = 0;</span>
<a href="#l39.112"></a><span id="l39.112">   mMap_Fill = 0;</span>
<a href="#l39.113"></a><span id="l39.113">   mMap_Keys = 0;</span>
<a href="#l39.114"></a><span id="l39.114">   mMap_Vals = 0;</span>
<a href="#l39.115"></a><span id="l39.115">   mMap_Assocs = 0;</span>
<a href="#l39.116"></a><span id="l39.116">   mMap_Changes = 0;</span>
<a href="#l39.117"></a><span id="l39.117">   mMap_Buckets = 0;</span>
<a href="#l39.118"></a><span id="l39.118">   mMap_FreeList = 0;</span>
<a href="#l39.119"></a><span id="l39.119">   MORK_MEMSET(&amp;mMap_Form, 0, sizeof(morkMapForm));</span>
<a href="#l39.120"></a><span id="l39.120" class="difflineminus">-  </span>
<a href="#l39.121"></a><span id="l39.121" class="difflineplus">+</span>
<a href="#l39.122"></a><span id="l39.122">   mMap_Heap = 0;</span>
<a href="#l39.123"></a><span id="l39.123">   if ( ioSlotHeap )</span>
<a href="#l39.124"></a><span id="l39.124">   {</span>
<a href="#l39.125"></a><span id="l39.125">     nsIMdbHeap_SlotStrongHeap(ioSlotHeap, ev, &amp;mMap_Heap);</span>
<a href="#l39.126"></a><span id="l39.126">   }</span>
<a href="#l39.127"></a><span id="l39.127">   else</span>
<a href="#l39.128"></a><span id="l39.128">     ev-&gt;NilPointerError();</span>
<a href="#l39.129"></a><span id="l39.129"> }</span>
<a href="#l39.130"></a><span id="l39.130"> </span>
<a href="#l39.131"></a><span id="l39.131" class="difflineminus">-morkMap::morkMap(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, </span>
<a href="#l39.132"></a><span id="l39.132" class="difflineplus">+morkMap::morkMap(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l39.133"></a><span id="l39.133">   mork_size inKeySize, mork_size inValSize,</span>
<a href="#l39.134"></a><span id="l39.134">   mork_size inSlots, nsIMdbHeap* ioSlotHeap, mork_bool inHoldChanges)</span>
<a href="#l39.135"></a><span id="l39.135"> : morkNode(ev, inUsage, ioHeap)</span>
<a href="#l39.136"></a><span id="l39.136"> , mMap_Heap( 0 )</span>
<a href="#l39.137"></a><span id="l39.137"> {</span>
<a href="#l39.138"></a><span id="l39.138">   if ( ev-&gt;Good() )</span>
<a href="#l39.139"></a><span id="l39.139">   {</span>
<a href="#l39.140"></a><span id="l39.140">     this-&gt;clear_map(ev, ioSlotHeap);</span>
<a href="#l39.141"></a><span id="l39.141">     if ( ev-&gt;Good() )</span>
<a href="#l39.142"></a><span id="l39.142">     {</span>
<a href="#l39.143"></a><span id="l39.143">       mMap_Form.mMapForm_HoldChanges = inHoldChanges;</span>
<a href="#l39.144"></a><span id="l39.144" class="difflineminus">-      </span>
<a href="#l39.145"></a><span id="l39.145" class="difflineplus">+</span>
<a href="#l39.146"></a><span id="l39.146">       mMap_Form.mMapForm_KeySize = inKeySize;</span>
<a href="#l39.147"></a><span id="l39.147">       mMap_Form.mMapForm_ValSize = inValSize;</span>
<a href="#l39.148"></a><span id="l39.148">       mMap_Form.mMapForm_KeyIsIP = ( inKeySize == sizeof(mork_ip) );</span>
<a href="#l39.149"></a><span id="l39.149">       mMap_Form.mMapForm_ValIsIP = ( inValSize == sizeof(mork_ip) );</span>
<a href="#l39.150"></a><span id="l39.150" class="difflineminus">-      </span>
<a href="#l39.151"></a><span id="l39.151" class="difflineplus">+</span>
<a href="#l39.152"></a><span id="l39.152">       this-&gt;InitMap(ev, inSlots);</span>
<a href="#l39.153"></a><span id="l39.153">       if ( ev-&gt;Good() )</span>
<a href="#l39.154"></a><span id="l39.154">         mNode_Derived = morkDerived_kMap;</span>
<a href="#l39.155"></a><span id="l39.155">     }</span>
<a href="#l39.156"></a><span id="l39.156">   }</span>
<a href="#l39.157"></a><span id="l39.157"> }</span>
<a href="#l39.158"></a><span id="l39.158"> </span>
<a href="#l39.159"></a><span id="l39.159"> void</span>
<a href="#l39.160"></a><span id="l39.160" class="difflineat">@@ -233,39 +233,39 @@ void morkMap::InitMap(morkEnv* ev, mork_</span>
<a href="#l39.161"></a><span id="l39.161">   if ( ev-&gt;Good() )</span>
<a href="#l39.162"></a><span id="l39.162">   {</span>
<a href="#l39.163"></a><span id="l39.163">     morkHashArrays old;</span>
<a href="#l39.164"></a><span id="l39.164">     // MORK_MEMCPY(&amp;mMap_Form, &amp;inForm, sizeof(morkMapForm));</span>
<a href="#l39.165"></a><span id="l39.165">     if ( inSlots &lt; 3 ) /* requested capacity absurdly small? */</span>
<a href="#l39.166"></a><span id="l39.166">       inSlots = 3; /* bump it up to a minimum practical level */</span>
<a href="#l39.167"></a><span id="l39.167">     else if ( inSlots &gt; (128 * 1024) ) /* requested slots absurdly big? */</span>
<a href="#l39.168"></a><span id="l39.168">       inSlots = (128 * 1024); /* decrease it to a maximum practical level */</span>
<a href="#l39.169"></a><span id="l39.169" class="difflineminus">-      </span>
<a href="#l39.170"></a><span id="l39.170" class="difflineplus">+</span>
<a href="#l39.171"></a><span id="l39.171">     if ( this-&gt;new_arrays(ev, &amp;old, inSlots) )</span>
<a href="#l39.172"></a><span id="l39.172">       mMap_Tag = morkMap_kTag;</span>
<a href="#l39.173"></a><span id="l39.173"> </span>
<a href="#l39.174"></a><span id="l39.174">     MORK_MEMSET(&amp;old, 0, sizeof(morkHashArrays)); // do NOT finalize</span>
<a href="#l39.175"></a><span id="l39.175">   }</span>
<a href="#l39.176"></a><span id="l39.176"> }</span>
<a href="#l39.177"></a><span id="l39.177"> </span>
<a href="#l39.178"></a><span id="l39.178"> morkAssoc**</span>
<a href="#l39.179"></a><span id="l39.179"> morkMap::find(morkEnv* ev, const void* inKey, mork_u4 inHash) const</span>
<a href="#l39.180"></a><span id="l39.180"> {</span>
<a href="#l39.181"></a><span id="l39.181">   mork_u1* keys = mMap_Keys;</span>
<a href="#l39.182"></a><span id="l39.182">   mork_num keySize = this-&gt;FormKeySize();</span>
<a href="#l39.183"></a><span id="l39.183">   // morkMap_mEqual equal = this-&gt;FormEqual();</span>
<a href="#l39.184"></a><span id="l39.184" class="difflineminus">-  </span>
<a href="#l39.185"></a><span id="l39.185" class="difflineplus">+</span>
<a href="#l39.186"></a><span id="l39.186">   morkAssoc** ref = mMap_Buckets + (inHash % mMap_Slots);</span>
<a href="#l39.187"></a><span id="l39.187">   morkAssoc* assoc = *ref;</span>
<a href="#l39.188"></a><span id="l39.188">   while ( assoc ) /* look at another assoc in the bucket? */</span>
<a href="#l39.189"></a><span id="l39.189">   {</span>
<a href="#l39.190"></a><span id="l39.190">     mork_pos i = assoc - mMap_Assocs; /* index of this assoc */</span>
<a href="#l39.191"></a><span id="l39.191">     if ( this-&gt;Equal(ev, keys + (i * keySize), inKey) ) /* found? */</span>
<a href="#l39.192"></a><span id="l39.192">       return ref;</span>
<a href="#l39.193"></a><span id="l39.193" class="difflineminus">-      </span>
<a href="#l39.194"></a><span id="l39.194" class="difflineplus">+</span>
<a href="#l39.195"></a><span id="l39.195">     ref = &amp;assoc-&gt;mAssoc_Next; /* consider next assoc slot in bucket */</span>
<a href="#l39.196"></a><span id="l39.196">     assoc = *ref; /* if this is null, then we are done */</span>
<a href="#l39.197"></a><span id="l39.197">   }</span>
<a href="#l39.198"></a><span id="l39.198">   return 0;</span>
<a href="#l39.199"></a><span id="l39.199"> }</span>
<a href="#l39.200"></a><span id="l39.200"> </span>
<a href="#l39.201"></a><span id="l39.201"> /*| get_assoc: read the key and/or value at index inPos</span>
<a href="#l39.202"></a><span id="l39.202"> |*/</span>
<a href="#l39.203"></a><span id="l39.203" class="difflineat">@@ -327,17 +327,17 @@ morkMap::clear_alloc(morkEnv* ev, mork_s</span>
<a href="#l39.204"></a><span id="l39.204">     if (NS_SUCCEEDED(heap-&gt;Alloc(ev-&gt;AsMdbEnv(), inSize, (void**) &amp;p)) &amp;&amp; p )</span>
<a href="#l39.205"></a><span id="l39.205">     {</span>
<a href="#l39.206"></a><span id="l39.206">       MORK_MEMSET(p, 0, inSize);</span>
<a href="#l39.207"></a><span id="l39.207">       return p;</span>
<a href="#l39.208"></a><span id="l39.208">     }</span>
<a href="#l39.209"></a><span id="l39.209">   }</span>
<a href="#l39.210"></a><span id="l39.210">   else</span>
<a href="#l39.211"></a><span id="l39.211">     ev-&gt;NilPointerError();</span>
<a href="#l39.212"></a><span id="l39.212" class="difflineminus">-    </span>
<a href="#l39.213"></a><span id="l39.213" class="difflineplus">+</span>
<a href="#l39.214"></a><span id="l39.214">   return (void*) 0;</span>
<a href="#l39.215"></a><span id="l39.215"> }</span>
<a href="#l39.216"></a><span id="l39.216"> </span>
<a href="#l39.217"></a><span id="l39.217"> void*</span>
<a href="#l39.218"></a><span id="l39.218"> morkMap::alloc(morkEnv* ev, mork_size inSize)</span>
<a href="#l39.219"></a><span id="l39.219"> {</span>
<a href="#l39.220"></a><span id="l39.220">   void* p = 0;</span>
<a href="#l39.221"></a><span id="l39.221">   nsIMdbHeap* heap = mMap_Heap;</span>
<a href="#l39.222"></a><span id="l39.222" class="difflineat">@@ -411,44 +411,44 @@ morkMap::new_assocs(morkEnv* ev, mork_nu</span>
<a href="#l39.223"></a><span id="l39.223">   }</span>
<a href="#l39.224"></a><span id="l39.224">   return assocs;</span>
<a href="#l39.225"></a><span id="l39.225"> }</span>
<a href="#l39.226"></a><span id="l39.226"> </span>
<a href="#l39.227"></a><span id="l39.227"> mork_bool</span>
<a href="#l39.228"></a><span id="l39.228"> morkMap::new_arrays(morkEnv* ev, morkHashArrays* old, mork_num inSlots)</span>
<a href="#l39.229"></a><span id="l39.229"> {</span>
<a href="#l39.230"></a><span id="l39.230">   mork_bool outNew = morkBool_kFalse;</span>
<a href="#l39.231"></a><span id="l39.231" class="difflineminus">-    </span>
<a href="#l39.232"></a><span id="l39.232" class="difflineplus">+</span>
<a href="#l39.233"></a><span id="l39.233">   /* see if we can allocate all the new arrays before we go any further: */</span>
<a href="#l39.234"></a><span id="l39.234">   morkAssoc** newBuckets = this-&gt;new_buckets(ev, inSlots);</span>
<a href="#l39.235"></a><span id="l39.235">   morkAssoc* newAssocs = this-&gt;new_assocs(ev, inSlots);</span>
<a href="#l39.236"></a><span id="l39.236">   mork_u1* newKeys = this-&gt;new_keys(ev, inSlots);</span>
<a href="#l39.237"></a><span id="l39.237">   mork_u1* newValues = this-&gt;new_values(ev, inSlots);</span>
<a href="#l39.238"></a><span id="l39.238">   mork_change* newChanges = this-&gt;new_changes(ev, inSlots);</span>
<a href="#l39.239"></a><span id="l39.239" class="difflineminus">-  </span>
<a href="#l39.240"></a><span id="l39.240" class="difflineplus">+</span>
<a href="#l39.241"></a><span id="l39.241">   /* it is okay for newChanges to be null when changes are not held: */</span>
<a href="#l39.242"></a><span id="l39.242">   mork_bool okayChanges = ( newChanges || !this-&gt;FormHoldChanges() );</span>
<a href="#l39.243"></a><span id="l39.243" class="difflineminus">-  </span>
<a href="#l39.244"></a><span id="l39.244" class="difflineplus">+</span>
<a href="#l39.245"></a><span id="l39.245">   /* it is okay for newValues to be null when values are zero sized: */</span>
<a href="#l39.246"></a><span id="l39.246">   mork_bool okayValues = ( newValues || !this-&gt;FormValSize() );</span>
<a href="#l39.247"></a><span id="l39.247" class="difflineminus">-  </span>
<a href="#l39.248"></a><span id="l39.248" class="difflineplus">+</span>
<a href="#l39.249"></a><span id="l39.249">   if ( newBuckets &amp;&amp; newAssocs &amp;&amp; newKeys &amp;&amp; okayChanges &amp;&amp; okayValues )</span>
<a href="#l39.250"></a><span id="l39.250">   {</span>
<a href="#l39.251"></a><span id="l39.251">     outNew = morkBool_kTrue; /* yes, we created all the arrays we need */</span>
<a href="#l39.252"></a><span id="l39.252"> </span>
<a href="#l39.253"></a><span id="l39.253">     /* init the old hashArrays with slots from this hash table: */</span>
<a href="#l39.254"></a><span id="l39.254">     old-&gt;mHashArrays_Heap = mMap_Heap;</span>
<a href="#l39.255"></a><span id="l39.255" class="difflineminus">-    </span>
<a href="#l39.256"></a><span id="l39.256" class="difflineplus">+</span>
<a href="#l39.257"></a><span id="l39.257">     old-&gt;mHashArrays_Slots = mMap_Slots;</span>
<a href="#l39.258"></a><span id="l39.258">     old-&gt;mHashArrays_Keys = mMap_Keys;</span>
<a href="#l39.259"></a><span id="l39.259">     old-&gt;mHashArrays_Vals = mMap_Vals;</span>
<a href="#l39.260"></a><span id="l39.260">     old-&gt;mHashArrays_Assocs = mMap_Assocs;</span>
<a href="#l39.261"></a><span id="l39.261">     old-&gt;mHashArrays_Buckets = mMap_Buckets;</span>
<a href="#l39.262"></a><span id="l39.262">     old-&gt;mHashArrays_Changes = mMap_Changes;</span>
<a href="#l39.263"></a><span id="l39.263" class="difflineminus">-    </span>
<a href="#l39.264"></a><span id="l39.264" class="difflineplus">+</span>
<a href="#l39.265"></a><span id="l39.265">     /* now replace all our array slots with the new structures: */</span>
<a href="#l39.266"></a><span id="l39.266">     ++mMap_Seed; /* note the map is now changed */</span>
<a href="#l39.267"></a><span id="l39.267">     mMap_Keys = newKeys;</span>
<a href="#l39.268"></a><span id="l39.268">     mMap_Vals = newValues;</span>
<a href="#l39.269"></a><span id="l39.269">     mMap_Buckets = newBuckets;</span>
<a href="#l39.270"></a><span id="l39.270">     mMap_Assocs = newAssocs;</span>
<a href="#l39.271"></a><span id="l39.271">     mMap_FreeList = newAssocs; /* all are free to start with */</span>
<a href="#l39.272"></a><span id="l39.272">     mMap_Changes = newChanges;</span>
<a href="#l39.273"></a><span id="l39.273" class="difflineat">@@ -463,20 +463,20 @@ morkMap::new_arrays(morkEnv* ev, morkHas</span>
<a href="#l39.274"></a><span id="l39.274">     if ( newAssocs )</span>
<a href="#l39.275"></a><span id="l39.275">       heap-&gt;Free(menv, newAssocs);</span>
<a href="#l39.276"></a><span id="l39.276">     if ( newKeys )</span>
<a href="#l39.277"></a><span id="l39.277">       heap-&gt;Free(menv, newKeys);</span>
<a href="#l39.278"></a><span id="l39.278">     if ( newValues )</span>
<a href="#l39.279"></a><span id="l39.279">       heap-&gt;Free(menv, newValues);</span>
<a href="#l39.280"></a><span id="l39.280">     if ( newChanges )</span>
<a href="#l39.281"></a><span id="l39.281">       heap-&gt;Free(menv, newChanges);</span>
<a href="#l39.282"></a><span id="l39.282" class="difflineminus">-    </span>
<a href="#l39.283"></a><span id="l39.283" class="difflineplus">+</span>
<a href="#l39.284"></a><span id="l39.284">     MORK_MEMSET(old, 0, sizeof(morkHashArrays));</span>
<a href="#l39.285"></a><span id="l39.285">   }</span>
<a href="#l39.286"></a><span id="l39.286" class="difflineminus">-  </span>
<a href="#l39.287"></a><span id="l39.287" class="difflineplus">+</span>
<a href="#l39.288"></a><span id="l39.288">   return outNew;</span>
<a href="#l39.289"></a><span id="l39.289"> }</span>
<a href="#l39.290"></a><span id="l39.290"> </span>
<a href="#l39.291"></a><span id="l39.291"> /*| grow: make the map arrays bigger by 33%.  The old map is completely</span>
<a href="#l39.292"></a><span id="l39.292"> **| full, or else we would not have called grow() to get more space.  This</span>
<a href="#l39.293"></a><span id="l39.293"> **| means the free list is empty, and also means every old key and value is in</span>
<a href="#l39.294"></a><span id="l39.294"> **| use in the old arrays.  So every key and value must be copied to the new</span>
<a href="#l39.295"></a><span id="l39.295"> **| arrays, and since they are contiguous in the old arrays, we can efficiently</span>
<a href="#l39.296"></a><span id="l39.296" class="difflineat">@@ -508,59 +508,59 @@ mork_bool morkMap::grow(morkEnv* ev)</span>
<a href="#l39.297"></a><span id="l39.297"> {</span>
<a href="#l39.298"></a><span id="l39.298">   if ( mMap_Heap ) /* can we grow the map? */</span>
<a href="#l39.299"></a><span id="l39.299">   {</span>
<a href="#l39.300"></a><span id="l39.300">     mork_num newSlots = (mMap_Slots * 2); /* +100% */</span>
<a href="#l39.301"></a><span id="l39.301">     morkHashArrays old; /* a place to temporarily hold all the old arrays */</span>
<a href="#l39.302"></a><span id="l39.302">     if ( this-&gt;new_arrays(ev, &amp;old, newSlots) ) /* have more? */</span>
<a href="#l39.303"></a><span id="l39.303">     {</span>
<a href="#l39.304"></a><span id="l39.304">       // morkMap_mHash hash = this-&gt;FormHash(); /* for terse loop use */</span>
<a href="#l39.305"></a><span id="l39.305" class="difflineminus">-      </span>
<a href="#l39.306"></a><span id="l39.306" class="difflineplus">+</span>
<a href="#l39.307"></a><span id="l39.307">       /* figure out the bulk volume sizes of old keys and values to move: */</span>
<a href="#l39.308"></a><span id="l39.308">       mork_num oldSlots = old.mHashArrays_Slots; /* number of old assocs */</span>
<a href="#l39.309"></a><span id="l39.309">       mork_num keyBulk = oldSlots * this-&gt;FormKeySize(); /* key volume */</span>
<a href="#l39.310"></a><span id="l39.310">       mork_num valBulk = oldSlots * this-&gt;FormValSize(); /* values */</span>
<a href="#l39.311"></a><span id="l39.311" class="difflineminus">-      </span>
<a href="#l39.312"></a><span id="l39.312" class="difflineplus">+</span>
<a href="#l39.313"></a><span id="l39.313">       /* convenient variables for new arrays that need to be rehashed: */</span>
<a href="#l39.314"></a><span id="l39.314">       morkAssoc** newBuckets = mMap_Buckets; /* new all zeroes */</span>
<a href="#l39.315"></a><span id="l39.315">       morkAssoc* newAssocs = mMap_Assocs; /* hash into buckets */</span>
<a href="#l39.316"></a><span id="l39.316">       morkAssoc* newFreeList = newAssocs + oldSlots; /* new room is free */</span>
<a href="#l39.317"></a><span id="l39.317">       mork_u1* key = mMap_Keys; /* the first key to rehash */</span>
<a href="#l39.318"></a><span id="l39.318">       --newAssocs; /* back up one before preincrement used in while loop */</span>
<a href="#l39.319"></a><span id="l39.319" class="difflineminus">-      </span>
<a href="#l39.320"></a><span id="l39.320" class="difflineplus">+</span>
<a href="#l39.321"></a><span id="l39.321">       /* move all old keys and values to the new arrays: */</span>
<a href="#l39.322"></a><span id="l39.322">       MORK_MEMCPY(mMap_Keys, old.mHashArrays_Keys, keyBulk);</span>
<a href="#l39.323"></a><span id="l39.323">       if ( valBulk ) /* are values nonzero sized? */</span>
<a href="#l39.324"></a><span id="l39.324">         MORK_MEMCPY(mMap_Vals, old.mHashArrays_Vals, valBulk);</span>
<a href="#l39.325"></a><span id="l39.325" class="difflineminus">-        </span>
<a href="#l39.326"></a><span id="l39.326" class="difflineplus">+</span>
<a href="#l39.327"></a><span id="l39.327">       mMap_FreeList = newFreeList; /* remaining assocs are free */</span>
<a href="#l39.328"></a><span id="l39.328" class="difflineminus">-      </span>
<a href="#l39.329"></a><span id="l39.329" class="difflineplus">+</span>
<a href="#l39.330"></a><span id="l39.330">       while ( ++newAssocs &lt; newFreeList ) /* rehash another old assoc? */</span>
<a href="#l39.331"></a><span id="l39.331">       {</span>
<a href="#l39.332"></a><span id="l39.332">         morkAssoc** top = newBuckets + (this-&gt;Hash(ev, key) % newSlots);</span>
<a href="#l39.333"></a><span id="l39.333">         key += this-&gt;FormKeySize(); /* the next key to rehash */</span>
<a href="#l39.334"></a><span id="l39.334">         newAssocs-&gt;mAssoc_Next = *top; /* link to prev bucket top */</span>
<a href="#l39.335"></a><span id="l39.335">         *top = newAssocs; /* push assoc on top of bucket */</span>
<a href="#l39.336"></a><span id="l39.336">       }</span>
<a href="#l39.337"></a><span id="l39.337">       ++mMap_Seed; /* note the map has changed */</span>
<a href="#l39.338"></a><span id="l39.338">       old.finalize(ev); /* remember to free the old arrays */</span>
<a href="#l39.339"></a><span id="l39.339">     }</span>
<a href="#l39.340"></a><span id="l39.340">   }</span>
<a href="#l39.341"></a><span id="l39.341">   else ev-&gt;OutOfMemoryError();</span>
<a href="#l39.342"></a><span id="l39.342" class="difflineminus">-  </span>
<a href="#l39.343"></a><span id="l39.343" class="difflineplus">+</span>
<a href="#l39.344"></a><span id="l39.344">   return ev-&gt;Good();</span>
<a href="#l39.345"></a><span id="l39.345"> }</span>
<a href="#l39.346"></a><span id="l39.346"> </span>
<a href="#l39.347"></a><span id="l39.347"> </span>
<a href="#l39.348"></a><span id="l39.348"> mork_bool</span>
<a href="#l39.349"></a><span id="l39.349"> morkMap::Put(morkEnv* ev, const void* inKey, const void* inVal,</span>
<a href="#l39.350"></a><span id="l39.350">   void* outKey, void* outVal, mork_change** outChange)</span>
<a href="#l39.351"></a><span id="l39.351"> {</span>
<a href="#l39.352"></a><span id="l39.352">   mork_bool outPut = morkBool_kFalse;</span>
<a href="#l39.353"></a><span id="l39.353" class="difflineminus">-  </span>
<a href="#l39.354"></a><span id="l39.354" class="difflineplus">+</span>
<a href="#l39.355"></a><span id="l39.355">   if ( this-&gt;GoodMap() ) /* looks good? */</span>
<a href="#l39.356"></a><span id="l39.356">   {</span>
<a href="#l39.357"></a><span id="l39.357">     mork_u4 hash = this-&gt;Hash(ev, inKey);</span>
<a href="#l39.358"></a><span id="l39.358">     morkAssoc** ref = this-&gt;find(ev, inKey, hash);</span>
<a href="#l39.359"></a><span id="l39.359">     if ( ref ) /* assoc was found? reuse an existing assoc slot? */</span>
<a href="#l39.360"></a><span id="l39.360">     {</span>
<a href="#l39.361"></a><span id="l39.361">       outPut = morkBool_kTrue; /* inKey was indeed already inside the map */</span>
<a href="#l39.362"></a><span id="l39.362">     }</span>
<a href="#l39.363"></a><span id="l39.363" class="difflineat">@@ -572,49 +572,49 @@ morkMap::Put(morkEnv* ev, const void* in</span>
<a href="#l39.364"></a><span id="l39.364">         if ( this-&gt;grow(ev) ) /* successfully made map larger? */</span>
<a href="#l39.365"></a><span id="l39.365">           assoc = this-&gt;pop_free_assoc();</span>
<a href="#l39.366"></a><span id="l39.366">       }</span>
<a href="#l39.367"></a><span id="l39.367">       if ( assoc ) /* allocated new assoc without error? */</span>
<a href="#l39.368"></a><span id="l39.368">       {</span>
<a href="#l39.369"></a><span id="l39.369">         ref = mMap_Buckets + (hash % mMap_Slots);</span>
<a href="#l39.370"></a><span id="l39.370">         assoc-&gt;mAssoc_Next = *ref; /* link to prev bucket top */</span>
<a href="#l39.371"></a><span id="l39.371">         *ref = assoc; /* push assoc on top of bucket */</span>
<a href="#l39.372"></a><span id="l39.372" class="difflineminus">-          </span>
<a href="#l39.373"></a><span id="l39.373" class="difflineplus">+</span>
<a href="#l39.374"></a><span id="l39.374">         ++mMap_Fill; /* one more member in the collection */</span>
<a href="#l39.375"></a><span id="l39.375">         ++mMap_Seed; /* note the map has changed */</span>
<a href="#l39.376"></a><span id="l39.376">       }</span>
<a href="#l39.377"></a><span id="l39.377">     }</span>
<a href="#l39.378"></a><span id="l39.378">     if ( ref ) /* did not have an error during possible growth? */</span>
<a href="#l39.379"></a><span id="l39.379">     {</span>
<a href="#l39.380"></a><span id="l39.380">       mork_pos i = (*ref) - mMap_Assocs; /* index of assoc */</span>
<a href="#l39.381"></a><span id="l39.381">       if ( outPut &amp;&amp; (outKey || outVal) ) /* copy old before cobbering? */</span>
<a href="#l39.382"></a><span id="l39.382">         this-&gt;get_assoc(outKey, outVal, i);</span>
<a href="#l39.383"></a><span id="l39.383"> </span>
<a href="#l39.384"></a><span id="l39.384">       this-&gt;put_assoc(inKey, inVal, i);</span>
<a href="#l39.385"></a><span id="l39.385">       ++mMap_Seed; /* note the map has changed */</span>
<a href="#l39.386"></a><span id="l39.386" class="difflineminus">-      </span>
<a href="#l39.387"></a><span id="l39.387" class="difflineplus">+</span>
<a href="#l39.388"></a><span id="l39.388">       if ( outChange )</span>
<a href="#l39.389"></a><span id="l39.389">       {</span>
<a href="#l39.390"></a><span id="l39.390">         if ( mMap_Changes )</span>
<a href="#l39.391"></a><span id="l39.391">           *outChange = mMap_Changes + i;</span>
<a href="#l39.392"></a><span id="l39.392">         else</span>
<a href="#l39.393"></a><span id="l39.393">           *outChange = this-&gt;FormDummyChange();</span>
<a href="#l39.394"></a><span id="l39.394">       }</span>
<a href="#l39.395"></a><span id="l39.395">     }</span>
<a href="#l39.396"></a><span id="l39.396">   }</span>
<a href="#l39.397"></a><span id="l39.397">   else this-&gt;NewBadMapError(ev);</span>
<a href="#l39.398"></a><span id="l39.398" class="difflineminus">-  </span>
<a href="#l39.399"></a><span id="l39.399" class="difflineplus">+</span>
<a href="#l39.400"></a><span id="l39.400">   return outPut;</span>
<a href="#l39.401"></a><span id="l39.401"> }</span>
<a href="#l39.402"></a><span id="l39.402"> </span>
<a href="#l39.403"></a><span id="l39.403"> mork_num</span>
<a href="#l39.404"></a><span id="l39.404"> morkMap::CutAll(morkEnv* ev)</span>
<a href="#l39.405"></a><span id="l39.405"> {</span>
<a href="#l39.406"></a><span id="l39.406">   mork_num outCutAll = 0;</span>
<a href="#l39.407"></a><span id="l39.407" class="difflineminus">-  </span>
<a href="#l39.408"></a><span id="l39.408" class="difflineplus">+</span>
<a href="#l39.409"></a><span id="l39.409">   if ( this-&gt;GoodMap() ) /* map looks good? */</span>
<a href="#l39.410"></a><span id="l39.410">   {</span>
<a href="#l39.411"></a><span id="l39.411">     mork_num slots = mMap_Slots;</span>
<a href="#l39.412"></a><span id="l39.412">     morkAssoc* before = mMap_Assocs - 1; /* before first member */</span>
<a href="#l39.413"></a><span id="l39.413">     morkAssoc* assoc = before + slots; /* the very last member */</span>
<a href="#l39.414"></a><span id="l39.414"> </span>
<a href="#l39.415"></a><span id="l39.415">     ++mMap_Seed; /* note the map is changed */</span>
<a href="#l39.416"></a><span id="l39.416"> </span>
<a href="#l39.417"></a><span id="l39.417" class="difflineat">@@ -624,26 +624,26 @@ morkMap::CutAll(morkEnv* ev)</span>
<a href="#l39.418"></a><span id="l39.418">       assoc-&gt;mAssoc_Next = assoc + 1;</span>
<a href="#l39.419"></a><span id="l39.419">     mMap_FreeList = mMap_Assocs; /* all are free */</span>
<a href="#l39.420"></a><span id="l39.420"> </span>
<a href="#l39.421"></a><span id="l39.421">     outCutAll = mMap_Fill; /* we'll cut all of them of course */</span>
<a href="#l39.422"></a><span id="l39.422"> </span>
<a href="#l39.423"></a><span id="l39.423">     mMap_Fill = 0; /* the map is completely empty */</span>
<a href="#l39.424"></a><span id="l39.424">   }</span>
<a href="#l39.425"></a><span id="l39.425">   else this-&gt;NewBadMapError(ev);</span>
<a href="#l39.426"></a><span id="l39.426" class="difflineminus">-  </span>
<a href="#l39.427"></a><span id="l39.427" class="difflineplus">+</span>
<a href="#l39.428"></a><span id="l39.428">   return outCutAll;</span>
<a href="#l39.429"></a><span id="l39.429"> }</span>
<a href="#l39.430"></a><span id="l39.430"> </span>
<a href="#l39.431"></a><span id="l39.431"> mork_bool</span>
<a href="#l39.432"></a><span id="l39.432"> morkMap::Cut(morkEnv* ev, const void* inKey,</span>
<a href="#l39.433"></a><span id="l39.433">   void* outKey, void* outVal, mork_change** outChange)</span>
<a href="#l39.434"></a><span id="l39.434"> {</span>
<a href="#l39.435"></a><span id="l39.435">   mork_bool outCut = morkBool_kFalse;</span>
<a href="#l39.436"></a><span id="l39.436" class="difflineminus">-  </span>
<a href="#l39.437"></a><span id="l39.437" class="difflineplus">+</span>
<a href="#l39.438"></a><span id="l39.438">   if ( this-&gt;GoodMap() ) /* looks good? */</span>
<a href="#l39.439"></a><span id="l39.439">   {</span>
<a href="#l39.440"></a><span id="l39.440">     mork_u4 hash = this-&gt;Hash(ev, inKey);</span>
<a href="#l39.441"></a><span id="l39.441">     morkAssoc** ref = this-&gt;find(ev, inKey, hash);</span>
<a href="#l39.442"></a><span id="l39.442">     if ( ref ) /* found an assoc for key? */</span>
<a href="#l39.443"></a><span id="l39.443">     {</span>
<a href="#l39.444"></a><span id="l39.444">       outCut = morkBool_kTrue;</span>
<a href="#l39.445"></a><span id="l39.445">       morkAssoc* assoc = *ref;</span>
<a href="#l39.446"></a><span id="l39.446" class="difflineat">@@ -656,35 +656,35 @@ morkMap::Cut(morkEnv* ev, const void* in</span>
<a href="#l39.447"></a><span id="l39.447"> </span>
<a href="#l39.448"></a><span id="l39.448">       if ( outChange )</span>
<a href="#l39.449"></a><span id="l39.449">       {</span>
<a href="#l39.450"></a><span id="l39.450">         if ( mMap_Changes )</span>
<a href="#l39.451"></a><span id="l39.451">           *outChange = mMap_Changes + i;</span>
<a href="#l39.452"></a><span id="l39.452">         else</span>
<a href="#l39.453"></a><span id="l39.453">           *outChange = this-&gt;FormDummyChange();</span>
<a href="#l39.454"></a><span id="l39.454">       }</span>
<a href="#l39.455"></a><span id="l39.455" class="difflineminus">-      </span>
<a href="#l39.456"></a><span id="l39.456" class="difflineplus">+</span>
<a href="#l39.457"></a><span id="l39.457">       ++mMap_Seed; /* note the map has changed */</span>
<a href="#l39.458"></a><span id="l39.458">       if ( mMap_Fill ) /* the count shows nonzero members? */</span>
<a href="#l39.459"></a><span id="l39.459">         --mMap_Fill; /* one less member in the collection */</span>
<a href="#l39.460"></a><span id="l39.460">       else</span>
<a href="#l39.461"></a><span id="l39.461">         this-&gt;NewSlotsUnderflowWarning(ev);</span>
<a href="#l39.462"></a><span id="l39.462">     }</span>
<a href="#l39.463"></a><span id="l39.463">   }</span>
<a href="#l39.464"></a><span id="l39.464">   else this-&gt;NewBadMapError(ev);</span>
<a href="#l39.465"></a><span id="l39.465" class="difflineminus">-  </span>
<a href="#l39.466"></a><span id="l39.466" class="difflineplus">+</span>
<a href="#l39.467"></a><span id="l39.467">   return outCut;</span>
<a href="#l39.468"></a><span id="l39.468"> }</span>
<a href="#l39.469"></a><span id="l39.469"> </span>
<a href="#l39.470"></a><span id="l39.470"> mork_bool</span>
<a href="#l39.471"></a><span id="l39.471"> morkMap::Get(morkEnv* ev, const void* inKey,</span>
<a href="#l39.472"></a><span id="l39.472">   void* outKey, void* outVal, mork_change** outChange)</span>
<a href="#l39.473"></a><span id="l39.473"> {</span>
<a href="#l39.474"></a><span id="l39.474">   mork_bool outGet = morkBool_kFalse;</span>
<a href="#l39.475"></a><span id="l39.475" class="difflineminus">-  </span>
<a href="#l39.476"></a><span id="l39.476" class="difflineplus">+</span>
<a href="#l39.477"></a><span id="l39.477">   if ( this-&gt;GoodMap() ) /* looks good? */</span>
<a href="#l39.478"></a><span id="l39.478">   {</span>
<a href="#l39.479"></a><span id="l39.479">     mork_u4 hash = this-&gt;Hash(ev, inKey);</span>
<a href="#l39.480"></a><span id="l39.480">     morkAssoc** ref = this-&gt;find(ev, inKey, hash);</span>
<a href="#l39.481"></a><span id="l39.481">     if ( ref ) /* found an assoc for inKey? */</span>
<a href="#l39.482"></a><span id="l39.482">     {</span>
<a href="#l39.483"></a><span id="l39.483">       mork_pos i = (*ref) - mMap_Assocs; /* index of assoc */</span>
<a href="#l39.484"></a><span id="l39.484">       outGet = morkBool_kTrue;</span>
<a href="#l39.485"></a><span id="l39.485" class="difflineat">@@ -694,25 +694,25 @@ morkMap::Get(morkEnv* ev, const void* in</span>
<a href="#l39.486"></a><span id="l39.486">         if ( mMap_Changes )</span>
<a href="#l39.487"></a><span id="l39.487">           *outChange = mMap_Changes + i;</span>
<a href="#l39.488"></a><span id="l39.488">         else</span>
<a href="#l39.489"></a><span id="l39.489">           *outChange = this-&gt;FormDummyChange();</span>
<a href="#l39.490"></a><span id="l39.490">       }</span>
<a href="#l39.491"></a><span id="l39.491">     }</span>
<a href="#l39.492"></a><span id="l39.492">   }</span>
<a href="#l39.493"></a><span id="l39.493">   else this-&gt;NewBadMapError(ev);</span>
<a href="#l39.494"></a><span id="l39.494" class="difflineminus">-  </span>
<a href="#l39.495"></a><span id="l39.495" class="difflineplus">+</span>
<a href="#l39.496"></a><span id="l39.496">   return outGet;</span>
<a href="#l39.497"></a><span id="l39.497"> }</span>
<a href="#l39.498"></a><span id="l39.498"> </span>
<a href="#l39.499"></a><span id="l39.499"> </span>
<a href="#l39.500"></a><span id="l39.500"> morkMapIter::morkMapIter( )</span>
<a href="#l39.501"></a><span id="l39.501"> : mMapIter_Map( 0 )</span>
<a href="#l39.502"></a><span id="l39.502"> , mMapIter_Seed( 0 )</span>
<a href="#l39.503"></a><span id="l39.503" class="difflineminus">-  </span>
<a href="#l39.504"></a><span id="l39.504" class="difflineplus">+</span>
<a href="#l39.505"></a><span id="l39.505"> , mMapIter_Bucket( 0 )</span>
<a href="#l39.506"></a><span id="l39.506"> , mMapIter_AssocRef( 0 )</span>
<a href="#l39.507"></a><span id="l39.507"> , mMapIter_Assoc( 0 )</span>
<a href="#l39.508"></a><span id="l39.508"> , mMapIter_Next( 0 )</span>
<a href="#l39.509"></a><span id="l39.509"> {</span>
<a href="#l39.510"></a><span id="l39.510"> }</span>
<a href="#l39.511"></a><span id="l39.511"> </span>
<a href="#l39.512"></a><span id="l39.512"> void</span>
<a href="#l39.513"></a><span id="l39.513" class="difflineat">@@ -736,17 +736,17 @@ morkMapIter::InitMapIter(morkEnv* ev, mo</span>
<a href="#l39.514"></a><span id="l39.514">     else ioMap-&gt;NewBadMapError(ev);</span>
<a href="#l39.515"></a><span id="l39.515">   }</span>
<a href="#l39.516"></a><span id="l39.516">   else ev-&gt;NilPointerError();</span>
<a href="#l39.517"></a><span id="l39.517"> }</span>
<a href="#l39.518"></a><span id="l39.518"> </span>
<a href="#l39.519"></a><span id="l39.519"> morkMapIter::morkMapIter(morkEnv* ev, morkMap* ioMap)</span>
<a href="#l39.520"></a><span id="l39.520"> : mMapIter_Map( 0 )</span>
<a href="#l39.521"></a><span id="l39.521"> , mMapIter_Seed( 0 )</span>
<a href="#l39.522"></a><span id="l39.522" class="difflineminus">-  </span>
<a href="#l39.523"></a><span id="l39.523" class="difflineplus">+</span>
<a href="#l39.524"></a><span id="l39.524"> , mMapIter_Bucket( 0 )</span>
<a href="#l39.525"></a><span id="l39.525"> , mMapIter_AssocRef( 0 )</span>
<a href="#l39.526"></a><span id="l39.526"> , mMapIter_Assoc( 0 )</span>
<a href="#l39.527"></a><span id="l39.527"> , mMapIter_Next( 0 )</span>
<a href="#l39.528"></a><span id="l39.528"> {</span>
<a href="#l39.529"></a><span id="l39.529">   if ( ioMap )</span>
<a href="#l39.530"></a><span id="l39.530">   {</span>
<a href="#l39.531"></a><span id="l39.531">     if ( ioMap-&gt;GoodMap() )</span>
<a href="#l39.532"></a><span id="l39.532" class="difflineat">@@ -760,194 +760,194 @@ morkMapIter::morkMapIter(morkEnv* ev, mo</span>
<a href="#l39.533"></a><span id="l39.533"> }</span>
<a href="#l39.534"></a><span id="l39.534"> </span>
<a href="#l39.535"></a><span id="l39.535"> void</span>
<a href="#l39.536"></a><span id="l39.536"> morkMapIter::CloseMapIter(morkEnv* ev)</span>
<a href="#l39.537"></a><span id="l39.537"> {</span>
<a href="#l39.538"></a><span id="l39.538">   MORK_USED_1(ev);</span>
<a href="#l39.539"></a><span id="l39.539">   mMapIter_Map = 0;</span>
<a href="#l39.540"></a><span id="l39.540">   mMapIter_Seed = 0;</span>
<a href="#l39.541"></a><span id="l39.541" class="difflineminus">-  </span>
<a href="#l39.542"></a><span id="l39.542" class="difflineplus">+</span>
<a href="#l39.543"></a><span id="l39.543">   mMapIter_Bucket = 0;</span>
<a href="#l39.544"></a><span id="l39.544">   mMapIter_AssocRef = 0;</span>
<a href="#l39.545"></a><span id="l39.545">   mMapIter_Assoc = 0;</span>
<a href="#l39.546"></a><span id="l39.546">   mMapIter_Next = 0;</span>
<a href="#l39.547"></a><span id="l39.547"> }</span>
<a href="#l39.548"></a><span id="l39.548"> </span>
<a href="#l39.549"></a><span id="l39.549"> mork_change*</span>
<a href="#l39.550"></a><span id="l39.550"> morkMapIter::First(morkEnv* ev, void* outKey, void* outVal)</span>
<a href="#l39.551"></a><span id="l39.551"> {</span>
<a href="#l39.552"></a><span id="l39.552">   mork_change* outFirst = 0;</span>
<a href="#l39.553"></a><span id="l39.553" class="difflineminus">-  </span>
<a href="#l39.554"></a><span id="l39.554" class="difflineplus">+</span>
<a href="#l39.555"></a><span id="l39.555">   morkMap* map = mMapIter_Map;</span>
<a href="#l39.556"></a><span id="l39.556" class="difflineminus">-  </span>
<a href="#l39.557"></a><span id="l39.557" class="difflineplus">+</span>
<a href="#l39.558"></a><span id="l39.558">   if ( map &amp;&amp; map-&gt;GoodMap() ) /* map looks good? */</span>
<a href="#l39.559"></a><span id="l39.559">   {</span>
<a href="#l39.560"></a><span id="l39.560">     morkAssoc** bucket = map-&gt;mMap_Buckets;</span>
<a href="#l39.561"></a><span id="l39.561">     morkAssoc** end = bucket + map-&gt;mMap_Slots; /* one past last */</span>
<a href="#l39.562"></a><span id="l39.562" class="difflineminus">- </span>
<a href="#l39.563"></a><span id="l39.563" class="difflineplus">+</span>
<a href="#l39.564"></a><span id="l39.564">     mMapIter_Seed = map-&gt;mMap_Seed; /* sync the seeds */</span>
<a href="#l39.565"></a><span id="l39.565" class="difflineminus">-   </span>
<a href="#l39.566"></a><span id="l39.566" class="difflineplus">+</span>
<a href="#l39.567"></a><span id="l39.567">     while ( bucket &lt; end ) /* another bucket in which to look for assocs? */</span>
<a href="#l39.568"></a><span id="l39.568">     {</span>
<a href="#l39.569"></a><span id="l39.569">       morkAssoc* assoc = *bucket++;</span>
<a href="#l39.570"></a><span id="l39.570">       if ( assoc ) /* found the first map assoc in use? */</span>
<a href="#l39.571"></a><span id="l39.571">       {</span>
<a href="#l39.572"></a><span id="l39.572">         mork_pos i = assoc - map-&gt;mMap_Assocs;</span>
<a href="#l39.573"></a><span id="l39.573">         mork_change* c = map-&gt;mMap_Changes;</span>
<a href="#l39.574"></a><span id="l39.574">         outFirst = ( c )? (c + i) : map-&gt;FormDummyChange();</span>
<a href="#l39.575"></a><span id="l39.575" class="difflineminus">-        </span>
<a href="#l39.576"></a><span id="l39.576" class="difflineplus">+</span>
<a href="#l39.577"></a><span id="l39.577">         mMapIter_Assoc = assoc; /* current assoc in iteration */</span>
<a href="#l39.578"></a><span id="l39.578">         mMapIter_Next = assoc-&gt;mAssoc_Next; /* more in bucket */</span>
<a href="#l39.579"></a><span id="l39.579">         mMapIter_Bucket = --bucket; /* bucket for this assoc */</span>
<a href="#l39.580"></a><span id="l39.580">         mMapIter_AssocRef = bucket; /* slot referencing assoc */</span>
<a href="#l39.581"></a><span id="l39.581" class="difflineminus">-        </span>
<a href="#l39.582"></a><span id="l39.582" class="difflineplus">+</span>
<a href="#l39.583"></a><span id="l39.583">         map-&gt;get_assoc(outKey, outVal, i);</span>
<a href="#l39.584"></a><span id="l39.584" class="difflineminus">-          </span>
<a href="#l39.585"></a><span id="l39.585" class="difflineplus">+</span>
<a href="#l39.586"></a><span id="l39.586">         break; /* end while loop */</span>
<a href="#l39.587"></a><span id="l39.587">       }</span>
<a href="#l39.588"></a><span id="l39.588">     }</span>
<a href="#l39.589"></a><span id="l39.589">   }</span>
<a href="#l39.590"></a><span id="l39.590">   else map-&gt;NewBadMapError(ev);</span>
<a href="#l39.591"></a><span id="l39.591"> </span>
<a href="#l39.592"></a><span id="l39.592">   return outFirst;</span>
<a href="#l39.593"></a><span id="l39.593"> }</span>
<a href="#l39.594"></a><span id="l39.594"> </span>
<a href="#l39.595"></a><span id="l39.595"> mork_change*</span>
<a href="#l39.596"></a><span id="l39.596"> morkMapIter::Next(morkEnv* ev, void* outKey, void* outVal)</span>
<a href="#l39.597"></a><span id="l39.597"> {</span>
<a href="#l39.598"></a><span id="l39.598">   mork_change* outNext = 0;</span>
<a href="#l39.599"></a><span id="l39.599" class="difflineminus">-  </span>
<a href="#l39.600"></a><span id="l39.600" class="difflineplus">+</span>
<a href="#l39.601"></a><span id="l39.601">   morkMap* map = mMapIter_Map;</span>
<a href="#l39.602"></a><span id="l39.602" class="difflineminus">-  </span>
<a href="#l39.603"></a><span id="l39.603" class="difflineplus">+</span>
<a href="#l39.604"></a><span id="l39.604">   if ( map &amp;&amp; map-&gt;GoodMap() ) /* map looks good? */</span>
<a href="#l39.605"></a><span id="l39.605">   {</span>
<a href="#l39.606"></a><span id="l39.606">     if ( mMapIter_Seed == map-&gt;mMap_Seed ) /* in sync? */</span>
<a href="#l39.607"></a><span id="l39.607">     {</span>
<a href="#l39.608"></a><span id="l39.608">       morkAssoc* here = mMapIter_Assoc; /* current assoc */</span>
<a href="#l39.609"></a><span id="l39.609">       if ( here ) /* iteration is not yet concluded? */</span>
<a href="#l39.610"></a><span id="l39.610">       {</span>
<a href="#l39.611"></a><span id="l39.611">         morkAssoc* next = mMapIter_Next;</span>
<a href="#l39.612"></a><span id="l39.612" class="difflineminus">-        morkAssoc* assoc = next; /* default new mMapIter_Assoc */  </span>
<a href="#l39.613"></a><span id="l39.613" class="difflineplus">+        morkAssoc* assoc = next; /* default new mMapIter_Assoc */</span>
<a href="#l39.614"></a><span id="l39.614">         if ( next ) /* there are more assocs in the same bucket after Here? */</span>
<a href="#l39.615"></a><span id="l39.615">         {</span>
<a href="#l39.616"></a><span id="l39.616">           morkAssoc** ref = mMapIter_AssocRef;</span>
<a href="#l39.617"></a><span id="l39.617" class="difflineminus">-          </span>
<a href="#l39.618"></a><span id="l39.618" class="difflineplus">+</span>
<a href="#l39.619"></a><span id="l39.619">           /* (*HereRef) equals Here, except when Here has been cut, after</span>
<a href="#l39.620"></a><span id="l39.620">           ** which (*HereRef) always equals Next.  So if (*HereRef) is not</span>
<a href="#l39.621"></a><span id="l39.621">           ** equal to Next, then HereRef still needs to be updated to point</span>
<a href="#l39.622"></a><span id="l39.622">           ** somewhere else other than Here.  Otherwise it is fine.</span>
<a href="#l39.623"></a><span id="l39.623">           */</span>
<a href="#l39.624"></a><span id="l39.624">           if ( *ref != next ) /* Here was not cut? must update HereRef? */</span>
<a href="#l39.625"></a><span id="l39.625">             mMapIter_AssocRef = &amp;here-&gt;mAssoc_Next;</span>
<a href="#l39.626"></a><span id="l39.626" class="difflineminus">-            </span>
<a href="#l39.627"></a><span id="l39.627" class="difflineplus">+</span>
<a href="#l39.628"></a><span id="l39.628">           mMapIter_Next = next-&gt;mAssoc_Next;</span>
<a href="#l39.629"></a><span id="l39.629">         }</span>
<a href="#l39.630"></a><span id="l39.630">         else /* look for the next assoc in the next nonempty bucket */</span>
<a href="#l39.631"></a><span id="l39.631">         {</span>
<a href="#l39.632"></a><span id="l39.632">           morkAssoc** bucket = map-&gt;mMap_Buckets;</span>
<a href="#l39.633"></a><span id="l39.633">           morkAssoc** end = bucket + map-&gt;mMap_Slots; /* beyond */</span>
<a href="#l39.634"></a><span id="l39.634">           mMapIter_Assoc = 0; /* default to no more assocs */</span>
<a href="#l39.635"></a><span id="l39.635">           bucket = mMapIter_Bucket; /* last exhausted bucket */</span>
<a href="#l39.636"></a><span id="l39.636">           mMapIter_Assoc = 0; /* default to iteration ended */</span>
<a href="#l39.637"></a><span id="l39.637" class="difflineminus">-          </span>
<a href="#l39.638"></a><span id="l39.638" class="difflineplus">+</span>
<a href="#l39.639"></a><span id="l39.639">           while ( ++bucket &lt; end ) /* another bucket to search for assocs? */</span>
<a href="#l39.640"></a><span id="l39.640">           {</span>
<a href="#l39.641"></a><span id="l39.641">             assoc = *bucket;</span>
<a href="#l39.642"></a><span id="l39.642">             if ( assoc ) /* found another map assoc in use? */</span>
<a href="#l39.643"></a><span id="l39.643">             {</span>
<a href="#l39.644"></a><span id="l39.644">               mMapIter_Bucket = bucket;</span>
<a href="#l39.645"></a><span id="l39.645">               mMapIter_AssocRef = bucket; /* ref to assoc */</span>
<a href="#l39.646"></a><span id="l39.646">               mMapIter_Next = assoc-&gt;mAssoc_Next; /* more */</span>
<a href="#l39.647"></a><span id="l39.647" class="difflineminus">-              </span>
<a href="#l39.648"></a><span id="l39.648" class="difflineplus">+</span>
<a href="#l39.649"></a><span id="l39.649">               break; /* end while loop */</span>
<a href="#l39.650"></a><span id="l39.650">             }</span>
<a href="#l39.651"></a><span id="l39.651">           }</span>
<a href="#l39.652"></a><span id="l39.652">         }</span>
<a href="#l39.653"></a><span id="l39.653">         if ( assoc ) /* did we find another assoc in the iteration? */</span>
<a href="#l39.654"></a><span id="l39.654">         {</span>
<a href="#l39.655"></a><span id="l39.655">           mMapIter_Assoc = assoc; /* current assoc */</span>
<a href="#l39.656"></a><span id="l39.656">           mork_pos i = assoc - map-&gt;mMap_Assocs;</span>
<a href="#l39.657"></a><span id="l39.657">           mork_change* c = map-&gt;mMap_Changes;</span>
<a href="#l39.658"></a><span id="l39.658">           outNext = ( c )? (c + i) : map-&gt;FormDummyChange();</span>
<a href="#l39.659"></a><span id="l39.659" class="difflineminus">-        </span>
<a href="#l39.660"></a><span id="l39.660" class="difflineplus">+</span>
<a href="#l39.661"></a><span id="l39.661">           map-&gt;get_assoc( outKey, outVal, i);</span>
<a href="#l39.662"></a><span id="l39.662">         }</span>
<a href="#l39.663"></a><span id="l39.663">       }</span>
<a href="#l39.664"></a><span id="l39.664">     }</span>
<a href="#l39.665"></a><span id="l39.665">     else map-&gt;NewIterOutOfSyncError(ev);</span>
<a href="#l39.666"></a><span id="l39.666">   }</span>
<a href="#l39.667"></a><span id="l39.667">   else map-&gt;NewBadMapError(ev);</span>
<a href="#l39.668"></a><span id="l39.668" class="difflineminus">-  </span>
<a href="#l39.669"></a><span id="l39.669" class="difflineplus">+</span>
<a href="#l39.670"></a><span id="l39.670">   return outNext;</span>
<a href="#l39.671"></a><span id="l39.671"> }</span>
<a href="#l39.672"></a><span id="l39.672"> </span>
<a href="#l39.673"></a><span id="l39.673"> mork_change*</span>
<a href="#l39.674"></a><span id="l39.674"> morkMapIter::Here(morkEnv* ev, void* outKey, void* outVal)</span>
<a href="#l39.675"></a><span id="l39.675"> {</span>
<a href="#l39.676"></a><span id="l39.676">   mork_change* outHere = 0;</span>
<a href="#l39.677"></a><span id="l39.677" class="difflineminus">-  </span>
<a href="#l39.678"></a><span id="l39.678" class="difflineplus">+</span>
<a href="#l39.679"></a><span id="l39.679">   morkMap* map = mMapIter_Map;</span>
<a href="#l39.680"></a><span id="l39.680" class="difflineminus">-  </span>
<a href="#l39.681"></a><span id="l39.681" class="difflineplus">+</span>
<a href="#l39.682"></a><span id="l39.682">   if ( map &amp;&amp; map-&gt;GoodMap() ) /* map looks good? */</span>
<a href="#l39.683"></a><span id="l39.683">   {</span>
<a href="#l39.684"></a><span id="l39.684">     if ( mMapIter_Seed == map-&gt;mMap_Seed ) /* in sync? */</span>
<a href="#l39.685"></a><span id="l39.685">     {</span>
<a href="#l39.686"></a><span id="l39.686">       morkAssoc* here = mMapIter_Assoc; /* current assoc */</span>
<a href="#l39.687"></a><span id="l39.687">       if ( here ) /* iteration is not yet concluded? */</span>
<a href="#l39.688"></a><span id="l39.688">       {</span>
<a href="#l39.689"></a><span id="l39.689">         mork_pos i = here - map-&gt;mMap_Assocs;</span>
<a href="#l39.690"></a><span id="l39.690">         mork_change* c = map-&gt;mMap_Changes;</span>
<a href="#l39.691"></a><span id="l39.691">         outHere = ( c )? (c + i) : map-&gt;FormDummyChange();</span>
<a href="#l39.692"></a><span id="l39.692" class="difflineminus">-          </span>
<a href="#l39.693"></a><span id="l39.693" class="difflineplus">+</span>
<a href="#l39.694"></a><span id="l39.694">         map-&gt;get_assoc(outKey, outVal, i);</span>
<a href="#l39.695"></a><span id="l39.695">       }</span>
<a href="#l39.696"></a><span id="l39.696">     }</span>
<a href="#l39.697"></a><span id="l39.697">     else map-&gt;NewIterOutOfSyncError(ev);</span>
<a href="#l39.698"></a><span id="l39.698">   }</span>
<a href="#l39.699"></a><span id="l39.699">   else map-&gt;NewBadMapError(ev);</span>
<a href="#l39.700"></a><span id="l39.700" class="difflineminus">-  </span>
<a href="#l39.701"></a><span id="l39.701" class="difflineplus">+</span>
<a href="#l39.702"></a><span id="l39.702">   return outHere;</span>
<a href="#l39.703"></a><span id="l39.703"> }</span>
<a href="#l39.704"></a><span id="l39.704"> </span>
<a href="#l39.705"></a><span id="l39.705"> mork_change*</span>
<a href="#l39.706"></a><span id="l39.706"> morkMapIter::CutHere(morkEnv* ev, void* outKey, void* outVal)</span>
<a href="#l39.707"></a><span id="l39.707"> {</span>
<a href="#l39.708"></a><span id="l39.708">   mork_change* outCutHere = 0;</span>
<a href="#l39.709"></a><span id="l39.709">   morkMap* map = mMapIter_Map;</span>
<a href="#l39.710"></a><span id="l39.710" class="difflineminus">-  </span>
<a href="#l39.711"></a><span id="l39.711" class="difflineplus">+</span>
<a href="#l39.712"></a><span id="l39.712">   if ( map &amp;&amp; map-&gt;GoodMap() ) /* map looks good? */</span>
<a href="#l39.713"></a><span id="l39.713">   {</span>
<a href="#l39.714"></a><span id="l39.714">     if ( mMapIter_Seed == map-&gt;mMap_Seed ) /* in sync? */</span>
<a href="#l39.715"></a><span id="l39.715">     {</span>
<a href="#l39.716"></a><span id="l39.716">       morkAssoc* here = mMapIter_Assoc; /* current assoc */</span>
<a href="#l39.717"></a><span id="l39.717">       if ( here ) /* iteration is not yet concluded? */</span>
<a href="#l39.718"></a><span id="l39.718">       {</span>
<a href="#l39.719"></a><span id="l39.719">         morkAssoc** ref = mMapIter_AssocRef;</span>
<a href="#l39.720"></a><span id="l39.720">         if ( *ref != mMapIter_Next ) /* not already cut? */</span>
<a href="#l39.721"></a><span id="l39.721">         {</span>
<a href="#l39.722"></a><span id="l39.722">           mork_pos i = here - map-&gt;mMap_Assocs;</span>
<a href="#l39.723"></a><span id="l39.723">           mork_change* c = map-&gt;mMap_Changes;</span>
<a href="#l39.724"></a><span id="l39.724">           outCutHere = ( c )? (c + i) : map-&gt;FormDummyChange();</span>
<a href="#l39.725"></a><span id="l39.725">           if ( outKey || outVal )</span>
<a href="#l39.726"></a><span id="l39.726">             map-&gt;get_assoc(outKey, outVal, i);</span>
<a href="#l39.727"></a><span id="l39.727" class="difflineminus">-            </span>
<a href="#l39.728"></a><span id="l39.728" class="difflineplus">+</span>
<a href="#l39.729"></a><span id="l39.729">           map-&gt;push_free_assoc(here); /* add to free list */</span>
<a href="#l39.730"></a><span id="l39.730">           *ref = mMapIter_Next; /* unlink here from bucket list */</span>
<a href="#l39.731"></a><span id="l39.731" class="difflineminus">-          </span>
<a href="#l39.732"></a><span id="l39.732" class="difflineplus">+</span>
<a href="#l39.733"></a><span id="l39.733">           /* note the map has changed, but we are still in sync: */</span>
<a href="#l39.734"></a><span id="l39.734">           mMapIter_Seed = ++map-&gt;mMap_Seed; /* sync */</span>
<a href="#l39.735"></a><span id="l39.735" class="difflineminus">-          </span>
<a href="#l39.736"></a><span id="l39.736" class="difflineplus">+</span>
<a href="#l39.737"></a><span id="l39.737">           if ( map-&gt;mMap_Fill ) /* still has nonzero value? */</span>
<a href="#l39.738"></a><span id="l39.738">             --map-&gt;mMap_Fill; /* one less member in the collection */</span>
<a href="#l39.739"></a><span id="l39.739">           else</span>
<a href="#l39.740"></a><span id="l39.740">             map-&gt;NewSlotsUnderflowWarning(ev);</span>
<a href="#l39.741"></a><span id="l39.741">         }</span>
<a href="#l39.742"></a><span id="l39.742">       }</span>
<a href="#l39.743"></a><span id="l39.743">     }</span>
<a href="#l39.744"></a><span id="l39.744">     else map-&gt;NewIterOutOfSyncError(ev);</span>
<a href="#l39.745"></a><span id="l39.745">   }</span>
<a href="#l39.746"></a><span id="l39.746">   else map-&gt;NewBadMapError(ev);</span>
<a href="#l39.747"></a><span id="l39.747" class="difflineminus">-  </span>
<a href="#l39.748"></a><span id="l39.748" class="difflineplus">+</span>
<a href="#l39.749"></a><span id="l39.749">   return outCutHere;</span>
<a href="#l39.750"></a><span id="l39.750"> }</span>
<a href="#l39.751"></a><span id="l39.751"> </span>
<a href="#l39.752"></a><span id="l39.752"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l40.1"></a><span id="l40.1" class="difflineminus">--- a/db/mork/src/morkMap.h</span>
<a href="#l40.2"></a><span id="l40.2" class="difflineplus">+++ b/db/mork/src/morkMap.h</span>
<a href="#l40.3"></a><span id="l40.3" class="difflineat">@@ -70,50 +70,50 @@ typedef mork_bool (* morkMap_mIsNil)</span>
<a href="#l40.4"></a><span id="l40.4"> //typedef void (* morkMap_mNote)</span>
<a href="#l40.5"></a><span id="l40.5"> //(morkMap* self, morkEnv* ev, void* inKeyOrVal);</span>
<a href="#l40.6"></a><span id="l40.6"> </span>
<a href="#l40.7"></a><span id="l40.7"> /*| morkMapForm: slots need to initialize a new dict.  (This is very similar</span>
<a href="#l40.8"></a><span id="l40.8"> **| to the config object for public domain IronDoc hash tables.)</span>
<a href="#l40.9"></a><span id="l40.9"> |*/</span>
<a href="#l40.10"></a><span id="l40.10"> class morkMapForm { // a struct of callback method pointers for morkMap</span>
<a href="#l40.11"></a><span id="l40.11"> public:</span>
<a href="#l40.12"></a><span id="l40.12" class="difflineminus">-  </span>
<a href="#l40.13"></a><span id="l40.13" class="difflineplus">+</span>
<a href="#l40.14"></a><span id="l40.14">   // const void*     mMapForm_NilKey;  // externally defined 'nil' bit pattern</span>
<a href="#l40.15"></a><span id="l40.15"> </span>
<a href="#l40.16"></a><span id="l40.16">   // void*           mMapForm_NilBuf[ 8 ]; // potential place to put NilKey</span>
<a href="#l40.17"></a><span id="l40.17">   // If keys are no larger than 8*sizeof(void*), NilKey can be put in NilBuf.</span>
<a href="#l40.18"></a><span id="l40.18">   // Note this should be true for all Mork subclasses, and we plan usage so.</span>
<a href="#l40.19"></a><span id="l40.19" class="difflineminus">-  </span>
<a href="#l40.20"></a><span id="l40.20" class="difflineplus">+</span>
<a href="#l40.21"></a><span id="l40.21">   // These three methods must always be provided, so zero will cause errors:</span>
<a href="#l40.22"></a><span id="l40.22" class="difflineminus">-  </span>
<a href="#l40.23"></a><span id="l40.23" class="difflineplus">+</span>
<a href="#l40.24"></a><span id="l40.24">   // morkMap_mEqual  mMapForm_Equal;   // for comparing two keys for identity</span>
<a href="#l40.25"></a><span id="l40.25">   // morkMap_mHash   mMapForm_Hash;    // deterministic key to hash method</span>
<a href="#l40.26"></a><span id="l40.26">   // morkMap_mIsNil  mMapForm_IsNil;   // to query whether a key equals 'nil'</span>
<a href="#l40.27"></a><span id="l40.27" class="difflineminus">-  </span>
<a href="#l40.28"></a><span id="l40.28" class="difflineplus">+</span>
<a href="#l40.29"></a><span id="l40.29">   // If any of these method slots are nonzero, then morkMap will call the</span>
<a href="#l40.30"></a><span id="l40.30">   // appropriate one to notify dict users when a key or value is added or cut.</span>
<a href="#l40.31"></a><span id="l40.31">   // Presumably a caller wants to know this in order to perform refcounting or</span>
<a href="#l40.32"></a><span id="l40.32">   // some other kind of memory management.  These methods are definitely only</span>
<a href="#l40.33"></a><span id="l40.33">   // called when references to keys or values are inserted or removed, and are</span>
<a href="#l40.34"></a><span id="l40.34">   // never called when the actual number of references does not change (such</span>
<a href="#l40.35"></a><span id="l40.35">   // as when added keys are already present or cut keys are alreading missing).</span>
<a href="#l40.36"></a><span id="l40.36" class="difflineminus">-  // </span>
<a href="#l40.37"></a><span id="l40.37" class="difflineplus">+  //</span>
<a href="#l40.38"></a><span id="l40.38">   // morkMap_mNote   mMapForm_AddKey;  // if nonzero, notify about add key</span>
<a href="#l40.39"></a><span id="l40.39">   // morkMap_mNote   mMapForm_CutKey;  // if nonzero, notify about cut key</span>
<a href="#l40.40"></a><span id="l40.40">   // morkMap_mNote   mMapForm_AddVal;  // if nonzero, notify about add val</span>
<a href="#l40.41"></a><span id="l40.41">   // morkMap_mNote   mMapForm_CutVal;  // if nonzero, notify about cut val</span>
<a href="#l40.42"></a><span id="l40.42">   //</span>
<a href="#l40.43"></a><span id="l40.43">   // These note methods have been removed because it seems difficult to</span>
<a href="#l40.44"></a><span id="l40.44">   // guarantee suitable alignment of objects passed to notification methods.</span>
<a href="#l40.45"></a><span id="l40.45" class="difflineminus">-  </span>
<a href="#l40.46"></a><span id="l40.46" class="difflineplus">+</span>
<a href="#l40.47"></a><span id="l40.47">   // Note dict clients should pick key and val sizes that provide whatever</span>
<a href="#l40.48"></a><span id="l40.48">   // alignment will be required for an array of such keys and values.</span>
<a href="#l40.49"></a><span id="l40.49">   mork_size       mMapForm_KeySize; // size of every key (cannot be zero)</span>
<a href="#l40.50"></a><span id="l40.50">   mork_size       mMapForm_ValSize; // size of every val (can indeed be zero)</span>
<a href="#l40.51"></a><span id="l40.51" class="difflineminus">-  </span>
<a href="#l40.52"></a><span id="l40.52" class="difflineplus">+</span>
<a href="#l40.53"></a><span id="l40.53">   mork_bool       mMapForm_HoldChanges; // support changes array in the map</span>
<a href="#l40.54"></a><span id="l40.54">   mork_change     mMapForm_DummyChange; // change used for false HoldChanges</span>
<a href="#l40.55"></a><span id="l40.55">   mork_bool       mMapForm_KeyIsIP;     // key is mork_ip sized</span>
<a href="#l40.56"></a><span id="l40.56">   mork_bool       mMapForm_ValIsIP;     // key is mork_ip sized</span>
<a href="#l40.57"></a><span id="l40.57"> };</span>
<a href="#l40.58"></a><span id="l40.58"> </span>
<a href="#l40.59"></a><span id="l40.59"> /*| morkAssoc: a canonical association slot in a morkMap.  A single assoc</span>
<a href="#l40.60"></a><span id="l40.60"> **| instance does nothing except point to the next assoc in the same bucket</span>
<a href="#l40.61"></a><span id="l40.61" class="difflineat">@@ -149,99 +149,99 @@ public:</span>
<a href="#l40.62"></a><span id="l40.62"> |*/</span>
<a href="#l40.63"></a><span id="l40.63"> class morkMap : public morkNode {</span>
<a href="#l40.64"></a><span id="l40.64"> </span>
<a href="#l40.65"></a><span id="l40.65"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l40.66"></a><span id="l40.66">   // nsIMdbHeap*       mNode_Heap;</span>
<a href="#l40.67"></a><span id="l40.67"> </span>
<a href="#l40.68"></a><span id="l40.68">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l40.69"></a><span id="l40.69">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l40.70"></a><span id="l40.70" class="difflineminus">-  </span>
<a href="#l40.71"></a><span id="l40.71" class="difflineplus">+</span>
<a href="#l40.72"></a><span id="l40.72">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l40.73"></a><span id="l40.73">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l40.74"></a><span id="l40.74">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l40.75"></a><span id="l40.75">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l40.76"></a><span id="l40.76" class="difflineminus">-  </span>
<a href="#l40.77"></a><span id="l40.77" class="difflineplus">+</span>
<a href="#l40.78"></a><span id="l40.78">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l40.79"></a><span id="l40.79">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l40.80"></a><span id="l40.80"> </span>
<a href="#l40.81"></a><span id="l40.81"> public: // state is public because the entire Mork system is private</span>
<a href="#l40.82"></a><span id="l40.82"> </span>
<a href="#l40.83"></a><span id="l40.83">   nsIMdbHeap*       mMap_Heap; // strong ref to heap allocating all space</span>
<a href="#l40.84"></a><span id="l40.84">   mork_u4           mMap_Tag; // must equal morkMap_kTag</span>
<a href="#l40.85"></a><span id="l40.85"> </span>
<a href="#l40.86"></a><span id="l40.86">   // When a morkMap instance is constructed, the dict form slots must be</span>
<a href="#l40.87"></a><span id="l40.87">   // provided in order to properly configure a dict with all runtime needs:</span>
<a href="#l40.88"></a><span id="l40.88" class="difflineminus">-  </span>
<a href="#l40.89"></a><span id="l40.89" class="difflineplus">+</span>
<a href="#l40.90"></a><span id="l40.90">   morkMapForm       mMap_Form; // construction time parameterization</span>
<a href="#l40.91"></a><span id="l40.91" class="difflineminus">-  </span>
<a href="#l40.92"></a><span id="l40.92" class="difflineplus">+</span>
<a href="#l40.93"></a><span id="l40.93">   // Whenever the dict changes structure in a way that would affect any</span>
<a href="#l40.94"></a><span id="l40.94">   // iteration of the dict associations, the seed increments to show this:</span>
<a href="#l40.95"></a><span id="l40.95" class="difflineminus">-  </span>
<a href="#l40.96"></a><span id="l40.96" class="difflineplus">+</span>
<a href="#l40.97"></a><span id="l40.97">   mork_seed         mMap_Seed;   // counter for member and structural changes</span>
<a href="#l40.98"></a><span id="l40.98" class="difflineminus">-  </span>
<a href="#l40.99"></a><span id="l40.99" class="difflineplus">+</span>
<a href="#l40.100"></a><span id="l40.100">   // The current total assoc capacity of the dict is mMap_Slots, where</span>
<a href="#l40.101"></a><span id="l40.101">   // mMap_Fill of these slots are actually holding content, so mMap_Fill</span>
<a href="#l40.102"></a><span id="l40.102">   // is the actual membership count, and mMap_Slots is how larger membership</span>
<a href="#l40.103"></a><span id="l40.103" class="difflineminus">-  // can become before the hash table must grow the buffers being used. </span>
<a href="#l40.104"></a><span id="l40.104" class="difflineminus">-  </span>
<a href="#l40.105"></a><span id="l40.105" class="difflineplus">+  // can become before the hash table must grow the buffers being used.</span>
<a href="#l40.106"></a><span id="l40.106" class="difflineplus">+</span>
<a href="#l40.107"></a><span id="l40.107">   mork_count        mMap_Slots;  // count of slots in the hash table</span>
<a href="#l40.108"></a><span id="l40.108">   mork_fill         mMap_Fill;   // number of used slots in the hash table</span>
<a href="#l40.109"></a><span id="l40.109" class="difflineminus">-  </span>
<a href="#l40.110"></a><span id="l40.110" class="difflineplus">+</span>
<a href="#l40.111"></a><span id="l40.111">   // Key and value slots are bound to corresponding mMap_Assocs array slots.</span>
<a href="#l40.112"></a><span id="l40.112">   // Instead of having a single array like this: {key,val,next}[ mMap_Slots ]</span>
<a href="#l40.113"></a><span id="l40.113">   // we have instead three parallel arrays with essentially the same meaning:</span>
<a href="#l40.114"></a><span id="l40.114">   // {key}[ mMap_Slots ], {val}[ mMap_Slots ], {assocs}[ mMap_Slots ]</span>
<a href="#l40.115"></a><span id="l40.115" class="difflineminus">-  </span>
<a href="#l40.116"></a><span id="l40.116" class="difflineplus">+</span>
<a href="#l40.117"></a><span id="l40.117">   mork_u1*          mMap_Keys;  // mMap_Slots * mMapForm_KeySize buffer</span>
<a href="#l40.118"></a><span id="l40.118">   mork_u1*          mMap_Vals;  // mMap_Slots * mMapForm_ValSize buffer</span>
<a href="#l40.119"></a><span id="l40.119"> </span>
<a href="#l40.120"></a><span id="l40.120">   // An assoc is &quot;used&quot; when it appears in a bucket's linked list of assocs.</span>
<a href="#l40.121"></a><span id="l40.121">   // Until an assoc is used, it appears in the FreeList linked list.  Every</span>
<a href="#l40.122"></a><span id="l40.122">   // assoc that becomes used goes into the bucket determined by hashing the</span>
<a href="#l40.123"></a><span id="l40.123">   // key associated with a new assoc.  The key associated with a new assoc</span>
<a href="#l40.124"></a><span id="l40.124">   // goes in to the slot in mMap_Keys which occupies exactly the same array</span>
<a href="#l40.125"></a><span id="l40.125">   // index as the array index of the used assoc in the mMap_Assocs array.</span>
<a href="#l40.126"></a><span id="l40.126" class="difflineminus">-  </span>
<a href="#l40.127"></a><span id="l40.127" class="difflineplus">+</span>
<a href="#l40.128"></a><span id="l40.128">   morkAssoc*        mMap_Assocs;   // mMap_Slots * sizeof(morkAssoc) buffer</span>
<a href="#l40.129"></a><span id="l40.129" class="difflineminus">-  </span>
<a href="#l40.130"></a><span id="l40.130" class="difflineplus">+</span>
<a href="#l40.131"></a><span id="l40.131">   // The changes array is only needed when the</span>
<a href="#l40.132"></a><span id="l40.132"> </span>
<a href="#l40.133"></a><span id="l40.133">   mork_change*      mMap_Changes;  // mMap_Slots * sizeof(mork_change) buffer</span>
<a href="#l40.134"></a><span id="l40.134" class="difflineminus">-  </span>
<a href="#l40.135"></a><span id="l40.135" class="difflineplus">+</span>
<a href="#l40.136"></a><span id="l40.136">   // The Buckets array need not be the same length as the Assocs array, but we</span>
<a href="#l40.137"></a><span id="l40.137">   // usually do it that way so the average bucket depth is no more than one.</span>
<a href="#l40.138"></a><span id="l40.138">   // (We could pick a different policy, or make it parameterizable, but that's</span>
<a href="#l40.139"></a><span id="l40.139">   // tuning we can do some other time.)</span>
<a href="#l40.140"></a><span id="l40.140" class="difflineminus">-  </span>
<a href="#l40.141"></a><span id="l40.141" class="difflineplus">+</span>
<a href="#l40.142"></a><span id="l40.142">   morkAssoc**       mMap_Buckets;  // mMap_Slots * sizeof(morkAssoc*) buffer</span>
<a href="#l40.143"></a><span id="l40.143" class="difflineminus">-  </span>
<a href="#l40.144"></a><span id="l40.144" class="difflineplus">+</span>
<a href="#l40.145"></a><span id="l40.145">   // The length of the mMap_FreeList should equal (mMap_Slots - mMap_Fill).</span>
<a href="#l40.146"></a><span id="l40.146">   // We need a free list instead of a simpler representation because assocs</span>
<a href="#l40.147"></a><span id="l40.147">   // can be cut and returned to availability in any kind of unknown pattern.</span>
<a href="#l40.148"></a><span id="l40.148">   // (However, when assocs are first allocated, or when the dict is grown, we</span>
<a href="#l40.149"></a><span id="l40.149">   // know all new assocs are contiguous and can chain together adjacently.)</span>
<a href="#l40.150"></a><span id="l40.150" class="difflineminus">-  </span>
<a href="#l40.151"></a><span id="l40.151" class="difflineminus">-  morkAssoc*        mMap_FreeList; // list of unused mMap_Assocs array slots </span>
<a href="#l40.152"></a><span id="l40.152" class="difflineplus">+</span>
<a href="#l40.153"></a><span id="l40.153" class="difflineplus">+  morkAssoc*        mMap_FreeList; // list of unused mMap_Assocs array slots</span>
<a href="#l40.154"></a><span id="l40.154"> </span>
<a href="#l40.155"></a><span id="l40.155"> public: // getters (morkProbeMap compatibility)</span>
<a href="#l40.156"></a><span id="l40.156">   mork_fill        MapFill() const { return mMap_Fill; }</span>
<a href="#l40.157"></a><span id="l40.157" class="difflineminus">-  </span>
<a href="#l40.158"></a><span id="l40.158" class="difflineplus">+</span>
<a href="#l40.159"></a><span id="l40.159"> // { ===== begin morkNode interface =====</span>
<a href="#l40.160"></a><span id="l40.160"> public: // morkNode virtual methods</span>
<a href="#l40.161"></a><span id="l40.161">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseMap() only if open</span>
<a href="#l40.162"></a><span id="l40.162">   virtual ~morkMap(); // assert that CloseMap() executed earlier</span>
<a href="#l40.163"></a><span id="l40.163" class="difflineminus">-  </span>
<a href="#l40.164"></a><span id="l40.164" class="difflineplus">+</span>
<a href="#l40.165"></a><span id="l40.165"> public: // morkMap construction &amp; destruction</span>
<a href="#l40.166"></a><span id="l40.166" class="difflineminus">-  morkMap(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioNodeHeap, </span>
<a href="#l40.167"></a><span id="l40.167" class="difflineplus">+  morkMap(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioNodeHeap,</span>
<a href="#l40.168"></a><span id="l40.168">     mork_size inKeySize, mork_size inValSize,</span>
<a href="#l40.169"></a><span id="l40.169">     mork_size inSlots, nsIMdbHeap* ioSlotHeap, mork_bool inHoldChanges);</span>
<a href="#l40.170"></a><span id="l40.170" class="difflineminus">-  </span>
<a href="#l40.171"></a><span id="l40.171" class="difflineminus">-  void CloseMap(morkEnv* ev); // called by </span>
<a href="#l40.172"></a><span id="l40.172" class="difflineminus">-  </span>
<a href="#l40.173"></a><span id="l40.173" class="difflineplus">+</span>
<a href="#l40.174"></a><span id="l40.174" class="difflineplus">+  void CloseMap(morkEnv* ev); // called by</span>
<a href="#l40.175"></a><span id="l40.175" class="difflineplus">+</span>
<a href="#l40.176"></a><span id="l40.176"> public: // dynamic type identification</span>
<a href="#l40.177"></a><span id="l40.177">   mork_bool IsMap() const</span>
<a href="#l40.178"></a><span id="l40.178">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kMap; }</span>
<a href="#l40.179"></a><span id="l40.179"> // } ===== end morkNode methods =====</span>
<a href="#l40.180"></a><span id="l40.180"> </span>
<a href="#l40.181"></a><span id="l40.181"> public: // poly map hash table methods</span>
<a href="#l40.182"></a><span id="l40.182"> </span>
<a href="#l40.183"></a><span id="l40.183"> // { ===== begin morkMap poly interface =====</span>
<a href="#l40.184"></a><span id="l40.184" class="difflineat">@@ -252,143 +252,143 @@ public: // poly map hash table methods</span>
<a href="#l40.185"></a><span id="l40.185">   Hash(morkEnv* ev, const void* inKey) const = 0;</span>
<a href="#l40.186"></a><span id="l40.186"> // } ===== end morkMap poly interface =====</span>
<a href="#l40.187"></a><span id="l40.187"> </span>
<a href="#l40.188"></a><span id="l40.188"> public: // open utitity methods</span>
<a href="#l40.189"></a><span id="l40.189"> </span>
<a href="#l40.190"></a><span id="l40.190">   mork_bool GoodMapTag() const { return mMap_Tag == morkMap_kTag; }</span>
<a href="#l40.191"></a><span id="l40.191">   mork_bool GoodMap() const</span>
<a href="#l40.192"></a><span id="l40.192">   { return ( IsNode() &amp;&amp; GoodMapTag() ); }</span>
<a href="#l40.193"></a><span id="l40.193" class="difflineminus">-  </span>
<a href="#l40.194"></a><span id="l40.194" class="difflineplus">+</span>
<a href="#l40.195"></a><span id="l40.195">   void NewIterOutOfSyncError(morkEnv* ev);</span>
<a href="#l40.196"></a><span id="l40.196">   void NewBadMapError(morkEnv* ev);</span>
<a href="#l40.197"></a><span id="l40.197">   void NewSlotsUnderflowWarning(morkEnv* ev);</span>
<a href="#l40.198"></a><span id="l40.198">   void InitMap(morkEnv* ev, mork_size inSlots);</span>
<a href="#l40.199"></a><span id="l40.199"> </span>
<a href="#l40.200"></a><span id="l40.200"> protected: // internal utitity methods</span>
<a href="#l40.201"></a><span id="l40.201"> </span>
<a href="#l40.202"></a><span id="l40.202">   friend class morkMapIter;</span>
<a href="#l40.203"></a><span id="l40.203">   void clear_map(morkEnv* ev, nsIMdbHeap* ioHeap);</span>
<a href="#l40.204"></a><span id="l40.204"> </span>
<a href="#l40.205"></a><span id="l40.205">   void* alloc(morkEnv* ev, mork_size inSize);</span>
<a href="#l40.206"></a><span id="l40.206">   void* clear_alloc(morkEnv* ev, mork_size inSize);</span>
<a href="#l40.207"></a><span id="l40.207" class="difflineminus">-  </span>
<a href="#l40.208"></a><span id="l40.208" class="difflineplus">+</span>
<a href="#l40.209"></a><span id="l40.209">   void push_free_assoc(morkAssoc* ioAssoc)</span>
<a href="#l40.210"></a><span id="l40.210">   {</span>
<a href="#l40.211"></a><span id="l40.211">     ioAssoc-&gt;mAssoc_Next = mMap_FreeList;</span>
<a href="#l40.212"></a><span id="l40.212">     mMap_FreeList = ioAssoc;</span>
<a href="#l40.213"></a><span id="l40.213">   }</span>
<a href="#l40.214"></a><span id="l40.214" class="difflineminus">-  </span>
<a href="#l40.215"></a><span id="l40.215" class="difflineplus">+</span>
<a href="#l40.216"></a><span id="l40.216">   morkAssoc* pop_free_assoc()</span>
<a href="#l40.217"></a><span id="l40.217">   {</span>
<a href="#l40.218"></a><span id="l40.218">     morkAssoc* assoc = mMap_FreeList;</span>
<a href="#l40.219"></a><span id="l40.219">     if ( assoc )</span>
<a href="#l40.220"></a><span id="l40.220">       mMap_FreeList = assoc-&gt;mAssoc_Next;</span>
<a href="#l40.221"></a><span id="l40.221">     return assoc;</span>
<a href="#l40.222"></a><span id="l40.222">   }</span>
<a href="#l40.223"></a><span id="l40.223"> </span>
<a href="#l40.224"></a><span id="l40.224">   morkAssoc** find(morkEnv* ev, const void* inKey, mork_u4 inHash) const;</span>
<a href="#l40.225"></a><span id="l40.225" class="difflineminus">-  </span>
<a href="#l40.226"></a><span id="l40.226" class="difflineplus">+</span>
<a href="#l40.227"></a><span id="l40.227">   mork_u1* new_keys(morkEnv* ev, mork_num inSlots);</span>
<a href="#l40.228"></a><span id="l40.228">   mork_u1* new_values(morkEnv* ev, mork_num inSlots);</span>
<a href="#l40.229"></a><span id="l40.229">   mork_change* new_changes(morkEnv* ev, mork_num inSlots);</span>
<a href="#l40.230"></a><span id="l40.230">   morkAssoc** new_buckets(morkEnv* ev, mork_num inSlots);</span>
<a href="#l40.231"></a><span id="l40.231">   morkAssoc* new_assocs(morkEnv* ev, mork_num inSlots);</span>
<a href="#l40.232"></a><span id="l40.232">   mork_bool new_arrays(morkEnv* ev, morkHashArrays* old, mork_num inSlots);</span>
<a href="#l40.233"></a><span id="l40.233" class="difflineminus">-  </span>
<a href="#l40.234"></a><span id="l40.234" class="difflineplus">+</span>
<a href="#l40.235"></a><span id="l40.235">   mork_bool grow(morkEnv* ev);</span>
<a href="#l40.236"></a><span id="l40.236"> </span>
<a href="#l40.237"></a><span id="l40.237">   void get_assoc(void* outKey, void* outVal, mork_pos inPos) const;</span>
<a href="#l40.238"></a><span id="l40.238">   void put_assoc(const void* inKey, const void* inVal, mork_pos inPos) const;</span>
<a href="#l40.239"></a><span id="l40.239" class="difflineminus">-  </span>
<a href="#l40.240"></a><span id="l40.240" class="difflineplus">+</span>
<a href="#l40.241"></a><span id="l40.241"> public: // inlines to form slots</span>
<a href="#l40.242"></a><span id="l40.242">   // const void*     FormNilKey() const { return mMap_Form.mMapForm_NilKey; }</span>
<a href="#l40.243"></a><span id="l40.243" class="difflineminus">-  </span>
<a href="#l40.244"></a><span id="l40.244" class="difflineplus">+</span>
<a href="#l40.245"></a><span id="l40.245">   // morkMap_mEqual  FormEqual() const { return mMap_Form.mMapForm_Equal; }</span>
<a href="#l40.246"></a><span id="l40.246">   // morkMap_mHash   FormHash() const { return mMap_Form.mMapForm_Hash; }</span>
<a href="#l40.247"></a><span id="l40.247" class="difflineminus">-  // orkMap_mIsNil  FormIsNil() const { return mMap_Form.mMapForm_IsNil; } </span>
<a href="#l40.248"></a><span id="l40.248" class="difflineminus">-    </span>
<a href="#l40.249"></a><span id="l40.249" class="difflineplus">+  // orkMap_mIsNil  FormIsNil() const { return mMap_Form.mMapForm_IsNil; }</span>
<a href="#l40.250"></a><span id="l40.250" class="difflineplus">+</span>
<a href="#l40.251"></a><span id="l40.251">   // morkMap_mNote   FormAddKey() const { return mMap_Form.mMapForm_AddKey; }</span>
<a href="#l40.252"></a><span id="l40.252">   // morkMap_mNote   FormCutKey() const { return mMap_Form.mMapForm_CutKey; }</span>
<a href="#l40.253"></a><span id="l40.253">   // morkMap_mNote   FormAddVal() const { return mMap_Form.mMapForm_AddVal; }</span>
<a href="#l40.254"></a><span id="l40.254">   // morkMap_mNote   FormCutVal() const { return mMap_Form.mMapForm_CutVal; }</span>
<a href="#l40.255"></a><span id="l40.255" class="difflineminus">-  </span>
<a href="#l40.256"></a><span id="l40.256" class="difflineplus">+</span>
<a href="#l40.257"></a><span id="l40.257">   mork_size       FormKeySize() const { return mMap_Form.mMapForm_KeySize; }</span>
<a href="#l40.258"></a><span id="l40.258">   mork_size       FormValSize() const { return mMap_Form.mMapForm_ValSize; }</span>
<a href="#l40.259"></a><span id="l40.259"> </span>
<a href="#l40.260"></a><span id="l40.260">   mork_bool       FormKeyIsIP() const { return mMap_Form.mMapForm_KeyIsIP; }</span>
<a href="#l40.261"></a><span id="l40.261">   mork_bool       FormValIsIP() const { return mMap_Form.mMapForm_ValIsIP; }</span>
<a href="#l40.262"></a><span id="l40.262"> </span>
<a href="#l40.263"></a><span id="l40.263">   mork_bool       FormHoldChanges() const</span>
<a href="#l40.264"></a><span id="l40.264">   { return mMap_Form.mMapForm_HoldChanges; }</span>
<a href="#l40.265"></a><span id="l40.265" class="difflineminus">-  </span>
<a href="#l40.266"></a><span id="l40.266" class="difflineplus">+</span>
<a href="#l40.267"></a><span id="l40.267">   mork_change*    FormDummyChange()</span>
<a href="#l40.268"></a><span id="l40.268">   { return &amp;mMap_Form.mMapForm_DummyChange; }</span>
<a href="#l40.269"></a><span id="l40.269"> </span>
<a href="#l40.270"></a><span id="l40.270"> public: // other map methods</span>
<a href="#l40.271"></a><span id="l40.271" class="difflineminus">- </span>
<a href="#l40.272"></a><span id="l40.272" class="difflineplus">+</span>
<a href="#l40.273"></a><span id="l40.273">   mork_bool Put(morkEnv* ev, const void* inKey, const void* inVal,</span>
<a href="#l40.274"></a><span id="l40.274">     void* outKey, void* outVal, mork_change** outChange);</span>
<a href="#l40.275"></a><span id="l40.275" class="difflineminus">-    </span>
<a href="#l40.276"></a><span id="l40.276" class="difflineplus">+</span>
<a href="#l40.277"></a><span id="l40.277">   mork_bool Cut(morkEnv* ev, const void* inKey,</span>
<a href="#l40.278"></a><span id="l40.278">     void* outKey, void* outVal, mork_change** outChange);</span>
<a href="#l40.279"></a><span id="l40.279" class="difflineminus">-    </span>
<a href="#l40.280"></a><span id="l40.280" class="difflineminus">-  mork_bool Get(morkEnv* ev, const void* inKey, </span>
<a href="#l40.281"></a><span id="l40.281" class="difflineplus">+</span>
<a href="#l40.282"></a><span id="l40.282" class="difflineplus">+  mork_bool Get(morkEnv* ev, const void* inKey,</span>
<a href="#l40.283"></a><span id="l40.283">     void* outKey, void* outVal, mork_change** outChange);</span>
<a href="#l40.284"></a><span id="l40.284" class="difflineminus">-    </span>
<a href="#l40.285"></a><span id="l40.285" class="difflineplus">+</span>
<a href="#l40.286"></a><span id="l40.286">   mork_num CutAll(morkEnv* ev);</span>
<a href="#l40.287"></a><span id="l40.287"> </span>
<a href="#l40.288"></a><span id="l40.288"> private: // copying is not allowed</span>
<a href="#l40.289"></a><span id="l40.289">   morkMap(const morkMap&amp; other);</span>
<a href="#l40.290"></a><span id="l40.290">   morkMap&amp; operator=(const morkMap&amp; other);</span>
<a href="#l40.291"></a><span id="l40.291"> </span>
<a href="#l40.292"></a><span id="l40.292"> </span>
<a href="#l40.293"></a><span id="l40.293"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l40.294"></a><span id="l40.294">   static void SlotWeakMap(morkMap* me,</span>
<a href="#l40.295"></a><span id="l40.295">     morkEnv* ev, morkMap** ioSlot)</span>
<a href="#l40.296"></a><span id="l40.296">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l40.297"></a><span id="l40.297" class="difflineminus">-  </span>
<a href="#l40.298"></a><span id="l40.298" class="difflineplus">+</span>
<a href="#l40.299"></a><span id="l40.299">   static void SlotStrongMap(morkMap* me,</span>
<a href="#l40.300"></a><span id="l40.300">     morkEnv* ev, morkMap** ioSlot)</span>
<a href="#l40.301"></a><span id="l40.301">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l40.302"></a><span id="l40.302"> };</span>
<a href="#l40.303"></a><span id="l40.303"> </span>
<a href="#l40.304"></a><span id="l40.304"> /*| morkMapIter: an iterator for morkMap and subclasses.  This is not a node,</span>
<a href="#l40.305"></a><span id="l40.305"> **| and expected usage is as a member of some other node subclass, such as in</span>
<a href="#l40.306"></a><span id="l40.306"> **| a cursor subclass or a thumb subclass.  Also, iters might be as temp stack</span>
<a href="#l40.307"></a><span id="l40.307"> **| objects when scanning the content of a map.</span>
<a href="#l40.308"></a><span id="l40.308"> |*/</span>
<a href="#l40.309"></a><span id="l40.309"> class morkMapIter{  // iterator for hash table map</span>
<a href="#l40.310"></a><span id="l40.310"> </span>
<a href="#l40.311"></a><span id="l40.311"> protected:</span>
<a href="#l40.312"></a><span id="l40.312">   morkMap*    mMapIter_Map;      // map to iterate, NOT refcounted</span>
<a href="#l40.313"></a><span id="l40.313">   mork_seed   mMapIter_Seed;     // cached copy of map's seed</span>
<a href="#l40.314"></a><span id="l40.314" class="difflineminus">-  </span>
<a href="#l40.315"></a><span id="l40.315" class="difflineplus">+</span>
<a href="#l40.316"></a><span id="l40.316">   morkAssoc** mMapIter_Bucket;   // one bucket in mMap_Buckets array</span>
<a href="#l40.317"></a><span id="l40.317">   morkAssoc** mMapIter_AssocRef; // usually *AtRef equals Here</span>
<a href="#l40.318"></a><span id="l40.318">   morkAssoc*  mMapIter_Assoc;    // the current assoc in an iteration</span>
<a href="#l40.319"></a><span id="l40.319">   morkAssoc*  mMapIter_Next;     // mMapIter_Assoc-&gt;mAssoc_Next */</span>
<a href="#l40.320"></a><span id="l40.320"> </span>
<a href="#l40.321"></a><span id="l40.321"> public:</span>
<a href="#l40.322"></a><span id="l40.322">   morkMapIter(morkEnv* ev, morkMap* ioMap);</span>
<a href="#l40.323"></a><span id="l40.323">   void CloseMapIter(morkEnv* ev);</span>
<a href="#l40.324"></a><span id="l40.324" class="difflineminus">- </span>
<a href="#l40.325"></a><span id="l40.325" class="difflineplus">+</span>
<a href="#l40.326"></a><span id="l40.326">   morkMapIter( ); // everything set to zero -- need to call InitMapIter()</span>
<a href="#l40.327"></a><span id="l40.327"> </span>
<a href="#l40.328"></a><span id="l40.328"> protected: // we want all subclasses to provide typesafe wrappers:</span>
<a href="#l40.329"></a><span id="l40.329"> </span>
<a href="#l40.330"></a><span id="l40.330">   void InitMapIter(morkEnv* ev, morkMap* ioMap);</span>
<a href="#l40.331"></a><span id="l40.331" class="difflineminus">- </span>
<a href="#l40.332"></a><span id="l40.332" class="difflineplus">+</span>
<a href="#l40.333"></a><span id="l40.333">   // The morkAssoc returned below is always either mork_change* or</span>
<a href="#l40.334"></a><span id="l40.334">   // else nil (when there is no such assoc).  We return a pointer to</span>
<a href="#l40.335"></a><span id="l40.335">   // the change rather than a simple bool, because callers might</span>
<a href="#l40.336"></a><span id="l40.336">   // want to access change info associated with an assoc.</span>
<a href="#l40.337"></a><span id="l40.337" class="difflineminus">-  </span>
<a href="#l40.338"></a><span id="l40.338" class="difflineplus">+</span>
<a href="#l40.339"></a><span id="l40.339">   mork_change* First(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l40.340"></a><span id="l40.340">   mork_change* Next(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l40.341"></a><span id="l40.341">   mork_change* Here(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l40.342"></a><span id="l40.342" class="difflineminus">-  </span>
<a href="#l40.343"></a><span id="l40.343" class="difflineplus">+</span>
<a href="#l40.344"></a><span id="l40.344">   mork_change* CutHere(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l40.345"></a><span id="l40.345"> };</span>
<a href="#l40.346"></a><span id="l40.346"> </span>
<a href="#l40.347"></a><span id="l40.347"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l40.348"></a><span id="l40.348"> </span>
<a href="#l40.349"></a><span id="l40.349"> #endif /* _MORKMAP_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l41.1"></a><span id="l41.1" class="difflineminus">--- a/db/mork/src/morkNode.cpp</span>
<a href="#l41.2"></a><span id="l41.2" class="difflineplus">+++ b/db/mork/src/morkNode.cpp</span>
<a href="#l41.3"></a><span id="l41.3" class="difflineat">@@ -229,17 +229,17 @@ morkNode::~morkNode() // assert that Clo</span>
<a href="#l41.4"></a><span id="l41.4"> /*public virtual*/</span>
<a href="#l41.5"></a><span id="l41.5"> // void CloseMorkNode(morkEnv* ev) = 0; // CloseNode() only if open</span>
<a href="#l41.6"></a><span id="l41.6">   // CloseMorkNode() is the polymorphic close method called when uses==0,</span>
<a href="#l41.7"></a><span id="l41.7">   // which must do NOTHING at all when IsOpenNode() is not true.  Otherwise,</span>
<a href="#l41.8"></a><span id="l41.8">   // CloseMorkNode() should call a static close method specific to an object.</span>
<a href="#l41.9"></a><span id="l41.9">   // Each such static close method should either call inherited static close</span>
<a href="#l41.10"></a><span id="l41.10">   // methods, or else perform the consolidated effect of calling them, where</span>
<a href="#l41.11"></a><span id="l41.11">   // subclasses should closely track any changes in base classes with care.</span>
<a href="#l41.12"></a><span id="l41.12" class="difflineminus">-  </span>
<a href="#l41.13"></a><span id="l41.13" class="difflineplus">+</span>
<a href="#l41.14"></a><span id="l41.14"> </span>
<a href="#l41.15"></a><span id="l41.15"> /*public non-poly*/</span>
<a href="#l41.16"></a><span id="l41.16"> morkNode::morkNode( mork_usage inCode )</span>
<a href="#l41.17"></a><span id="l41.17"> : mNode_Heap( 0 )</span>
<a href="#l41.18"></a><span id="l41.18"> , mNode_Base( morkBase_kNode )</span>
<a href="#l41.19"></a><span id="l41.19"> , mNode_Derived ( 0 ) // until subclass sets appropriately</span>
<a href="#l41.20"></a><span id="l41.20"> , mNode_Access( morkAccess_kOpen )</span>
<a href="#l41.21"></a><span id="l41.21"> , mNode_Usage( inCode )</span>
<a href="#l41.22"></a><span id="l41.22" class="difflineat">@@ -281,17 +281,17 @@ morkNode::morkNode(morkEnv* ev,</span>
<a href="#l41.23"></a><span id="l41.23"> {</span>
<a href="#l41.24"></a><span id="l41.24">   if ( !ioHeap &amp;&amp; mNode_Usage == morkUsage_kHeap )</span>
<a href="#l41.25"></a><span id="l41.25">   {</span>
<a href="#l41.26"></a><span id="l41.26">     this-&gt;NilHeapError(ev);</span>
<a href="#l41.27"></a><span id="l41.27">   }</span>
<a href="#l41.28"></a><span id="l41.28"> }</span>
<a href="#l41.29"></a><span id="l41.29"> </span>
<a href="#l41.30"></a><span id="l41.30"> /*protected non-poly*/ void</span>
<a href="#l41.31"></a><span id="l41.31" class="difflineminus">-morkNode::RefsUnderUsesWarning(morkEnv* ev) const </span>
<a href="#l41.32"></a><span id="l41.32" class="difflineplus">+morkNode::RefsUnderUsesWarning(morkEnv* ev) const</span>
<a href="#l41.33"></a><span id="l41.33"> {</span>
<a href="#l41.34"></a><span id="l41.34">   ev-&gt;NewError(&quot;mNode_Refs &lt; mNode_Uses&quot;);</span>
<a href="#l41.35"></a><span id="l41.35"> }</span>
<a href="#l41.36"></a><span id="l41.36"> </span>
<a href="#l41.37"></a><span id="l41.37"> /*protected non-poly*/ void</span>
<a href="#l41.38"></a><span id="l41.38"> morkNode::NonNodeError(morkEnv* ev) const // called when IsNode() is false</span>
<a href="#l41.39"></a><span id="l41.39"> {</span>
<a href="#l41.40"></a><span id="l41.40">   ev-&gt;NewError(&quot;non-morkNode&quot;);</span>
<a href="#l41.41"></a><span id="l41.41" class="difflineat">@@ -437,17 +437,17 @@ morkNode::SlotWeakNode(morkNode* me, mor</span>
<a href="#l41.42"></a><span id="l41.42"> morkNode::AddStrongRef(morkEnv* ev)</span>
<a href="#l41.43"></a><span id="l41.43"> {</span>
<a href="#l41.44"></a><span id="l41.44">   mork_uses outUses = 0;</span>
<a href="#l41.45"></a><span id="l41.45">     if ( this-&gt;IsNode() )</span>
<a href="#l41.46"></a><span id="l41.46">     {</span>
<a href="#l41.47"></a><span id="l41.47">       mork_uses uses = mNode_Uses;</span>
<a href="#l41.48"></a><span id="l41.48">       mork_refs refs = mNode_Refs;</span>
<a href="#l41.49"></a><span id="l41.49">       if ( refs &lt; uses ) // need to fix broken refs/uses relation?</span>
<a href="#l41.50"></a><span id="l41.50" class="difflineminus">-      { </span>
<a href="#l41.51"></a><span id="l41.51" class="difflineplus">+      {</span>
<a href="#l41.52"></a><span id="l41.52">         this-&gt;RefsUnderUsesWarning(ev);</span>
<a href="#l41.53"></a><span id="l41.53">         mNode_Refs = mNode_Uses = refs = uses;</span>
<a href="#l41.54"></a><span id="l41.54">       }</span>
<a href="#l41.55"></a><span id="l41.55">       if ( refs &lt; morkNode_kMaxRefCount ) // not too great?</span>
<a href="#l41.56"></a><span id="l41.56">       {</span>
<a href="#l41.57"></a><span id="l41.57">         mNode_Refs = ++refs;</span>
<a href="#l41.58"></a><span id="l41.58">         mNode_Uses = ++uses;</span>
<a href="#l41.59"></a><span id="l41.59">       }</span>
<a href="#l41.60"></a><span id="l41.60" class="difflineat">@@ -514,17 +514,17 @@ morkNode::AddWeakRef(morkEnv* ev)</span>
<a href="#l41.61"></a><span id="l41.61">   mork_refs outRefs = 0;</span>
<a href="#l41.62"></a><span id="l41.62">     if ( this-&gt;IsNode() )</span>
<a href="#l41.63"></a><span id="l41.63">     {</span>
<a href="#l41.64"></a><span id="l41.64">       mork_refs refs = mNode_Refs;</span>
<a href="#l41.65"></a><span id="l41.65">       if ( refs &lt; morkNode_kMaxRefCount ) // not too great?</span>
<a href="#l41.66"></a><span id="l41.66">         mNode_Refs = ++refs;</span>
<a href="#l41.67"></a><span id="l41.67">       else</span>
<a href="#l41.68"></a><span id="l41.68">         this-&gt;RefsOverflowWarning(ev);</span>
<a href="#l41.69"></a><span id="l41.69" class="difflineminus">-        </span>
<a href="#l41.70"></a><span id="l41.70" class="difflineplus">+</span>
<a href="#l41.71"></a><span id="l41.71">       outRefs = refs;</span>
<a href="#l41.72"></a><span id="l41.72">     }</span>
<a href="#l41.73"></a><span id="l41.73">     else</span>
<a href="#l41.74"></a><span id="l41.74">       this-&gt;NonNodeError(ev);</span>
<a href="#l41.75"></a><span id="l41.75"> </span>
<a href="#l41.76"></a><span id="l41.76">   return outRefs;</span>
<a href="#l41.77"></a><span id="l41.77"> }</span>
<a href="#l41.78"></a><span id="l41.78"> </span>
<a href="#l41.79"></a><span id="l41.79" class="difflineat">@@ -537,21 +537,21 @@ morkNode::CutWeakRef(morkEnv* ev)</span>
<a href="#l41.80"></a><span id="l41.80">       mork_uses uses = mNode_Uses;</span>
<a href="#l41.81"></a><span id="l41.81">       mork_refs refs = mNode_Refs;</span>
<a href="#l41.82"></a><span id="l41.82">       if ( refs ) // not yet zero?</span>
<a href="#l41.83"></a><span id="l41.83">         mNode_Refs = --refs;</span>
<a href="#l41.84"></a><span id="l41.84">       else</span>
<a href="#l41.85"></a><span id="l41.85">         this-&gt;RefsUnderflowWarning(ev);</span>
<a href="#l41.86"></a><span id="l41.86"> </span>
<a href="#l41.87"></a><span id="l41.87">       if ( refs &lt; uses ) // need to fix broken refs/uses relation?</span>
<a href="#l41.88"></a><span id="l41.88" class="difflineminus">-      { </span>
<a href="#l41.89"></a><span id="l41.89" class="difflineplus">+      {</span>
<a href="#l41.90"></a><span id="l41.90">         this-&gt;RefsUnderUsesWarning(ev);</span>
<a href="#l41.91"></a><span id="l41.91">         mNode_Refs = mNode_Uses = refs = uses;</span>
<a href="#l41.92"></a><span id="l41.92">       }</span>
<a href="#l41.93"></a><span id="l41.93" class="difflineminus">-        </span>
<a href="#l41.94"></a><span id="l41.94" class="difflineplus">+</span>
<a href="#l41.95"></a><span id="l41.95">       outRefs = refs;</span>
<a href="#l41.96"></a><span id="l41.96">       if ( !refs ) // last reference gone? time to destroy node?</span>
<a href="#l41.97"></a><span id="l41.97">         this-&gt;ZapOld(ev, mNode_Heap); // self destroy, use this no longer</span>
<a href="#l41.98"></a><span id="l41.98">     }</span>
<a href="#l41.99"></a><span id="l41.99">     else</span>
<a href="#l41.100"></a><span id="l41.100">       this-&gt;NonNodeError(ev);</span>
<a href="#l41.101"></a><span id="l41.101"> </span>
<a href="#l41.102"></a><span id="l41.102">   return outRefs;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l42.1"></a><span id="l42.1" class="difflineminus">--- a/db/mork/src/morkNode.h</span>
<a href="#l42.2"></a><span id="l42.2" class="difflineplus">+++ b/db/mork/src/morkNode.h</span>
<a href="#l42.3"></a><span id="l42.3" class="difflineat">@@ -49,44 +49,44 @@</span>
<a href="#l42.4"></a><span id="l42.4"> #define morkUsage_kMember  'm'</span>
<a href="#l42.5"></a><span id="l42.5"> #define morkUsage_kGlobal  'g'</span>
<a href="#l42.6"></a><span id="l42.6"> #define morkUsage_kPool    'p'</span>
<a href="#l42.7"></a><span id="l42.7"> #define morkUsage_kNone    'n'</span>
<a href="#l42.8"></a><span id="l42.8"> </span>
<a href="#l42.9"></a><span id="l42.9"> class morkUsage {</span>
<a href="#l42.10"></a><span id="l42.10"> public:</span>
<a href="#l42.11"></a><span id="l42.11">   mork_usage     mUsage_Code;  // kHeap, kStack, kMember, or kGhost</span>
<a href="#l42.12"></a><span id="l42.12" class="difflineminus">-  </span>
<a href="#l42.13"></a><span id="l42.13" class="difflineplus">+</span>
<a href="#l42.14"></a><span id="l42.14"> public:</span>
<a href="#l42.15"></a><span id="l42.15">   morkUsage(mork_usage inCode);</span>
<a href="#l42.16"></a><span id="l42.16"> </span>
<a href="#l42.17"></a><span id="l42.17">   morkUsage(); // does nothing except maybe call EnsureReadyStaticUsage()</span>
<a href="#l42.18"></a><span id="l42.18">   void InitUsage( mork_usage inCode)</span>
<a href="#l42.19"></a><span id="l42.19">   { mUsage_Code = inCode; }</span>
<a href="#l42.20"></a><span id="l42.20" class="difflineminus">-  </span>
<a href="#l42.21"></a><span id="l42.21" class="difflineplus">+</span>
<a href="#l42.22"></a><span id="l42.22">   ~morkUsage() { }</span>
<a href="#l42.23"></a><span id="l42.23">   mork_usage Code() const { return mUsage_Code; }</span>
<a href="#l42.24"></a><span id="l42.24" class="difflineminus">-  </span>
<a href="#l42.25"></a><span id="l42.25" class="difflineplus">+</span>
<a href="#l42.26"></a><span id="l42.26">   static void EnsureReadyStaticUsage();</span>
<a href="#l42.27"></a><span id="l42.27" class="difflineminus">-  </span>
<a href="#l42.28"></a><span id="l42.28" class="difflineplus">+</span>
<a href="#l42.29"></a><span id="l42.29"> public:</span>
<a href="#l42.30"></a><span id="l42.30">   static const morkUsage&amp; kHeap;      // morkUsage_kHeap</span>
<a href="#l42.31"></a><span id="l42.31">   static const morkUsage&amp; kStack;     // morkUsage_kStack</span>
<a href="#l42.32"></a><span id="l42.32">   static const morkUsage&amp; kMember;    // morkUsage_kMember</span>
<a href="#l42.33"></a><span id="l42.33">   static const morkUsage&amp; kGlobal;    // morkUsage_kGlobal</span>
<a href="#l42.34"></a><span id="l42.34">   static const morkUsage&amp; kPool;      // morkUsage_kPool</span>
<a href="#l42.35"></a><span id="l42.35">   static const morkUsage&amp; kNone;      // morkUsage_kNone</span>
<a href="#l42.36"></a><span id="l42.36" class="difflineminus">-  </span>
<a href="#l42.37"></a><span id="l42.37" class="difflineplus">+</span>
<a href="#l42.38"></a><span id="l42.38">   static const morkUsage&amp; GetHeap();   // kHeap, safe at static init time</span>
<a href="#l42.39"></a><span id="l42.39">   static const morkUsage&amp; GetStack();  // kStack, safe at static init time</span>
<a href="#l42.40"></a><span id="l42.40">   static const morkUsage&amp; GetMember(); // kMember, safe at static init time</span>
<a href="#l42.41"></a><span id="l42.41">   static const morkUsage&amp; GetGlobal(); // kGlobal, safe at static init time</span>
<a href="#l42.42"></a><span id="l42.42">   static const morkUsage&amp; GetPool();   // kPool, safe at static init time</span>
<a href="#l42.43"></a><span id="l42.43">   static const morkUsage&amp; GetNone();   // kNone, safe at static init time</span>
<a href="#l42.44"></a><span id="l42.44" class="difflineminus">-    </span>
<a href="#l42.45"></a><span id="l42.45" class="difflineplus">+</span>
<a href="#l42.46"></a><span id="l42.46"> };</span>
<a href="#l42.47"></a><span id="l42.47"> </span>
<a href="#l42.48"></a><span id="l42.48"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l42.49"></a><span id="l42.49"> </span>
<a href="#l42.50"></a><span id="l42.50"> #define morkNode_kMaxRefCount 0x0FFFF /* count sticks if it hits this */</span>
<a href="#l42.51"></a><span id="l42.51"> </span>
<a href="#l42.52"></a><span id="l42.52"> #define morkBase_kNode      /*i*/ 0x4E64 /* ascii 'Nd' */</span>
<a href="#l42.53"></a><span id="l42.53"> </span>
<a href="#l42.54"></a><span id="l42.54" class="difflineat">@@ -107,63 +107,63 @@ public:</span>
<a href="#l42.55"></a><span id="l42.55"> **| Occasionally a node subclass will indeed wish to hold a refcounted</span>
<a href="#l42.56"></a><span id="l42.56"> **| reference to a heap, and possibly the same heap that is in mNode_Heap,</span>
<a href="#l42.57"></a><span id="l42.57"> **| but this is always done in a separate slot that explicitly refcounts,</span>
<a href="#l42.58"></a><span id="l42.58"> **| so we avoid confusing what is meant by the mNode_Heap slot.</span>
<a href="#l42.59"></a><span id="l42.59"> |*/</span>
<a href="#l42.60"></a><span id="l42.60"> class morkNode /*: public nsISupports */ { // base class for constructing Mork object graphs</span>
<a href="#l42.61"></a><span id="l42.61"> </span>
<a href="#l42.62"></a><span id="l42.62"> public: // state is public because the entire Mork system is private</span>
<a href="#l42.63"></a><span id="l42.63" class="difflineminus">-  </span>
<a href="#l42.64"></a><span id="l42.64" class="difflineplus">+</span>
<a href="#l42.65"></a><span id="l42.65"> //  NS_DECL_ISUPPORTS;</span>
<a href="#l42.66"></a><span id="l42.66">   nsIMdbHeap*    mNode_Heap;     // NON-refcounted heap pointer</span>
<a href="#l42.67"></a><span id="l42.67"> </span>
<a href="#l42.68"></a><span id="l42.68">   mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l42.69"></a><span id="l42.69">   mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l42.70"></a><span id="l42.70" class="difflineminus">-  </span>
<a href="#l42.71"></a><span id="l42.71" class="difflineplus">+</span>
<a href="#l42.72"></a><span id="l42.72">   mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l42.73"></a><span id="l42.73">   mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l42.74"></a><span id="l42.74">   mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l42.75"></a><span id="l42.75">   mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l42.76"></a><span id="l42.76" class="difflineminus">-  </span>
<a href="#l42.77"></a><span id="l42.77" class="difflineplus">+</span>
<a href="#l42.78"></a><span id="l42.78">   mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l42.79"></a><span id="l42.79">   mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l42.80"></a><span id="l42.80" class="difflineminus">-  </span>
<a href="#l42.81"></a><span id="l42.81" class="difflineplus">+</span>
<a href="#l42.82"></a><span id="l42.82"> protected: // special case empty construction for morkHandleFrame</span>
<a href="#l42.83"></a><span id="l42.83">   friend class morkHandleFrame;</span>
<a href="#l42.84"></a><span id="l42.84">   morkNode() { }</span>
<a href="#l42.85"></a><span id="l42.85" class="difflineminus">-  </span>
<a href="#l42.86"></a><span id="l42.86" class="difflineplus">+</span>
<a href="#l42.87"></a><span id="l42.87"> public: // inlines for weird mNode_Mutable and mNode_Load constants</span>
<a href="#l42.88"></a><span id="l42.88"> </span>
<a href="#l42.89"></a><span id="l42.89">   void SetFrozen() { mNode_Mutable = morkAble_kDisabled; }</span>
<a href="#l42.90"></a><span id="l42.90">   void SetMutable() { mNode_Mutable = morkAble_kEnabled; }</span>
<a href="#l42.91"></a><span id="l42.91">   void SetAsleep() { mNode_Mutable = morkAble_kAsleep; }</span>
<a href="#l42.92"></a><span id="l42.92" class="difflineminus">-  </span>
<a href="#l42.93"></a><span id="l42.93" class="difflineplus">+</span>
<a href="#l42.94"></a><span id="l42.94">   mork_bool IsFrozen() const { return mNode_Mutable == morkAble_kDisabled; }</span>
<a href="#l42.95"></a><span id="l42.95">   mork_bool IsMutable() const { return mNode_Mutable == morkAble_kEnabled; }</span>
<a href="#l42.96"></a><span id="l42.96">   mork_bool IsAsleep() const { return mNode_Mutable == morkAble_kAsleep; }</span>
<a href="#l42.97"></a><span id="l42.97"> </span>
<a href="#l42.98"></a><span id="l42.98">   void SetNodeClean() { mNode_Load = morkLoad_kClean; }</span>
<a href="#l42.99"></a><span id="l42.99">   void SetNodeDirty() { mNode_Load = morkLoad_kDirty; }</span>
<a href="#l42.100"></a><span id="l42.100" class="difflineminus">-  </span>
<a href="#l42.101"></a><span id="l42.101" class="difflineplus">+</span>
<a href="#l42.102"></a><span id="l42.102">   mork_bool IsNodeClean() const { return mNode_Load == morkLoad_kClean; }</span>
<a href="#l42.103"></a><span id="l42.103">   mork_bool IsNodeDirty() const { return mNode_Load == morkLoad_kDirty; }</span>
<a href="#l42.104"></a><span id="l42.104" class="difflineminus">-  </span>
<a href="#l42.105"></a><span id="l42.105" class="difflineplus">+</span>
<a href="#l42.106"></a><span id="l42.106"> public: // morkNode memory management methods</span>
<a href="#l42.107"></a><span id="l42.107">   static void* MakeNew(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev);</span>
<a href="#l42.108"></a><span id="l42.108" class="difflineminus">-  </span>
<a href="#l42.109"></a><span id="l42.109" class="difflineplus">+</span>
<a href="#l42.110"></a><span id="l42.110">   void ZapOld(morkEnv* ev, nsIMdbHeap* ioHeap); // replaces operator delete()</span>
<a href="#l42.111"></a><span id="l42.111">   // this-&gt;morkNode::~morkNode(); // first call polymorphic destructor</span>
<a href="#l42.112"></a><span id="l42.112">   // if ( ioHeap ) // was this node heap allocated?</span>
<a href="#l42.113"></a><span id="l42.113">   //    ioHeap-&gt;Free(ev-&gt;AsMdbEnv(), this);</span>
<a href="#l42.114"></a><span id="l42.114"> </span>
<a href="#l42.115"></a><span id="l42.115"> public: // morkNode memory management operators</span>
<a href="#l42.116"></a><span id="l42.116">   void* operator new(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev) CPP_THROW_NEW</span>
<a href="#l42.117"></a><span id="l42.117">   { return morkNode::MakeNew(inSize, ioHeap, ev); }</span>
<a href="#l42.118"></a><span id="l42.118" class="difflineminus">-  </span>
<a href="#l42.119"></a><span id="l42.119" class="difflineplus">+</span>
<a href="#l42.120"></a><span id="l42.120"> </span>
<a href="#l42.121"></a><span id="l42.121"> protected: // construction without an anv needed for first env constructed:</span>
<a href="#l42.122"></a><span id="l42.122">   morkNode(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap);</span>
<a href="#l42.123"></a><span id="l42.123"> </span>
<a href="#l42.124"></a><span id="l42.124">   morkNode(mork_usage inCode); // usage == inCode, heap == nil</span>
<a href="#l42.125"></a><span id="l42.125"> </span>
<a href="#l42.126"></a><span id="l42.126"> // { ===== begin basic node interface =====</span>
<a href="#l42.127"></a><span id="l42.127"> public: // morkNode virtual methods</span>
<a href="#l42.128"></a><span id="l42.128" class="difflineat">@@ -174,31 +174,31 @@ public: // morkNode virtual methods</span>
<a href="#l42.129"></a><span id="l42.129">   virtual void CloseMorkNode(morkEnv* ev); // CloseNode() only if open</span>
<a href="#l42.130"></a><span id="l42.130"> </span>
<a href="#l42.131"></a><span id="l42.131">   // CloseMorkNode() is the polymorphic close method called when uses==0,</span>
<a href="#l42.132"></a><span id="l42.132">   // which must do NOTHING at all when IsOpenNode() is not true.  Otherwise,</span>
<a href="#l42.133"></a><span id="l42.133">   // CloseMorkNode() should call a static close method specific to an object.</span>
<a href="#l42.134"></a><span id="l42.134">   // Each such static close method should either call inherited static close</span>
<a href="#l42.135"></a><span id="l42.135">   // methods, or else perform the consolidated effect of calling them, where</span>
<a href="#l42.136"></a><span id="l42.136">   // subclasses should closely track any changes in base classes with care.</span>
<a href="#l42.137"></a><span id="l42.137" class="difflineminus">-  </span>
<a href="#l42.138"></a><span id="l42.138" class="difflineplus">+</span>
<a href="#l42.139"></a><span id="l42.139"> public: // morkNode construction</span>
<a href="#l42.140"></a><span id="l42.140">   morkNode(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap);</span>
<a href="#l42.141"></a><span id="l42.141">   void CloseNode(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l42.142"></a><span id="l42.142">   nsresult CloseMdbObject(morkEnv *ev);</span>
<a href="#l42.143"></a><span id="l42.143">   NS_IMETHOD CloseMdbObject(nsIMdbEnv *ev);</span>
<a href="#l42.144"></a><span id="l42.144"> private: // copying is not allowed</span>
<a href="#l42.145"></a><span id="l42.145">   morkNode(const morkNode&amp; other);</span>
<a href="#l42.146"></a><span id="l42.146">   morkNode&amp; operator=(const morkNode&amp; other);</span>
<a href="#l42.147"></a><span id="l42.147"> </span>
<a href="#l42.148"></a><span id="l42.148"> public: // dynamic type identification</span>
<a href="#l42.149"></a><span id="l42.149">   mork_bool IsNode() const</span>
<a href="#l42.150"></a><span id="l42.150">   { return mNode_Base == morkBase_kNode; }</span>
<a href="#l42.151"></a><span id="l42.151"> // } ===== end basic node methods =====</span>
<a href="#l42.152"></a><span id="l42.152" class="difflineminus">-    </span>
<a href="#l42.153"></a><span id="l42.153" class="difflineplus">+</span>
<a href="#l42.154"></a><span id="l42.154"> public: // public error &amp; warning methods</span>
<a href="#l42.155"></a><span id="l42.155"> </span>
<a href="#l42.156"></a><span id="l42.156">   void RefsUnderUsesWarning(morkEnv* ev) const; // call if mNode_Refs &lt; mNode_Uses</span>
<a href="#l42.157"></a><span id="l42.157">   void NonNodeError(morkEnv* ev) const; // call when IsNode() is false</span>
<a href="#l42.158"></a><span id="l42.158">   void NilHeapError(morkEnv* ev) const; // zero mNode_Heap when usage is kHeap</span>
<a href="#l42.159"></a><span id="l42.159">   void NonOpenNodeError(morkEnv* ev) const; // call when IsOpenNode() is false</span>
<a href="#l42.160"></a><span id="l42.160"> </span>
<a href="#l42.161"></a><span id="l42.161">   void NonMutableNodeError(morkEnv* ev) const; // when IsMutable() is false</span>
<a href="#l42.162"></a><span id="l42.162" class="difflineat">@@ -245,29 +245,29 @@ public: // other morkNode methods</span>
<a href="#l42.163"></a><span id="l42.163">   mork_bool IsClosingNode() const</span>
<a href="#l42.164"></a><span id="l42.164">   { return mNode_Access == morkAccess_kClosing; }</span>
<a href="#l42.165"></a><span id="l42.165"> </span>
<a href="#l42.166"></a><span id="l42.166">   mork_bool IsOpenOrClosingNode() const</span>
<a href="#l42.167"></a><span id="l42.167">   { return IsOpenNode() || IsClosingNode(); }</span>
<a href="#l42.168"></a><span id="l42.168"> </span>
<a href="#l42.169"></a><span id="l42.169">   mork_bool HasNodeAccess() const</span>
<a href="#l42.170"></a><span id="l42.170">   { return ( IsOpenNode() || IsShutNode() || IsClosingNode() ); }</span>
<a href="#l42.171"></a><span id="l42.171" class="difflineminus">-    </span>
<a href="#l42.172"></a><span id="l42.172" class="difflineplus">+</span>
<a href="#l42.173"></a><span id="l42.173">   void MarkShut() { mNode_Access = morkAccess_kShut; }</span>
<a href="#l42.174"></a><span id="l42.174">   void MarkClosing() { mNode_Access = morkAccess_kClosing; }</span>
<a href="#l42.175"></a><span id="l42.175">   void MarkDead() { mNode_Access = morkAccess_kDead; }</span>
<a href="#l42.176"></a><span id="l42.176"> </span>
<a href="#l42.177"></a><span id="l42.177"> public: // refcounting for typesafe subclass inline methods</span>
<a href="#l42.178"></a><span id="l42.178">   static void SlotWeakNode(morkNode* me, morkEnv* ev, morkNode** ioSlot);</span>
<a href="#l42.179"></a><span id="l42.179">   // If *ioSlot is non-nil, that node is released by CutWeakRef() and</span>
<a href="#l42.180"></a><span id="l42.180">   // then zeroed out.  Then if me is non-nil, this is acquired by</span>
<a href="#l42.181"></a><span id="l42.181">   // calling AddWeakRef(), and if positive is returned to show success,</span>
<a href="#l42.182"></a><span id="l42.182">   // then this is put into slot *ioSlot.  Note me can be nil, so we</span>
<a href="#l42.183"></a><span id="l42.183">   // permit expression '((morkNode*) 0L)-&gt;SlotWeakNode(ev, &amp;slot)'.</span>
<a href="#l42.184"></a><span id="l42.184" class="difflineminus">-  </span>
<a href="#l42.185"></a><span id="l42.185" class="difflineplus">+</span>
<a href="#l42.186"></a><span id="l42.186">   static void SlotStrongNode(morkNode* me, morkEnv* ev, morkNode** ioSlot);</span>
<a href="#l42.187"></a><span id="l42.187">   // If *ioSlot is non-nil, that node is released by CutStrongRef() and</span>
<a href="#l42.188"></a><span id="l42.188">   // then zeroed out.  Then if me is non-nil, this is acquired by</span>
<a href="#l42.189"></a><span id="l42.189">   // calling AddStrongRef(), and if positive is returned to show success,</span>
<a href="#l42.190"></a><span id="l42.190">   // then me is put into slot *ioSlot.  Note me can be nil, so we take</span>
<a href="#l42.191"></a><span id="l42.191">   // expression 'morkNode::SlotStrongNode((morkNode*) 0, ev, &amp;slot)'.</span>
<a href="#l42.192"></a><span id="l42.192"> };</span>
<a href="#l42.193"></a><span id="l42.193"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l43.1"></a><span id="l43.1" class="difflineminus">--- a/db/mork/src/morkNodeMap.cpp</span>
<a href="#l43.2"></a><span id="l43.2" class="difflineplus">+++ b/db/mork/src/morkNodeMap.cpp</span>
<a href="#l43.3"></a><span id="l43.3" class="difflineat">@@ -28,17 +28,17 @@</span>
<a href="#l43.4"></a><span id="l43.4"> #endif</span>
<a href="#l43.5"></a><span id="l43.5"> </span>
<a href="#l43.6"></a><span id="l43.6"> #ifndef _MORKNODEMAP_</span>
<a href="#l43.7"></a><span id="l43.7"> #include &quot;morkNodeMap.h&quot;</span>
<a href="#l43.8"></a><span id="l43.8"> #endif</span>
<a href="#l43.9"></a><span id="l43.9"> </span>
<a href="#l43.10"></a><span id="l43.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l43.11"></a><span id="l43.11"> </span>
<a href="#l43.12"></a><span id="l43.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l43.13"></a><span id="l43.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l43.14"></a><span id="l43.14"> // { ===== begin morkNode interface =====</span>
<a href="#l43.15"></a><span id="l43.15"> </span>
<a href="#l43.16"></a><span id="l43.16"> /*public virtual*/ void</span>
<a href="#l43.17"></a><span id="l43.17"> morkNodeMap::CloseMorkNode(morkEnv* ev) // CloseNodeMap() only if open</span>
<a href="#l43.18"></a><span id="l43.18"> {</span>
<a href="#l43.19"></a><span id="l43.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l43.20"></a><span id="l43.20">   {</span>
<a href="#l43.21"></a><span id="l43.21">     this-&gt;MarkClosing();</span>
<a href="#l43.22"></a><span id="l43.22" class="difflineat">@@ -72,84 +72,84 @@ morkNodeMap::CloseNodeMap(morkEnv* ev) /</span>
<a href="#l43.23"></a><span id="l43.23">       this-&gt;CloseMap(ev);</span>
<a href="#l43.24"></a><span id="l43.24">       this-&gt;MarkShut();</span>
<a href="#l43.25"></a><span id="l43.25">     }</span>
<a href="#l43.26"></a><span id="l43.26">     else</span>
<a href="#l43.27"></a><span id="l43.27">       this-&gt;NonNodeError(ev);</span>
<a href="#l43.28"></a><span id="l43.28"> }</span>
<a href="#l43.29"></a><span id="l43.29"> </span>
<a href="#l43.30"></a><span id="l43.30"> // } ===== end morkNode methods =====</span>
<a href="#l43.31"></a><span id="l43.31" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l43.32"></a><span id="l43.32" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l43.33"></a><span id="l43.33"> </span>
<a href="#l43.34"></a><span id="l43.34"> mork_bool</span>
<a href="#l43.35"></a><span id="l43.35"> morkNodeMap::AddNode(morkEnv* ev, mork_token inToken, morkNode* ioNode)</span>
<a href="#l43.36"></a><span id="l43.36">   // the AddNode() method return value equals ev-&gt;Good().</span>
<a href="#l43.37"></a><span id="l43.37"> {</span>
<a href="#l43.38"></a><span id="l43.38">   if ( ioNode &amp;&amp; ev-&gt;Good() )</span>
<a href="#l43.39"></a><span id="l43.39">   {</span>
<a href="#l43.40"></a><span id="l43.40">     morkNode* node = 0; // old val in the map</span>
<a href="#l43.41"></a><span id="l43.41" class="difflineminus">-    </span>
<a href="#l43.42"></a><span id="l43.42" class="difflineplus">+</span>
<a href="#l43.43"></a><span id="l43.43">     mork_bool put = this-&gt;Put(ev, &amp;inToken, &amp;ioNode,</span>
<a href="#l43.44"></a><span id="l43.44">       /*key*/ (void*) 0, &amp;node, (mork_change**) 0);</span>
<a href="#l43.45"></a><span id="l43.45" class="difflineminus">-      </span>
<a href="#l43.46"></a><span id="l43.46" class="difflineplus">+</span>
<a href="#l43.47"></a><span id="l43.47">     if ( put ) // replaced an existing value for key inToken?</span>
<a href="#l43.48"></a><span id="l43.48">     {</span>
<a href="#l43.49"></a><span id="l43.49">       if ( node &amp;&amp; node != ioNode ) // need to release old node?</span>
<a href="#l43.50"></a><span id="l43.50">         node-&gt;CutStrongRef(ev);</span>
<a href="#l43.51"></a><span id="l43.51">     }</span>
<a href="#l43.52"></a><span id="l43.52" class="difflineminus">-    </span>
<a href="#l43.53"></a><span id="l43.53" class="difflineplus">+</span>
<a href="#l43.54"></a><span id="l43.54">     if ( ev-&gt;Bad() || !ioNode-&gt;AddStrongRef(ev) )</span>
<a href="#l43.55"></a><span id="l43.55">     {</span>
<a href="#l43.56"></a><span id="l43.56">       // problems adding node or increasing refcount?</span>
<a href="#l43.57"></a><span id="l43.57">       this-&gt;Cut(ev, &amp;inToken,  // make sure not in map</span>
<a href="#l43.58"></a><span id="l43.58">         /*key*/ (void*) 0, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l43.59"></a><span id="l43.59">     }</span>
<a href="#l43.60"></a><span id="l43.60">   }</span>
<a href="#l43.61"></a><span id="l43.61">   else if ( !ioNode )</span>
<a href="#l43.62"></a><span id="l43.62">     ev-&gt;NilPointerError();</span>
<a href="#l43.63"></a><span id="l43.63" class="difflineminus">-    </span>
<a href="#l43.64"></a><span id="l43.64" class="difflineplus">+</span>
<a href="#l43.65"></a><span id="l43.65">   return ev-&gt;Good();</span>
<a href="#l43.66"></a><span id="l43.66"> }</span>
<a href="#l43.67"></a><span id="l43.67"> </span>
<a href="#l43.68"></a><span id="l43.68"> mork_bool</span>
<a href="#l43.69"></a><span id="l43.69"> morkNodeMap::CutNode(morkEnv* ev, mork_token inToken)</span>
<a href="#l43.70"></a><span id="l43.70"> {</span>
<a href="#l43.71"></a><span id="l43.71">   morkNode* node = 0; // old val in the map</span>
<a href="#l43.72"></a><span id="l43.72" class="difflineminus">-  mork_bool outCutNode = this-&gt;Cut(ev, &amp;inToken, </span>
<a href="#l43.73"></a><span id="l43.73" class="difflineplus">+  mork_bool outCutNode = this-&gt;Cut(ev, &amp;inToken,</span>
<a href="#l43.74"></a><span id="l43.74">     /*key*/ (void*) 0, &amp;node, (mork_change**) 0);</span>
<a href="#l43.75"></a><span id="l43.75">   if ( node )</span>
<a href="#l43.76"></a><span id="l43.76">     node-&gt;CutStrongRef(ev);</span>
<a href="#l43.77"></a><span id="l43.77" class="difflineminus">-  </span>
<a href="#l43.78"></a><span id="l43.78" class="difflineplus">+</span>
<a href="#l43.79"></a><span id="l43.79">   return outCutNode;</span>
<a href="#l43.80"></a><span id="l43.80"> }</span>
<a href="#l43.81"></a><span id="l43.81"> </span>
<a href="#l43.82"></a><span id="l43.82"> morkNode*</span>
<a href="#l43.83"></a><span id="l43.83"> morkNodeMap::GetNode(morkEnv* ev, mork_token inToken)</span>
<a href="#l43.84"></a><span id="l43.84">   // Note the returned node does NOT have an increase in refcount for this.</span>
<a href="#l43.85"></a><span id="l43.85"> {</span>
<a href="#l43.86"></a><span id="l43.86">   morkNode* node = 0; // old val in the map</span>
<a href="#l43.87"></a><span id="l43.87">   this-&gt;Get(ev, &amp;inToken, /*key*/ (void*) 0, &amp;node, (mork_change**) 0);</span>
<a href="#l43.88"></a><span id="l43.88" class="difflineminus">-  </span>
<a href="#l43.89"></a><span id="l43.89" class="difflineplus">+</span>
<a href="#l43.90"></a><span id="l43.90">   return node;</span>
<a href="#l43.91"></a><span id="l43.91"> }</span>
<a href="#l43.92"></a><span id="l43.92"> </span>
<a href="#l43.93"></a><span id="l43.93"> mork_num</span>
<a href="#l43.94"></a><span id="l43.94"> morkNodeMap::CutAllNodes(morkEnv* ev)</span>
<a href="#l43.95"></a><span id="l43.95">   // CutAllNodes() releases all the reference node values.</span>
<a href="#l43.96"></a><span id="l43.96"> {</span>
<a href="#l43.97"></a><span id="l43.97">   mork_num outSlots = mMap_Slots;</span>
<a href="#l43.98"></a><span id="l43.98">   mork_token key = 0; // old key token in the map</span>
<a href="#l43.99"></a><span id="l43.99">   morkNode* val = 0; // old val node in the map</span>
<a href="#l43.100"></a><span id="l43.100" class="difflineminus">-  </span>
<a href="#l43.101"></a><span id="l43.101" class="difflineplus">+</span>
<a href="#l43.102"></a><span id="l43.102">   mork_change* c = 0;</span>
<a href="#l43.103"></a><span id="l43.103">   morkNodeMapIter i(ev, this);</span>
<a href="#l43.104"></a><span id="l43.104">   for ( c = i.FirstNode(ev, &amp;key, &amp;val); c ; c = i.NextNode(ev, &amp;key, &amp;val) )</span>
<a href="#l43.105"></a><span id="l43.105">   {</span>
<a href="#l43.106"></a><span id="l43.106">     if ( val )</span>
<a href="#l43.107"></a><span id="l43.107">       val-&gt;CutStrongRef(ev);</span>
<a href="#l43.108"></a><span id="l43.108">     i.CutHereNode(ev, /*key*/ (mork_token*) 0, /*val*/ (morkNode**) 0);</span>
<a href="#l43.109"></a><span id="l43.109">   }</span>
<a href="#l43.110"></a><span id="l43.110" class="difflineminus">-  </span>
<a href="#l43.111"></a><span id="l43.111" class="difflineplus">+</span>
<a href="#l43.112"></a><span id="l43.112">   return outSlots;</span>
<a href="#l43.113"></a><span id="l43.113"> }</span>
<a href="#l43.114"></a><span id="l43.114"> </span>
<a href="#l43.115"></a><span id="l43.115"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l43.116"></a><span id="l43.116"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l44.1"></a><span id="l44.1" class="difflineminus">--- a/db/mork/src/morkNodeMap.h</span>
<a href="#l44.2"></a><span id="l44.2" class="difflineplus">+++ b/db/mork/src/morkNodeMap.h</span>
<a href="#l44.3"></a><span id="l44.3" class="difflineat">@@ -52,47 +52,47 @@ public: // dynamic type identification</span>
<a href="#l44.4"></a><span id="l44.4"> // } ===== end morkMap poly interface =====</span>
<a href="#l44.5"></a><span id="l44.5"> </span>
<a href="#l44.6"></a><span id="l44.6"> protected: // we want all subclasses to provide typesafe wrappers:</span>
<a href="#l44.7"></a><span id="l44.7"> </span>
<a href="#l44.8"></a><span id="l44.8">   mork_bool  AddNode(morkEnv* ev, mork_token inToken, morkNode* ioNode);</span>
<a href="#l44.9"></a><span id="l44.9">   // the AddNode() boolean return equals ev-&gt;Good().</span>
<a href="#l44.10"></a><span id="l44.10"> </span>
<a href="#l44.11"></a><span id="l44.11">   mork_bool  CutNode(morkEnv* ev, mork_token inToken);</span>
<a href="#l44.12"></a><span id="l44.12" class="difflineminus">-  // The CutNode() boolean return indicates whether removal happened. </span>
<a href="#l44.13"></a><span id="l44.13" class="difflineminus">-  </span>
<a href="#l44.14"></a><span id="l44.14" class="difflineplus">+  // The CutNode() boolean return indicates whether removal happened.</span>
<a href="#l44.15"></a><span id="l44.15" class="difflineplus">+</span>
<a href="#l44.16"></a><span id="l44.16">   morkNode*  GetNode(morkEnv* ev, mork_token inToken);</span>
<a href="#l44.17"></a><span id="l44.17">   // Note the returned node does NOT have an increase in refcount for this.</span>
<a href="#l44.18"></a><span id="l44.18"> </span>
<a href="#l44.19"></a><span id="l44.19">   mork_num CutAllNodes(morkEnv* ev);</span>
<a href="#l44.20"></a><span id="l44.20">   // CutAllNodes() releases all the reference node values.</span>
<a href="#l44.21"></a><span id="l44.21"> };</span>
<a href="#l44.22"></a><span id="l44.22"> </span>
<a href="#l44.23"></a><span id="l44.23"> class morkNodeMapIter: public morkMapIter{ // typesafe wrapper class</span>
<a href="#l44.24"></a><span id="l44.24"> </span>
<a href="#l44.25"></a><span id="l44.25"> public:</span>
<a href="#l44.26"></a><span id="l44.26">   morkNodeMapIter(morkEnv* ev, morkNodeMap* ioMap)</span>
<a href="#l44.27"></a><span id="l44.27">   : morkMapIter(ev, ioMap) { }</span>
<a href="#l44.28"></a><span id="l44.28" class="difflineminus">- </span>
<a href="#l44.29"></a><span id="l44.29" class="difflineplus">+</span>
<a href="#l44.30"></a><span id="l44.30">   morkNodeMapIter( ) : morkMapIter()  { }</span>
<a href="#l44.31"></a><span id="l44.31">   void InitNodeMapIter(morkEnv* ev, morkNodeMap* ioMap)</span>
<a href="#l44.32"></a><span id="l44.32">   { this-&gt;InitMapIter(ev, ioMap); }</span>
<a href="#l44.33"></a><span id="l44.33" class="difflineminus">-   </span>
<a href="#l44.34"></a><span id="l44.34" class="difflineplus">+</span>
<a href="#l44.35"></a><span id="l44.35">   mork_change*</span>
<a href="#l44.36"></a><span id="l44.36">   FirstNode(morkEnv* ev, mork_token* outToken, morkNode** outNode)</span>
<a href="#l44.37"></a><span id="l44.37">   { return this-&gt;First(ev, outToken, outNode); }</span>
<a href="#l44.38"></a><span id="l44.38" class="difflineminus">-  </span>
<a href="#l44.39"></a><span id="l44.39" class="difflineplus">+</span>
<a href="#l44.40"></a><span id="l44.40">   mork_change*</span>
<a href="#l44.41"></a><span id="l44.41">   NextNode(morkEnv* ev, mork_token* outToken, morkNode** outNode)</span>
<a href="#l44.42"></a><span id="l44.42">   { return this-&gt;Next(ev, outToken, outNode); }</span>
<a href="#l44.43"></a><span id="l44.43" class="difflineminus">-  </span>
<a href="#l44.44"></a><span id="l44.44" class="difflineplus">+</span>
<a href="#l44.45"></a><span id="l44.45">   mork_change*</span>
<a href="#l44.46"></a><span id="l44.46">   HereNode(morkEnv* ev, mork_token* outToken, morkNode** outNode)</span>
<a href="#l44.47"></a><span id="l44.47">   { return this-&gt;Here(ev, outToken, outNode); }</span>
<a href="#l44.48"></a><span id="l44.48" class="difflineminus">-  </span>
<a href="#l44.49"></a><span id="l44.49" class="difflineplus">+</span>
<a href="#l44.50"></a><span id="l44.50">   mork_change*</span>
<a href="#l44.51"></a><span id="l44.51">   CutHereNode(morkEnv* ev, mork_token* outToken, morkNode** outNode)</span>
<a href="#l44.52"></a><span id="l44.52">   { return this-&gt;CutHere(ev, outToken, outNode); }</span>
<a href="#l44.53"></a><span id="l44.53"> };</span>
<a href="#l44.54"></a><span id="l44.54"> </span>
<a href="#l44.55"></a><span id="l44.55"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l44.56"></a><span id="l44.56"> </span>
<a href="#l44.57"></a><span id="l44.57"> #endif /* _MORKNODEMAP_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l45.1"></a><span id="l45.1" class="difflineminus">--- a/db/mork/src/morkObject.cpp</span>
<a href="#l45.2"></a><span id="l45.2" class="difflineplus">+++ b/db/mork/src/morkObject.cpp</span>
<a href="#l45.3"></a><span id="l45.3" class="difflineat">@@ -29,17 +29,17 @@</span>
<a href="#l45.4"></a><span id="l45.4"> </span>
<a href="#l45.5"></a><span id="l45.5"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l45.6"></a><span id="l45.6"> </span>
<a href="#l45.7"></a><span id="l45.7"> </span>
<a href="#l45.8"></a><span id="l45.8"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l45.9"></a><span id="l45.9"> </span>
<a href="#l45.10"></a><span id="l45.10"> NS_IMPL_ISUPPORTS(morkObject, nsIMdbObject)</span>
<a href="#l45.11"></a><span id="l45.11"> </span>
<a href="#l45.12"></a><span id="l45.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l45.13"></a><span id="l45.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l45.14"></a><span id="l45.14"> // { ===== begin morkNode interface =====</span>
<a href="#l45.15"></a><span id="l45.15"> </span>
<a href="#l45.16"></a><span id="l45.16"> /*public virtual*/ void</span>
<a href="#l45.17"></a><span id="l45.17"> morkObject::CloseMorkNode(morkEnv* ev) // CloseObject() only if open</span>
<a href="#l45.18"></a><span id="l45.18"> {</span>
<a href="#l45.19"></a><span id="l45.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l45.20"></a><span id="l45.20">   {</span>
<a href="#l45.21"></a><span id="l45.21">     this-&gt;MarkClosing();</span>
<a href="#l45.22"></a><span id="l45.22" class="difflineat">@@ -62,76 +62,76 @@ morkObject::morkObject(const morkUsage&amp; </span>
<a href="#l45.23"></a><span id="l45.23"> : morkBead(inUsage, ioHeap, inBeadColor)</span>
<a href="#l45.24"></a><span id="l45.24"> , mObject_Handle( 0 )</span>
<a href="#l45.25"></a><span id="l45.25"> {</span>
<a href="#l45.26"></a><span id="l45.26">   mMorkEnv = nullptr;</span>
<a href="#l45.27"></a><span id="l45.27"> }</span>
<a href="#l45.28"></a><span id="l45.28"> </span>
<a href="#l45.29"></a><span id="l45.29"> /*public non-poly*/</span>
<a href="#l45.30"></a><span id="l45.30"> morkObject::morkObject(morkEnv* ev,</span>
<a href="#l45.31"></a><span id="l45.31" class="difflineminus">-  const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, </span>
<a href="#l45.32"></a><span id="l45.32" class="difflineplus">+  const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l45.33"></a><span id="l45.33">   mork_color inBeadColor, morkHandle* ioHandle)</span>
<a href="#l45.34"></a><span id="l45.34"> : morkBead(ev, inUsage, ioHeap, inBeadColor)</span>
<a href="#l45.35"></a><span id="l45.35"> , mObject_Handle( 0 )</span>
<a href="#l45.36"></a><span id="l45.36"> {</span>
<a href="#l45.37"></a><span id="l45.37">   mMorkEnv = ev;</span>
<a href="#l45.38"></a><span id="l45.38">   if ( ev-&gt;Good() )</span>
<a href="#l45.39"></a><span id="l45.39">   {</span>
<a href="#l45.40"></a><span id="l45.40">     if ( ioHandle )</span>
<a href="#l45.41"></a><span id="l45.41">       morkHandle::SlotWeakHandle(ioHandle, ev, &amp;mObject_Handle);</span>
<a href="#l45.42"></a><span id="l45.42" class="difflineminus">-      </span>
<a href="#l45.43"></a><span id="l45.43" class="difflineplus">+</span>
<a href="#l45.44"></a><span id="l45.44">     if ( ev-&gt;Good() )</span>
<a href="#l45.45"></a><span id="l45.45">       mNode_Derived = morkDerived_kObject;</span>
<a href="#l45.46"></a><span id="l45.46">   }</span>
<a href="#l45.47"></a><span id="l45.47"> }</span>
<a href="#l45.48"></a><span id="l45.48"> </span>
<a href="#l45.49"></a><span id="l45.49"> /*public non-poly*/ void</span>
<a href="#l45.50"></a><span id="l45.50"> morkObject::CloseObject(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l45.51"></a><span id="l45.51"> {</span>
<a href="#l45.52"></a><span id="l45.52">     if ( this-&gt;IsNode() )</span>
<a href="#l45.53"></a><span id="l45.53">     {</span>
<a href="#l45.54"></a><span id="l45.54">       if ( !this-&gt;IsShutNode() )</span>
<a href="#l45.55"></a><span id="l45.55">       {</span>
<a href="#l45.56"></a><span id="l45.56">         if ( mObject_Handle )</span>
<a href="#l45.57"></a><span id="l45.57">           morkHandle::SlotWeakHandle((morkHandle*) 0L, ev, &amp;mObject_Handle);</span>
<a href="#l45.58"></a><span id="l45.58" class="difflineminus">-          </span>
<a href="#l45.59"></a><span id="l45.59" class="difflineplus">+</span>
<a href="#l45.60"></a><span id="l45.60">         mBead_Color = 0; // this-&gt;CloseBead(ev);</span>
<a href="#l45.61"></a><span id="l45.61">         this-&gt;MarkShut();</span>
<a href="#l45.62"></a><span id="l45.62">       }</span>
<a href="#l45.63"></a><span id="l45.63">     }</span>
<a href="#l45.64"></a><span id="l45.64">     else</span>
<a href="#l45.65"></a><span id="l45.65">       this-&gt;NonNodeError(ev);</span>
<a href="#l45.66"></a><span id="l45.66"> }</span>
<a href="#l45.67"></a><span id="l45.67"> </span>
<a href="#l45.68"></a><span id="l45.68"> // } ===== end morkNode methods =====</span>
<a href="#l45.69"></a><span id="l45.69" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l45.70"></a><span id="l45.70" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l45.71"></a><span id="l45.71"> </span>
<a href="#l45.72"></a><span id="l45.72"> // { ----- begin factory methods -----</span>
<a href="#l45.73"></a><span id="l45.73"> NS_IMETHODIMP</span>
<a href="#l45.74"></a><span id="l45.74"> morkObject::GetMdbFactory(nsIMdbEnv* mev, nsIMdbFactory** acqFactory)</span>
<a href="#l45.75"></a><span id="l45.75"> {</span>
<a href="#l45.76"></a><span id="l45.76">   nsresult rv;</span>
<a href="#l45.77"></a><span id="l45.77">   nsCOMPtr &lt;nsIMdbObject&gt; obj = do_QueryInterface(mev);</span>
<a href="#l45.78"></a><span id="l45.78">   if (obj)</span>
<a href="#l45.79"></a><span id="l45.79">     rv = obj-&gt;GetMdbFactory(mev, acqFactory);</span>
<a href="#l45.80"></a><span id="l45.80">   else</span>
<a href="#l45.81"></a><span id="l45.81">     return NS_ERROR_NO_INTERFACE;</span>
<a href="#l45.82"></a><span id="l45.82"> </span>
<a href="#l45.83"></a><span id="l45.83">   return rv;</span>
<a href="#l45.84"></a><span id="l45.84" class="difflineminus">-} </span>
<a href="#l45.85"></a><span id="l45.85" class="difflineplus">+}</span>
<a href="#l45.86"></a><span id="l45.86"> // } ----- end factory methods -----</span>
<a href="#l45.87"></a><span id="l45.87"> </span>
<a href="#l45.88"></a><span id="l45.88"> // { ----- begin ref counting for well-behaved cyclic graphs -----</span>
<a href="#l45.89"></a><span id="l45.89"> NS_IMETHODIMP</span>
<a href="#l45.90"></a><span id="l45.90"> morkObject::GetWeakRefCount(nsIMdbEnv* mev, // weak refs</span>
<a href="#l45.91"></a><span id="l45.91">   mdb_count* outCount)</span>
<a href="#l45.92"></a><span id="l45.92"> {</span>
<a href="#l45.93"></a><span id="l45.93">   *outCount = WeakRefsOnly();</span>
<a href="#l45.94"></a><span id="l45.94">   return NS_OK;</span>
<a href="#l45.95"></a><span id="l45.95" class="difflineminus">-}  </span>
<a href="#l45.96"></a><span id="l45.96" class="difflineplus">+}</span>
<a href="#l45.97"></a><span id="l45.97"> NS_IMETHODIMP</span>
<a href="#l45.98"></a><span id="l45.98"> morkObject::GetStrongRefCount(nsIMdbEnv* mev, // strong refs</span>
<a href="#l45.99"></a><span id="l45.99">   mdb_count* outCount)</span>
<a href="#l45.100"></a><span id="l45.100"> {</span>
<a href="#l45.101"></a><span id="l45.101">   *outCount = StrongRefsOnly();</span>
<a href="#l45.102"></a><span id="l45.102">   return NS_OK;</span>
<a href="#l45.103"></a><span id="l45.103"> }</span>
<a href="#l45.104"></a><span id="l45.104"> // ### TODO - clean up this cast, if required</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l46.1"></a><span id="l46.1" class="difflineminus">--- a/db/mork/src/morkObject.h</span>
<a href="#l46.2"></a><span id="l46.2" class="difflineplus">+++ b/db/mork/src/morkObject.h</span>
<a href="#l46.3"></a><span id="l46.3" class="difflineat">@@ -29,45 +29,45 @@</span>
<a href="#l46.4"></a><span id="l46.4"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l46.5"></a><span id="l46.5"> </span>
<a href="#l46.6"></a><span id="l46.6"> #define morkDerived_kObject   /*i*/ 0x6F42 /* ascii 'oB' */</span>
<a href="#l46.7"></a><span id="l46.7"> </span>
<a href="#l46.8"></a><span id="l46.8"> /*| morkObject: subclass of morkNode that adds knowledge of db suite factory</span>
<a href="#l46.9"></a><span id="l46.9"> **| and containing port to those objects that are exposed as instances of</span>
<a href="#l46.10"></a><span id="l46.10"> **| nsIMdbObject in the public interface.</span>
<a href="#l46.11"></a><span id="l46.11"> |*/</span>
<a href="#l46.12"></a><span id="l46.12" class="difflineminus">-class morkObject : public morkBead, public nsIMdbObject { </span>
<a href="#l46.13"></a><span id="l46.13" class="difflineplus">+class morkObject : public morkBead, public nsIMdbObject {</span>
<a href="#l46.14"></a><span id="l46.14"> </span>
<a href="#l46.15"></a><span id="l46.15"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l46.16"></a><span id="l46.16">   // nsIMdbHeap*    mNode_Heap;</span>
<a href="#l46.17"></a><span id="l46.17"> </span>
<a href="#l46.18"></a><span id="l46.18">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l46.19"></a><span id="l46.19">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l46.20"></a><span id="l46.20" class="difflineminus">-  </span>
<a href="#l46.21"></a><span id="l46.21" class="difflineplus">+</span>
<a href="#l46.22"></a><span id="l46.22">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l46.23"></a><span id="l46.23">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l46.24"></a><span id="l46.24">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l46.25"></a><span id="l46.25">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l46.26"></a><span id="l46.26" class="difflineminus">-  </span>
<a href="#l46.27"></a><span id="l46.27" class="difflineplus">+</span>
<a href="#l46.28"></a><span id="l46.28">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l46.29"></a><span id="l46.29">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l46.30"></a><span id="l46.30"> </span>
<a href="#l46.31"></a><span id="l46.31">   // mork_color      mBead_Color;   // ID for this bead</span>
<a href="#l46.32"></a><span id="l46.32" class="difflineminus">-  </span>
<a href="#l46.33"></a><span id="l46.33" class="difflineplus">+</span>
<a href="#l46.34"></a><span id="l46.34"> public: // state is public because the entire Mork system is private</span>
<a href="#l46.35"></a><span id="l46.35"> </span>
<a href="#l46.36"></a><span id="l46.36">   morkHandle*      mObject_Handle;   // weak ref to handle for this object</span>
<a href="#l46.37"></a><span id="l46.37"> </span>
<a href="#l46.38"></a><span id="l46.38">   morkEnv * mMorkEnv; // weak ref to environment this object created in.</span>
<a href="#l46.39"></a><span id="l46.39"> // { ===== begin morkNode interface =====</span>
<a href="#l46.40"></a><span id="l46.40"> public: // morkNode virtual methods</span>
<a href="#l46.41"></a><span id="l46.41">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseObject() only if open</span>
<a href="#l46.42"></a><span id="l46.42"> #ifdef MORK_DEBUG_HEAP_STATS</span>
<a href="#l46.43"></a><span id="l46.43">   void operator delete(void* ioAddress, size_t size)</span>
<a href="#l46.44"></a><span id="l46.44" class="difflineminus">-  { </span>
<a href="#l46.45"></a><span id="l46.45" class="difflineplus">+  {</span>
<a href="#l46.46"></a><span id="l46.46">     mork_u4* array = (mork_u4*) ioAddress;</span>
<a href="#l46.47"></a><span id="l46.47">     array -= 3;</span>
<a href="#l46.48"></a><span id="l46.48">     orkinHeap *heap = (orkinHeap *) *array;</span>
<a href="#l46.49"></a><span id="l46.49">     if (heap)</span>
<a href="#l46.50"></a><span id="l46.50">       heap-&gt;Free(nullptr, ioAddress);</span>
<a href="#l46.51"></a><span id="l46.51">   }</span>
<a href="#l46.52"></a><span id="l46.52"> #endif</span>
<a href="#l46.53"></a><span id="l46.53"> </span>
<a href="#l46.54"></a><span id="l46.54" class="difflineat">@@ -100,44 +100,44 @@ public: // morkNode virtual methods</span>
<a href="#l46.55"></a><span id="l46.55">   // The first declaration of CutStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l46.56"></a><span id="l46.56">   NS_IMETHOD_(mork_uses) CutStrongRef(morkEnv* ev) override;</span>
<a href="#l46.57"></a><span id="l46.57"> #endif</span>
<a href="#l46.58"></a><span id="l46.58">   NS_IMETHOD CutStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l46.59"></a><span id="l46.59"> </span>
<a href="#l46.60"></a><span id="l46.60">   NS_IMETHOD CloseMdbObject(nsIMdbEnv* ev) override; // called at strong refs zero</span>
<a href="#l46.61"></a><span id="l46.61">   NS_IMETHOD IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen) override;</span>
<a href="#l46.62"></a><span id="l46.62">   // } ----- end ref counting -----</span>
<a href="#l46.63"></a><span id="l46.63" class="difflineminus">-  </span>
<a href="#l46.64"></a><span id="l46.64" class="difflineplus">+</span>
<a href="#l46.65"></a><span id="l46.65"> </span>
<a href="#l46.66"></a><span id="l46.66"> protected: // special case construction of first env without preceding env</span>
<a href="#l46.67"></a><span id="l46.67">   morkObject(const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l46.68"></a><span id="l46.68">     mork_color inBeadColor);</span>
<a href="#l46.69"></a><span id="l46.69">   virtual ~morkObject(); // assert that CloseObject() executed earlier</span>
<a href="#l46.70"></a><span id="l46.70" class="difflineminus">-  </span>
<a href="#l46.71"></a><span id="l46.71" class="difflineplus">+</span>
<a href="#l46.72"></a><span id="l46.72"> public: // morkEnv construction &amp; destruction</span>
<a href="#l46.73"></a><span id="l46.73" class="difflineminus">-  morkObject(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, </span>
<a href="#l46.74"></a><span id="l46.74" class="difflineplus">+  morkObject(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l46.75"></a><span id="l46.75">      mork_color inBeadColor, morkHandle* ioHandle); // ioHandle can be nil</span>
<a href="#l46.76"></a><span id="l46.76">   void CloseObject(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l46.77"></a><span id="l46.77"> </span>
<a href="#l46.78"></a><span id="l46.78"> private: // copying is not allowed</span>
<a href="#l46.79"></a><span id="l46.79">   morkObject(const morkObject&amp; other);</span>
<a href="#l46.80"></a><span id="l46.80">   morkObject&amp; operator=(const morkObject&amp; other);</span>
<a href="#l46.81"></a><span id="l46.81"> </span>
<a href="#l46.82"></a><span id="l46.82"> public: // dynamic type identification</span>
<a href="#l46.83"></a><span id="l46.83">   mork_bool IsObject() const</span>
<a href="#l46.84"></a><span id="l46.84">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kObject; }</span>
<a href="#l46.85"></a><span id="l46.85"> // } ===== end morkNode methods =====</span>
<a href="#l46.86"></a><span id="l46.86"> </span>
<a href="#l46.87"></a><span id="l46.87">   // void NewNilHandleError(morkEnv* ev); // mObject_Handle is nil</span>
<a href="#l46.88"></a><span id="l46.88" class="difflineminus">-  </span>
<a href="#l46.89"></a><span id="l46.89" class="difflineplus">+</span>
<a href="#l46.90"></a><span id="l46.90"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l46.91"></a><span id="l46.91">   static void SlotWeakObject(morkObject* me,</span>
<a href="#l46.92"></a><span id="l46.92">     morkEnv* ev, morkObject** ioSlot)</span>
<a href="#l46.93"></a><span id="l46.93">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l46.94"></a><span id="l46.94" class="difflineminus">-  </span>
<a href="#l46.95"></a><span id="l46.95" class="difflineplus">+</span>
<a href="#l46.96"></a><span id="l46.96">   static void SlotStrongObject(morkObject* me,</span>
<a href="#l46.97"></a><span id="l46.97">     morkEnv* ev, morkObject** ioSlot)</span>
<a href="#l46.98"></a><span id="l46.98">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l46.99"></a><span id="l46.99"> };</span>
<a href="#l46.100"></a><span id="l46.100"> </span>
<a href="#l46.101"></a><span id="l46.101"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l46.102"></a><span id="l46.102"> </span>
<a href="#l46.103"></a><span id="l46.103"> #endif /* _MORKOBJECT_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l47.1"></a><span id="l47.1" class="difflineminus">--- a/db/mork/src/morkParser.cpp</span>
<a href="#l47.2"></a><span id="l47.2" class="difflineplus">+++ b/db/mork/src/morkParser.cpp</span>
<a href="#l47.3"></a><span id="l47.3" class="difflineat">@@ -44,17 +44,17 @@</span>
<a href="#l47.4"></a><span id="l47.4"> #endif</span>
<a href="#l47.5"></a><span id="l47.5"> </span>
<a href="#l47.6"></a><span id="l47.6"> #ifndef _MORKSTORE_</span>
<a href="#l47.7"></a><span id="l47.7"> #include &quot;morkStore.h&quot;</span>
<a href="#l47.8"></a><span id="l47.8"> #endif</span>
<a href="#l47.9"></a><span id="l47.9"> </span>
<a href="#l47.10"></a><span id="l47.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l47.11"></a><span id="l47.11"> </span>
<a href="#l47.12"></a><span id="l47.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l47.13"></a><span id="l47.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l47.14"></a><span id="l47.14"> // { ===== begin morkNode interface =====</span>
<a href="#l47.15"></a><span id="l47.15"> </span>
<a href="#l47.16"></a><span id="l47.16"> /*public virtual*/ void</span>
<a href="#l47.17"></a><span id="l47.17"> morkParser::CloseMorkNode(morkEnv* ev) // CloseParser() only if open</span>
<a href="#l47.18"></a><span id="l47.18"> {</span>
<a href="#l47.19"></a><span id="l47.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l47.20"></a><span id="l47.20">   {</span>
<a href="#l47.21"></a><span id="l47.21">     this-&gt;MarkClosing();</span>
<a href="#l47.22"></a><span id="l47.22" class="difflineat">@@ -67,51 +67,51 @@ morkParser::CloseMorkNode(morkEnv* ev) /</span>
<a href="#l47.23"></a><span id="l47.23"> morkParser::~morkParser() // assert CloseParser() executed earlier</span>
<a href="#l47.24"></a><span id="l47.24"> {</span>
<a href="#l47.25"></a><span id="l47.25">   MORK_ASSERT(mParser_Heap==0);</span>
<a href="#l47.26"></a><span id="l47.26">   MORK_ASSERT(mParser_Stream==0);</span>
<a href="#l47.27"></a><span id="l47.27"> }</span>
<a href="#l47.28"></a><span id="l47.28"> </span>
<a href="#l47.29"></a><span id="l47.29"> /*public non-poly*/</span>
<a href="#l47.30"></a><span id="l47.30"> morkParser::morkParser(morkEnv* ev,</span>
<a href="#l47.31"></a><span id="l47.31" class="difflineminus">-  const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, </span>
<a href="#l47.32"></a><span id="l47.32" class="difflineplus">+  const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l47.33"></a><span id="l47.33">   morkStream* ioStream, mdb_count inBytesPerParseSegment,</span>
<a href="#l47.34"></a><span id="l47.34">   nsIMdbHeap* ioSlotHeap)</span>
<a href="#l47.35"></a><span id="l47.35"> : morkNode(ev, inUsage, ioHeap)</span>
<a href="#l47.36"></a><span id="l47.36"> , mParser_Heap( 0 )</span>
<a href="#l47.37"></a><span id="l47.37"> , mParser_Stream( 0 )</span>
<a href="#l47.38"></a><span id="l47.38"> , mParser_MoreGranularity( inBytesPerParseSegment )</span>
<a href="#l47.39"></a><span id="l47.39"> , mParser_State( morkParser_kStartState )</span>
<a href="#l47.40"></a><span id="l47.40"> </span>
<a href="#l47.41"></a><span id="l47.41"> , mParser_GroupContentStartPos( 0 )</span>
<a href="#l47.42"></a><span id="l47.42"> </span>
<a href="#l47.43"></a><span id="l47.43"> , mParser_TableMid(  )</span>
<a href="#l47.44"></a><span id="l47.44"> , mParser_RowMid(  )</span>
<a href="#l47.45"></a><span id="l47.45"> , mParser_CellMid(  )</span>
<a href="#l47.46"></a><span id="l47.46" class="difflineminus">-    </span>
<a href="#l47.47"></a><span id="l47.47" class="difflineplus">+</span>
<a href="#l47.48"></a><span id="l47.48"> , mParser_InPort( morkBool_kFalse )</span>
<a href="#l47.49"></a><span id="l47.49"> , mParser_InDict( morkBool_kFalse )</span>
<a href="#l47.50"></a><span id="l47.50"> , mParser_InCell( morkBool_kFalse )</span>
<a href="#l47.51"></a><span id="l47.51"> , mParser_InMeta( morkBool_kFalse )</span>
<a href="#l47.52"></a><span id="l47.52" class="difflineminus">-    </span>
<a href="#l47.53"></a><span id="l47.53" class="difflineplus">+</span>
<a href="#l47.54"></a><span id="l47.54"> , mParser_InPortRow( morkBool_kFalse )</span>
<a href="#l47.55"></a><span id="l47.55"> , mParser_InRow( morkBool_kFalse )</span>
<a href="#l47.56"></a><span id="l47.56"> , mParser_InTable( morkBool_kFalse )</span>
<a href="#l47.57"></a><span id="l47.57"> , mParser_InGroup( morkBool_kFalse )</span>
<a href="#l47.58"></a><span id="l47.58"> </span>
<a href="#l47.59"></a><span id="l47.59"> , mParser_AtomChange( morkChange_kNil )</span>
<a href="#l47.60"></a><span id="l47.60"> , mParser_CellChange( morkChange_kNil )</span>
<a href="#l47.61"></a><span id="l47.61"> , mParser_RowChange( morkChange_kNil )</span>
<a href="#l47.62"></a><span id="l47.62"> , mParser_TableChange( morkChange_kNil )</span>
<a href="#l47.63"></a><span id="l47.63"> </span>
<a href="#l47.64"></a><span id="l47.64"> , mParser_Change( morkChange_kNil )</span>
<a href="#l47.65"></a><span id="l47.65"> , mParser_IsBroken( morkBool_kFalse )</span>
<a href="#l47.66"></a><span id="l47.66"> , mParser_IsDone( morkBool_kFalse )</span>
<a href="#l47.67"></a><span id="l47.67"> , mParser_DoMore( morkBool_kTrue )</span>
<a href="#l47.68"></a><span id="l47.68" class="difflineminus">-    </span>
<a href="#l47.69"></a><span id="l47.69" class="difflineplus">+</span>
<a href="#l47.70"></a><span id="l47.70"> , mParser_Mid()</span>
<a href="#l47.71"></a><span id="l47.71"> </span>
<a href="#l47.72"></a><span id="l47.72"> , mParser_ScopeCoil(ev, ioSlotHeap)</span>
<a href="#l47.73"></a><span id="l47.73"> , mParser_ValueCoil(ev, ioSlotHeap)</span>
<a href="#l47.74"></a><span id="l47.74"> , mParser_ColumnCoil(ev, ioSlotHeap)</span>
<a href="#l47.75"></a><span id="l47.75"> , mParser_StringCoil(ev, ioSlotHeap)</span>
<a href="#l47.76"></a><span id="l47.76"> </span>
<a href="#l47.77"></a><span id="l47.77"> , mParser_ScopeSpool(ev, &amp;mParser_ScopeCoil)</span>
<a href="#l47.78"></a><span id="l47.78" class="difflineat">@@ -120,24 +120,24 @@ morkParser::morkParser(morkEnv* ev,</span>
<a href="#l47.79"></a><span id="l47.79"> , mParser_StringSpool(ev, &amp;mParser_StringCoil)</span>
<a href="#l47.80"></a><span id="l47.80"> </span>
<a href="#l47.81"></a><span id="l47.81"> , mParser_MidYarn(ev, morkUsage_kMember, ioSlotHeap)</span>
<a href="#l47.82"></a><span id="l47.82"> {</span>
<a href="#l47.83"></a><span id="l47.83">   if ( inBytesPerParseSegment &lt; morkParser_kMinGranularity )</span>
<a href="#l47.84"></a><span id="l47.84">     inBytesPerParseSegment = morkParser_kMinGranularity;</span>
<a href="#l47.85"></a><span id="l47.85">   else if ( inBytesPerParseSegment &gt; morkParser_kMaxGranularity )</span>
<a href="#l47.86"></a><span id="l47.86">     inBytesPerParseSegment = morkParser_kMaxGranularity;</span>
<a href="#l47.87"></a><span id="l47.87" class="difflineminus">-    </span>
<a href="#l47.88"></a><span id="l47.88" class="difflineplus">+</span>
<a href="#l47.89"></a><span id="l47.89">   mParser_MoreGranularity = inBytesPerParseSegment;</span>
<a href="#l47.90"></a><span id="l47.90"> </span>
<a href="#l47.91"></a><span id="l47.91">   if ( ioSlotHeap &amp;&amp; ioStream )</span>
<a href="#l47.92"></a><span id="l47.92">   {</span>
<a href="#l47.93"></a><span id="l47.93">     nsIMdbHeap_SlotStrongHeap(ioSlotHeap, ev, &amp;mParser_Heap);</span>
<a href="#l47.94"></a><span id="l47.94">     morkStream::SlotStrongStream(ioStream, ev, &amp;mParser_Stream);</span>
<a href="#l47.95"></a><span id="l47.95" class="difflineminus">-    </span>
<a href="#l47.96"></a><span id="l47.96" class="difflineplus">+</span>
<a href="#l47.97"></a><span id="l47.97">     if ( ev-&gt;Good() )</span>
<a href="#l47.98"></a><span id="l47.98">     {</span>
<a href="#l47.99"></a><span id="l47.99">       mParser_Tag = morkParser_kTag;</span>
<a href="#l47.100"></a><span id="l47.100">       mNode_Derived = morkDerived_kParser;</span>
<a href="#l47.101"></a><span id="l47.101">     }</span>
<a href="#l47.102"></a><span id="l47.102">   }</span>
<a href="#l47.103"></a><span id="l47.103">   else</span>
<a href="#l47.104"></a><span id="l47.104">     ev-&gt;NilPointerError();</span>
<a href="#l47.105"></a><span id="l47.105" class="difflineat">@@ -159,17 +159,17 @@ morkParser::CloseParser(morkEnv* ev) // </span>
<a href="#l47.106"></a><span id="l47.106">         this-&gt;MarkShut();</span>
<a href="#l47.107"></a><span id="l47.107">       }</span>
<a href="#l47.108"></a><span id="l47.108">     }</span>
<a href="#l47.109"></a><span id="l47.109">     else</span>
<a href="#l47.110"></a><span id="l47.110">       this-&gt;NonNodeError(ev);</span>
<a href="#l47.111"></a><span id="l47.111"> }</span>
<a href="#l47.112"></a><span id="l47.112"> </span>
<a href="#l47.113"></a><span id="l47.113"> // } ===== end morkNode methods =====</span>
<a href="#l47.114"></a><span id="l47.114" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l47.115"></a><span id="l47.115" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l47.116"></a><span id="l47.116"> </span>
<a href="#l47.117"></a><span id="l47.117"> /*protected non-poly*/ void</span>
<a href="#l47.118"></a><span id="l47.118"> morkParser::NonGoodParserError(morkEnv* ev) // when GoodParserTag() is false</span>
<a href="#l47.119"></a><span id="l47.119"> {</span>
<a href="#l47.120"></a><span id="l47.120">   ev-&gt;NewError(&quot;non-morkNode&quot;);</span>
<a href="#l47.121"></a><span id="l47.121"> }</span>
<a href="#l47.122"></a><span id="l47.122"> </span>
<a href="#l47.123"></a><span id="l47.123"> /*protected non-poly*/ void</span>
<a href="#l47.124"></a><span id="l47.124" class="difflineat">@@ -197,21 +197,21 @@ morkParser::NonUsableParserError(morkEnv</span>
<a href="#l47.125"></a><span id="l47.125"> /*protected non-poly*/ void</span>
<a href="#l47.126"></a><span id="l47.126"> morkParser::StartParse(morkEnv* ev)</span>
<a href="#l47.127"></a><span id="l47.127"> {</span>
<a href="#l47.128"></a><span id="l47.128">   MORK_USED_1(ev);</span>
<a href="#l47.129"></a><span id="l47.129">   mParser_InCell = morkBool_kFalse;</span>
<a href="#l47.130"></a><span id="l47.130">   mParser_InMeta = morkBool_kFalse;</span>
<a href="#l47.131"></a><span id="l47.131">   mParser_InDict = morkBool_kFalse;</span>
<a href="#l47.132"></a><span id="l47.132">   mParser_InPortRow = morkBool_kFalse;</span>
<a href="#l47.133"></a><span id="l47.133" class="difflineminus">-  </span>
<a href="#l47.134"></a><span id="l47.134" class="difflineplus">+</span>
<a href="#l47.135"></a><span id="l47.135">   mParser_RowMid.ClearMid();</span>
<a href="#l47.136"></a><span id="l47.136">   mParser_TableMid.ClearMid();</span>
<a href="#l47.137"></a><span id="l47.137">   mParser_CellMid.ClearMid();</span>
<a href="#l47.138"></a><span id="l47.138" class="difflineminus">-  </span>
<a href="#l47.139"></a><span id="l47.139" class="difflineplus">+</span>
<a href="#l47.140"></a><span id="l47.140">   mParser_GroupId = 0;</span>
<a href="#l47.141"></a><span id="l47.141">   mParser_InPort = morkBool_kTrue;</span>
<a href="#l47.142"></a><span id="l47.142"> </span>
<a href="#l47.143"></a><span id="l47.143">   mParser_GroupSpan.ClearSpan();</span>
<a href="#l47.144"></a><span id="l47.144">   mParser_DictSpan.ClearSpan();</span>
<a href="#l47.145"></a><span id="l47.145">   mParser_AliasSpan.ClearSpan();</span>
<a href="#l47.146"></a><span id="l47.146">   mParser_MetaSpan.ClearSpan();</span>
<a href="#l47.147"></a><span id="l47.147">   mParser_TableSpan.ClearSpan();</span>
<a href="#l47.148"></a><span id="l47.148" class="difflineat">@@ -277,42 +277,42 @@ morkParser::StopParse(morkEnv* ev)</span>
<a href="#l47.149"></a><span id="l47.149">   }</span>
<a href="#l47.150"></a><span id="l47.150"> }</span>
<a href="#l47.151"></a><span id="l47.151"> </span>
<a href="#l47.152"></a><span id="l47.152"> int morkParser::eat_comment(morkEnv* ev) // last char was '/'</span>
<a href="#l47.153"></a><span id="l47.153"> {</span>
<a href="#l47.154"></a><span id="l47.154">   morkStream* s = mParser_Stream;</span>
<a href="#l47.155"></a><span id="l47.155">   // Note morkStream::Getc() returns EOF when an error occurs, so</span>
<a href="#l47.156"></a><span id="l47.156">   // we don't need to check for both c != EOF and ev-&gt;Good() below.</span>
<a href="#l47.157"></a><span id="l47.157" class="difflineminus">-  </span>
<a href="#l47.158"></a><span id="l47.158" class="difflineplus">+</span>
<a href="#l47.159"></a><span id="l47.159">   int c = s-&gt;Getc(ev);</span>
<a href="#l47.160"></a><span id="l47.160">   if ( c == '/' ) // C++ style comment?</span>
<a href="#l47.161"></a><span id="l47.161">   {</span>
<a href="#l47.162"></a><span id="l47.162">     while ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; c != 0xA &amp;&amp; c != 0xD )</span>
<a href="#l47.163"></a><span id="l47.163">       /* empty */;</span>
<a href="#l47.164"></a><span id="l47.164" class="difflineminus">-      </span>
<a href="#l47.165"></a><span id="l47.165" class="difflineplus">+</span>
<a href="#l47.166"></a><span id="l47.166">     if ( c == 0xA || c == 0xD )</span>
<a href="#l47.167"></a><span id="l47.167">       c = this-&gt;eat_line_break(ev, c);</span>
<a href="#l47.168"></a><span id="l47.168">   }</span>
<a href="#l47.169"></a><span id="l47.169">   else if ( c == '*' ) /* C style comment? */</span>
<a href="#l47.170"></a><span id="l47.170">   {</span>
<a href="#l47.171"></a><span id="l47.171">     int depth = 1; // count depth of comments until depth reaches zero</span>
<a href="#l47.172"></a><span id="l47.172" class="difflineminus">-    </span>
<a href="#l47.173"></a><span id="l47.173" class="difflineplus">+</span>
<a href="#l47.174"></a><span id="l47.174">     while ( depth &gt; 0 &amp;&amp; c != EOF ) // still looking for comment end(s)?</span>
<a href="#l47.175"></a><span id="l47.175">     {</span>
<a href="#l47.176"></a><span id="l47.176">       while ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; c != '/' &amp;&amp; c != '*' )</span>
<a href="#l47.177"></a><span id="l47.177">       {</span>
<a href="#l47.178"></a><span id="l47.178">         if ( c == 0xA || c == 0xD ) // need to count a line break?</span>
<a href="#l47.179"></a><span id="l47.179">         {</span>
<a href="#l47.180"></a><span id="l47.180">           c = this-&gt;eat_line_break(ev, c);</span>
<a href="#l47.181"></a><span id="l47.181">           if ( c == '/' || c == '*' )</span>
<a href="#l47.182"></a><span id="l47.182">             break; // end while loop</span>
<a href="#l47.183"></a><span id="l47.183">         }</span>
<a href="#l47.184"></a><span id="l47.184">       }</span>
<a href="#l47.185"></a><span id="l47.185" class="difflineminus">-        </span>
<a href="#l47.186"></a><span id="l47.186" class="difflineplus">+</span>
<a href="#l47.187"></a><span id="l47.187">       if ( c == '*' ) // maybe end of a comment, if next char is '/'?</span>
<a href="#l47.188"></a><span id="l47.188">       {</span>
<a href="#l47.189"></a><span id="l47.189">         if ( (c = s-&gt;Getc(ev)) == '/' ) // end of comment?</span>
<a href="#l47.190"></a><span id="l47.190">         {</span>
<a href="#l47.191"></a><span id="l47.191">           --depth; // depth of comments has decreased by one</span>
<a href="#l47.192"></a><span id="l47.192">           if ( !depth ) // comments all done?</span>
<a href="#l47.193"></a><span id="l47.193">             c = s-&gt;Getc(ev); // return the byte after end of comment</span>
<a href="#l47.194"></a><span id="l47.194">         }</span>
<a href="#l47.195"></a><span id="l47.195" class="difflineat">@@ -321,26 +321,26 @@ int morkParser::eat_comment(morkEnv* ev)</span>
<a href="#l47.196"></a><span id="l47.196">       }</span>
<a href="#l47.197"></a><span id="l47.197">       else if ( c == '/' ) // maybe nested comemnt, if next char is '*'?</span>
<a href="#l47.198"></a><span id="l47.198">       {</span>
<a href="#l47.199"></a><span id="l47.199">         if ( (c = s-&gt;Getc(ev)) == '*' ) // nested comment?</span>
<a href="#l47.200"></a><span id="l47.200">           ++depth; // depth of comments has increased by one</span>
<a href="#l47.201"></a><span id="l47.201">         else if ( c != EOF ) // need to put the char back?</span>
<a href="#l47.202"></a><span id="l47.202">           s-&gt;Ungetc(c); // especially need to put back '/', 0xA, or 0xD</span>
<a href="#l47.203"></a><span id="l47.203">       }</span>
<a href="#l47.204"></a><span id="l47.204" class="difflineminus">-        </span>
<a href="#l47.205"></a><span id="l47.205" class="difflineplus">+</span>
<a href="#l47.206"></a><span id="l47.206">       if ( ev-&gt;Bad() )</span>
<a href="#l47.207"></a><span id="l47.207">         c = EOF;</span>
<a href="#l47.208"></a><span id="l47.208">     }</span>
<a href="#l47.209"></a><span id="l47.209">     if ( c == EOF &amp;&amp; depth &gt; 0 )</span>
<a href="#l47.210"></a><span id="l47.210">       ev-&gt;NewWarning(&quot;EOF before end of comment&quot;);</span>
<a href="#l47.211"></a><span id="l47.211">   }</span>
<a href="#l47.212"></a><span id="l47.212">   else</span>
<a href="#l47.213"></a><span id="l47.213">     ev-&gt;NewWarning(&quot;expected / or *&quot;);</span>
<a href="#l47.214"></a><span id="l47.214" class="difflineminus">-  </span>
<a href="#l47.215"></a><span id="l47.215" class="difflineplus">+</span>
<a href="#l47.216"></a><span id="l47.216">   return c;</span>
<a href="#l47.217"></a><span id="l47.217"> }</span>
<a href="#l47.218"></a><span id="l47.218"> </span>
<a href="#l47.219"></a><span id="l47.219"> int morkParser::eat_line_break(morkEnv* ev, int inLast)</span>
<a href="#l47.220"></a><span id="l47.220"> {</span>
<a href="#l47.221"></a><span id="l47.221">   morkStream* s = mParser_Stream;</span>
<a href="#l47.222"></a><span id="l47.222">   int c = s-&gt;Getc(ev); // get next char after 0xA or 0xD</span>
<a href="#l47.223"></a><span id="l47.223">   this-&gt;CountLineBreak();</span>
<a href="#l47.224"></a><span id="l47.224" class="difflineat">@@ -357,17 +357,17 @@ int morkParser::eat_line_continue(morkEn</span>
<a href="#l47.225"></a><span id="l47.225">   morkStream* s = mParser_Stream;</span>
<a href="#l47.226"></a><span id="l47.226">   int c = s-&gt;Getc(ev);</span>
<a href="#l47.227"></a><span id="l47.227">   if ( c == 0xA || c == 0xD ) // linebreak follows \ as expected?</span>
<a href="#l47.228"></a><span id="l47.228">   {</span>
<a href="#l47.229"></a><span id="l47.229">     c = this-&gt;eat_line_break(ev, c);</span>
<a href="#l47.230"></a><span id="l47.230">   }</span>
<a href="#l47.231"></a><span id="l47.231">   else</span>
<a href="#l47.232"></a><span id="l47.232">     ev-&gt;NewWarning(&quot;expected linebreak&quot;);</span>
<a href="#l47.233"></a><span id="l47.233" class="difflineminus">-  </span>
<a href="#l47.234"></a><span id="l47.234" class="difflineplus">+</span>
<a href="#l47.235"></a><span id="l47.235">   return c;</span>
<a href="#l47.236"></a><span id="l47.236"> }</span>
<a href="#l47.237"></a><span id="l47.237"> </span>
<a href="#l47.238"></a><span id="l47.238"> int morkParser::NextChar(morkEnv* ev) // next non-white content</span>
<a href="#l47.239"></a><span id="l47.239"> {</span>
<a href="#l47.240"></a><span id="l47.240">   morkStream* s = mParser_Stream;</span>
<a href="#l47.241"></a><span id="l47.241">   int c = s-&gt;Getc(ev);</span>
<a href="#l47.242"></a><span id="l47.242">   while ( c &gt; 0 &amp;&amp; ev-&gt;Good() )</span>
<a href="#l47.243"></a><span id="l47.243" class="difflineat">@@ -375,17 +375,17 @@ int morkParser::NextChar(morkEnv* ev) //</span>
<a href="#l47.244"></a><span id="l47.244">     if ( c == '/' )</span>
<a href="#l47.245"></a><span id="l47.245">       c = this-&gt;eat_comment(ev);</span>
<a href="#l47.246"></a><span id="l47.246">     else if ( c == 0xA || c == 0xD )</span>
<a href="#l47.247"></a><span id="l47.247">       c = this-&gt;eat_line_break(ev, c);</span>
<a href="#l47.248"></a><span id="l47.248">     else if ( c == '\\' )</span>
<a href="#l47.249"></a><span id="l47.249">       c = this-&gt;eat_line_continue(ev);</span>
<a href="#l47.250"></a><span id="l47.250">     else if ( morkCh_IsWhite(c) )</span>
<a href="#l47.251"></a><span id="l47.251">       c = s-&gt;Getc(ev);</span>
<a href="#l47.252"></a><span id="l47.252" class="difflineminus">-    else  </span>
<a href="#l47.253"></a><span id="l47.253" class="difflineplus">+    else</span>
<a href="#l47.254"></a><span id="l47.254">       break; // end while loop when return c is acceptable</span>
<a href="#l47.255"></a><span id="l47.255">   }</span>
<a href="#l47.256"></a><span id="l47.256">   if ( ev-&gt;Bad() )</span>
<a href="#l47.257"></a><span id="l47.257">   {</span>
<a href="#l47.258"></a><span id="l47.258">     mParser_State = morkParser_kBrokenState;</span>
<a href="#l47.259"></a><span id="l47.259">     mParser_DoMore = morkBool_kFalse;</span>
<a href="#l47.260"></a><span id="l47.260">     mParser_IsDone = morkBool_kTrue;</span>
<a href="#l47.261"></a><span id="l47.261">     mParser_IsBroken = morkBool_kTrue;</span>
<a href="#l47.262"></a><span id="l47.262" class="difflineat">@@ -427,84 +427,84 @@ void</span>
<a href="#l47.263"></a><span id="l47.263"> morkParser::OnDictState(morkEnv* ev)</span>
<a href="#l47.264"></a><span id="l47.264"> {</span>
<a href="#l47.265"></a><span id="l47.265">   ev-&gt;StubMethodOnlyError();</span>
<a href="#l47.266"></a><span id="l47.266"> }</span>
<a href="#l47.267"></a><span id="l47.267"> </span>
<a href="#l47.268"></a><span id="l47.268"> morkBuf* morkParser::ReadName(morkEnv* ev, int c)</span>
<a href="#l47.269"></a><span id="l47.269"> {</span>
<a href="#l47.270"></a><span id="l47.270">   morkBuf* outBuf = 0;</span>
<a href="#l47.271"></a><span id="l47.271" class="difflineminus">-  </span>
<a href="#l47.272"></a><span id="l47.272" class="difflineplus">+</span>
<a href="#l47.273"></a><span id="l47.273">   if ( !morkCh_IsName(c) )</span>
<a href="#l47.274"></a><span id="l47.274">     ev-&gt;NewError(&quot;not a name char&quot;);</span>
<a href="#l47.275"></a><span id="l47.275"> </span>
<a href="#l47.276"></a><span id="l47.276">   morkCoil* coil = &amp;mParser_ColumnCoil;</span>
<a href="#l47.277"></a><span id="l47.277">   coil-&gt;ClearBufFill();</span>
<a href="#l47.278"></a><span id="l47.278"> </span>
<a href="#l47.279"></a><span id="l47.279">   morkSpool* spool = &amp;mParser_ColumnSpool;</span>
<a href="#l47.280"></a><span id="l47.280">   spool-&gt;Seek(ev, /*pos*/ 0);</span>
<a href="#l47.281"></a><span id="l47.281" class="difflineminus">-  </span>
<a href="#l47.282"></a><span id="l47.282" class="difflineplus">+</span>
<a href="#l47.283"></a><span id="l47.283">   if ( ev-&gt;Good() )</span>
<a href="#l47.284"></a><span id="l47.284">   {</span>
<a href="#l47.285"></a><span id="l47.285">     spool-&gt;Putc(ev, c);</span>
<a href="#l47.286"></a><span id="l47.286" class="difflineminus">-    </span>
<a href="#l47.287"></a><span id="l47.287" class="difflineplus">+</span>
<a href="#l47.288"></a><span id="l47.288">     morkStream* s = mParser_Stream;</span>
<a href="#l47.289"></a><span id="l47.289">     while ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; morkCh_IsMore(c) &amp;&amp; ev-&gt;Good() )</span>
<a href="#l47.290"></a><span id="l47.290">       spool-&gt;Putc(ev, c);</span>
<a href="#l47.291"></a><span id="l47.291" class="difflineminus">-      </span>
<a href="#l47.292"></a><span id="l47.292" class="difflineplus">+</span>
<a href="#l47.293"></a><span id="l47.293">     if ( ev-&gt;Good() )</span>
<a href="#l47.294"></a><span id="l47.294">     {</span>
<a href="#l47.295"></a><span id="l47.295">       if ( c != EOF )</span>
<a href="#l47.296"></a><span id="l47.296">       {</span>
<a href="#l47.297"></a><span id="l47.297">         s-&gt;Ungetc(c);</span>
<a href="#l47.298"></a><span id="l47.298">         spool-&gt;FlushSink(ev); // update coil-&gt;mBuf_Fill</span>
<a href="#l47.299"></a><span id="l47.299">       }</span>
<a href="#l47.300"></a><span id="l47.300">       else</span>
<a href="#l47.301"></a><span id="l47.301">         this-&gt;UnexpectedEofError(ev);</span>
<a href="#l47.302"></a><span id="l47.302" class="difflineminus">-        </span>
<a href="#l47.303"></a><span id="l47.303" class="difflineplus">+</span>
<a href="#l47.304"></a><span id="l47.304">       if ( ev-&gt;Good() )</span>
<a href="#l47.305"></a><span id="l47.305">         outBuf = coil;</span>
<a href="#l47.306"></a><span id="l47.306">     }</span>
<a href="#l47.307"></a><span id="l47.307" class="difflineminus">-  }  </span>
<a href="#l47.308"></a><span id="l47.308" class="difflineplus">+  }</span>
<a href="#l47.309"></a><span id="l47.309">   return outBuf;</span>
<a href="#l47.310"></a><span id="l47.310"> }</span>
<a href="#l47.311"></a><span id="l47.311"> </span>
<a href="#l47.312"></a><span id="l47.312"> mork_bool</span>
<a href="#l47.313"></a><span id="l47.313"> morkParser::ReadMid(morkEnv* ev, morkMid* outMid)</span>
<a href="#l47.314"></a><span id="l47.314"> {</span>
<a href="#l47.315"></a><span id="l47.315">   outMid-&gt;ClearMid();</span>
<a href="#l47.316"></a><span id="l47.316" class="difflineminus">-  </span>
<a href="#l47.317"></a><span id="l47.317" class="difflineplus">+</span>
<a href="#l47.318"></a><span id="l47.318">   morkStream* s = mParser_Stream;</span>
<a href="#l47.319"></a><span id="l47.319">   int next;</span>
<a href="#l47.320"></a><span id="l47.320">   outMid-&gt;mMid_Oid.mOid_Id = this-&gt;ReadHex(ev, &amp;next);</span>
<a href="#l47.321"></a><span id="l47.321">   int c = next;</span>
<a href="#l47.322"></a><span id="l47.322">   if ( c == ':' )</span>
<a href="#l47.323"></a><span id="l47.323">   {</span>
<a href="#l47.324"></a><span id="l47.324">     if ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; ev-&gt;Good() )</span>
<a href="#l47.325"></a><span id="l47.325">     {</span>
<a href="#l47.326"></a><span id="l47.326">       if ( c == '^' )</span>
<a href="#l47.327"></a><span id="l47.327">       {</span>
<a href="#l47.328"></a><span id="l47.328">         outMid-&gt;mMid_Oid.mOid_Scope = this-&gt;ReadHex(ev, &amp;next);</span>
<a href="#l47.329"></a><span id="l47.329">         if ( ev-&gt;Good() )</span>
<a href="#l47.330"></a><span id="l47.330">           s-&gt;Ungetc(next);</span>
<a href="#l47.331"></a><span id="l47.331">       }</span>
<a href="#l47.332"></a><span id="l47.332">       else if ( morkCh_IsName(c) )</span>
<a href="#l47.333"></a><span id="l47.333">       {</span>
<a href="#l47.334"></a><span id="l47.334" class="difflineminus">-        outMid-&gt;mMid_Buf = this-&gt;ReadName(ev, c); </span>
<a href="#l47.335"></a><span id="l47.335" class="difflineplus">+        outMid-&gt;mMid_Buf = this-&gt;ReadName(ev, c);</span>
<a href="#l47.336"></a><span id="l47.336">       }</span>
<a href="#l47.337"></a><span id="l47.337">       else</span>
<a href="#l47.338"></a><span id="l47.338">         ev-&gt;NewError(&quot;expected name or hex after ':' following ID&quot;);</span>
<a href="#l47.339"></a><span id="l47.339">     }</span>
<a href="#l47.340"></a><span id="l47.340" class="difflineminus">-    </span>
<a href="#l47.341"></a><span id="l47.341" class="difflineplus">+</span>
<a href="#l47.342"></a><span id="l47.342">     if ( c == EOF &amp;&amp; ev-&gt;Good() )</span>
<a href="#l47.343"></a><span id="l47.343">       this-&gt;UnexpectedEofError(ev);</span>
<a href="#l47.344"></a><span id="l47.344">   }</span>
<a href="#l47.345"></a><span id="l47.345">   else</span>
<a href="#l47.346"></a><span id="l47.346">     s-&gt;Ungetc(c);</span>
<a href="#l47.347"></a><span id="l47.347" class="difflineminus">-  </span>
<a href="#l47.348"></a><span id="l47.348" class="difflineplus">+</span>
<a href="#l47.349"></a><span id="l47.349">   return ev-&gt;Good();</span>
<a href="#l47.350"></a><span id="l47.350"> }</span>
<a href="#l47.351"></a><span id="l47.351"> </span>
<a href="#l47.352"></a><span id="l47.352"> void</span>
<a href="#l47.353"></a><span id="l47.353"> morkParser::ReadCell(morkEnv* ev)</span>
<a href="#l47.354"></a><span id="l47.354"> {</span>
<a href="#l47.355"></a><span id="l47.355">   mParser_CellMid.ClearMid();</span>
<a href="#l47.356"></a><span id="l47.356">   // this-&gt;StartSpanOnLastByte(ev, &amp;mParser_CellSpan);</span>
<a href="#l47.357"></a><span id="l47.357" class="difflineat">@@ -526,17 +526,17 @@ morkParser::ReadCell(morkEnv* ev)</span>
<a href="#l47.358"></a><span id="l47.358">     else</span>
<a href="#l47.359"></a><span id="l47.359">     {</span>
<a href="#l47.360"></a><span id="l47.360">       if (mParser_InMeta &amp;&amp; c == morkStore_kFormColumn)</span>
<a href="#l47.361"></a><span id="l47.361">       {</span>
<a href="#l47.362"></a><span id="l47.362">         ReadCellForm(ev, c);</span>
<a href="#l47.363"></a><span id="l47.363">         return;</span>
<a href="#l47.364"></a><span id="l47.364">       }</span>
<a href="#l47.365"></a><span id="l47.365">       else</span>
<a href="#l47.366"></a><span id="l47.366" class="difflineminus">-        cellBuf = this-&gt;ReadName(ev, c); </span>
<a href="#l47.367"></a><span id="l47.367" class="difflineplus">+        cellBuf = this-&gt;ReadName(ev, c);</span>
<a href="#l47.368"></a><span id="l47.368">     }</span>
<a href="#l47.369"></a><span id="l47.369">     if ( ev-&gt;Good() )</span>
<a href="#l47.370"></a><span id="l47.370">     {</span>
<a href="#l47.371"></a><span id="l47.371">       // this-&gt;EndSpanOnThisByte(ev, &amp;mParser_ColumnSpan);</span>
<a href="#l47.372"></a><span id="l47.372"> </span>
<a href="#l47.373"></a><span id="l47.373">       mParser_InCell = morkBool_kTrue;</span>
<a href="#l47.374"></a><span id="l47.374">       this-&gt;OnNewCell(ev, *mParser_CellSpan.AsPlace(),</span>
<a href="#l47.375"></a><span id="l47.375">         cellMid, cellBuf); // , mParser_CellChange</span>
<a href="#l47.376"></a><span id="l47.376" class="difflineat">@@ -561,47 +561,47 @@ morkParser::ReadCell(morkEnv* ev)</span>
<a href="#l47.377"></a><span id="l47.377">             // this-&gt;EndSpanOnThisByte(ev, &amp;mParser_SlotSpan);</span>
<a href="#l47.378"></a><span id="l47.378">             if ( (c = this-&gt;NextChar(ev)) != EOF &amp;&amp; ev-&gt;Good() )</span>
<a href="#l47.379"></a><span id="l47.379">             {</span>
<a href="#l47.380"></a><span id="l47.380">               if ( c != ')' )</span>
<a href="#l47.381"></a><span id="l47.381">                 ev-&gt;NewError(&quot;expected ')' after cell ^ID value&quot;);</span>
<a href="#l47.382"></a><span id="l47.382">             }</span>
<a href="#l47.383"></a><span id="l47.383">             else if ( c == EOF )</span>
<a href="#l47.384"></a><span id="l47.384">               this-&gt;UnexpectedEofError(ev);</span>
<a href="#l47.385"></a><span id="l47.385" class="difflineminus">-            </span>
<a href="#l47.386"></a><span id="l47.386" class="difflineplus">+</span>
<a href="#l47.387"></a><span id="l47.387">             if ( ev-&gt;Good() )</span>
<a href="#l47.388"></a><span id="l47.388">               this-&gt;OnValueMid(ev, mParser_SlotSpan, mParser_Mid);</span>
<a href="#l47.389"></a><span id="l47.389">           }</span>
<a href="#l47.390"></a><span id="l47.390">         }</span>
<a href="#l47.391"></a><span id="l47.391">         else if ( c == 'r' || c == 't' || c == '&quot;' || c == '\'' )</span>
<a href="#l47.392"></a><span id="l47.392">         {</span>
<a href="#l47.393"></a><span id="l47.393">           ev-&gt;NewError(&quot;cell syntax not yet supported&quot;);</span>
<a href="#l47.394"></a><span id="l47.394">         }</span>
<a href="#l47.395"></a><span id="l47.395">         else</span>
<a href="#l47.396"></a><span id="l47.396">         {</span>
<a href="#l47.397"></a><span id="l47.397">           ev-&gt;NewError(&quot;unknown cell syntax&quot;);</span>
<a href="#l47.398"></a><span id="l47.398">         }</span>
<a href="#l47.399"></a><span id="l47.399">       }</span>
<a href="#l47.400"></a><span id="l47.400" class="difflineminus">-      </span>
<a href="#l47.401"></a><span id="l47.401" class="difflineplus">+</span>
<a href="#l47.402"></a><span id="l47.402">       // this-&gt;EndSpanOnThisByte(ev, &amp;mParser_CellSpan);</span>
<a href="#l47.403"></a><span id="l47.403">       mParser_InCell = morkBool_kFalse;</span>
<a href="#l47.404"></a><span id="l47.404">       this-&gt;OnCellEnd(ev, mParser_CellSpan);</span>
<a href="#l47.405"></a><span id="l47.405">     }</span>
<a href="#l47.406"></a><span id="l47.406">   }</span>
<a href="#l47.407"></a><span id="l47.407">   mParser_CellChange = morkChange_kNil;</span>
<a href="#l47.408"></a><span id="l47.408" class="difflineminus">-  </span>
<a href="#l47.409"></a><span id="l47.409" class="difflineplus">+</span>
<a href="#l47.410"></a><span id="l47.410">   if ( c == EOF &amp;&amp; ev-&gt;Good() )</span>
<a href="#l47.411"></a><span id="l47.411">     this-&gt;UnexpectedEofError(ev);</span>
<a href="#l47.412"></a><span id="l47.412"> }</span>
<a href="#l47.413"></a><span id="l47.413"> </span>
<a href="#l47.414"></a><span id="l47.414"> void morkParser::ReadRowPos(morkEnv* ev)</span>
<a href="#l47.415"></a><span id="l47.415"> {</span>
<a href="#l47.416"></a><span id="l47.416">   int c; // next character</span>
<a href="#l47.417"></a><span id="l47.417">   mork_pos rowPos = this-&gt;ReadHex(ev, &amp;c);</span>
<a href="#l47.418"></a><span id="l47.418" class="difflineminus">-  </span>
<a href="#l47.419"></a><span id="l47.419" class="difflineplus">+</span>
<a href="#l47.420"></a><span id="l47.420">   if ( ev-&gt;Good() &amp;&amp; c != EOF ) // should put back byte after hex?</span>
<a href="#l47.421"></a><span id="l47.421">     mParser_Stream-&gt;Ungetc(c);</span>
<a href="#l47.422"></a><span id="l47.422"> </span>
<a href="#l47.423"></a><span id="l47.423">   this-&gt;OnRowPos(ev, rowPos);</span>
<a href="#l47.424"></a><span id="l47.424"> }</span>
<a href="#l47.425"></a><span id="l47.425"> </span>
<a href="#l47.426"></a><span id="l47.426"> void morkParser::ReadRow(morkEnv* ev, int c)</span>
<a href="#l47.427"></a><span id="l47.427"> // zm:Row       ::= zm:S? '[' zm:S? zm:Id zm:RowItem* zm:S? ']'</span>
<a href="#l47.428"></a><span id="l47.428" class="difflineat">@@ -634,82 +634,82 @@ void morkParser::ReadRow(morkEnv* ev, in</span>
<a href="#l47.429"></a><span id="l47.429"> </span>
<a href="#l47.430"></a><span id="l47.430">         while ( (c = this-&gt;NextChar(ev)) != EOF &amp;&amp; ev-&gt;Good() &amp;&amp; c != ']' )</span>
<a href="#l47.431"></a><span id="l47.431">         {</span>
<a href="#l47.432"></a><span id="l47.432">           switch ( c )</span>
<a href="#l47.433"></a><span id="l47.433">           {</span>
<a href="#l47.434"></a><span id="l47.434">             case '(': // cell</span>
<a href="#l47.435"></a><span id="l47.435">               this-&gt;ReadCell(ev);</span>
<a href="#l47.436"></a><span id="l47.436">               break;</span>
<a href="#l47.437"></a><span id="l47.437" class="difflineminus">-              </span>
<a href="#l47.438"></a><span id="l47.438" class="difflineplus">+</span>
<a href="#l47.439"></a><span id="l47.439">             case '[': // meta</span>
<a href="#l47.440"></a><span id="l47.440">               this-&gt;ReadMeta(ev, ']');</span>
<a href="#l47.441"></a><span id="l47.441">               break;</span>
<a href="#l47.442"></a><span id="l47.442" class="difflineminus">-            </span>
<a href="#l47.443"></a><span id="l47.443" class="difflineplus">+</span>
<a href="#l47.444"></a><span id="l47.444">             // case '+': // plus</span>
<a href="#l47.445"></a><span id="l47.445">             //   mParser_CellChange = morkChange_kAdd;</span>
<a href="#l47.446"></a><span id="l47.446">             //   break;</span>
<a href="#l47.447"></a><span id="l47.447" class="difflineminus">-              </span>
<a href="#l47.448"></a><span id="l47.448" class="difflineplus">+</span>
<a href="#l47.449"></a><span id="l47.449">             case '-': // minus</span>
<a href="#l47.450"></a><span id="l47.450">               // mParser_CellChange = morkChange_kCut;</span>
<a href="#l47.451"></a><span id="l47.451">               this-&gt;OnMinusCell(ev);</span>
<a href="#l47.452"></a><span id="l47.452">               break;</span>
<a href="#l47.453"></a><span id="l47.453" class="difflineminus">-              </span>
<a href="#l47.454"></a><span id="l47.454" class="difflineplus">+</span>
<a href="#l47.455"></a><span id="l47.455">             // case '!': // bang</span>
<a href="#l47.456"></a><span id="l47.456">             //   mParser_CellChange = morkChange_kSet;</span>
<a href="#l47.457"></a><span id="l47.457">             //  break;</span>
<a href="#l47.458"></a><span id="l47.458" class="difflineminus">-              </span>
<a href="#l47.459"></a><span id="l47.459" class="difflineplus">+</span>
<a href="#l47.460"></a><span id="l47.460">             default:</span>
<a href="#l47.461"></a><span id="l47.461">               ev-&gt;NewWarning(&quot;unexpected byte in row&quot;);</span>
<a href="#l47.462"></a><span id="l47.462">               break;</span>
<a href="#l47.463"></a><span id="l47.463">           } // switch</span>
<a href="#l47.464"></a><span id="l47.464">         } // while</span>
<a href="#l47.465"></a><span id="l47.465" class="difflineminus">-        </span>
<a href="#l47.466"></a><span id="l47.466" class="difflineplus">+</span>
<a href="#l47.467"></a><span id="l47.467">         if ( ev-&gt;Good() )</span>
<a href="#l47.468"></a><span id="l47.468">         {</span>
<a href="#l47.469"></a><span id="l47.469">           if ( (c = this-&gt;NextChar(ev)) == '!' )</span>
<a href="#l47.470"></a><span id="l47.470">             this-&gt;ReadRowPos(ev);</span>
<a href="#l47.471"></a><span id="l47.471">           else if ( c != EOF &amp;&amp; ev-&gt;Good() )</span>
<a href="#l47.472"></a><span id="l47.472">             mParser_Stream-&gt;Ungetc(c);</span>
<a href="#l47.473"></a><span id="l47.473">         }</span>
<a href="#l47.474"></a><span id="l47.474" class="difflineminus">-        </span>
<a href="#l47.475"></a><span id="l47.475" class="difflineplus">+</span>
<a href="#l47.476"></a><span id="l47.476">         // this-&gt;EndSpanOnThisByte(ev, &amp;mParser_RowSpan);</span>
<a href="#l47.477"></a><span id="l47.477">         mParser_InRow = morkBool_kFalse;</span>
<a href="#l47.478"></a><span id="l47.478">         this-&gt;OnRowEnd(ev, mParser_RowSpan);</span>
<a href="#l47.479"></a><span id="l47.479"> </span>
<a href="#l47.480"></a><span id="l47.480">       } // if ReadMid</span>
<a href="#l47.481"></a><span id="l47.481">     } // if '['</span>
<a href="#l47.482"></a><span id="l47.482" class="difflineminus">-    </span>
<a href="#l47.483"></a><span id="l47.483" class="difflineplus">+</span>
<a href="#l47.484"></a><span id="l47.484">     else // c != '['</span>
<a href="#l47.485"></a><span id="l47.485">     {</span>
<a href="#l47.486"></a><span id="l47.486">       morkStream* s = mParser_Stream;</span>
<a href="#l47.487"></a><span id="l47.487">       s-&gt;Ungetc(c);</span>
<a href="#l47.488"></a><span id="l47.488">       if ( this-&gt;ReadMid(ev, &amp;mParser_RowMid) )</span>
<a href="#l47.489"></a><span id="l47.489">       {</span>
<a href="#l47.490"></a><span id="l47.490">         mParser_InRow = morkBool_kTrue;</span>
<a href="#l47.491"></a><span id="l47.491">         this-&gt;OnNewRow(ev, *mParser_RowSpan.AsPlace(),</span>
<a href="#l47.492"></a><span id="l47.492">           mParser_RowMid, cutAllRowCols);</span>
<a href="#l47.493"></a><span id="l47.493"> </span>
<a href="#l47.494"></a><span id="l47.494">         mParser_Change = mParser_RowChange = morkChange_kNil;</span>
<a href="#l47.495"></a><span id="l47.495" class="difflineminus">-        </span>
<a href="#l47.496"></a><span id="l47.496" class="difflineplus">+</span>
<a href="#l47.497"></a><span id="l47.497">         if ( ev-&gt;Good() )</span>
<a href="#l47.498"></a><span id="l47.498">         {</span>
<a href="#l47.499"></a><span id="l47.499">           if ( (c = this-&gt;NextChar(ev)) == '!' )</span>
<a href="#l47.500"></a><span id="l47.500">             this-&gt;ReadRowPos(ev);</span>
<a href="#l47.501"></a><span id="l47.501">           else if ( c != EOF &amp;&amp; ev-&gt;Good() )</span>
<a href="#l47.502"></a><span id="l47.502">             s-&gt;Ungetc(c);</span>
<a href="#l47.503"></a><span id="l47.503">         }</span>
<a href="#l47.504"></a><span id="l47.504"> </span>
<a href="#l47.505"></a><span id="l47.505">         // this-&gt;EndSpanOnThisByte(ev, &amp;mParser_RowSpan);</span>
<a href="#l47.506"></a><span id="l47.506">         mParser_InRow = morkBool_kFalse;</span>
<a href="#l47.507"></a><span id="l47.507">         this-&gt;OnRowEnd(ev, mParser_RowSpan);</span>
<a href="#l47.508"></a><span id="l47.508">       }</span>
<a href="#l47.509"></a><span id="l47.509">     }</span>
<a href="#l47.510"></a><span id="l47.510">   }</span>
<a href="#l47.511"></a><span id="l47.511" class="difflineminus">-  </span>
<a href="#l47.512"></a><span id="l47.512" class="difflineplus">+</span>
<a href="#l47.513"></a><span id="l47.513">   if ( ev-&gt;Bad() )</span>
<a href="#l47.514"></a><span id="l47.514">     mParser_State = morkParser_kBrokenState;</span>
<a href="#l47.515"></a><span id="l47.515">   else if ( c == EOF )</span>
<a href="#l47.516"></a><span id="l47.516">     mParser_State = morkParser_kDoneState;</span>
<a href="#l47.517"></a><span id="l47.517"> }</span>
<a href="#l47.518"></a><span id="l47.518"> </span>
<a href="#l47.519"></a><span id="l47.519"> void morkParser::ReadTable(morkEnv* ev)</span>
<a href="#l47.520"></a><span id="l47.520"> // zm:Table     ::= zm:S? '{' zm:S? zm:Id zm:TableItem* zm:S? '}'</span>
<a href="#l47.521"></a><span id="l47.521" class="difflineat">@@ -717,27 +717,27 @@ void morkParser::ReadTable(morkEnv* ev)</span>
<a href="#l47.522"></a><span id="l47.522"> // zm:MetaTable ::= zm:S? '{' zm:S? zm:Cell* zm:S? '}' /* meta attributes */</span>
<a href="#l47.523"></a><span id="l47.523"> {</span>
<a href="#l47.524"></a><span id="l47.524">   // this-&gt;StartSpanOnLastByte(ev, &amp;mParser_TableSpan);</span>
<a href="#l47.525"></a><span id="l47.525"> </span>
<a href="#l47.526"></a><span id="l47.526">   if ( mParser_Change )</span>
<a href="#l47.527"></a><span id="l47.527">     mParser_TableChange = mParser_Change;</span>
<a href="#l47.528"></a><span id="l47.528"> </span>
<a href="#l47.529"></a><span id="l47.529">   mork_bool cutAllTableRows = morkBool_kFalse;</span>
<a href="#l47.530"></a><span id="l47.530" class="difflineminus">-  </span>
<a href="#l47.531"></a><span id="l47.531" class="difflineplus">+</span>
<a href="#l47.532"></a><span id="l47.532">   int c = this-&gt;NextChar(ev);</span>
<a href="#l47.533"></a><span id="l47.533">   if ( c == '-' )</span>
<a href="#l47.534"></a><span id="l47.534">     cutAllTableRows = morkBool_kTrue;</span>
<a href="#l47.535"></a><span id="l47.535">   else if ( ev-&gt;Good() &amp;&amp; c != EOF )</span>
<a href="#l47.536"></a><span id="l47.536">     mParser_Stream-&gt;Ungetc(c);</span>
<a href="#l47.537"></a><span id="l47.537" class="difflineminus">-  </span>
<a href="#l47.538"></a><span id="l47.538" class="difflineplus">+</span>
<a href="#l47.539"></a><span id="l47.539">   if ( ev-&gt;Good() &amp;&amp; this-&gt;ReadMid(ev, &amp;mParser_TableMid) )</span>
<a href="#l47.540"></a><span id="l47.540">   {</span>
<a href="#l47.541"></a><span id="l47.541">     mParser_InTable = morkBool_kTrue;</span>
<a href="#l47.542"></a><span id="l47.542" class="difflineminus">-    this-&gt;OnNewTable(ev, *mParser_TableSpan.AsPlace(),  </span>
<a href="#l47.543"></a><span id="l47.543" class="difflineplus">+    this-&gt;OnNewTable(ev, *mParser_TableSpan.AsPlace(),</span>
<a href="#l47.544"></a><span id="l47.544">       mParser_TableMid, cutAllTableRows);</span>
<a href="#l47.545"></a><span id="l47.545"> </span>
<a href="#l47.546"></a><span id="l47.546">     mParser_Change = mParser_TableChange = morkChange_kNil;</span>
<a href="#l47.547"></a><span id="l47.547"> </span>
<a href="#l47.548"></a><span id="l47.548">     while ( (c = this-&gt;NextChar(ev)) != EOF &amp;&amp; ev-&gt;Good() &amp;&amp; c != '}' )</span>
<a href="#l47.549"></a><span id="l47.549">     {</span>
<a href="#l47.550"></a><span id="l47.550">       if ( morkCh_IsHex(c) )</span>
<a href="#l47.551"></a><span id="l47.551">       {</span>
<a href="#l47.552"></a><span id="l47.552" class="difflineat">@@ -745,34 +745,34 @@ void morkParser::ReadTable(morkEnv* ev)</span>
<a href="#l47.553"></a><span id="l47.553">       }</span>
<a href="#l47.554"></a><span id="l47.554">       else</span>
<a href="#l47.555"></a><span id="l47.555">       {</span>
<a href="#l47.556"></a><span id="l47.556">         switch ( c )</span>
<a href="#l47.557"></a><span id="l47.557">         {</span>
<a href="#l47.558"></a><span id="l47.558">           case '[': // row</span>
<a href="#l47.559"></a><span id="l47.559">             this-&gt;ReadRow(ev, '[');</span>
<a href="#l47.560"></a><span id="l47.560">             break;</span>
<a href="#l47.561"></a><span id="l47.561" class="difflineminus">-            </span>
<a href="#l47.562"></a><span id="l47.562" class="difflineplus">+</span>
<a href="#l47.563"></a><span id="l47.563">           case '{': // meta</span>
<a href="#l47.564"></a><span id="l47.564">             this-&gt;ReadMeta(ev, '}');</span>
<a href="#l47.565"></a><span id="l47.565">             break;</span>
<a href="#l47.566"></a><span id="l47.566" class="difflineminus">-          </span>
<a href="#l47.567"></a><span id="l47.567" class="difflineplus">+</span>
<a href="#l47.568"></a><span id="l47.568">           // case '+': // plus</span>
<a href="#l47.569"></a><span id="l47.569">           //   mParser_RowChange = morkChange_kAdd;</span>
<a href="#l47.570"></a><span id="l47.570">           //   break;</span>
<a href="#l47.571"></a><span id="l47.571" class="difflineminus">-            </span>
<a href="#l47.572"></a><span id="l47.572" class="difflineplus">+</span>
<a href="#l47.573"></a><span id="l47.573">           case '-': // minus</span>
<a href="#l47.574"></a><span id="l47.574">             // mParser_RowChange = morkChange_kCut;</span>
<a href="#l47.575"></a><span id="l47.575">             this-&gt;OnMinusRow(ev);</span>
<a href="#l47.576"></a><span id="l47.576">             break;</span>
<a href="#l47.577"></a><span id="l47.577" class="difflineminus">-            </span>
<a href="#l47.578"></a><span id="l47.578" class="difflineplus">+</span>
<a href="#l47.579"></a><span id="l47.579">           // case '!': // bang</span>
<a href="#l47.580"></a><span id="l47.580">           //   mParser_RowChange = morkChange_kSet;</span>
<a href="#l47.581"></a><span id="l47.581">           //   break;</span>
<a href="#l47.582"></a><span id="l47.582" class="difflineminus">-            </span>
<a href="#l47.583"></a><span id="l47.583" class="difflineplus">+</span>
<a href="#l47.584"></a><span id="l47.584">           default:</span>
<a href="#l47.585"></a><span id="l47.585">             ev-&gt;NewWarning(&quot;unexpected byte in table&quot;);</span>
<a href="#l47.586"></a><span id="l47.586">             break;</span>
<a href="#l47.587"></a><span id="l47.587">         }</span>
<a href="#l47.588"></a><span id="l47.588">       }</span>
<a href="#l47.589"></a><span id="l47.589">     }</span>
<a href="#l47.590"></a><span id="l47.590"> </span>
<a href="#l47.591"></a><span id="l47.591">     // this-&gt;EndSpanOnThisByte(ev, &amp;mParser_TableSpan);</span>
<a href="#l47.592"></a><span id="l47.592" class="difflineat">@@ -789,17 +789,17 @@ void morkParser::ReadTable(morkEnv* ev)</span>
<a href="#l47.593"></a><span id="l47.593"> mork_id morkParser::ReadHex(morkEnv* ev, int* outNextChar)</span>
<a href="#l47.594"></a><span id="l47.594"> // zm:Hex   ::= [0-9a-fA-F] /* a single hex digit */</span>
<a href="#l47.595"></a><span id="l47.595"> // zm:Hex+  ::= zm:Hex | zm:Hex zm:Hex+</span>
<a href="#l47.596"></a><span id="l47.596"> {</span>
<a href="#l47.597"></a><span id="l47.597">   mork_id hex = 0;</span>
<a href="#l47.598"></a><span id="l47.598"> </span>
<a href="#l47.599"></a><span id="l47.599">   morkStream* s = mParser_Stream;</span>
<a href="#l47.600"></a><span id="l47.600">   int c = this-&gt;NextChar(ev);</span>
<a href="#l47.601"></a><span id="l47.601" class="difflineminus">-    </span>
<a href="#l47.602"></a><span id="l47.602" class="difflineplus">+</span>
<a href="#l47.603"></a><span id="l47.603">   if ( ev-&gt;Good() )</span>
<a href="#l47.604"></a><span id="l47.604">   {</span>
<a href="#l47.605"></a><span id="l47.605">     if ( c != EOF )</span>
<a href="#l47.606"></a><span id="l47.606">     {</span>
<a href="#l47.607"></a><span id="l47.607">       if ( morkCh_IsHex(c) )</span>
<a href="#l47.608"></a><span id="l47.608">       {</span>
<a href="#l47.609"></a><span id="l47.609">         do</span>
<a href="#l47.610"></a><span id="l47.610">         {</span>
<a href="#l47.611"></a><span id="l47.611" class="difflineat">@@ -815,17 +815,17 @@ mork_id morkParser::ReadHex(morkEnv* ev,</span>
<a href="#l47.612"></a><span id="l47.612">         while ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; ev-&gt;Good() &amp;&amp; morkCh_IsHex(c) );</span>
<a href="#l47.613"></a><span id="l47.613">       }</span>
<a href="#l47.614"></a><span id="l47.614">       else</span>
<a href="#l47.615"></a><span id="l47.615">         this-&gt;ExpectedHexDigitError(ev, c);</span>
<a href="#l47.616"></a><span id="l47.616">     }</span>
<a href="#l47.617"></a><span id="l47.617">   }</span>
<a href="#l47.618"></a><span id="l47.618">   if ( c == EOF )</span>
<a href="#l47.619"></a><span id="l47.619">     this-&gt;EofInsteadOfHexError(ev);</span>
<a href="#l47.620"></a><span id="l47.620" class="difflineminus">-    </span>
<a href="#l47.621"></a><span id="l47.621" class="difflineplus">+</span>
<a href="#l47.622"></a><span id="l47.622">   *outNextChar = c;</span>
<a href="#l47.623"></a><span id="l47.623">   return hex;</span>
<a href="#l47.624"></a><span id="l47.624"> }</span>
<a href="#l47.625"></a><span id="l47.625"> </span>
<a href="#l47.626"></a><span id="l47.626"> /*static*/ void</span>
<a href="#l47.627"></a><span id="l47.627"> morkParser::EofInsteadOfHexError(morkEnv* ev)</span>
<a href="#l47.628"></a><span id="l47.628"> {</span>
<a href="#l47.629"></a><span id="l47.629">   ev-&gt;NewWarning(&quot;eof instead of hex&quot;);</span>
<a href="#l47.630"></a><span id="l47.630" class="difflineat">@@ -855,24 +855,24 @@ morkBuf* morkParser::ReadValue(morkEnv* </span>
<a href="#l47.631"></a><span id="l47.631"> {</span>
<a href="#l47.632"></a><span id="l47.632">   morkBuf* outBuf = 0;</span>
<a href="#l47.633"></a><span id="l47.633"> </span>
<a href="#l47.634"></a><span id="l47.634">   morkCoil* coil = &amp;mParser_ValueCoil;</span>
<a href="#l47.635"></a><span id="l47.635">   coil-&gt;ClearBufFill();</span>
<a href="#l47.636"></a><span id="l47.636"> </span>
<a href="#l47.637"></a><span id="l47.637">   morkSpool* spool = &amp;mParser_ValueSpool;</span>
<a href="#l47.638"></a><span id="l47.638">   spool-&gt;Seek(ev, /*pos*/ 0);</span>
<a href="#l47.639"></a><span id="l47.639" class="difflineminus">-  </span>
<a href="#l47.640"></a><span id="l47.640" class="difflineplus">+</span>
<a href="#l47.641"></a><span id="l47.641">   if ( ev-&gt;Good() )</span>
<a href="#l47.642"></a><span id="l47.642">   {</span>
<a href="#l47.643"></a><span id="l47.643">     morkStream* s = mParser_Stream;</span>
<a href="#l47.644"></a><span id="l47.644">     int c;</span>
<a href="#l47.645"></a><span id="l47.645">     while ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; c != ')' &amp;&amp; ev-&gt;Good() )</span>
<a href="#l47.646"></a><span id="l47.646">     {</span>
<a href="#l47.647"></a><span id="l47.647" class="difflineminus">-      if ( c == '\\' ) // next char is escaped by '\'? </span>
<a href="#l47.648"></a><span id="l47.648" class="difflineplus">+      if ( c == '\\' ) // next char is escaped by '\'?</span>
<a href="#l47.649"></a><span id="l47.649">       {</span>
<a href="#l47.650"></a><span id="l47.650">         if ( (c = s-&gt;Getc(ev)) == 0xA || c == 0xD ) // linebreak after \?</span>
<a href="#l47.651"></a><span id="l47.651">         {</span>
<a href="#l47.652"></a><span id="l47.652">           c = this-&gt;eat_line_break(ev, c);</span>
<a href="#l47.653"></a><span id="l47.653">           if ( c == ')' || c == '\\' || c == '$' )</span>
<a href="#l47.654"></a><span id="l47.654">           {</span>
<a href="#l47.655"></a><span id="l47.655">             s-&gt;Ungetc(c); // just let while loop test read this again</span>
<a href="#l47.656"></a><span id="l47.656">             continue; // goto next iteration of while loop</span>
<a href="#l47.657"></a><span id="l47.657" class="difflineat">@@ -894,29 +894,29 @@ morkBuf* morkParser::ReadValue(morkEnv* </span>
<a href="#l47.658"></a><span id="l47.658">           else</span>
<a href="#l47.659"></a><span id="l47.659">             break; // end while loop</span>
<a href="#l47.660"></a><span id="l47.660">         }</span>
<a href="#l47.661"></a><span id="l47.661">         else</span>
<a href="#l47.662"></a><span id="l47.662">           break; // end while loop</span>
<a href="#l47.663"></a><span id="l47.663">       }</span>
<a href="#l47.664"></a><span id="l47.664">       spool-&gt;Putc(ev, c);</span>
<a href="#l47.665"></a><span id="l47.665">     }</span>
<a href="#l47.666"></a><span id="l47.666" class="difflineminus">-      </span>
<a href="#l47.667"></a><span id="l47.667" class="difflineplus">+</span>
<a href="#l47.668"></a><span id="l47.668">     if ( ev-&gt;Good() )</span>
<a href="#l47.669"></a><span id="l47.669">     {</span>
<a href="#l47.670"></a><span id="l47.670">       if ( c != EOF )</span>
<a href="#l47.671"></a><span id="l47.671">         spool-&gt;FlushSink(ev); // update coil-&gt;mBuf_Fill</span>
<a href="#l47.672"></a><span id="l47.672">       else</span>
<a href="#l47.673"></a><span id="l47.673">         this-&gt;UnexpectedEofError(ev);</span>
<a href="#l47.674"></a><span id="l47.674" class="difflineminus">-        </span>
<a href="#l47.675"></a><span id="l47.675" class="difflineplus">+</span>
<a href="#l47.676"></a><span id="l47.676">       if ( ev-&gt;Good() )</span>
<a href="#l47.677"></a><span id="l47.677">         outBuf = coil;</span>
<a href="#l47.678"></a><span id="l47.678">     }</span>
<a href="#l47.679"></a><span id="l47.679">   }</span>
<a href="#l47.680"></a><span id="l47.680" class="difflineminus">-  return outBuf; </span>
<a href="#l47.681"></a><span id="l47.681" class="difflineplus">+  return outBuf;</span>
<a href="#l47.682"></a><span id="l47.682"> }</span>
<a href="#l47.683"></a><span id="l47.683"> </span>
<a href="#l47.684"></a><span id="l47.684"> void morkParser::ReadDictForm(morkEnv *ev)</span>
<a href="#l47.685"></a><span id="l47.685"> {</span>
<a href="#l47.686"></a><span id="l47.686">   int nextChar;</span>
<a href="#l47.687"></a><span id="l47.687">   nextChar = this-&gt;NextChar(ev);</span>
<a href="#l47.688"></a><span id="l47.688">   if (nextChar == '(')</span>
<a href="#l47.689"></a><span id="l47.689">   {</span>
<a href="#l47.690"></a><span id="l47.690" class="difflineat">@@ -1037,45 +1037,45 @@ void morkParser::ReadMeta(morkEnv* ev, i</span>
<a href="#l47.691"></a><span id="l47.691">   int c;</span>
<a href="#l47.692"></a><span id="l47.692">   while ( more &amp;&amp; (c = this-&gt;NextChar(ev)) != EOF &amp;&amp; ev-&gt;Good() )</span>
<a href="#l47.693"></a><span id="l47.693">   {</span>
<a href="#l47.694"></a><span id="l47.694">     switch ( c )</span>
<a href="#l47.695"></a><span id="l47.695">     {</span>
<a href="#l47.696"></a><span id="l47.696">       case '(': // cell</span>
<a href="#l47.697"></a><span id="l47.697">         this-&gt;ReadCell(ev);</span>
<a href="#l47.698"></a><span id="l47.698">         break;</span>
<a href="#l47.699"></a><span id="l47.699" class="difflineminus">-        </span>
<a href="#l47.700"></a><span id="l47.700" class="difflineplus">+</span>
<a href="#l47.701"></a><span id="l47.701">       case '&gt;': // maybe end meta?</span>
<a href="#l47.702"></a><span id="l47.702">         if ( inEndMeta == '&gt;' )</span>
<a href="#l47.703"></a><span id="l47.703">           more = morkBool_kFalse; // stop reading meta</span>
<a href="#l47.704"></a><span id="l47.704">         else</span>
<a href="#l47.705"></a><span id="l47.705">           this-&gt;UnexpectedByteInMetaWarning(ev);</span>
<a href="#l47.706"></a><span id="l47.706">         break;</span>
<a href="#l47.707"></a><span id="l47.707" class="difflineminus">-        </span>
<a href="#l47.708"></a><span id="l47.708" class="difflineplus">+</span>
<a href="#l47.709"></a><span id="l47.709">       case '}': // maybe end meta?</span>
<a href="#l47.710"></a><span id="l47.710">         if ( inEndMeta == '}' )</span>
<a href="#l47.711"></a><span id="l47.711">           more = morkBool_kFalse; // stop reading meta</span>
<a href="#l47.712"></a><span id="l47.712">         else</span>
<a href="#l47.713"></a><span id="l47.713">           this-&gt;UnexpectedByteInMetaWarning(ev);</span>
<a href="#l47.714"></a><span id="l47.714">         break;</span>
<a href="#l47.715"></a><span id="l47.715" class="difflineminus">-        </span>
<a href="#l47.716"></a><span id="l47.716" class="difflineplus">+</span>
<a href="#l47.717"></a><span id="l47.717">       case ']': // maybe end meta?</span>
<a href="#l47.718"></a><span id="l47.718">         if ( inEndMeta == ']' )</span>
<a href="#l47.719"></a><span id="l47.719">           more = morkBool_kFalse; // stop reading meta</span>
<a href="#l47.720"></a><span id="l47.720">         else</span>
<a href="#l47.721"></a><span id="l47.721">           this-&gt;UnexpectedByteInMetaWarning(ev);</span>
<a href="#l47.722"></a><span id="l47.722">         break;</span>
<a href="#l47.723"></a><span id="l47.723" class="difflineminus">-        </span>
<a href="#l47.724"></a><span id="l47.724" class="difflineplus">+</span>
<a href="#l47.725"></a><span id="l47.725">       case '[': // maybe table meta row?</span>
<a href="#l47.726"></a><span id="l47.726">         if ( mParser_InTable )</span>
<a href="#l47.727"></a><span id="l47.727" class="difflineminus">-          this-&gt;ReadRow(ev, '['); </span>
<a href="#l47.728"></a><span id="l47.728" class="difflineplus">+          this-&gt;ReadRow(ev, '[');</span>
<a href="#l47.729"></a><span id="l47.729">         else</span>
<a href="#l47.730"></a><span id="l47.730">           this-&gt;UnexpectedByteInMetaWarning(ev);</span>
<a href="#l47.731"></a><span id="l47.731">         break;</span>
<a href="#l47.732"></a><span id="l47.732" class="difflineminus">-        </span>
<a href="#l47.733"></a><span id="l47.733" class="difflineplus">+</span>
<a href="#l47.734"></a><span id="l47.734">       default:</span>
<a href="#l47.735"></a><span id="l47.735">         if ( mParser_InTable &amp;&amp; morkCh_IsHex(c) )</span>
<a href="#l47.736"></a><span id="l47.736">           this-&gt;ReadRow(ev, c);</span>
<a href="#l47.737"></a><span id="l47.737">         else</span>
<a href="#l47.738"></a><span id="l47.738">           this-&gt;UnexpectedByteInMetaWarning(ev);</span>
<a href="#l47.739"></a><span id="l47.739">         break;</span>
<a href="#l47.740"></a><span id="l47.740">     }</span>
<a href="#l47.741"></a><span id="l47.741">   }</span>
<a href="#l47.742"></a><span id="l47.742" class="difflineat">@@ -1112,23 +1112,23 @@ mork_bool morkParser::MatchPattern(morkE</span>
<a href="#l47.743"></a><span id="l47.743">     }</span>
<a href="#l47.744"></a><span id="l47.744">   }</span>
<a href="#l47.745"></a><span id="l47.745">   return ev-&gt;Good();</span>
<a href="#l47.746"></a><span id="l47.746"> }</span>
<a href="#l47.747"></a><span id="l47.747"> </span>
<a href="#l47.748"></a><span id="l47.748"> mork_bool morkParser::FindGroupEnd(morkEnv* ev)</span>
<a href="#l47.749"></a><span id="l47.749"> {</span>
<a href="#l47.750"></a><span id="l47.750">   mork_bool foundEnd = morkBool_kFalse;</span>
<a href="#l47.751"></a><span id="l47.751" class="difflineminus">-  </span>
<a href="#l47.752"></a><span id="l47.752" class="difflineplus">+</span>
<a href="#l47.753"></a><span id="l47.753">   // char gidBuf[ 64 ]; // to hold hex pattern we want</span>
<a href="#l47.754"></a><span id="l47.754">   // (void) ev-&gt;TokenAsHex(gidBuf, mParser_GroupId);</span>
<a href="#l47.755"></a><span id="l47.755" class="difflineminus">-  </span>
<a href="#l47.756"></a><span id="l47.756" class="difflineplus">+</span>
<a href="#l47.757"></a><span id="l47.757">   morkStream* s = mParser_Stream;</span>
<a href="#l47.758"></a><span id="l47.758">   int c;</span>
<a href="#l47.759"></a><span id="l47.759" class="difflineminus">-  </span>
<a href="#l47.760"></a><span id="l47.760" class="difflineplus">+</span>
<a href="#l47.761"></a><span id="l47.761">   while ( (c = s-&gt;Getc(ev)) != EOF &amp;&amp; ev-&gt;Good() &amp;&amp; !foundEnd )</span>
<a href="#l47.762"></a><span id="l47.762">   {</span>
<a href="#l47.763"></a><span id="l47.763">     if ( c == '@' ) // maybe start of group ending?</span>
<a href="#l47.764"></a><span id="l47.764">     {</span>
<a href="#l47.765"></a><span id="l47.765">       // this-&gt;EndSpanOnThisByte(ev, &amp;mParser_GroupSpan);</span>
<a href="#l47.766"></a><span id="l47.766">       if ( (c = s-&gt;Getc(ev)) == '$' ) // '$' follows '@' ?</span>
<a href="#l47.767"></a><span id="l47.767">       {</span>
<a href="#l47.768"></a><span id="l47.768">         if ( (c = s-&gt;Getc(ev)) == '$' ) // '$' follows &quot;@$&quot; ?</span>
<a href="#l47.769"></a><span id="l47.769" class="difflineat">@@ -1165,38 +1165,38 @@ void morkParser::ReadGroup(morkEnv* mev)</span>
<a href="#l47.770"></a><span id="l47.770">     	// we really need the following span inside morkBuilder::OnNewGroup():</span>
<a href="#l47.771"></a><span id="l47.771">       this-&gt;StartSpanOnThisByte(mev, &amp;mParser_GroupSpan);</span>
<a href="#l47.772"></a><span id="l47.772">       mork_pos startPos = mParser_GroupSpan.mSpan_Start.mPlace_Pos;</span>
<a href="#l47.773"></a><span id="l47.773"> </span>
<a href="#l47.774"></a><span id="l47.774">       // if ( !store-&gt;mStore_FirstCommitGroupPos )</span>
<a href="#l47.775"></a><span id="l47.775">       //   store-&gt;mStore_FirstCommitGroupPos = startPos;</span>
<a href="#l47.776"></a><span id="l47.776">       // else if ( !store-&gt;mStore_SecondCommitGroupPos )</span>
<a href="#l47.777"></a><span id="l47.777">       //   store-&gt;mStore_SecondCommitGroupPos = startPos;</span>
<a href="#l47.778"></a><span id="l47.778" class="difflineminus">-      </span>
<a href="#l47.779"></a><span id="l47.779" class="difflineplus">+</span>
<a href="#l47.780"></a><span id="l47.780">       if ( this-&gt;FindGroupEnd(mev) )</span>
<a href="#l47.781"></a><span id="l47.781">       {</span>
<a href="#l47.782"></a><span id="l47.782">         mork_pos outPos;</span>
<a href="#l47.783"></a><span id="l47.783">         s-&gt;Seek(ev, startPos, &amp;outPos);</span>
<a href="#l47.784"></a><span id="l47.784">         if ( mev-&gt;Good() )</span>
<a href="#l47.785"></a><span id="l47.785">         {</span>
<a href="#l47.786"></a><span id="l47.786">           this-&gt;OnNewGroup(mev, mParser_GroupSpan.mSpan_Start,</span>
<a href="#l47.787"></a><span id="l47.787">             mParser_GroupId);</span>
<a href="#l47.788"></a><span id="l47.788" class="difflineminus">-          </span>
<a href="#l47.789"></a><span id="l47.789" class="difflineplus">+</span>
<a href="#l47.790"></a><span id="l47.790">           this-&gt;ReadContent(mev, /*inInsideGroup*/ morkBool_kTrue);</span>
<a href="#l47.791"></a><span id="l47.791"> </span>
<a href="#l47.792"></a><span id="l47.792">           this-&gt;OnGroupCommitEnd(mev, mParser_GroupSpan);</span>
<a href="#l47.793"></a><span id="l47.793">         }</span>
<a href="#l47.794"></a><span id="l47.794">       }</span>
<a href="#l47.795"></a><span id="l47.795">     }</span>
<a href="#l47.796"></a><span id="l47.796">     else</span>
<a href="#l47.797"></a><span id="l47.797">       mev-&gt;NewError(&quot;expected '@' after @$${id{&quot;);</span>
<a href="#l47.798"></a><span id="l47.798">   }</span>
<a href="#l47.799"></a><span id="l47.799">   else</span>
<a href="#l47.800"></a><span id="l47.800">     mev-&gt;NewError(&quot;expected '{' after @$$id&quot;);</span>
<a href="#l47.801"></a><span id="l47.801" class="difflineminus">-    </span>
<a href="#l47.802"></a><span id="l47.802" class="difflineplus">+</span>
<a href="#l47.803"></a><span id="l47.803"> }</span>
<a href="#l47.804"></a><span id="l47.804"> </span>
<a href="#l47.805"></a><span id="l47.805"> mork_bool morkParser::ReadAt(morkEnv* ev, mork_bool inInsideGroup)</span>
<a href="#l47.806"></a><span id="l47.806"> /* groups must be ignored until properly terminated */</span>
<a href="#l47.807"></a><span id="l47.807"> // zm:Group       ::= zm:GroupStart zm:Content zm:GroupEnd /* transaction */</span>
<a href="#l47.808"></a><span id="l47.808"> // zm:GroupStart  ::= zm:S? '@$${' zm:Hex+ '{@' /* xaction id has own space */</span>
<a href="#l47.809"></a><span id="l47.809"> // zm:GroupEnd    ::= zm:GroupCommit | zm:GroupAbort</span>
<a href="#l47.810"></a><span id="l47.810"> // zm:GroupCommit ::= zm:S? '@$$}' zm:Hex+ '}@'  /* id matches start id */</span>
<a href="#l47.811"></a><span id="l47.811" class="difflineat">@@ -1280,44 +1280,44 @@ mork_bool morkParser::ReadEndGroupId(mor</span>
<a href="#l47.812"></a><span id="l47.812"> void morkParser::ReadDict(morkEnv* ev)</span>
<a href="#l47.813"></a><span id="l47.813"> // zm:Dict      ::= zm:S? '&lt;' zm:DictItem* zm:S? '&gt;'</span>
<a href="#l47.814"></a><span id="l47.814"> // zm:DictItem  ::= zm:MetaDict | zm:Alias</span>
<a href="#l47.815"></a><span id="l47.815"> // zm:MetaDict  ::= zm:S? '&lt;' zm:S? zm:Cell* zm:S? '&gt;' /* meta attributes */</span>
<a href="#l47.816"></a><span id="l47.816"> // zm:Alias     ::= zm:S? '(' ('#')? zm:Hex+ zm:S? zm:Value ')'</span>
<a href="#l47.817"></a><span id="l47.817"> {</span>
<a href="#l47.818"></a><span id="l47.818">   mParser_Change = morkChange_kNil;</span>
<a href="#l47.819"></a><span id="l47.819">   mParser_AtomChange = morkChange_kNil;</span>
<a href="#l47.820"></a><span id="l47.820" class="difflineminus">-  </span>
<a href="#l47.821"></a><span id="l47.821" class="difflineplus">+</span>
<a href="#l47.822"></a><span id="l47.822">   // this-&gt;StartSpanOnLastByte(ev, &amp;mParser_DictSpan);</span>
<a href="#l47.823"></a><span id="l47.823">   mParser_InDict = morkBool_kTrue;</span>
<a href="#l47.824"></a><span id="l47.824">   this-&gt;OnNewDict(ev, *mParser_DictSpan.AsPlace());</span>
<a href="#l47.825"></a><span id="l47.825" class="difflineminus">-  </span>
<a href="#l47.826"></a><span id="l47.826" class="difflineplus">+</span>
<a href="#l47.827"></a><span id="l47.827">   int c;</span>
<a href="#l47.828"></a><span id="l47.828">   while ( (c = this-&gt;NextChar(ev)) != EOF &amp;&amp; ev-&gt;Good() &amp;&amp; c != '&gt;' )</span>
<a href="#l47.829"></a><span id="l47.829">   {</span>
<a href="#l47.830"></a><span id="l47.830">     switch ( c )</span>
<a href="#l47.831"></a><span id="l47.831">     {</span>
<a href="#l47.832"></a><span id="l47.832">       case '(': // alias</span>
<a href="#l47.833"></a><span id="l47.833">         this-&gt;ReadAlias(ev);</span>
<a href="#l47.834"></a><span id="l47.834">         break;</span>
<a href="#l47.835"></a><span id="l47.835" class="difflineminus">-        </span>
<a href="#l47.836"></a><span id="l47.836" class="difflineplus">+</span>
<a href="#l47.837"></a><span id="l47.837">       case '&lt;': // meta</span>
<a href="#l47.838"></a><span id="l47.838">         this-&gt;ReadMeta(ev, '&gt;');</span>
<a href="#l47.839"></a><span id="l47.839">         break;</span>
<a href="#l47.840"></a><span id="l47.840" class="difflineminus">-        </span>
<a href="#l47.841"></a><span id="l47.841" class="difflineplus">+</span>
<a href="#l47.842"></a><span id="l47.842">       default:</span>
<a href="#l47.843"></a><span id="l47.843">         ev-&gt;NewWarning(&quot;unexpected byte in dict&quot;);</span>
<a href="#l47.844"></a><span id="l47.844">         break;</span>
<a href="#l47.845"></a><span id="l47.845">     }</span>
<a href="#l47.846"></a><span id="l47.846">   }</span>
<a href="#l47.847"></a><span id="l47.847"> </span>
<a href="#l47.848"></a><span id="l47.848">   // this-&gt;EndSpanOnThisByte(ev, &amp;mParser_DictSpan);</span>
<a href="#l47.849"></a><span id="l47.849">   mParser_InDict = morkBool_kFalse;</span>
<a href="#l47.850"></a><span id="l47.850">   this-&gt;OnDictEnd(ev, mParser_DictSpan);</span>
<a href="#l47.851"></a><span id="l47.851" class="difflineminus">-  </span>
<a href="#l47.852"></a><span id="l47.852" class="difflineplus">+</span>
<a href="#l47.853"></a><span id="l47.853">   if ( ev-&gt;Bad() )</span>
<a href="#l47.854"></a><span id="l47.854">     mParser_State = morkParser_kBrokenState;</span>
<a href="#l47.855"></a><span id="l47.855">   else if ( c == EOF )</span>
<a href="#l47.856"></a><span id="l47.856">     mParser_State = morkParser_kDoneState;</span>
<a href="#l47.857"></a><span id="l47.857"> }</span>
<a href="#l47.858"></a><span id="l47.858"> </span>
<a href="#l47.859"></a><span id="l47.859"> void morkParser::EndSpanOnThisByte(morkEnv* mev, morkSpan* ioSpan)</span>
<a href="#l47.860"></a><span id="l47.860"> {</span>
<a href="#l47.861"></a><span id="l47.861" class="difflineat">@@ -1387,53 +1387,53 @@ morkParser::ReadContent(morkEnv* ev, mor</span>
<a href="#l47.862"></a><span id="l47.862">   while ( keep_going &amp;&amp; (c = this-&gt;NextChar(ev)) != EOF &amp;&amp; ev-&gt;Good())</span>
<a href="#l47.863"></a><span id="l47.863">   {</span>
<a href="#l47.864"></a><span id="l47.864">     switch ( c )</span>
<a href="#l47.865"></a><span id="l47.865">     {</span>
<a href="#l47.866"></a><span id="l47.866">       case '[': // row</span>
<a href="#l47.867"></a><span id="l47.867">         this-&gt;ReadRow(ev, '[');</span>
<a href="#l47.868"></a><span id="l47.868">         keep_going = false;</span>
<a href="#l47.869"></a><span id="l47.869">         break;</span>
<a href="#l47.870"></a><span id="l47.870" class="difflineminus">-        </span>
<a href="#l47.871"></a><span id="l47.871" class="difflineplus">+</span>
<a href="#l47.872"></a><span id="l47.872">       case '{': // table</span>
<a href="#l47.873"></a><span id="l47.873">         this-&gt;ReadTable(ev);</span>
<a href="#l47.874"></a><span id="l47.874">         keep_going = false;</span>
<a href="#l47.875"></a><span id="l47.875">         break;</span>
<a href="#l47.876"></a><span id="l47.876" class="difflineminus">-        </span>
<a href="#l47.877"></a><span id="l47.877" class="difflineplus">+</span>
<a href="#l47.878"></a><span id="l47.878">       case '&lt;': // dict</span>
<a href="#l47.879"></a><span id="l47.879">         this-&gt;ReadDict(ev);</span>
<a href="#l47.880"></a><span id="l47.880">         keep_going = false;</span>
<a href="#l47.881"></a><span id="l47.881">         break;</span>
<a href="#l47.882"></a><span id="l47.882" class="difflineminus">-        </span>
<a href="#l47.883"></a><span id="l47.883" class="difflineplus">+</span>
<a href="#l47.884"></a><span id="l47.884">       case '@': // group</span>
<a href="#l47.885"></a><span id="l47.885">         return this-&gt;ReadAt(ev, inInsideGroup);</span>
<a href="#l47.886"></a><span id="l47.886">         // break;</span>
<a href="#l47.887"></a><span id="l47.887" class="difflineminus">-        </span>
<a href="#l47.888"></a><span id="l47.888" class="difflineplus">+</span>
<a href="#l47.889"></a><span id="l47.889">       // case '+': // plus</span>
<a href="#l47.890"></a><span id="l47.890">       //   mParser_Change = morkChange_kAdd;</span>
<a href="#l47.891"></a><span id="l47.891">       //   break;</span>
<a href="#l47.892"></a><span id="l47.892" class="difflineminus">-        </span>
<a href="#l47.893"></a><span id="l47.893" class="difflineplus">+</span>
<a href="#l47.894"></a><span id="l47.894">       // case '-': // minus</span>
<a href="#l47.895"></a><span id="l47.895">       //   mParser_Change = morkChange_kCut;</span>
<a href="#l47.896"></a><span id="l47.896">       //   break;</span>
<a href="#l47.897"></a><span id="l47.897" class="difflineminus">-        </span>
<a href="#l47.898"></a><span id="l47.898" class="difflineplus">+</span>
<a href="#l47.899"></a><span id="l47.899">       // case '!': // bang</span>
<a href="#l47.900"></a><span id="l47.900">       //   mParser_Change = morkChange_kSet;</span>
<a href="#l47.901"></a><span id="l47.901">       //   break;</span>
<a href="#l47.902"></a><span id="l47.902" class="difflineminus">-        </span>
<a href="#l47.903"></a><span id="l47.903" class="difflineplus">+</span>
<a href="#l47.904"></a><span id="l47.904">       default:</span>
<a href="#l47.905"></a><span id="l47.905">         ev-&gt;NewWarning(&quot;unexpected byte in ReadContent()&quot;);</span>
<a href="#l47.906"></a><span id="l47.906">         break;</span>
<a href="#l47.907"></a><span id="l47.907">     }</span>
<a href="#l47.908"></a><span id="l47.908">   }</span>
<a href="#l47.909"></a><span id="l47.909">   if ( ev-&gt;Bad() )</span>
<a href="#l47.910"></a><span id="l47.910">     mParser_State = morkParser_kBrokenState;</span>
<a href="#l47.911"></a><span id="l47.911">   else if ( c == EOF )</span>
<a href="#l47.912"></a><span id="l47.912">     mParser_State = morkParser_kDoneState;</span>
<a href="#l47.913"></a><span id="l47.913" class="difflineminus">-    </span>
<a href="#l47.914"></a><span id="l47.914" class="difflineplus">+</span>
<a href="#l47.915"></a><span id="l47.915">   return ( ev-&gt;Good() &amp;&amp; c != EOF );</span>
<a href="#l47.916"></a><span id="l47.916"> }</span>
<a href="#l47.917"></a><span id="l47.917"> </span>
<a href="#l47.918"></a><span id="l47.918"> void</span>
<a href="#l47.919"></a><span id="l47.919"> morkParser::OnPortState(morkEnv* ev)</span>
<a href="#l47.920"></a><span id="l47.920"> {</span>
<a href="#l47.921"></a><span id="l47.921">   mork_bool firstTime = !mParser_InPort;</span>
<a href="#l47.922"></a><span id="l47.922">   mParser_InPort = morkBool_kTrue;</span>
<a href="#l47.923"></a><span id="l47.923" class="difflineat">@@ -1442,17 +1442,17 @@ morkParser::OnPortState(morkEnv* ev)</span>
<a href="#l47.924"></a><span id="l47.924"> </span>
<a href="#l47.925"></a><span id="l47.925">   mork_bool done = !this-&gt;ReadContent(ev, mParser_InGroup/*inInsideGroup*/);</span>
<a href="#l47.926"></a><span id="l47.926"> </span>
<a href="#l47.927"></a><span id="l47.927">   if (done)</span>
<a href="#l47.928"></a><span id="l47.928">   {</span>
<a href="#l47.929"></a><span id="l47.929">     mParser_InPort = morkBool_kFalse;</span>
<a href="#l47.930"></a><span id="l47.930">     this-&gt;OnPortEnd(ev, mParser_PortSpan);</span>
<a href="#l47.931"></a><span id="l47.931">   }</span>
<a href="#l47.932"></a><span id="l47.932" class="difflineminus">-  </span>
<a href="#l47.933"></a><span id="l47.933" class="difflineplus">+</span>
<a href="#l47.934"></a><span id="l47.934">   if ( ev-&gt;Bad() )</span>
<a href="#l47.935"></a><span id="l47.935">     mParser_State = morkParser_kBrokenState;</span>
<a href="#l47.936"></a><span id="l47.936"> }</span>
<a href="#l47.937"></a><span id="l47.937"> </span>
<a href="#l47.938"></a><span id="l47.938"> void</span>
<a href="#l47.939"></a><span id="l47.939"> morkParser::OnStartState(morkEnv* mev)</span>
<a href="#l47.940"></a><span id="l47.940"> {</span>
<a href="#l47.941"></a><span id="l47.941">   morkStream* s = mParser_Stream;</span>
<a href="#l47.942"></a><span id="l47.942" class="difflineat">@@ -1474,85 +1474,85 @@ morkParser::OnStartState(morkEnv* mev)</span>
<a href="#l47.943"></a><span id="l47.943">     mParser_State = morkParser_kBrokenState;</span>
<a href="#l47.944"></a><span id="l47.944"> }</span>
<a href="#l47.945"></a><span id="l47.945"> </span>
<a href="#l47.946"></a><span id="l47.946"> /*protected non-poly*/ void</span>
<a href="#l47.947"></a><span id="l47.947"> morkParser::ParseChunk(morkEnv* ev)</span>
<a href="#l47.948"></a><span id="l47.948"> {</span>
<a href="#l47.949"></a><span id="l47.949">   mParser_Change = morkChange_kNil;</span>
<a href="#l47.950"></a><span id="l47.950">   mParser_DoMore = morkBool_kTrue;</span>
<a href="#l47.951"></a><span id="l47.951" class="difflineminus">-            </span>
<a href="#l47.952"></a><span id="l47.952" class="difflineplus">+</span>
<a href="#l47.953"></a><span id="l47.953">   switch ( mParser_State )</span>
<a href="#l47.954"></a><span id="l47.954">   {</span>
<a href="#l47.955"></a><span id="l47.955">     case morkParser_kCellState: // 0</span>
<a href="#l47.956"></a><span id="l47.956">       this-&gt;OnCellState(ev); break;</span>
<a href="#l47.957"></a><span id="l47.957" class="difflineminus">-      </span>
<a href="#l47.958"></a><span id="l47.958" class="difflineplus">+</span>
<a href="#l47.959"></a><span id="l47.959">     case morkParser_kMetaState: // 1</span>
<a href="#l47.960"></a><span id="l47.960">       this-&gt;OnMetaState(ev); break;</span>
<a href="#l47.961"></a><span id="l47.961" class="difflineminus">-      </span>
<a href="#l47.962"></a><span id="l47.962" class="difflineplus">+</span>
<a href="#l47.963"></a><span id="l47.963">     case morkParser_kRowState: // 2</span>
<a href="#l47.964"></a><span id="l47.964">       this-&gt;OnRowState(ev); break;</span>
<a href="#l47.965"></a><span id="l47.965" class="difflineminus">-      </span>
<a href="#l47.966"></a><span id="l47.966" class="difflineplus">+</span>
<a href="#l47.967"></a><span id="l47.967">     case morkParser_kTableState: // 3</span>
<a href="#l47.968"></a><span id="l47.968">       this-&gt;OnTableState(ev); break;</span>
<a href="#l47.969"></a><span id="l47.969" class="difflineminus">-      </span>
<a href="#l47.970"></a><span id="l47.970" class="difflineplus">+</span>
<a href="#l47.971"></a><span id="l47.971">     case morkParser_kDictState: // 4</span>
<a href="#l47.972"></a><span id="l47.972">       this-&gt;OnDictState(ev); break;</span>
<a href="#l47.973"></a><span id="l47.973" class="difflineminus">-      </span>
<a href="#l47.974"></a><span id="l47.974" class="difflineplus">+</span>
<a href="#l47.975"></a><span id="l47.975">     case morkParser_kPortState: // 5</span>
<a href="#l47.976"></a><span id="l47.976">       this-&gt;OnPortState(ev); break;</span>
<a href="#l47.977"></a><span id="l47.977" class="difflineminus">-      </span>
<a href="#l47.978"></a><span id="l47.978" class="difflineplus">+</span>
<a href="#l47.979"></a><span id="l47.979">     case morkParser_kStartState: // 6</span>
<a href="#l47.980"></a><span id="l47.980">       this-&gt;OnStartState(ev); break;</span>
<a href="#l47.981"></a><span id="l47.981" class="difflineminus">-     </span>
<a href="#l47.982"></a><span id="l47.982" class="difflineplus">+</span>
<a href="#l47.983"></a><span id="l47.983">     case morkParser_kDoneState: // 7</span>
<a href="#l47.984"></a><span id="l47.984">       mParser_DoMore = morkBool_kFalse;</span>
<a href="#l47.985"></a><span id="l47.985">       mParser_IsDone = morkBool_kTrue;</span>
<a href="#l47.986"></a><span id="l47.986">       this-&gt;StopParse(ev);</span>
<a href="#l47.987"></a><span id="l47.987">       break;</span>
<a href="#l47.988"></a><span id="l47.988">     case morkParser_kBrokenState: // 8</span>
<a href="#l47.989"></a><span id="l47.989">       mParser_DoMore = morkBool_kFalse;</span>
<a href="#l47.990"></a><span id="l47.990">       mParser_IsBroken = morkBool_kTrue;</span>
<a href="#l47.991"></a><span id="l47.991">       this-&gt;StopParse(ev);</span>
<a href="#l47.992"></a><span id="l47.992">       break;</span>
<a href="#l47.993"></a><span id="l47.993">     default: // ?</span>
<a href="#l47.994"></a><span id="l47.994">       MORK_ASSERT(morkBool_kFalse);</span>
<a href="#l47.995"></a><span id="l47.995">       mParser_State = morkParser_kBrokenState;</span>
<a href="#l47.996"></a><span id="l47.996">       break;</span>
<a href="#l47.997"></a><span id="l47.997">   }</span>
<a href="#l47.998"></a><span id="l47.998"> }</span>
<a href="#l47.999"></a><span id="l47.999" class="difflineminus">-    </span>
<a href="#l47.1000"></a><span id="l47.1000" class="difflineplus">+</span>
<a href="#l47.1001"></a><span id="l47.1001"> /*public non-poly*/ mdb_count</span>
<a href="#l47.1002"></a><span id="l47.1002"> morkParser::ParseMore( // return count of bytes consumed now</span>
<a href="#l47.1003"></a><span id="l47.1003">     morkEnv* ev,          // context</span>
<a href="#l47.1004"></a><span id="l47.1004">     mork_pos* outPos,     // current byte pos in the stream afterwards</span>
<a href="#l47.1005"></a><span id="l47.1005">     mork_bool* outDone,   // is parsing finished?</span>
<a href="#l47.1006"></a><span id="l47.1006">     mork_bool* outBroken  // is parsing irreparably dead and broken?</span>
<a href="#l47.1007"></a><span id="l47.1007">   )</span>
<a href="#l47.1008"></a><span id="l47.1008"> {</span>
<a href="#l47.1009"></a><span id="l47.1009">   mdb_count outCount = 0;</span>
<a href="#l47.1010"></a><span id="l47.1010">   if ( this-&gt;IsNode() &amp;&amp; this-&gt;GoodParserTag() &amp;&amp; this-&gt;IsOpenNode() )</span>
<a href="#l47.1011"></a><span id="l47.1011">   {</span>
<a href="#l47.1012"></a><span id="l47.1012">     mork_pos startPos = this-&gt;HerePos();</span>
<a href="#l47.1013"></a><span id="l47.1013"> </span>
<a href="#l47.1014"></a><span id="l47.1014">     if ( !mParser_IsDone &amp;&amp; !mParser_IsBroken )</span>
<a href="#l47.1015"></a><span id="l47.1015">       this-&gt;ParseChunk(ev);</span>
<a href="#l47.1016"></a><span id="l47.1016" class="difflineminus">-  </span>
<a href="#l47.1017"></a><span id="l47.1017" class="difflineplus">+</span>
<a href="#l47.1018"></a><span id="l47.1018">     // HerePos is only updated for groups. I'd like it to be more accurate.</span>
<a href="#l47.1019"></a><span id="l47.1019"> </span>
<a href="#l47.1020"></a><span id="l47.1020">     mork_pos here;</span>
<a href="#l47.1021"></a><span id="l47.1021">     mParser_Stream-&gt;Tell(ev, &amp;here);</span>
<a href="#l47.1022"></a><span id="l47.1022"> </span>
<a href="#l47.1023"></a><span id="l47.1023">     if ( outDone )</span>
<a href="#l47.1024"></a><span id="l47.1024">       *outDone = mParser_IsDone;</span>
<a href="#l47.1025"></a><span id="l47.1025">     if ( outBroken )</span>
<a href="#l47.1026"></a><span id="l47.1026">       *outBroken = mParser_IsBroken;</span>
<a href="#l47.1027"></a><span id="l47.1027">     if ( outPos )</span>
<a href="#l47.1028"></a><span id="l47.1028">       *outPos = here;</span>
<a href="#l47.1029"></a><span id="l47.1029" class="difflineminus">-      </span>
<a href="#l47.1030"></a><span id="l47.1030" class="difflineplus">+</span>
<a href="#l47.1031"></a><span id="l47.1031">     if ( here &gt; startPos )</span>
<a href="#l47.1032"></a><span id="l47.1032">       outCount = (mdb_count) (here - startPos);</span>
<a href="#l47.1033"></a><span id="l47.1033">   }</span>
<a href="#l47.1034"></a><span id="l47.1034">   else</span>
<a href="#l47.1035"></a><span id="l47.1035">   {</span>
<a href="#l47.1036"></a><span id="l47.1036">     this-&gt;NonUsableParserError(ev);</span>
<a href="#l47.1037"></a><span id="l47.1037">     if ( outDone )</span>
<a href="#l47.1038"></a><span id="l47.1038">       *outDone = morkBool_kTrue;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l48.1"></a><span id="l48.1" class="difflineminus">--- a/db/mork/src/morkParser.h</span>
<a href="#l48.2"></a><span id="l48.2" class="difflineplus">+++ b/db/mork/src/morkParser.h</span>
<a href="#l48.3"></a><span id="l48.3" class="difflineat">@@ -22,56 +22,56 @@</span>
<a href="#l48.4"></a><span id="l48.4"> #include &quot;morkYarn.h&quot;</span>
<a href="#l48.5"></a><span id="l48.5"> #endif</span>
<a href="#l48.6"></a><span id="l48.6"> </span>
<a href="#l48.7"></a><span id="l48.7"> #ifndef _MORKCELL_</span>
<a href="#l48.8"></a><span id="l48.8"> #include &quot;morkCell.h&quot;</span>
<a href="#l48.9"></a><span id="l48.9"> #endif</span>
<a href="#l48.10"></a><span id="l48.10"> </span>
<a href="#l48.11"></a><span id="l48.11"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l48.12"></a><span id="l48.12" class="difflineminus">- </span>
<a href="#l48.13"></a><span id="l48.13" class="difflineplus">+</span>
<a href="#l48.14"></a><span id="l48.14"> /*=============================================================================</span>
<a href="#l48.15"></a><span id="l48.15">  * morkPlace: stream byte position and stream line count</span>
<a href="#l48.16"></a><span id="l48.16">  */</span>
<a href="#l48.17"></a><span id="l48.17"> </span>
<a href="#l48.18"></a><span id="l48.18"> class morkPlace {</span>
<a href="#l48.19"></a><span id="l48.19"> public:</span>
<a href="#l48.20"></a><span id="l48.20">   mork_pos   mPlace_Pos;   // byte offset in an input stream</span>
<a href="#l48.21"></a><span id="l48.21">   mork_line  mPlace_Line;  // line count in an input stream</span>
<a href="#l48.22"></a><span id="l48.22" class="difflineminus">-  </span>
<a href="#l48.23"></a><span id="l48.23" class="difflineplus">+</span>
<a href="#l48.24"></a><span id="l48.24">   void ClearPlace()</span>
<a href="#l48.25"></a><span id="l48.25">   {</span>
<a href="#l48.26"></a><span id="l48.26">     mPlace_Pos = 0; mPlace_Line = 0;</span>
<a href="#l48.27"></a><span id="l48.27">   }</span>
<a href="#l48.28"></a><span id="l48.28"> </span>
<a href="#l48.29"></a><span id="l48.29">   void SetPlace(mork_pos inPos, mork_line inLine)</span>
<a href="#l48.30"></a><span id="l48.30">   {</span>
<a href="#l48.31"></a><span id="l48.31">     mPlace_Pos = inPos; mPlace_Line = inLine;</span>
<a href="#l48.32"></a><span id="l48.32">   }</span>
<a href="#l48.33"></a><span id="l48.33"> </span>
<a href="#l48.34"></a><span id="l48.34">   morkPlace() { mPlace_Pos = 0; mPlace_Line = 0; }</span>
<a href="#l48.35"></a><span id="l48.35" class="difflineminus">-  </span>
<a href="#l48.36"></a><span id="l48.36" class="difflineplus">+</span>
<a href="#l48.37"></a><span id="l48.37">   morkPlace(mork_pos inPos, mork_line inLine)</span>
<a href="#l48.38"></a><span id="l48.38">   { mPlace_Pos = inPos; mPlace_Line = inLine; }</span>
<a href="#l48.39"></a><span id="l48.39" class="difflineminus">-  </span>
<a href="#l48.40"></a><span id="l48.40" class="difflineplus">+</span>
<a href="#l48.41"></a><span id="l48.41">   morkPlace(const morkPlace&amp; inPlace)</span>
<a href="#l48.42"></a><span id="l48.42">   : mPlace_Pos(inPlace.mPlace_Pos), mPlace_Line(inPlace.mPlace_Line) { }</span>
<a href="#l48.43"></a><span id="l48.43"> };</span>
<a href="#l48.44"></a><span id="l48.44"> </span>
<a href="#l48.45"></a><span id="l48.45"> /*=============================================================================</span>
<a href="#l48.46"></a><span id="l48.46">  * morkGlitch: stream place and error comment describing a parsing error</span>
<a href="#l48.47"></a><span id="l48.47">  */</span>
<a href="#l48.48"></a><span id="l48.48"> </span>
<a href="#l48.49"></a><span id="l48.49"> class morkGlitch {</span>
<a href="#l48.50"></a><span id="l48.50"> public:</span>
<a href="#l48.51"></a><span id="l48.51">   morkPlace    mGlitch_Place;   // place in stream where problem happened</span>
<a href="#l48.52"></a><span id="l48.52">   const char*  mGlitch_Comment; // null-terminated ASCII C string</span>
<a href="#l48.53"></a><span id="l48.53"> </span>
<a href="#l48.54"></a><span id="l48.54">   morkGlitch() { mGlitch_Comment = 0; }</span>
<a href="#l48.55"></a><span id="l48.55" class="difflineminus">-  </span>
<a href="#l48.56"></a><span id="l48.56" class="difflineplus">+</span>
<a href="#l48.57"></a><span id="l48.57">   morkGlitch(const morkPlace&amp; inPlace, const char* inComment)</span>
<a href="#l48.58"></a><span id="l48.58">   : mGlitch_Place(inPlace), mGlitch_Comment(inComment) { }</span>
<a href="#l48.59"></a><span id="l48.59"> };</span>
<a href="#l48.60"></a><span id="l48.60"> </span>
<a href="#l48.61"></a><span id="l48.61"> /*=============================================================================</span>
<a href="#l48.62"></a><span id="l48.62">  * morkMid: all possible ways needed to express an alias ID in Mork syntax</span>
<a href="#l48.63"></a><span id="l48.63">  */</span>
<a href="#l48.64"></a><span id="l48.64"> </span>
<a href="#l48.65"></a><span id="l48.65" class="difflineat">@@ -92,81 +92,81 @@ public:</span>
<a href="#l48.66"></a><span id="l48.66"> **| the same scope, so the second ID need not be disambiguated.)</span>
<a href="#l48.67"></a><span id="l48.67"> **|</span>
<a href="#l48.68"></a><span id="l48.68"> **|| The only time mMid_Oid.mOid_Id is ever zero is when mMid_Buf alone</span>
<a href="#l48.69"></a><span id="l48.69"> **| is nonzero, to indicate an explicit string instead of an alias appeared.</span>
<a href="#l48.70"></a><span id="l48.70"> **| This case happens to make the representation of columns in cells somewhat</span>
<a href="#l48.71"></a><span id="l48.71"> **| easier to represent, since columns can just appear as a string name; and</span>
<a href="#l48.72"></a><span id="l48.72"> **| this unifies those interfaces with row and table APIs expecting IDs.</span>
<a href="#l48.73"></a><span id="l48.73"> **|</span>
<a href="#l48.74"></a><span id="l48.74" class="difflineminus">-**|| So when the parser passes an instance of morkMid to a subclass, the </span>
<a href="#l48.75"></a><span id="l48.75" class="difflineplus">+**|| So when the parser passes an instance of morkMid to a subclass, the</span>
<a href="#l48.76"></a><span id="l48.76"> **| mMid_Oid.mOid_Id slot should usually be nonzero.  And the other two</span>
<a href="#l48.77"></a><span id="l48.77"> **| slots, mMid_Oid.mOid_Scope and mMid_Buf, might both be zero, or at</span>
<a href="#l48.78"></a><span id="l48.78"> **| most one of them will be nonzero to indicate an explicit scope; the</span>
<a href="#l48.79"></a><span id="l48.79"> **| parser is responsible for ensuring at most one of these is nonzero.</span>
<a href="#l48.80"></a><span id="l48.80"> |*/</span>
<a href="#l48.81"></a><span id="l48.81"> class morkMid {</span>
<a href="#l48.82"></a><span id="l48.82"> public:</span>
<a href="#l48.83"></a><span id="l48.83">   mdbOid          mMid_Oid;  // mOid_Scope is zero when not specified</span>
<a href="#l48.84"></a><span id="l48.84">   const morkBuf*  mMid_Buf;  // points to some specific buf subclass</span>
<a href="#l48.85"></a><span id="l48.85" class="difflineminus">-  </span>
<a href="#l48.86"></a><span id="l48.86" class="difflineplus">+</span>
<a href="#l48.87"></a><span id="l48.87">   morkMid()</span>
<a href="#l48.88"></a><span id="l48.88">   { mMid_Oid.mOid_Scope = 0; mMid_Oid.mOid_Id = morkId_kMinusOne;</span>
<a href="#l48.89"></a><span id="l48.89">    mMid_Buf = 0; }</span>
<a href="#l48.90"></a><span id="l48.90" class="difflineminus">-  </span>
<a href="#l48.91"></a><span id="l48.91" class="difflineplus">+</span>
<a href="#l48.92"></a><span id="l48.92">   void InitMidWithCoil(morkCoil* ioCoil)</span>
<a href="#l48.93"></a><span id="l48.93">   { mMid_Oid.mOid_Scope = 0; mMid_Oid.mOid_Id = morkId_kMinusOne;</span>
<a href="#l48.94"></a><span id="l48.94">    mMid_Buf = ioCoil; }</span>
<a href="#l48.95"></a><span id="l48.95" class="difflineminus">-    </span>
<a href="#l48.96"></a><span id="l48.96" class="difflineplus">+</span>
<a href="#l48.97"></a><span id="l48.97">   void ClearMid()</span>
<a href="#l48.98"></a><span id="l48.98">   { mMid_Oid.mOid_Scope = 0; mMid_Oid.mOid_Id = morkId_kMinusOne;</span>
<a href="#l48.99"></a><span id="l48.99">    mMid_Buf = 0; }</span>
<a href="#l48.100"></a><span id="l48.100"> </span>
<a href="#l48.101"></a><span id="l48.101">   morkMid(const morkMid&amp; other)</span>
<a href="#l48.102"></a><span id="l48.102">   : mMid_Oid(other.mMid_Oid), mMid_Buf(other.mMid_Buf) { }</span>
<a href="#l48.103"></a><span id="l48.103" class="difflineminus">-  </span>
<a href="#l48.104"></a><span id="l48.104" class="difflineplus">+</span>
<a href="#l48.105"></a><span id="l48.105">   mork_bool HasNoId() const // ID is unspecified?</span>
<a href="#l48.106"></a><span id="l48.106">   { return ( mMid_Oid.mOid_Id == morkId_kMinusOne ); }</span>
<a href="#l48.107"></a><span id="l48.107" class="difflineminus">-  </span>
<a href="#l48.108"></a><span id="l48.108" class="difflineplus">+</span>
<a href="#l48.109"></a><span id="l48.109">   mork_bool HasSomeId() const // ID is specified?</span>
<a href="#l48.110"></a><span id="l48.110">   { return ( mMid_Oid.mOid_Id != morkId_kMinusOne ); }</span>
<a href="#l48.111"></a><span id="l48.111"> };</span>
<a href="#l48.112"></a><span id="l48.112"> </span>
<a href="#l48.113"></a><span id="l48.113"> /*=============================================================================</span>
<a href="#l48.114"></a><span id="l48.114">  * morkSpan: start and end stream byte position and stream line count</span>
<a href="#l48.115"></a><span id="l48.115">  */</span>
<a href="#l48.116"></a><span id="l48.116"> </span>
<a href="#l48.117"></a><span id="l48.117"> class morkSpan {</span>
<a href="#l48.118"></a><span id="l48.118"> public:</span>
<a href="#l48.119"></a><span id="l48.119">   morkPlace   mSpan_Start;</span>
<a href="#l48.120"></a><span id="l48.120">   morkPlace   mSpan_End;</span>
<a href="#l48.121"></a><span id="l48.121"> </span>
<a href="#l48.122"></a><span id="l48.122"> public: // methods</span>
<a href="#l48.123"></a><span id="l48.123" class="difflineminus">-  </span>
<a href="#l48.124"></a><span id="l48.124" class="difflineplus">+</span>
<a href="#l48.125"></a><span id="l48.125"> public: // inlines</span>
<a href="#l48.126"></a><span id="l48.126">   morkSpan() { } // use inline empty constructor for each place</span>
<a href="#l48.127"></a><span id="l48.127" class="difflineminus">-  </span>
<a href="#l48.128"></a><span id="l48.128" class="difflineplus">+</span>
<a href="#l48.129"></a><span id="l48.129">   morkPlace* AsPlace() { return &amp;mSpan_Start; }</span>
<a href="#l48.130"></a><span id="l48.130">   const morkPlace* AsConstPlace() const { return &amp;mSpan_Start; }</span>
<a href="#l48.131"></a><span id="l48.131" class="difflineminus">-  </span>
<a href="#l48.132"></a><span id="l48.132" class="difflineplus">+</span>
<a href="#l48.133"></a><span id="l48.133">   void SetSpan(mork_pos inFromPos, mork_line inFromLine,</span>
<a href="#l48.134"></a><span id="l48.134">     mork_pos inToPos, mork_line inToLine)</span>
<a href="#l48.135"></a><span id="l48.135">   {</span>
<a href="#l48.136"></a><span id="l48.136">     mSpan_Start.SetPlace(inFromPos, inFromLine);</span>
<a href="#l48.137"></a><span id="l48.137">     mSpan_End.SetPlace(inToPos,inToLine);</span>
<a href="#l48.138"></a><span id="l48.138">   }</span>
<a href="#l48.139"></a><span id="l48.139"> </span>
<a href="#l48.140"></a><span id="l48.140">   // setting end, useful to terminate a span using current port span end:</span>
<a href="#l48.141"></a><span id="l48.141">   void SetEndWithEnd(const morkSpan&amp; inSpan) // end &lt;- span.end</span>
<a href="#l48.142"></a><span id="l48.142">   { mSpan_End = inSpan.mSpan_End; }</span>
<a href="#l48.143"></a><span id="l48.143"> </span>
<a href="#l48.144"></a><span id="l48.144">   // setting start, useful to initiate a span using current port span end:</span>
<a href="#l48.145"></a><span id="l48.145">   void SetStartWithEnd(const morkSpan&amp; inSpan) // start &lt;- span.end</span>
<a href="#l48.146"></a><span id="l48.146">   { mSpan_Start = inSpan.mSpan_End; }</span>
<a href="#l48.147"></a><span id="l48.147" class="difflineminus">-  </span>
<a href="#l48.148"></a><span id="l48.148" class="difflineplus">+</span>
<a href="#l48.149"></a><span id="l48.149">   void ClearSpan()</span>
<a href="#l48.150"></a><span id="l48.150">   {</span>
<a href="#l48.151"></a><span id="l48.151">     mSpan_Start.mPlace_Pos = 0; mSpan_Start.mPlace_Line = 0;</span>
<a href="#l48.152"></a><span id="l48.152">     mSpan_End.mPlace_Pos = 0; mSpan_End.mPlace_Line = 0;</span>
<a href="#l48.153"></a><span id="l48.153">   }</span>
<a href="#l48.154"></a><span id="l48.154"> </span>
<a href="#l48.155"></a><span id="l48.155">   morkSpan(mork_pos inFromPos, mork_line inFromLine,</span>
<a href="#l48.156"></a><span id="l48.156">     mork_pos inToPos, mork_line inToLine)</span>
<a href="#l48.157"></a><span id="l48.157" class="difflineat">@@ -200,28 +200,28 @@ public: // inlines</span>
<a href="#l48.158"></a><span id="l48.158"> </span>
<a href="#l48.159"></a><span id="l48.159"> class morkParser /*d*/ : public morkNode {</span>
<a href="#l48.160"></a><span id="l48.160"> </span>
<a href="#l48.161"></a><span id="l48.161"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l48.162"></a><span id="l48.162">   // nsIMdbHeap*       mNode_Heap;</span>
<a href="#l48.163"></a><span id="l48.163"> </span>
<a href="#l48.164"></a><span id="l48.164">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l48.165"></a><span id="l48.165">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l48.166"></a><span id="l48.166" class="difflineminus">-  </span>
<a href="#l48.167"></a><span id="l48.167" class="difflineplus">+</span>
<a href="#l48.168"></a><span id="l48.168">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l48.169"></a><span id="l48.169">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l48.170"></a><span id="l48.170">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l48.171"></a><span id="l48.171">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l48.172"></a><span id="l48.172" class="difflineminus">-  </span>
<a href="#l48.173"></a><span id="l48.173" class="difflineplus">+</span>
<a href="#l48.174"></a><span id="l48.174">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l48.175"></a><span id="l48.175">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l48.176"></a><span id="l48.176"> </span>
<a href="#l48.177"></a><span id="l48.177" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l48.178"></a><span id="l48.178" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l48.179"></a><span id="l48.179"> protected: // protected morkParser members</span>
<a href="#l48.180"></a><span id="l48.180" class="difflineminus">-  </span>
<a href="#l48.181"></a><span id="l48.181" class="difflineplus">+</span>
<a href="#l48.182"></a><span id="l48.182">   nsIMdbHeap*   mParser_Heap;   // refcounted heap used for allocation</span>
<a href="#l48.183"></a><span id="l48.183">   morkStream*   mParser_Stream; // refcounted input stream</span>
<a href="#l48.184"></a><span id="l48.184"> </span>
<a href="#l48.185"></a><span id="l48.185">   mork_u4       mParser_Tag; // must equal morkParser_kTag</span>
<a href="#l48.186"></a><span id="l48.186">   mork_count    mParser_MoreGranularity; // constructor inBytesPerParseSegment</span>
<a href="#l48.187"></a><span id="l48.187"> </span>
<a href="#l48.188"></a><span id="l48.188">   mork_u4       mParser_State; // state where parser should resume</span>
<a href="#l48.189"></a><span id="l48.189"> </span>
<a href="#l48.190"></a><span id="l48.190" class="difflineat">@@ -238,25 +238,25 @@ protected: // protected morkParser membe</span>
<a href="#l48.191"></a><span id="l48.191">   mork_bool     mParser_InCell;  // called OnNewCell but not OnCellEnd?</span>
<a href="#l48.192"></a><span id="l48.192">   mork_bool     mParser_InMeta;  // called OnNewMeta but not OnMetaEnd?</span>
<a href="#l48.193"></a><span id="l48.193"> </span>
<a href="#l48.194"></a><span id="l48.194">   mork_bool     mParser_InPortRow;  // called OnNewPortRow but not OnPortRowEnd?</span>
<a href="#l48.195"></a><span id="l48.195">   mork_bool     mParser_InRow;    // called OnNewRow but not OnNewRowEnd?</span>
<a href="#l48.196"></a><span id="l48.196">   mork_bool     mParser_InTable;  // called OnNewMeta but not OnMetaEnd?</span>
<a href="#l48.197"></a><span id="l48.197">   mork_bool     mParser_InGroup;  // called OnNewGroup but not OnGroupEnd?</span>
<a href="#l48.198"></a><span id="l48.198"> </span>
<a href="#l48.199"></a><span id="l48.199" class="difflineminus">-  mork_change   mParser_AtomChange;  // driven by mParser_Change </span>
<a href="#l48.200"></a><span id="l48.200" class="difflineminus">-  mork_change   mParser_CellChange;  // driven by mParser_Change </span>
<a href="#l48.201"></a><span id="l48.201" class="difflineminus">-  mork_change   mParser_RowChange;   // driven by mParser_Change </span>
<a href="#l48.202"></a><span id="l48.202" class="difflineminus">-  mork_change   mParser_TableChange; // driven by mParser_Change </span>
<a href="#l48.203"></a><span id="l48.203" class="difflineplus">+  mork_change   mParser_AtomChange;  // driven by mParser_Change</span>
<a href="#l48.204"></a><span id="l48.204" class="difflineplus">+  mork_change   mParser_CellChange;  // driven by mParser_Change</span>
<a href="#l48.205"></a><span id="l48.205" class="difflineplus">+  mork_change   mParser_RowChange;   // driven by mParser_Change</span>
<a href="#l48.206"></a><span id="l48.206" class="difflineplus">+  mork_change   mParser_TableChange; // driven by mParser_Change</span>
<a href="#l48.207"></a><span id="l48.207"> </span>
<a href="#l48.208"></a><span id="l48.208" class="difflineminus">-  mork_change   mParser_Change;     // driven by modifier in text </span>
<a href="#l48.209"></a><span id="l48.209" class="difflineplus">+  mork_change   mParser_Change;     // driven by modifier in text</span>
<a href="#l48.210"></a><span id="l48.210">   mork_bool     mParser_IsBroken;   // has the parse become broken?</span>
<a href="#l48.211"></a><span id="l48.211">   mork_bool     mParser_IsDone;     // has the parse finished?</span>
<a href="#l48.212"></a><span id="l48.212" class="difflineminus">-  mork_bool     mParser_DoMore;     // mParser_MoreGranularity not exhausted? </span>
<a href="#l48.213"></a><span id="l48.213" class="difflineplus">+  mork_bool     mParser_DoMore;     // mParser_MoreGranularity not exhausted?</span>
<a href="#l48.214"></a><span id="l48.214"> </span>
<a href="#l48.215"></a><span id="l48.215">   morkMid       mParser_Mid;   // current alias being parsed</span>
<a href="#l48.216"></a><span id="l48.216">   // note that mParser_Mid.mMid_Buf points at mParser_ScopeCoil below:</span>
<a href="#l48.217"></a><span id="l48.217"> </span>
<a href="#l48.218"></a><span id="l48.218">   // blob coils allocated in mParser_Heap</span>
<a href="#l48.219"></a><span id="l48.219">   morkCoil     mParser_ScopeCoil;   // place to accumulate ID scope blobs</span>
<a href="#l48.220"></a><span id="l48.220">   morkCoil     mParser_ValueCoil;   // place to accumulate value blobs</span>
<a href="#l48.221"></a><span id="l48.221">   morkCoil     mParser_ColumnCoil;  // place to accumulate column blobs</span>
<a href="#l48.222"></a><span id="l48.222" class="difflineat">@@ -300,55 +300,55 @@ public: // morkNode virtual methods</span>
<a href="#l48.223"></a><span id="l48.223">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseParser() only if open</span>
<a href="#l48.224"></a><span id="l48.224">   virtual ~morkParser(); // assert that CloseParser() executed earlier</span>
<a href="#l48.225"></a><span id="l48.225"> </span>
<a href="#l48.226"></a><span id="l48.226"> public: // morkYarn construction &amp; destruction</span>
<a href="#l48.227"></a><span id="l48.227">   morkParser(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l48.228"></a><span id="l48.228">     morkStream* ioStream,  // the readonly stream for input bytes</span>
<a href="#l48.229"></a><span id="l48.229">     mdb_count inBytesPerParseSegment, // target for ParseMore()</span>
<a href="#l48.230"></a><span id="l48.230">     nsIMdbHeap* ioSlotHeap);</span>
<a href="#l48.231"></a><span id="l48.231" class="difflineminus">-      </span>
<a href="#l48.232"></a><span id="l48.232" class="difflineplus">+</span>
<a href="#l48.233"></a><span id="l48.233">   void CloseParser(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l48.234"></a><span id="l48.234"> </span>
<a href="#l48.235"></a><span id="l48.235"> private: // copying is not allowed</span>
<a href="#l48.236"></a><span id="l48.236">   morkParser(const morkParser&amp; other);</span>
<a href="#l48.237"></a><span id="l48.237">   morkParser&amp; operator=(const morkParser&amp; other);</span>
<a href="#l48.238"></a><span id="l48.238"> </span>
<a href="#l48.239"></a><span id="l48.239"> public: // dynamic type identification</span>
<a href="#l48.240"></a><span id="l48.240">   mork_bool IsParser() const</span>
<a href="#l48.241"></a><span id="l48.241">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kParser; }</span>
<a href="#l48.242"></a><span id="l48.242" class="difflineminus">-  </span>
<a href="#l48.243"></a><span id="l48.243" class="difflineplus">+</span>
<a href="#l48.244"></a><span id="l48.244"> // } ===== end morkNode methods =====</span>
<a href="#l48.245"></a><span id="l48.245"> </span>
<a href="#l48.246"></a><span id="l48.246"> public: // errors and warnings</span>
<a href="#l48.247"></a><span id="l48.247">   static void UnexpectedEofError(morkEnv* ev);</span>
<a href="#l48.248"></a><span id="l48.248">   static void EofInsteadOfHexError(morkEnv* ev);</span>
<a href="#l48.249"></a><span id="l48.249">   static void ExpectedEqualError(morkEnv* ev);</span>
<a href="#l48.250"></a><span id="l48.250">   static void ExpectedHexDigitError(morkEnv* ev, int c);</span>
<a href="#l48.251"></a><span id="l48.251">   static void NonParserTypeError(morkEnv* ev);</span>
<a href="#l48.252"></a><span id="l48.252">   static void UnexpectedByteInMetaWarning(morkEnv* ev);</span>
<a href="#l48.253"></a><span id="l48.253"> </span>
<a href="#l48.254"></a><span id="l48.254"> public: // other type methods</span>
<a href="#l48.255"></a><span id="l48.255">   mork_bool GoodParserTag() const { return mParser_Tag == morkParser_kTag; }</span>
<a href="#l48.256"></a><span id="l48.256">   void NonGoodParserError(morkEnv* ev);</span>
<a href="#l48.257"></a><span id="l48.257">   void NonUsableParserError(morkEnv* ev);</span>
<a href="#l48.258"></a><span id="l48.258">   // call when IsNode() or GoodParserTag() is false</span>
<a href="#l48.259"></a><span id="l48.259" class="difflineminus">-  </span>
<a href="#l48.260"></a><span id="l48.260" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l48.261"></a><span id="l48.261" class="difflineplus">+</span>
<a href="#l48.262"></a><span id="l48.262" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l48.263"></a><span id="l48.263"> public: // in virtual morkParser methods, data flow subclass to parser</span>
<a href="#l48.264"></a><span id="l48.264"> </span>
<a href="#l48.265"></a><span id="l48.265">     virtual void MidToYarn(morkEnv* ev,</span>
<a href="#l48.266"></a><span id="l48.266">       const morkMid&amp; inMid,  // typically an alias to concat with strings</span>
<a href="#l48.267"></a><span id="l48.267">       mdbYarn* outYarn) = 0;</span>
<a href="#l48.268"></a><span id="l48.268">     // The parser might ask that some aliases be turned into yarns, so they</span>
<a href="#l48.269"></a><span id="l48.269">     // can be concatenated into longer blobs under some circumstances.  This</span>
<a href="#l48.270"></a><span id="l48.270">     // is an alternative to using a long and complex callback for many parts</span>
<a href="#l48.271"></a><span id="l48.271">     // for a single cell value.</span>
<a href="#l48.272"></a><span id="l48.272" class="difflineminus">-  </span>
<a href="#l48.273"></a><span id="l48.273" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l48.274"></a><span id="l48.274" class="difflineplus">+</span>
<a href="#l48.275"></a><span id="l48.275" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l48.276"></a><span id="l48.276"> public: // out virtual morkParser methods, data flow parser to subclass</span>
<a href="#l48.277"></a><span id="l48.277"> </span>
<a href="#l48.278"></a><span id="l48.278"> // The virtual methods below will be called in a pattern corresponding</span>
<a href="#l48.279"></a><span id="l48.279"> // to the following grammar isomorphic to the Mork grammar.  There should</span>
<a href="#l48.280"></a><span id="l48.280"> // be no exceptions, so subclasses can rely on seeing an appropriate &quot;end&quot;</span>
<a href="#l48.281"></a><span id="l48.281"> // method whenever some &quot;new&quot; method has been seen earlier.  In the event</span>
<a href="#l48.282"></a><span id="l48.282"> // that some error occurs that causes content to be flushed, or sudden early</span>
<a href="#l48.283"></a><span id="l48.283"> // termination of a larger containing entity, we will always call a more</span>
<a href="#l48.284"></a><span id="l48.284" class="difflineat">@@ -377,95 +377,95 @@ public: // out virtual morkParser method</span>
<a href="#l48.285"></a><span id="l48.285"> // mp:Slot      ::= OnValue | OnValueMid | OnRowMid | OnTableMid</span>
<a href="#l48.286"></a><span id="l48.286"> </span>
<a href="#l48.287"></a><span id="l48.287"> </span>
<a href="#l48.288"></a><span id="l48.288">   // Note that in interfaces below, mork_change parameters kAdd and kNil</span>
<a href="#l48.289"></a><span id="l48.289">   // both mean about the same thing by default.  Only kCut is interesting,</span>
<a href="#l48.290"></a><span id="l48.290">   // because this usually means to remove members instead of adding them.</span>
<a href="#l48.291"></a><span id="l48.291"> </span>
<a href="#l48.292"></a><span id="l48.292">   virtual void OnNewPort(morkEnv* ev, const morkPlace&amp; inPlace) = 0;</span>
<a href="#l48.293"></a><span id="l48.293" class="difflineminus">-  virtual void OnPortGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;  </span>
<a href="#l48.294"></a><span id="l48.294" class="difflineminus">-  virtual void OnPortEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;  </span>
<a href="#l48.295"></a><span id="l48.295" class="difflineplus">+  virtual void OnPortGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;</span>
<a href="#l48.296"></a><span id="l48.296" class="difflineplus">+  virtual void OnPortEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;</span>
<a href="#l48.297"></a><span id="l48.297"> </span>
<a href="#l48.298"></a><span id="l48.298">   virtual void OnNewGroup(morkEnv* ev, const morkPlace&amp; inPlace, mork_gid inGid) = 0;</span>
<a href="#l48.299"></a><span id="l48.299" class="difflineminus">-  virtual void OnGroupGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;  </span>
<a href="#l48.300"></a><span id="l48.300" class="difflineminus">-  virtual void OnGroupCommitEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;  </span>
<a href="#l48.301"></a><span id="l48.301" class="difflineminus">-  virtual void OnGroupAbortEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;  </span>
<a href="#l48.302"></a><span id="l48.302" class="difflineplus">+  virtual void OnGroupGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;</span>
<a href="#l48.303"></a><span id="l48.303" class="difflineplus">+  virtual void OnGroupCommitEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;</span>
<a href="#l48.304"></a><span id="l48.304" class="difflineplus">+  virtual void OnGroupAbortEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;</span>
<a href="#l48.305"></a><span id="l48.305"> </span>
<a href="#l48.306"></a><span id="l48.306" class="difflineminus">-  virtual void OnNewPortRow(morkEnv* ev, const morkPlace&amp; inPlace, </span>
<a href="#l48.307"></a><span id="l48.307" class="difflineplus">+  virtual void OnNewPortRow(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l48.308"></a><span id="l48.308">     const morkMid&amp; inMid, mork_change inChange) = 0;</span>
<a href="#l48.309"></a><span id="l48.309" class="difflineminus">-  virtual void OnPortRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;  </span>
<a href="#l48.310"></a><span id="l48.310" class="difflineminus">-  virtual void OnPortRowEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;  </span>
<a href="#l48.311"></a><span id="l48.311" class="difflineplus">+  virtual void OnPortRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;</span>
<a href="#l48.312"></a><span id="l48.312" class="difflineplus">+  virtual void OnPortRowEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;</span>
<a href="#l48.313"></a><span id="l48.313"> </span>
<a href="#l48.314"></a><span id="l48.314">   virtual void OnNewTable(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l48.315"></a><span id="l48.315">     const morkMid&amp; inMid, mork_bool inCutAllRows) = 0;</span>
<a href="#l48.316"></a><span id="l48.316">   virtual void OnTableGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;</span>
<a href="#l48.317"></a><span id="l48.317">   virtual void OnTableEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;</span>
<a href="#l48.318"></a><span id="l48.318" class="difflineminus">-    </span>
<a href="#l48.319"></a><span id="l48.319" class="difflineplus">+</span>
<a href="#l48.320"></a><span id="l48.320">   virtual void OnNewMeta(morkEnv* ev, const morkPlace&amp; inPlace) = 0;</span>
<a href="#l48.321"></a><span id="l48.321">   virtual void OnMetaGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;</span>
<a href="#l48.322"></a><span id="l48.322">   virtual void OnMetaEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;</span>
<a href="#l48.323"></a><span id="l48.323"> </span>
<a href="#l48.324"></a><span id="l48.324">   virtual void OnMinusRow(morkEnv* ev) = 0;</span>
<a href="#l48.325"></a><span id="l48.325" class="difflineminus">-  virtual void OnNewRow(morkEnv* ev, const morkPlace&amp; inPlace, </span>
<a href="#l48.326"></a><span id="l48.326" class="difflineplus">+  virtual void OnNewRow(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l48.327"></a><span id="l48.327">     const morkMid&amp; inMid, mork_bool inCutAllCols) = 0;</span>
<a href="#l48.328"></a><span id="l48.328" class="difflineminus">-  virtual void OnRowPos(morkEnv* ev, mork_pos inRowPos) = 0;  </span>
<a href="#l48.329"></a><span id="l48.329" class="difflineminus">-  virtual void OnRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;  </span>
<a href="#l48.330"></a><span id="l48.330" class="difflineminus">-  virtual void OnRowEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;  </span>
<a href="#l48.331"></a><span id="l48.331" class="difflineplus">+  virtual void OnRowPos(morkEnv* ev, mork_pos inRowPos) = 0;</span>
<a href="#l48.332"></a><span id="l48.332" class="difflineplus">+  virtual void OnRowGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;</span>
<a href="#l48.333"></a><span id="l48.333" class="difflineplus">+  virtual void OnRowEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;</span>
<a href="#l48.334"></a><span id="l48.334"> </span>
<a href="#l48.335"></a><span id="l48.335">   virtual void OnNewDict(morkEnv* ev, const morkPlace&amp; inPlace) = 0;</span>
<a href="#l48.336"></a><span id="l48.336" class="difflineminus">-  virtual void OnDictGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;  </span>
<a href="#l48.337"></a><span id="l48.337" class="difflineminus">-  virtual void OnDictEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;  </span>
<a href="#l48.338"></a><span id="l48.338" class="difflineplus">+  virtual void OnDictGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;</span>
<a href="#l48.339"></a><span id="l48.339" class="difflineplus">+  virtual void OnDictEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;</span>
<a href="#l48.340"></a><span id="l48.340"> </span>
<a href="#l48.341"></a><span id="l48.341">   virtual void OnAlias(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l48.342"></a><span id="l48.342">     const morkMid&amp; inMid) = 0;</span>
<a href="#l48.343"></a><span id="l48.343"> </span>
<a href="#l48.344"></a><span id="l48.344">   virtual void OnAliasGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;</span>
<a href="#l48.345"></a><span id="l48.345"> </span>
<a href="#l48.346"></a><span id="l48.346">   virtual void OnMinusCell(morkEnv* ev) = 0;</span>
<a href="#l48.347"></a><span id="l48.347">   virtual void OnNewCell(morkEnv* ev, const morkPlace&amp; inPlace,</span>
<a href="#l48.348"></a><span id="l48.348">     const morkMid* inMid, const morkBuf* inBuf) = 0;</span>
<a href="#l48.349"></a><span id="l48.349">   // Exactly one of inMid and inBuf is nil, and the other is non-nil.</span>
<a href="#l48.350"></a><span id="l48.350">   // When hex ID syntax is used for a column, then inMid is not nil, and</span>
<a href="#l48.351"></a><span id="l48.351">   // when a naked string names a column, then inBuf is not nil.</span>
<a href="#l48.352"></a><span id="l48.352" class="difflineminus">-    </span>
<a href="#l48.353"></a><span id="l48.353" class="difflineplus">+</span>
<a href="#l48.354"></a><span id="l48.354">   virtual void OnCellGlitch(morkEnv* ev, const morkGlitch&amp; inGlitch) = 0;</span>
<a href="#l48.355"></a><span id="l48.355">   virtual void OnCellForm(morkEnv* ev, mork_cscode inCharsetFormat) = 0;</span>
<a href="#l48.356"></a><span id="l48.356">   virtual void OnCellEnd(morkEnv* ev, const morkSpan&amp; inSpan) = 0;</span>
<a href="#l48.357"></a><span id="l48.357" class="difflineminus">-    </span>
<a href="#l48.358"></a><span id="l48.358" class="difflineplus">+</span>
<a href="#l48.359"></a><span id="l48.359">   virtual void OnValue(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l48.360"></a><span id="l48.360">     const morkBuf&amp; inBuf) = 0;</span>
<a href="#l48.361"></a><span id="l48.361"> </span>
<a href="#l48.362"></a><span id="l48.362">   virtual void OnValueMid(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l48.363"></a><span id="l48.363">     const morkMid&amp; inMid) = 0;</span>
<a href="#l48.364"></a><span id="l48.364"> </span>
<a href="#l48.365"></a><span id="l48.365">   virtual void OnRowMid(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l48.366"></a><span id="l48.366">     const morkMid&amp; inMid) = 0;</span>
<a href="#l48.367"></a><span id="l48.367"> </span>
<a href="#l48.368"></a><span id="l48.368">   virtual void OnTableMid(morkEnv* ev, const morkSpan&amp; inSpan,</span>
<a href="#l48.369"></a><span id="l48.369">     const morkMid&amp; inMid) = 0;</span>
<a href="#l48.370"></a><span id="l48.370" class="difflineminus">-  </span>
<a href="#l48.371"></a><span id="l48.371" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l48.372"></a><span id="l48.372" class="difflineplus">+</span>
<a href="#l48.373"></a><span id="l48.373" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l48.374"></a><span id="l48.374"> protected: // protected parser helper methods</span>
<a href="#l48.375"></a><span id="l48.375"> </span>
<a href="#l48.376"></a><span id="l48.376">   void ParseChunk(morkEnv* ev); // find parse continuation and resume</span>
<a href="#l48.377"></a><span id="l48.377"> </span>
<a href="#l48.378"></a><span id="l48.378">   void StartParse(morkEnv* ev); // prepare for parsing</span>
<a href="#l48.379"></a><span id="l48.379">   void StopParse(morkEnv* ev); // terminate parsing &amp; call needed methods</span>
<a href="#l48.380"></a><span id="l48.380"> </span>
<a href="#l48.381"></a><span id="l48.381">   int NextChar(morkEnv* ev); // next non-white content</span>
<a href="#l48.382"></a><span id="l48.382"> </span>
<a href="#l48.383"></a><span id="l48.383">   void OnCellState(morkEnv* ev);</span>
<a href="#l48.384"></a><span id="l48.384">   void OnMetaState(morkEnv* ev);</span>
<a href="#l48.385"></a><span id="l48.385">   void OnRowState(morkEnv* ev);</span>
<a href="#l48.386"></a><span id="l48.386">   void OnTableState(morkEnv* ev);</span>
<a href="#l48.387"></a><span id="l48.387">   void OnDictState(morkEnv* ev);</span>
<a href="#l48.388"></a><span id="l48.388">   void OnPortState(morkEnv* ev);</span>
<a href="#l48.389"></a><span id="l48.389">   void OnStartState(morkEnv* ev);</span>
<a href="#l48.390"></a><span id="l48.390" class="difflineminus">-  </span>
<a href="#l48.391"></a><span id="l48.391" class="difflineplus">+</span>
<a href="#l48.392"></a><span id="l48.392">   void ReadCell(morkEnv* ev);</span>
<a href="#l48.393"></a><span id="l48.393">   void ReadRow(morkEnv* ev, int c);</span>
<a href="#l48.394"></a><span id="l48.394">   void ReadRowPos(morkEnv* ev);</span>
<a href="#l48.395"></a><span id="l48.395">   void ReadTable(morkEnv* ev);</span>
<a href="#l48.396"></a><span id="l48.396">   void ReadTableMeta(morkEnv* ev);</span>
<a href="#l48.397"></a><span id="l48.397">   void ReadDict(morkEnv* ev);</span>
<a href="#l48.398"></a><span id="l48.398">   mork_bool ReadContent(morkEnv* ev, mork_bool inInsideGroup);</span>
<a href="#l48.399"></a><span id="l48.399">   void ReadGroup(morkEnv* ev);</span>
<a href="#l48.400"></a><span id="l48.400" class="difflineat">@@ -475,58 +475,58 @@ protected: // protected parser helper me</span>
<a href="#l48.401"></a><span id="l48.401">   void ReadMeta(morkEnv* ev, int inEndMeta);</span>
<a href="#l48.402"></a><span id="l48.402">   void ReadAlias(morkEnv* ev);</span>
<a href="#l48.403"></a><span id="l48.403">   mork_id ReadHex(morkEnv* ev, int* outNextChar);</span>
<a href="#l48.404"></a><span id="l48.404">   morkBuf* ReadValue(morkEnv* ev);</span>
<a href="#l48.405"></a><span id="l48.405">   morkBuf* ReadName(morkEnv* ev, int c);</span>
<a href="#l48.406"></a><span id="l48.406">   mork_bool ReadMid(morkEnv* ev, morkMid* outMid);</span>
<a href="#l48.407"></a><span id="l48.407">   void ReadDictForm(morkEnv *ev);</span>
<a href="#l48.408"></a><span id="l48.408">   void ReadCellForm(morkEnv *ev, int c);</span>
<a href="#l48.409"></a><span id="l48.409" class="difflineminus">-  </span>
<a href="#l48.410"></a><span id="l48.410" class="difflineplus">+</span>
<a href="#l48.411"></a><span id="l48.411">   mork_bool MatchPattern(morkEnv* ev, const char* inPattern);</span>
<a href="#l48.412"></a><span id="l48.412" class="difflineminus">-  </span>
<a href="#l48.413"></a><span id="l48.413" class="difflineplus">+</span>
<a href="#l48.414"></a><span id="l48.414">   void EndSpanOnThisByte(morkEnv* ev, morkSpan* ioSpan);</span>
<a href="#l48.415"></a><span id="l48.415">   void EndSpanOnLastByte(morkEnv* ev, morkSpan* ioSpan);</span>
<a href="#l48.416"></a><span id="l48.416">   void StartSpanOnLastByte(morkEnv* ev, morkSpan* ioSpan);</span>
<a href="#l48.417"></a><span id="l48.417" class="difflineminus">-  </span>
<a href="#l48.418"></a><span id="l48.418" class="difflineplus">+</span>
<a href="#l48.419"></a><span id="l48.419">   void StartSpanOnThisByte(morkEnv* ev, morkSpan* ioSpan);</span>
<a href="#l48.420"></a><span id="l48.420" class="difflineminus">-  </span>
<a href="#l48.421"></a><span id="l48.421" class="difflineminus">-  </span>
<a href="#l48.422"></a><span id="l48.422" class="difflineplus">+</span>
<a href="#l48.423"></a><span id="l48.423" class="difflineplus">+</span>
<a href="#l48.424"></a><span id="l48.424">   // void EndSpanOnThisByte(morkEnv* ev, morkSpan* ioSpan)</span>
<a href="#l48.425"></a><span id="l48.425">   // { MORK_USED_2(ev,ioSpan); }</span>
<a href="#l48.426"></a><span id="l48.426" class="difflineminus">-  </span>
<a href="#l48.427"></a><span id="l48.427" class="difflineplus">+</span>
<a href="#l48.428"></a><span id="l48.428">   // void EndSpanOnLastByte(morkEnv* ev, morkSpan* ioSpan)</span>
<a href="#l48.429"></a><span id="l48.429">   // { MORK_USED_2(ev,ioSpan); }</span>
<a href="#l48.430"></a><span id="l48.430" class="difflineminus">-  </span>
<a href="#l48.431"></a><span id="l48.431" class="difflineplus">+</span>
<a href="#l48.432"></a><span id="l48.432">   // void StartSpanOnLastByte(morkEnv* ev, morkSpan* ioSpan)</span>
<a href="#l48.433"></a><span id="l48.433">   // { MORK_USED_2(ev,ioSpan); }</span>
<a href="#l48.434"></a><span id="l48.434" class="difflineminus">-  </span>
<a href="#l48.435"></a><span id="l48.435" class="difflineplus">+</span>
<a href="#l48.436"></a><span id="l48.436">   // void StartSpanOnThisByte(morkEnv* ev, morkSpan* ioSpan)</span>
<a href="#l48.437"></a><span id="l48.437">   // { MORK_USED_2(ev,ioSpan); }</span>
<a href="#l48.438"></a><span id="l48.438" class="difflineminus">-  </span>
<a href="#l48.439"></a><span id="l48.439" class="difflineplus">+</span>
<a href="#l48.440"></a><span id="l48.440">   int eat_line_break(morkEnv* ev, int inLast);</span>
<a href="#l48.441"></a><span id="l48.441">   int eat_line_continue(morkEnv* ev); // last char was '\\'</span>
<a href="#l48.442"></a><span id="l48.442">   int eat_comment(morkEnv* ev); // last char was '/'</span>
<a href="#l48.443"></a><span id="l48.443" class="difflineminus">-  </span>
<a href="#l48.444"></a><span id="l48.444" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l48.445"></a><span id="l48.445" class="difflineplus">+</span>
<a href="#l48.446"></a><span id="l48.446" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l48.447"></a><span id="l48.447"> public: // public non-poly morkParser methods</span>
<a href="#l48.448"></a><span id="l48.448" class="difflineminus">-    </span>
<a href="#l48.449"></a><span id="l48.449" class="difflineplus">+</span>
<a href="#l48.450"></a><span id="l48.450">   mdb_count ParseMore( // return count of bytes consumed now</span>
<a href="#l48.451"></a><span id="l48.451">     morkEnv* ev,          // context</span>
<a href="#l48.452"></a><span id="l48.452">     mork_pos* outPos,     // current byte pos in the stream afterwards</span>
<a href="#l48.453"></a><span id="l48.453">     mork_bool* outDone,   // is parsing finished?</span>
<a href="#l48.454"></a><span id="l48.454">     mork_bool* outBroken  // is parsing irreparably dead and broken?</span>
<a href="#l48.455"></a><span id="l48.455">   );</span>
<a href="#l48.456"></a><span id="l48.456" class="difflineminus">-  </span>
<a href="#l48.457"></a><span id="l48.457" class="difflineminus">-  </span>
<a href="#l48.458"></a><span id="l48.458" class="difflineplus">+</span>
<a href="#l48.459"></a><span id="l48.459" class="difflineplus">+</span>
<a href="#l48.460"></a><span id="l48.460"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l48.461"></a><span id="l48.461">   static void SlotWeakParser(morkParser* me,</span>
<a href="#l48.462"></a><span id="l48.462">     morkEnv* ev, morkParser** ioSlot)</span>
<a href="#l48.463"></a><span id="l48.463">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l48.464"></a><span id="l48.464" class="difflineminus">-  </span>
<a href="#l48.465"></a><span id="l48.465" class="difflineplus">+</span>
<a href="#l48.466"></a><span id="l48.466">   static void SlotStrongParser(morkParser* me,</span>
<a href="#l48.467"></a><span id="l48.467">     morkEnv* ev, morkParser** ioSlot)</span>
<a href="#l48.468"></a><span id="l48.468">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l48.469"></a><span id="l48.469"> };</span>
<a href="#l48.470"></a><span id="l48.470"> </span>
<a href="#l48.471"></a><span id="l48.471"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l48.472"></a><span id="l48.472"> </span>
<a href="#l48.473"></a><span id="l48.473"> #endif /* _MORKPARSER_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l49.1"></a><span id="l49.1" class="difflineminus">--- a/db/mork/src/morkPool.cpp</span>
<a href="#l49.2"></a><span id="l49.2" class="difflineplus">+++ b/db/mork/src/morkPool.cpp</span>
<a href="#l49.3"></a><span id="l49.3" class="difflineat">@@ -48,17 +48,17 @@</span>
<a href="#l49.4"></a><span id="l49.4"> #endif</span>
<a href="#l49.5"></a><span id="l49.5"> </span>
<a href="#l49.6"></a><span id="l49.6"> #ifndef _MORKZONE_</span>
<a href="#l49.7"></a><span id="l49.7"> #include &quot;morkZone.h&quot;</span>
<a href="#l49.8"></a><span id="l49.8"> #endif</span>
<a href="#l49.9"></a><span id="l49.9"> </span>
<a href="#l49.10"></a><span id="l49.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l49.11"></a><span id="l49.11"> </span>
<a href="#l49.12"></a><span id="l49.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l49.13"></a><span id="l49.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l49.14"></a><span id="l49.14"> // { ===== begin morkNode interface =====</span>
<a href="#l49.15"></a><span id="l49.15"> </span>
<a href="#l49.16"></a><span id="l49.16"> /*public virtual*/ void</span>
<a href="#l49.17"></a><span id="l49.17"> morkPool::CloseMorkNode(morkEnv* ev) // ClosePool() only if open</span>
<a href="#l49.18"></a><span id="l49.18"> {</span>
<a href="#l49.19"></a><span id="l49.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l49.20"></a><span id="l49.20">   {</span>
<a href="#l49.21"></a><span id="l49.21">     this-&gt;MarkClosing();</span>
<a href="#l49.22"></a><span id="l49.22" class="difflineat">@@ -117,30 +117,30 @@ morkPool::ClosePool(morkEnv* ev) // call</span>
<a href="#l49.23"></a><span id="l49.23"> #endif /*morkZone_CONFIG_ARENA*/</span>
<a href="#l49.24"></a><span id="l49.24"> </span>
<a href="#l49.25"></a><span id="l49.25">       nsIMdbHeap* heap = mPool_Heap;</span>
<a href="#l49.26"></a><span id="l49.26">       nsIMdbEnv* mev = ev-&gt;AsMdbEnv();</span>
<a href="#l49.27"></a><span id="l49.27">       morkLink* aLink;</span>
<a href="#l49.28"></a><span id="l49.28">       morkDeque* d = &amp;mPool_FreeHandleFrames;</span>
<a href="#l49.29"></a><span id="l49.29">       while ( (aLink = d-&gt;RemoveFirst()) != 0 )</span>
<a href="#l49.30"></a><span id="l49.30">         heap-&gt;Free(mev, aLink);</span>
<a href="#l49.31"></a><span id="l49.31" class="difflineminus">-  </span>
<a href="#l49.32"></a><span id="l49.32" class="difflineplus">+</span>
<a href="#l49.33"></a><span id="l49.33">       // if the pool's closed, get rid of the frames in use too.</span>
<a href="#l49.34"></a><span id="l49.34">       d = &amp;mPool_UsedHandleFrames;</span>
<a href="#l49.35"></a><span id="l49.35">       while ( (aLink = d-&gt;RemoveFirst()) != 0 )</span>
<a href="#l49.36"></a><span id="l49.36">         heap-&gt;Free(mev, aLink);</span>
<a href="#l49.37"></a><span id="l49.37" class="difflineminus">-  </span>
<a href="#l49.38"></a><span id="l49.38" class="difflineplus">+</span>
<a href="#l49.39"></a><span id="l49.39">       this-&gt;MarkShut();</span>
<a href="#l49.40"></a><span id="l49.40">     }</span>
<a href="#l49.41"></a><span id="l49.41">     else</span>
<a href="#l49.42"></a><span id="l49.42">       this-&gt;NonNodeError(ev);</span>
<a href="#l49.43"></a><span id="l49.43"> }</span>
<a href="#l49.44"></a><span id="l49.44"> </span>
<a href="#l49.45"></a><span id="l49.45"> // } ===== end morkNode methods =====</span>
<a href="#l49.46"></a><span id="l49.46" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l49.47"></a><span id="l49.47" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l49.48"></a><span id="l49.48"> </span>
<a href="#l49.49"></a><span id="l49.49"> </span>
<a href="#l49.50"></a><span id="l49.50"> // alloc and free individual instances of handles (inside hand frames):</span>
<a href="#l49.51"></a><span id="l49.51"> morkHandleFace*</span>
<a href="#l49.52"></a><span id="l49.52"> morkPool::NewHandle(morkEnv* ev, mork_size inSize, morkZone* ioZone)</span>
<a href="#l49.53"></a><span id="l49.53"> {</span>
<a href="#l49.54"></a><span id="l49.54">   void* newBlock = 0;</span>
<a href="#l49.55"></a><span id="l49.55">   if ( inSize &lt;= sizeof(morkHandleFrame) )</span>
<a href="#l49.56"></a><span id="l49.56" class="difflineat">@@ -174,43 +174,43 @@ morkPool::NewHandle(morkEnv* ev, mork_si</span>
<a href="#l49.57"></a><span id="l49.57"> void</span>
<a href="#l49.58"></a><span id="l49.58"> morkPool::ZapHandle(morkEnv* ev, morkHandleFace* ioHandle)</span>
<a href="#l49.59"></a><span id="l49.59"> {</span>
<a href="#l49.60"></a><span id="l49.60">   if ( ioHandle )</span>
<a href="#l49.61"></a><span id="l49.61">   {</span>
<a href="#l49.62"></a><span id="l49.62">     morkLink* handleLink = (morkLink*) ioHandle;</span>
<a href="#l49.63"></a><span id="l49.63">     mPool_FreeHandleFrames.AddLast(handleLink);</span>
<a href="#l49.64"></a><span id="l49.64">     ++mPool_FreeFramesCount;</span>
<a href="#l49.65"></a><span id="l49.65" class="difflineminus">-    // lets free all handles to track down leaks </span>
<a href="#l49.66"></a><span id="l49.66" class="difflineplus">+    // lets free all handles to track down leaks</span>
<a href="#l49.67"></a><span id="l49.67">     // - uncomment out next 3 lines, comment out above 2</span>
<a href="#l49.68"></a><span id="l49.68"> //      nsIMdbHeap* heap = mPool_Heap;</span>
<a href="#l49.69"></a><span id="l49.69"> //      nsIMdbEnv* mev = ev-&gt;AsMdbEnv();</span>
<a href="#l49.70"></a><span id="l49.70"> //      heap-&gt;Free(mev, handleLink);</span>
<a href="#l49.71"></a><span id="l49.71" class="difflineminus">- </span>
<a href="#l49.72"></a><span id="l49.72" class="difflineplus">+</span>
<a href="#l49.73"></a><span id="l49.73">   }</span>
<a href="#l49.74"></a><span id="l49.74"> }</span>
<a href="#l49.75"></a><span id="l49.75"> </span>
<a href="#l49.76"></a><span id="l49.76"> </span>
<a href="#l49.77"></a><span id="l49.77"> // alloc and free individual instances of rows:</span>
<a href="#l49.78"></a><span id="l49.78"> morkRow*</span>
<a href="#l49.79"></a><span id="l49.79"> morkPool::NewRow(morkEnv* ev, morkZone* ioZone) // allocate a new row instance</span>
<a href="#l49.80"></a><span id="l49.80"> {</span>
<a href="#l49.81"></a><span id="l49.81">   morkRow* newRow = 0;</span>
<a href="#l49.82"></a><span id="l49.82" class="difflineminus">-  </span>
<a href="#l49.83"></a><span id="l49.83" class="difflineplus">+</span>
<a href="#l49.84"></a><span id="l49.84"> #ifdef morkZone_CONFIG_ARENA</span>
<a href="#l49.85"></a><span id="l49.85">   // a zone 'chip' remembers no size, and so cannot be deallocated:</span>
<a href="#l49.86"></a><span id="l49.86">   newRow = (morkRow*) ioZone-&gt;ZoneNewChip(ev, sizeof(morkRow));</span>
<a href="#l49.87"></a><span id="l49.87"> #else /*morkZone_CONFIG_ARENA*/</span>
<a href="#l49.88"></a><span id="l49.88">   MORK_USED_1(ioZone);</span>
<a href="#l49.89"></a><span id="l49.89">   mPool_Heap-&gt;Alloc(ev-&gt;AsMdbEnv(), sizeof(morkRow), (void**) &amp;newRow);</span>
<a href="#l49.90"></a><span id="l49.90"> #endif /*morkZone_CONFIG_ARENA*/</span>
<a href="#l49.91"></a><span id="l49.91"> </span>
<a href="#l49.92"></a><span id="l49.92">   if ( newRow )</span>
<a href="#l49.93"></a><span id="l49.93">     MORK_MEMSET(newRow, 0, sizeof(morkRow));</span>
<a href="#l49.94"></a><span id="l49.94" class="difflineminus">-  </span>
<a href="#l49.95"></a><span id="l49.95" class="difflineplus">+</span>
<a href="#l49.96"></a><span id="l49.96">   return newRow;</span>
<a href="#l49.97"></a><span id="l49.97"> }</span>
<a href="#l49.98"></a><span id="l49.98"> </span>
<a href="#l49.99"></a><span id="l49.99"> void</span>
<a href="#l49.100"></a><span id="l49.100"> morkPool::ZapRow(morkEnv* ev, morkRow* ioRow,</span>
<a href="#l49.101"></a><span id="l49.101">   morkZone* ioZone) // free old row instance</span>
<a href="#l49.102"></a><span id="l49.102"> {</span>
<a href="#l49.103"></a><span id="l49.103"> #ifdef morkZone_CONFIG_ARENA</span>
<a href="#l49.104"></a><span id="l49.104" class="difflineat">@@ -236,17 +236,17 @@ morkPool::NewCells(morkEnv* ev, mork_siz</span>
<a href="#l49.105"></a><span id="l49.105"> #ifdef morkZone_CONFIG_ARENA</span>
<a href="#l49.106"></a><span id="l49.106">     // a zone 'run' knows its size, and can indeed be deallocated:</span>
<a href="#l49.107"></a><span id="l49.107">     newCells = (morkCell*) ioZone-&gt;ZoneNewRun(ev, size);</span>
<a href="#l49.108"></a><span id="l49.108"> #else /*morkZone_CONFIG_ARENA*/</span>
<a href="#l49.109"></a><span id="l49.109">     MORK_USED_1(ioZone);</span>
<a href="#l49.110"></a><span id="l49.110">     mPool_Heap-&gt;Alloc(ev-&gt;AsMdbEnv(), size, (void**) &amp;newCells);</span>
<a href="#l49.111"></a><span id="l49.111"> #endif /*morkZone_CONFIG_ARENA*/</span>
<a href="#l49.112"></a><span id="l49.112">   }</span>
<a href="#l49.113"></a><span id="l49.113" class="difflineminus">-    </span>
<a href="#l49.114"></a><span id="l49.114" class="difflineplus">+</span>
<a href="#l49.115"></a><span id="l49.115">   // note morkAtom depends on having nil stored in all new mCell_Atom slots:</span>
<a href="#l49.116"></a><span id="l49.116">   if ( newCells )</span>
<a href="#l49.117"></a><span id="l49.117">     MORK_MEMSET(newCells, 0, size);</span>
<a href="#l49.118"></a><span id="l49.118">   return newCells;</span>
<a href="#l49.119"></a><span id="l49.119"> }</span>
<a href="#l49.120"></a><span id="l49.120"> </span>
<a href="#l49.121"></a><span id="l49.121"> void</span>
<a href="#l49.122"></a><span id="l49.122"> morkPool::ZapCells(morkEnv* ev, morkCell* ioVector, mork_size inSize,</span>
<a href="#l49.123"></a><span id="l49.123" class="difflineat">@@ -290,17 +290,17 @@ morkPool::AddRowCells(morkEnv* ev, morkR</span>
<a href="#l49.124"></a><span id="l49.124">       while ( oldCells &lt; end )</span>
<a href="#l49.125"></a><span id="l49.125">       {</span>
<a href="#l49.126"></a><span id="l49.126">         *c++ = *oldCells++; // bitwise copy each old cell struct</span>
<a href="#l49.127"></a><span id="l49.127">       }</span>
<a href="#l49.128"></a><span id="l49.128">       oldCells = ioRow-&gt;mRow_Cells;</span>
<a href="#l49.129"></a><span id="l49.129">       ioRow-&gt;mRow_Cells = newCells;</span>
<a href="#l49.130"></a><span id="l49.130">       ioRow-&gt;mRow_Length = (mork_u2) inNewSize;</span>
<a href="#l49.131"></a><span id="l49.131">       ++ioRow-&gt;mRow_Seed;</span>
<a href="#l49.132"></a><span id="l49.132" class="difflineminus">-      </span>
<a href="#l49.133"></a><span id="l49.133" class="difflineplus">+</span>
<a href="#l49.134"></a><span id="l49.134">       if ( oldCells )</span>
<a href="#l49.135"></a><span id="l49.135">         this-&gt;ZapCells(ev, oldCells, fill, ioZone);</span>
<a href="#l49.136"></a><span id="l49.136">     }</span>
<a href="#l49.137"></a><span id="l49.137">   }</span>
<a href="#l49.138"></a><span id="l49.138">   return ( ev-&gt;Good() &amp;&amp; ioRow-&gt;mRow_Length &gt;= inNewSize );</span>
<a href="#l49.139"></a><span id="l49.139"> }</span>
<a href="#l49.140"></a><span id="l49.140"> </span>
<a href="#l49.141"></a><span id="l49.141"> mork_bool</span>
<a href="#l49.142"></a><span id="l49.142" class="difflineat">@@ -334,28 +334,28 @@ morkPool::CutRowCells(morkEnv* ev, morkR</span>
<a href="#l49.143"></a><span id="l49.143">           if ( oldCells-&gt;mCell_Atom ) // need to unref old cell atom?</span>
<a href="#l49.144"></a><span id="l49.144">             oldCells-&gt;SetAtom(ev, (morkAtom*) 0, this); // unref cell atom</span>
<a href="#l49.145"></a><span id="l49.145">           ++oldCells;</span>
<a href="#l49.146"></a><span id="l49.146">         }</span>
<a href="#l49.147"></a><span id="l49.147">         oldCells = ioRow-&gt;mRow_Cells;</span>
<a href="#l49.148"></a><span id="l49.148">         ioRow-&gt;mRow_Cells = saveNewCells;</span>
<a href="#l49.149"></a><span id="l49.149">         ioRow-&gt;mRow_Length = (mork_u2) inNewSize;</span>
<a href="#l49.150"></a><span id="l49.150">         ++ioRow-&gt;mRow_Seed;</span>
<a href="#l49.151"></a><span id="l49.151" class="difflineminus">-        </span>
<a href="#l49.152"></a><span id="l49.152" class="difflineplus">+</span>
<a href="#l49.153"></a><span id="l49.153">         if ( oldCells )</span>
<a href="#l49.154"></a><span id="l49.154">           this-&gt;ZapCells(ev, oldCells, fill, ioZone);</span>
<a href="#l49.155"></a><span id="l49.155">       }</span>
<a href="#l49.156"></a><span id="l49.156">     }</span>
<a href="#l49.157"></a><span id="l49.157">     else // get rid of all row cells</span>
<a href="#l49.158"></a><span id="l49.158">     {</span>
<a href="#l49.159"></a><span id="l49.159">       morkCell* oldCells = ioRow-&gt;mRow_Cells;</span>
<a href="#l49.160"></a><span id="l49.160">       ioRow-&gt;mRow_Cells = 0;</span>
<a href="#l49.161"></a><span id="l49.161">       ioRow-&gt;mRow_Length = 0;</span>
<a href="#l49.162"></a><span id="l49.162">       ++ioRow-&gt;mRow_Seed;</span>
<a href="#l49.163"></a><span id="l49.163" class="difflineminus">-      </span>
<a href="#l49.164"></a><span id="l49.164" class="difflineplus">+</span>
<a href="#l49.165"></a><span id="l49.165">       if ( oldCells )</span>
<a href="#l49.166"></a><span id="l49.166">         this-&gt;ZapCells(ev, oldCells, fill, ioZone);</span>
<a href="#l49.167"></a><span id="l49.167">     }</span>
<a href="#l49.168"></a><span id="l49.168">   }</span>
<a href="#l49.169"></a><span id="l49.169">   return ( ev-&gt;Good() &amp;&amp; ioRow-&gt;mRow_Length &lt;= inNewSize );</span>
<a href="#l49.170"></a><span id="l49.170"> }</span>
<a href="#l49.171"></a><span id="l49.171"> </span>
<a href="#l49.172"></a><span id="l49.172"> // alloc &amp; free individual instances of atoms (lots of atom subclasses):</span>
<a href="#l49.173"></a><span id="l49.173" class="difflineat">@@ -373,17 +373,17 @@ morkPool::ZapAtom(morkEnv* ev, morkAtom*</span>
<a href="#l49.174"></a><span id="l49.174"> #endif /*morkZone_CONFIG_ARENA*/</span>
<a href="#l49.175"></a><span id="l49.175"> }</span>
<a href="#l49.176"></a><span id="l49.176"> </span>
<a href="#l49.177"></a><span id="l49.177"> morkOidAtom*</span>
<a href="#l49.178"></a><span id="l49.178"> morkPool::NewRowOidAtom(morkEnv* ev, const mdbOid&amp; inOid,</span>
<a href="#l49.179"></a><span id="l49.179">   morkZone* ioZone)</span>
<a href="#l49.180"></a><span id="l49.180"> {</span>
<a href="#l49.181"></a><span id="l49.181">   morkOidAtom* newAtom = 0;</span>
<a href="#l49.182"></a><span id="l49.182" class="difflineminus">-  </span>
<a href="#l49.183"></a><span id="l49.183" class="difflineplus">+</span>
<a href="#l49.184"></a><span id="l49.184"> #ifdef morkZone_CONFIG_ARENA</span>
<a href="#l49.185"></a><span id="l49.185">   // a zone 'chip' remembers no size, and so cannot be deallocated:</span>
<a href="#l49.186"></a><span id="l49.186">   newAtom = (morkOidAtom*) ioZone-&gt;ZoneNewChip(ev, sizeof(morkOidAtom));</span>
<a href="#l49.187"></a><span id="l49.187"> #else /*morkZone_CONFIG_ARENA*/</span>
<a href="#l49.188"></a><span id="l49.188">   MORK_USED_1(ioZone);</span>
<a href="#l49.189"></a><span id="l49.189">   mPool_Heap-&gt;Alloc(ev-&gt;AsMdbEnv(), sizeof(morkOidAtom),(void**) &amp;newAtom);</span>
<a href="#l49.190"></a><span id="l49.190"> #endif /*morkZone_CONFIG_ARENA*/</span>
<a href="#l49.191"></a><span id="l49.191"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l50.1"></a><span id="l50.1" class="difflineminus">--- a/db/mork/src/morkPool.h</span>
<a href="#l50.2"></a><span id="l50.2" class="difflineplus">+++ b/db/mork/src/morkPool.h</span>
<a href="#l50.3"></a><span id="l50.3" class="difflineat">@@ -28,40 +28,40 @@ class morkFarBookAtom;</span>
<a href="#l50.4"></a><span id="l50.4"> </span>
<a href="#l50.5"></a><span id="l50.5"> #define morkDerived_kPool     /*i*/ 0x706C /* ascii 'pl' */</span>
<a href="#l50.6"></a><span id="l50.6"> </span>
<a href="#l50.7"></a><span id="l50.7"> /*| morkPool: a place to manage pools of non-node objects that are memory</span>
<a href="#l50.8"></a><span id="l50.8"> **| managed out of large chunks of space, so that per-object management</span>
<a href="#l50.9"></a><span id="l50.9"> **| space overhead has no signficant cost.</span>
<a href="#l50.10"></a><span id="l50.10"> |*/</span>
<a href="#l50.11"></a><span id="l50.11"> class morkPool : public morkNode {</span>
<a href="#l50.12"></a><span id="l50.12" class="difflineminus">-  </span>
<a href="#l50.13"></a><span id="l50.13" class="difflineplus">+</span>
<a href="#l50.14"></a><span id="l50.14"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l50.15"></a><span id="l50.15">   // nsIMdbHeap*       mNode_Heap;</span>
<a href="#l50.16"></a><span id="l50.16"> </span>
<a href="#l50.17"></a><span id="l50.17">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l50.18"></a><span id="l50.18">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l50.19"></a><span id="l50.19" class="difflineminus">-  </span>
<a href="#l50.20"></a><span id="l50.20" class="difflineplus">+</span>
<a href="#l50.21"></a><span id="l50.21">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l50.22"></a><span id="l50.22">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l50.23"></a><span id="l50.23">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l50.24"></a><span id="l50.24">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l50.25"></a><span id="l50.25" class="difflineminus">-  </span>
<a href="#l50.26"></a><span id="l50.26" class="difflineplus">+</span>
<a href="#l50.27"></a><span id="l50.27">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l50.28"></a><span id="l50.28">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l50.29"></a><span id="l50.29"> </span>
<a href="#l50.30"></a><span id="l50.30"> public: // state is public because the entire Mork system is private</span>
<a href="#l50.31"></a><span id="l50.31">   nsIMdbHeap*  mPool_Heap; // NON-refcounted heap instance</span>
<a href="#l50.32"></a><span id="l50.32" class="difflineminus">-  </span>
<a href="#l50.33"></a><span id="l50.33" class="difflineplus">+</span>
<a href="#l50.34"></a><span id="l50.34">   morkDeque    mPool_Blocks;      // linked list of large blocks from heap</span>
<a href="#l50.35"></a><span id="l50.35" class="difflineminus">-  </span>
<a href="#l50.36"></a><span id="l50.36" class="difflineplus">+</span>
<a href="#l50.37"></a><span id="l50.37">   // These two lists contain instances of morkHandleFrame:</span>
<a href="#l50.38"></a><span id="l50.38">   morkDeque    mPool_UsedHandleFrames; // handle frames currently being used</span>
<a href="#l50.39"></a><span id="l50.39">   morkDeque    mPool_FreeHandleFrames; // handle frames currently in free list</span>
<a href="#l50.40"></a><span id="l50.40" class="difflineminus">-  </span>
<a href="#l50.41"></a><span id="l50.41" class="difflineplus">+</span>
<a href="#l50.42"></a><span id="l50.42">   mork_count   mPool_UsedFramesCount; // length of mPool_UsedHandleFrames</span>
<a href="#l50.43"></a><span id="l50.43">   mork_count   mPool_FreeFramesCount; // length of mPool_UsedHandleFrames</span>
<a href="#l50.44"></a><span id="l50.44"> </span>
<a href="#l50.45"></a><span id="l50.45"> // { ===== begin morkNode interface =====</span>
<a href="#l50.46"></a><span id="l50.46"> public: // morkNode virtual methods</span>
<a href="#l50.47"></a><span id="l50.47">   virtual void CloseMorkNode(morkEnv* ev); // ClosePool() only if open</span>
<a href="#l50.48"></a><span id="l50.48">   virtual ~morkPool(); // assert that ClosePool() executed earlier</span>
<a href="#l50.49"></a><span id="l50.49"> </span>
<a href="#l50.50"></a><span id="l50.50" class="difflineat">@@ -82,70 +82,70 @@ public: // dynamic type identification</span>
<a href="#l50.51"></a><span id="l50.51"> // } ===== end morkNode methods =====</span>
<a href="#l50.52"></a><span id="l50.52"> </span>
<a href="#l50.53"></a><span id="l50.53"> public: // typing</span>
<a href="#l50.54"></a><span id="l50.54">   void NonPoolTypeError(morkEnv* ev);</span>
<a href="#l50.55"></a><span id="l50.55"> </span>
<a href="#l50.56"></a><span id="l50.56"> public: // morkNode memory management operators</span>
<a href="#l50.57"></a><span id="l50.57">   void* operator new(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev) CPP_THROW_NEW</span>
<a href="#l50.58"></a><span id="l50.58">   { return morkNode::MakeNew(inSize, ioHeap, ev); }</span>
<a href="#l50.59"></a><span id="l50.59" class="difflineminus">-  </span>
<a href="#l50.60"></a><span id="l50.60" class="difflineplus">+</span>
<a href="#l50.61"></a><span id="l50.61">   void* operator new(size_t inSize) CPP_THROW_NEW</span>
<a href="#l50.62"></a><span id="l50.62">   { return ::operator new(inSize); }</span>
<a href="#l50.63"></a><span id="l50.63" class="difflineminus">-  </span>
<a href="#l50.64"></a><span id="l50.64" class="difflineplus">+</span>
<a href="#l50.65"></a><span id="l50.65"> </span>
<a href="#l50.66"></a><span id="l50.66"> public: // other pool methods</span>
<a href="#l50.67"></a><span id="l50.67"> </span>
<a href="#l50.68"></a><span id="l50.68">   // alloc and free individual instances of handles (inside hand frames):</span>
<a href="#l50.69"></a><span id="l50.69">   morkHandleFace*  NewHandle(morkEnv* ev, mork_size inSize, morkZone* ioZone);</span>
<a href="#l50.70"></a><span id="l50.70">   void             ZapHandle(morkEnv* ev, morkHandleFace* ioHandle);</span>
<a href="#l50.71"></a><span id="l50.71"> </span>
<a href="#l50.72"></a><span id="l50.72">   // alloc and free individual instances of rows:</span>
<a href="#l50.73"></a><span id="l50.73">   morkRow*  NewRow(morkEnv* ev, morkZone* ioZone); // alloc new row instance</span>
<a href="#l50.74"></a><span id="l50.74">   void      ZapRow(morkEnv* ev, morkRow* ioRow, morkZone* ioZone); // free old row instance</span>
<a href="#l50.75"></a><span id="l50.75"> </span>
<a href="#l50.76"></a><span id="l50.76">   // alloc and free entire vectors of cells (not just one cell at a time)</span>
<a href="#l50.77"></a><span id="l50.77">   morkCell* NewCells(morkEnv* ev, mork_size inSize, morkZone* ioZone);</span>
<a href="#l50.78"></a><span id="l50.78">   void      ZapCells(morkEnv* ev, morkCell* ioVector, mork_size inSize, morkZone* ioZone);</span>
<a href="#l50.79"></a><span id="l50.79" class="difflineminus">-  </span>
<a href="#l50.80"></a><span id="l50.80" class="difflineplus">+</span>
<a href="#l50.81"></a><span id="l50.81">   // resize (grow or trim) cell vectors inside a containing row instance</span>
<a href="#l50.82"></a><span id="l50.82">   mork_bool AddRowCells(morkEnv* ev, morkRow* ioRow, mork_size inNewSize, morkZone* ioZone);</span>
<a href="#l50.83"></a><span id="l50.83">   mork_bool CutRowCells(morkEnv* ev, morkRow* ioRow, mork_size inNewSize, morkZone* ioZone);</span>
<a href="#l50.84"></a><span id="l50.84" class="difflineminus">-  </span>
<a href="#l50.85"></a><span id="l50.85" class="difflineplus">+</span>
<a href="#l50.86"></a><span id="l50.86">   // alloc &amp; free individual instances of atoms (lots of atom subclasses):</span>
<a href="#l50.87"></a><span id="l50.87">   void ZapAtom(morkEnv* ev, morkAtom* ioAtom, morkZone* ioZone); // any subclass (by kind)</span>
<a href="#l50.88"></a><span id="l50.88" class="difflineminus">-  </span>
<a href="#l50.89"></a><span id="l50.89" class="difflineminus">-  morkOidAtom* NewRowOidAtom(morkEnv* ev, const mdbOid&amp; inOid, morkZone* ioZone); </span>
<a href="#l50.90"></a><span id="l50.90" class="difflineplus">+</span>
<a href="#l50.91"></a><span id="l50.91" class="difflineplus">+  morkOidAtom* NewRowOidAtom(morkEnv* ev, const mdbOid&amp; inOid, morkZone* ioZone);</span>
<a href="#l50.92"></a><span id="l50.92">   morkOidAtom* NewTableOidAtom(morkEnv* ev, const mdbOid&amp; inOid, morkZone* ioZone);</span>
<a href="#l50.93"></a><span id="l50.93" class="difflineminus">-  </span>
<a href="#l50.94"></a><span id="l50.94" class="difflineplus">+</span>
<a href="#l50.95"></a><span id="l50.95">   morkAtom* NewAnonAtom(morkEnv* ev, const morkBuf&amp; inBuf,</span>
<a href="#l50.96"></a><span id="l50.96">     mork_cscode inForm, morkZone* ioZone);</span>
<a href="#l50.97"></a><span id="l50.97">     // if inForm is zero, and inBuf.mBuf_Fill is less than 256, then a 'wee'</span>
<a href="#l50.98"></a><span id="l50.98">     // anon atom will be created, and otherwise a 'big' anon atom.</span>
<a href="#l50.99"></a><span id="l50.99" class="difflineminus">-    </span>
<a href="#l50.100"></a><span id="l50.100" class="difflineplus">+</span>
<a href="#l50.101"></a><span id="l50.101">   morkBookAtom* NewBookAtom(morkEnv* ev, const morkBuf&amp; inBuf,</span>
<a href="#l50.102"></a><span id="l50.102">     mork_cscode inForm, morkAtomSpace* ioSpace, mork_aid inAid, morkZone* ioZone);</span>
<a href="#l50.103"></a><span id="l50.103">     // if inForm is zero, and inBuf.mBuf_Fill is less than 256, then a 'wee'</span>
<a href="#l50.104"></a><span id="l50.104">     // book atom will be created, and otherwise a 'big' book atom.</span>
<a href="#l50.105"></a><span id="l50.105" class="difflineminus">-    </span>
<a href="#l50.106"></a><span id="l50.106" class="difflineplus">+</span>
<a href="#l50.107"></a><span id="l50.107">   morkBookAtom* NewBookAtomCopy(morkEnv* ev, const morkBigBookAtom&amp; inAtom, morkZone* ioZone);</span>
<a href="#l50.108"></a><span id="l50.108">     // make the smallest kind of book atom that can hold content in inAtom.</span>
<a href="#l50.109"></a><span id="l50.109">     // The inAtom parameter is often expected to be a staged book atom in</span>
<a href="#l50.110"></a><span id="l50.110">     // the store, which was used to search an atom space for existing atoms.</span>
<a href="#l50.111"></a><span id="l50.111" class="difflineminus">-    </span>
<a href="#l50.112"></a><span id="l50.112" class="difflineplus">+</span>
<a href="#l50.113"></a><span id="l50.113">   morkBookAtom* NewFarBookAtomCopy(morkEnv* ev, const morkFarBookAtom&amp; inAtom, morkZone* ioZone);</span>
<a href="#l50.114"></a><span id="l50.114">     // make the smallest kind of book atom that can hold content in inAtom.</span>
<a href="#l50.115"></a><span id="l50.115">     // The inAtom parameter is often expected to be a staged book atom in</span>
<a href="#l50.116"></a><span id="l50.116">     // the store, which was used to search an atom space for existing atoms.</span>
<a href="#l50.117"></a><span id="l50.117"> </span>
<a href="#l50.118"></a><span id="l50.118"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l50.119"></a><span id="l50.119">   static void SlotWeakPool(morkPool* me,</span>
<a href="#l50.120"></a><span id="l50.120">     morkEnv* ev, morkPool** ioSlot)</span>
<a href="#l50.121"></a><span id="l50.121">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l50.122"></a><span id="l50.122" class="difflineminus">-  </span>
<a href="#l50.123"></a><span id="l50.123" class="difflineplus">+</span>
<a href="#l50.124"></a><span id="l50.124">   static void SlotStrongPool(morkPool* me,</span>
<a href="#l50.125"></a><span id="l50.125">     morkEnv* ev, morkPool** ioSlot)</span>
<a href="#l50.126"></a><span id="l50.126">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l50.127"></a><span id="l50.127"> };</span>
<a href="#l50.128"></a><span id="l50.128"> </span>
<a href="#l50.129"></a><span id="l50.129"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l50.130"></a><span id="l50.130"> </span>
<a href="#l50.131"></a><span id="l50.131"> #endif /* _MORKPOOL_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l51.1"></a><span id="l51.1" class="difflineminus">--- a/db/mork/src/morkPortTableCursor.cpp</span>
<a href="#l51.2"></a><span id="l51.2" class="difflineplus">+++ b/db/mork/src/morkPortTableCursor.cpp</span>
<a href="#l51.3"></a><span id="l51.3" class="difflineat">@@ -28,17 +28,17 @@</span>
<a href="#l51.4"></a><span id="l51.4"> #endif</span>
<a href="#l51.5"></a><span id="l51.5"> </span>
<a href="#l51.6"></a><span id="l51.6"> #ifndef _MORKSTORE_</span>
<a href="#l51.7"></a><span id="l51.7"> #include &quot;morkStore.h&quot;</span>
<a href="#l51.8"></a><span id="l51.8"> #endif</span>
<a href="#l51.9"></a><span id="l51.9"> </span>
<a href="#l51.10"></a><span id="l51.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l51.11"></a><span id="l51.11"> </span>
<a href="#l51.12"></a><span id="l51.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l51.13"></a><span id="l51.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l51.14"></a><span id="l51.14"> // { ===== begin morkNode interface =====</span>
<a href="#l51.15"></a><span id="l51.15"> </span>
<a href="#l51.16"></a><span id="l51.16"> /*public virtual*/ void</span>
<a href="#l51.17"></a><span id="l51.17"> morkPortTableCursor::CloseMorkNode(morkEnv* ev) // ClosePortTableCursor() only if open</span>
<a href="#l51.18"></a><span id="l51.18"> {</span>
<a href="#l51.19"></a><span id="l51.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l51.20"></a><span id="l51.20">   {</span>
<a href="#l51.21"></a><span id="l51.21">     this-&gt;MarkClosing();</span>
<a href="#l51.22"></a><span id="l51.22" class="difflineat">@@ -72,17 +72,17 @@ morkPortTableCursor::morkPortTableCursor</span>
<a href="#l51.23"></a><span id="l51.23">     if ( ioStore &amp;&amp; ioSlotHeap )</span>
<a href="#l51.24"></a><span id="l51.24">     {</span>
<a href="#l51.25"></a><span id="l51.25">       mCursor_Pos = -1;</span>
<a href="#l51.26"></a><span id="l51.26">       mCursor_Seed = 0; // let the iterator do its own seed handling</span>
<a href="#l51.27"></a><span id="l51.27">       morkStore::SlotWeakStore(ioStore, ev, &amp;mPortTableCursor_Store);</span>
<a href="#l51.28"></a><span id="l51.28"> </span>
<a href="#l51.29"></a><span id="l51.29">       if ( this-&gt;SetRowScope(ev, inRowScope) )</span>
<a href="#l51.30"></a><span id="l51.30">         this-&gt;SetTableKind(ev, inTableKind);</span>
<a href="#l51.31"></a><span id="l51.31" class="difflineminus">-        </span>
<a href="#l51.32"></a><span id="l51.32" class="difflineplus">+</span>
<a href="#l51.33"></a><span id="l51.33">       if ( ev-&gt;Good() )</span>
<a href="#l51.34"></a><span id="l51.34">         mNode_Derived = morkDerived_kPortTableCursor;</span>
<a href="#l51.35"></a><span id="l51.35">     }</span>
<a href="#l51.36"></a><span id="l51.36">     else</span>
<a href="#l51.37"></a><span id="l51.37">       ev-&gt;NilPointerError();</span>
<a href="#l51.38"></a><span id="l51.38">   }</span>
<a href="#l51.39"></a><span id="l51.39"> }</span>
<a href="#l51.40"></a><span id="l51.40"> </span>
<a href="#l51.41"></a><span id="l51.41" class="difflineat">@@ -103,17 +103,17 @@ morkPortTableCursor::CanUsePortTableCurs</span>
<a href="#l51.42"></a><span id="l51.42">     *outErr = ev-&gt;AsErr();</span>
<a href="#l51.43"></a><span id="l51.43">   }</span>
<a href="#l51.44"></a><span id="l51.44">   MORK_ASSERT(outEnv);</span>
<a href="#l51.45"></a><span id="l51.45">   return outEnv;</span>
<a href="#l51.46"></a><span id="l51.46"> }</span>
<a href="#l51.47"></a><span id="l51.47"> </span>
<a href="#l51.48"></a><span id="l51.48"> </span>
<a href="#l51.49"></a><span id="l51.49"> /*public non-poly*/ void</span>
<a href="#l51.50"></a><span id="l51.50" class="difflineminus">-morkPortTableCursor::ClosePortTableCursor(morkEnv* ev) </span>
<a href="#l51.51"></a><span id="l51.51" class="difflineplus">+morkPortTableCursor::ClosePortTableCursor(morkEnv* ev)</span>
<a href="#l51.52"></a><span id="l51.52"> {</span>
<a href="#l51.53"></a><span id="l51.53">     if ( this-&gt;IsNode() )</span>
<a href="#l51.54"></a><span id="l51.54">     {</span>
<a href="#l51.55"></a><span id="l51.55">       mCursor_Pos = -1;</span>
<a href="#l51.56"></a><span id="l51.56">       mCursor_Seed = 0;</span>
<a href="#l51.57"></a><span id="l51.57">       mPortTableCursor_LastTable = 0;</span>
<a href="#l51.58"></a><span id="l51.58">       morkStore::SlotWeakStore((morkStore*) 0, ev, &amp;mPortTableCursor_Store);</span>
<a href="#l51.59"></a><span id="l51.59">       morkRowSpace::SlotStrongRowSpace((morkRowSpace*) 0, ev,</span>
<a href="#l51.60"></a><span id="l51.60" class="difflineat">@@ -121,73 +121,73 @@ morkPortTableCursor::ClosePortTableCurso</span>
<a href="#l51.61"></a><span id="l51.61">       this-&gt;CloseCursor(ev);</span>
<a href="#l51.62"></a><span id="l51.62">       this-&gt;MarkShut();</span>
<a href="#l51.63"></a><span id="l51.63">     }</span>
<a href="#l51.64"></a><span id="l51.64">     else</span>
<a href="#l51.65"></a><span id="l51.65">       this-&gt;NonNodeError(ev);</span>
<a href="#l51.66"></a><span id="l51.66"> }</span>
<a href="#l51.67"></a><span id="l51.67"> </span>
<a href="#l51.68"></a><span id="l51.68"> // } ===== end morkNode methods =====</span>
<a href="#l51.69"></a><span id="l51.69" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l51.70"></a><span id="l51.70" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l51.71"></a><span id="l51.71"> </span>
<a href="#l51.72"></a><span id="l51.72"> /*static*/ void</span>
<a href="#l51.73"></a><span id="l51.73"> morkPortTableCursor::NilCursorStoreError(morkEnv* ev)</span>
<a href="#l51.74"></a><span id="l51.74"> {</span>
<a href="#l51.75"></a><span id="l51.75">   ev-&gt;NewError(&quot;nil mPortTableCursor_Store&quot;);</span>
<a href="#l51.76"></a><span id="l51.76"> }</span>
<a href="#l51.77"></a><span id="l51.77"> </span>
<a href="#l51.78"></a><span id="l51.78"> /*static*/ void</span>
<a href="#l51.79"></a><span id="l51.79"> morkPortTableCursor::NonPortTableCursorTypeError(morkEnv* ev)</span>
<a href="#l51.80"></a><span id="l51.80"> {</span>
<a href="#l51.81"></a><span id="l51.81">   ev-&gt;NewError(&quot;non morkPortTableCursor&quot;);</span>
<a href="#l51.82"></a><span id="l51.82"> }</span>
<a href="#l51.83"></a><span id="l51.83"> </span>
<a href="#l51.84"></a><span id="l51.84" class="difflineminus">-mork_bool </span>
<a href="#l51.85"></a><span id="l51.85" class="difflineplus">+mork_bool</span>
<a href="#l51.86"></a><span id="l51.86"> morkPortTableCursor::SetRowScope(morkEnv* ev, mork_scope inRowScope)</span>
<a href="#l51.87"></a><span id="l51.87"> {</span>
<a href="#l51.88"></a><span id="l51.88">   mPortTableCursor_RowScope = inRowScope;</span>
<a href="#l51.89"></a><span id="l51.89">   mPortTableCursor_LastTable = 0; // restart iteration of space</span>
<a href="#l51.90"></a><span id="l51.90" class="difflineminus">-  </span>
<a href="#l51.91"></a><span id="l51.91" class="difflineplus">+</span>
<a href="#l51.92"></a><span id="l51.92">   mPortTableCursor_TableIter.CloseMapIter(ev);</span>
<a href="#l51.93"></a><span id="l51.93">   mPortTableCursor_TablesDidEnd = morkBool_kTrue;</span>
<a href="#l51.94"></a><span id="l51.94">   mPortTableCursor_SpacesDidEnd = morkBool_kTrue;</span>
<a href="#l51.95"></a><span id="l51.95" class="difflineminus">-  </span>
<a href="#l51.96"></a><span id="l51.96" class="difflineplus">+</span>
<a href="#l51.97"></a><span id="l51.97">   morkStore* store = mPortTableCursor_Store;</span>
<a href="#l51.98"></a><span id="l51.98">   if ( store )</span>
<a href="#l51.99"></a><span id="l51.99">   {</span>
<a href="#l51.100"></a><span id="l51.100">     morkRowSpace* space = mPortTableCursor_RowSpace;</span>
<a href="#l51.101"></a><span id="l51.101"> </span>
<a href="#l51.102"></a><span id="l51.102">     if ( inRowScope ) // intend to cover a specific scope only?</span>
<a href="#l51.103"></a><span id="l51.103">     {</span>
<a href="#l51.104"></a><span id="l51.104">       space = store-&gt;LazyGetRowSpace(ev, inRowScope);</span>
<a href="#l51.105"></a><span id="l51.105" class="difflineminus">-      morkRowSpace::SlotStrongRowSpace(space, ev, </span>
<a href="#l51.106"></a><span id="l51.106" class="difflineplus">+      morkRowSpace::SlotStrongRowSpace(space, ev,</span>
<a href="#l51.107"></a><span id="l51.107">        &amp;mPortTableCursor_RowSpace);</span>
<a href="#l51.108"></a><span id="l51.108" class="difflineminus">-       </span>
<a href="#l51.109"></a><span id="l51.109" class="difflineplus">+</span>
<a href="#l51.110"></a><span id="l51.110">       // We want mPortTableCursor_SpacesDidEnd == morkBool_kTrue</span>
<a href="#l51.111"></a><span id="l51.111">       // to show this is the only space to be covered.</span>
<a href="#l51.112"></a><span id="l51.112">     }</span>
<a href="#l51.113"></a><span id="l51.113">     else // prepare space map iter to cover all space scopes</span>
<a href="#l51.114"></a><span id="l51.114">     {</span>
<a href="#l51.115"></a><span id="l51.115">       morkRowSpaceMapIter* rsi = &amp;mPortTableCursor_SpaceIter;</span>
<a href="#l51.116"></a><span id="l51.116">       rsi-&gt;InitRowSpaceMapIter(ev, &amp;store-&gt;mStore_RowSpaces);</span>
<a href="#l51.117"></a><span id="l51.117" class="difflineminus">-      </span>
<a href="#l51.118"></a><span id="l51.118" class="difflineplus">+</span>
<a href="#l51.119"></a><span id="l51.119">       space = 0;</span>
<a href="#l51.120"></a><span id="l51.120">       (void) rsi-&gt;FirstRowSpace(ev, (mork_scope*) 0, &amp;space);</span>
<a href="#l51.121"></a><span id="l51.121">       morkRowSpace::SlotStrongRowSpace(space, ev,</span>
<a href="#l51.122"></a><span id="l51.122">         &amp;mPortTableCursor_RowSpace);</span>
<a href="#l51.123"></a><span id="l51.123" class="difflineminus">-        </span>
<a href="#l51.124"></a><span id="l51.124" class="difflineplus">+</span>
<a href="#l51.125"></a><span id="l51.125">       if ( space ) // found first space in store</span>
<a href="#l51.126"></a><span id="l51.126">         mPortTableCursor_SpacesDidEnd = morkBool_kFalse;</span>
<a href="#l51.127"></a><span id="l51.127">     }</span>
<a href="#l51.128"></a><span id="l51.128"> </span>
<a href="#l51.129"></a><span id="l51.129">     this-&gt;init_space_tables_map(ev);</span>
<a href="#l51.130"></a><span id="l51.130">   }</span>
<a href="#l51.131"></a><span id="l51.131">   else</span>
<a href="#l51.132"></a><span id="l51.132">     this-&gt;NilCursorStoreError(ev);</span>
<a href="#l51.133"></a><span id="l51.133" class="difflineminus">-    </span>
<a href="#l51.134"></a><span id="l51.134" class="difflineplus">+</span>
<a href="#l51.135"></a><span id="l51.135">   return ev-&gt;Good();</span>
<a href="#l51.136"></a><span id="l51.136"> }</span>
<a href="#l51.137"></a><span id="l51.137"> </span>
<a href="#l51.138"></a><span id="l51.138"> void</span>
<a href="#l51.139"></a><span id="l51.139"> morkPortTableCursor::init_space_tables_map(morkEnv* ev)</span>
<a href="#l51.140"></a><span id="l51.140"> {</span>
<a href="#l51.141"></a><span id="l51.141">   morkRowSpace* space = mPortTableCursor_RowSpace;</span>
<a href="#l51.142"></a><span id="l51.142">   if ( space &amp;&amp; ev-&gt;Good() )</span>
<a href="#l51.143"></a><span id="l51.143" class="difflineat">@@ -231,54 +231,54 @@ morkPortTableCursor::NextSpace(morkEnv* </span>
<a href="#l51.144"></a><span id="l51.144">     morkStore* store = mPortTableCursor_Store;</span>
<a href="#l51.145"></a><span id="l51.145">     if ( store )</span>
<a href="#l51.146"></a><span id="l51.146">     {</span>
<a href="#l51.147"></a><span id="l51.147">       morkRowSpaceMapIter* rsi = &amp;mPortTableCursor_SpaceIter;</span>
<a href="#l51.148"></a><span id="l51.148"> </span>
<a href="#l51.149"></a><span id="l51.149">       (void) rsi-&gt;NextRowSpace(ev, (mork_scope*) 0, &amp;outSpace);</span>
<a href="#l51.150"></a><span id="l51.150">       morkRowSpace::SlotStrongRowSpace(outSpace, ev,</span>
<a href="#l51.151"></a><span id="l51.151">         &amp;mPortTableCursor_RowSpace);</span>
<a href="#l51.152"></a><span id="l51.152" class="difflineminus">-        </span>
<a href="#l51.153"></a><span id="l51.153" class="difflineplus">+</span>
<a href="#l51.154"></a><span id="l51.154">       if ( outSpace ) // found next space in store</span>
<a href="#l51.155"></a><span id="l51.155">       {</span>
<a href="#l51.156"></a><span id="l51.156">         mPortTableCursor_SpacesDidEnd = morkBool_kFalse;</span>
<a href="#l51.157"></a><span id="l51.157" class="difflineminus">-        </span>
<a href="#l51.158"></a><span id="l51.158" class="difflineplus">+</span>
<a href="#l51.159"></a><span id="l51.159">         this-&gt;init_space_tables_map(ev);</span>
<a href="#l51.160"></a><span id="l51.160"> </span>
<a href="#l51.161"></a><span id="l51.161">         if ( ev-&gt;Bad() )</span>
<a href="#l51.162"></a><span id="l51.162">           outSpace = 0;</span>
<a href="#l51.163"></a><span id="l51.163">       }</span>
<a href="#l51.164"></a><span id="l51.164">     }</span>
<a href="#l51.165"></a><span id="l51.165">     else</span>
<a href="#l51.166"></a><span id="l51.166">       this-&gt;NilCursorStoreError(ev);</span>
<a href="#l51.167"></a><span id="l51.167">   }</span>
<a href="#l51.168"></a><span id="l51.168" class="difflineminus">-    </span>
<a href="#l51.169"></a><span id="l51.169" class="difflineplus">+</span>
<a href="#l51.170"></a><span id="l51.170">   return outSpace;</span>
<a href="#l51.171"></a><span id="l51.171"> }</span>
<a href="#l51.172"></a><span id="l51.172"> </span>
<a href="#l51.173"></a><span id="l51.173"> morkTable *</span>
<a href="#l51.174"></a><span id="l51.174"> morkPortTableCursor::NextTable(morkEnv* ev)</span>
<a href="#l51.175"></a><span id="l51.175"> {</span>
<a href="#l51.176"></a><span id="l51.176">   mork_kind kind = mPortTableCursor_TableKind;</span>
<a href="#l51.177"></a><span id="l51.177" class="difflineminus">-  </span>
<a href="#l51.178"></a><span id="l51.178" class="difflineplus">+</span>
<a href="#l51.179"></a><span id="l51.179">   do // until spaces end, or until we find a table in a space</span>
<a href="#l51.180"></a><span id="l51.180" class="difflineminus">-  { </span>
<a href="#l51.181"></a><span id="l51.181" class="difflineplus">+  {</span>
<a href="#l51.182"></a><span id="l51.182">     morkRowSpace* space = mPortTableCursor_RowSpace;</span>
<a href="#l51.183"></a><span id="l51.183">     if ( mPortTableCursor_TablesDidEnd ) // current space exhausted?</span>
<a href="#l51.184"></a><span id="l51.184">       space = this-&gt;NextSpace(ev); // go on to the next space</span>
<a href="#l51.185"></a><span id="l51.185" class="difflineminus">-      </span>
<a href="#l51.186"></a><span id="l51.186" class="difflineplus">+</span>
<a href="#l51.187"></a><span id="l51.187">     if ( space ) // have a space remaining that might hold tables?</span>
<a href="#l51.188"></a><span id="l51.188">     {</span>
<a href="#l51.189"></a><span id="l51.189"> #ifdef MORK_BEAD_OVER_NODE_MAPS</span>
<a href="#l51.190"></a><span id="l51.190">       morkTableMapIter* ti = &amp;mPortTableCursor_TableIter;</span>
<a href="#l51.191"></a><span id="l51.191">       morkTable* table = ( mPortTableCursor_LastTable )?</span>
<a href="#l51.192"></a><span id="l51.192">         ti-&gt;NextTable(ev) : ti-&gt;FirstTable(ev);</span>
<a href="#l51.193"></a><span id="l51.193"> </span>
<a href="#l51.194"></a><span id="l51.194">       for ( ; table &amp;&amp; ev-&gt;Good(); table = ti-&gt;NextTable(ev) )</span>
<a href="#l51.195"></a><span id="l51.195" class="difflineminus">-      </span>
<a href="#l51.196"></a><span id="l51.196" class="difflineplus">+</span>
<a href="#l51.197"></a><span id="l51.197"> #else /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l51.198"></a><span id="l51.198">       mork_tid* key = 0; // ignore keys in table map</span>
<a href="#l51.199"></a><span id="l51.199">       morkTable* table = 0; // old value table in the map</span>
<a href="#l51.200"></a><span id="l51.200">       morkTableMapIter* ti = &amp;mPortTableCursor_TableIter;</span>
<a href="#l51.201"></a><span id="l51.201">       mork_change* c = ( mPortTableCursor_LastTable )?</span>
<a href="#l51.202"></a><span id="l51.202">         ti-&gt;NextTable(ev, key, &amp;table) : ti-&gt;FirstTable(ev, key, &amp;table);</span>
<a href="#l51.203"></a><span id="l51.203"> </span>
<a href="#l51.204"></a><span id="l51.204">       for ( ; c &amp;&amp; ev-&gt;Good(); c = ti-&gt;NextTable(ev, key, &amp;table) )</span>
<a href="#l51.205"></a><span id="l51.205" class="difflineat">@@ -293,17 +293,17 @@ morkPortTableCursor::NextTable(morkEnv* </span>
<a href="#l51.206"></a><span id="l51.206">           }</span>
<a href="#l51.207"></a><span id="l51.207">         }</span>
<a href="#l51.208"></a><span id="l51.208">         else</span>
<a href="#l51.209"></a><span id="l51.209">           table-&gt;NonTableTypeWarning(ev);</span>
<a href="#l51.210"></a><span id="l51.210">       }</span>
<a href="#l51.211"></a><span id="l51.211">       mPortTableCursor_TablesDidEnd = morkBool_kTrue; // space is done</span>
<a href="#l51.212"></a><span id="l51.212">       mPortTableCursor_LastTable = 0; // make sure next space starts fresh</span>
<a href="#l51.213"></a><span id="l51.213">     }</span>
<a href="#l51.214"></a><span id="l51.214" class="difflineminus">-  </span>
<a href="#l51.215"></a><span id="l51.215" class="difflineplus">+</span>
<a href="#l51.216"></a><span id="l51.216">   } while ( ev-&gt;Good() &amp;&amp; !mPortTableCursor_SpacesDidEnd );</span>
<a href="#l51.217"></a><span id="l51.217"> </span>
<a href="#l51.218"></a><span id="l51.218">   return (morkTable*) 0;</span>
<a href="#l51.219"></a><span id="l51.219"> }</span>
<a href="#l51.220"></a><span id="l51.220"> </span>
<a href="#l51.221"></a><span id="l51.221"> </span>
<a href="#l51.222"></a><span id="l51.222"> // { ----- begin table iteration methods -----</span>
<a href="#l51.223"></a><span id="l51.223"> </span>
<a href="#l51.224"></a><span id="l51.224" class="difflineat">@@ -340,17 +340,17 @@ morkPortTableCursor::SetRowScope(nsIMdbE</span>
<a href="#l51.225"></a><span id="l51.225">   mdb_scope inRowScope)</span>
<a href="#l51.226"></a><span id="l51.226"> {</span>
<a href="#l51.227"></a><span id="l51.227">   nsresult outErr = NS_OK;</span>
<a href="#l51.228"></a><span id="l51.228">   morkEnv* ev =</span>
<a href="#l51.229"></a><span id="l51.229">     this-&gt;CanUsePortTableCursor(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l51.230"></a><span id="l51.230">   if ( ev )</span>
<a href="#l51.231"></a><span id="l51.231">   {</span>
<a href="#l51.232"></a><span id="l51.232">     mCursor_Pos = -1;</span>
<a href="#l51.233"></a><span id="l51.233" class="difflineminus">-    </span>
<a href="#l51.234"></a><span id="l51.234" class="difflineplus">+</span>
<a href="#l51.235"></a><span id="l51.235">     SetRowScope(ev, inRowScope);</span>
<a href="#l51.236"></a><span id="l51.236">     outErr = ev-&gt;AsErr();</span>
<a href="#l51.237"></a><span id="l51.237">   }</span>
<a href="#l51.238"></a><span id="l51.238">   return outErr;</span>
<a href="#l51.239"></a><span id="l51.239"> }</span>
<a href="#l51.240"></a><span id="l51.240"> </span>
<a href="#l51.241"></a><span id="l51.241"> NS_IMETHODIMP</span>
<a href="#l51.242"></a><span id="l51.242"> morkPortTableCursor::GetRowScope(nsIMdbEnv* mev, mdb_scope* outRowScope)</span>
<a href="#l51.243"></a><span id="l51.243" class="difflineat">@@ -363,28 +363,28 @@ morkPortTableCursor::GetRowScope(nsIMdbE</span>
<a href="#l51.244"></a><span id="l51.244">   {</span>
<a href="#l51.245"></a><span id="l51.245">     rowScope = mPortTableCursor_RowScope;</span>
<a href="#l51.246"></a><span id="l51.246">     outErr = ev-&gt;AsErr();</span>
<a href="#l51.247"></a><span id="l51.247">   }</span>
<a href="#l51.248"></a><span id="l51.248">   *outRowScope = rowScope;</span>
<a href="#l51.249"></a><span id="l51.249">   return outErr;</span>
<a href="#l51.250"></a><span id="l51.250"> }</span>
<a href="#l51.251"></a><span id="l51.251"> // setting row scope to zero iterates over all row scopes in port</span>
<a href="#l51.252"></a><span id="l51.252" class="difflineminus">-  </span>
<a href="#l51.253"></a><span id="l51.253" class="difflineplus">+</span>
<a href="#l51.254"></a><span id="l51.254"> NS_IMETHODIMP</span>
<a href="#l51.255"></a><span id="l51.255"> morkPortTableCursor::SetTableKind(nsIMdbEnv* mev, // sets pos to -1</span>
<a href="#l51.256"></a><span id="l51.256">   mdb_kind inTableKind)</span>
<a href="#l51.257"></a><span id="l51.257"> {</span>
<a href="#l51.258"></a><span id="l51.258">   nsresult outErr = NS_OK;</span>
<a href="#l51.259"></a><span id="l51.259">   morkEnv* ev =</span>
<a href="#l51.260"></a><span id="l51.260">     this-&gt;CanUsePortTableCursor(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l51.261"></a><span id="l51.261">   if ( ev )</span>
<a href="#l51.262"></a><span id="l51.262">   {</span>
<a href="#l51.263"></a><span id="l51.263">     mCursor_Pos = -1;</span>
<a href="#l51.264"></a><span id="l51.264" class="difflineminus">-    </span>
<a href="#l51.265"></a><span id="l51.265" class="difflineplus">+</span>
<a href="#l51.266"></a><span id="l51.266">     SetTableKind(ev, inTableKind);</span>
<a href="#l51.267"></a><span id="l51.267">     outErr = ev-&gt;AsErr();</span>
<a href="#l51.268"></a><span id="l51.268">   }</span>
<a href="#l51.269"></a><span id="l51.269">   return outErr;</span>
<a href="#l51.270"></a><span id="l51.270"> }</span>
<a href="#l51.271"></a><span id="l51.271"> </span>
<a href="#l51.272"></a><span id="l51.272"> NS_IMETHODIMP</span>
<a href="#l51.273"></a><span id="l51.273"> morkPortTableCursor::GetTableKind(nsIMdbEnv* mev, mdb_kind* outTableKind)</span>
<a href="#l51.274"></a><span id="l51.274" class="difflineat">@@ -414,17 +414,17 @@ morkPortTableCursor::NextTable( // get t</span>
<a href="#l51.275"></a><span id="l51.275">   nsIMdbTable* outTable = 0;</span>
<a href="#l51.276"></a><span id="l51.276">   morkEnv* ev =</span>
<a href="#l51.277"></a><span id="l51.277">     CanUsePortTableCursor(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l51.278"></a><span id="l51.278">   if ( ev )</span>
<a href="#l51.279"></a><span id="l51.279">   {</span>
<a href="#l51.280"></a><span id="l51.280">     morkTable* table = NextTable(ev);</span>
<a href="#l51.281"></a><span id="l51.281">     if ( table &amp;&amp; ev-&gt;Good() )</span>
<a href="#l51.282"></a><span id="l51.282">       outTable = table-&gt;AcquireTableHandle(ev);</span>
<a href="#l51.283"></a><span id="l51.283" class="difflineminus">-        </span>
<a href="#l51.284"></a><span id="l51.284" class="difflineplus">+</span>
<a href="#l51.285"></a><span id="l51.285">     outErr = ev-&gt;AsErr();</span>
<a href="#l51.286"></a><span id="l51.286">   }</span>
<a href="#l51.287"></a><span id="l51.287">   if ( acqTable )</span>
<a href="#l51.288"></a><span id="l51.288">     *acqTable = outTable;</span>
<a href="#l51.289"></a><span id="l51.289">   return outErr;</span>
<a href="#l51.290"></a><span id="l51.290"> }</span>
<a href="#l51.291"></a><span id="l51.291"> </span>
<a href="#l51.292"></a><span id="l51.292"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l52.1"></a><span id="l52.1" class="difflineminus">--- a/db/mork/src/morkPortTableCursor.h</span>
<a href="#l52.2"></a><span id="l52.2" class="difflineplus">+++ b/db/mork/src/morkPortTableCursor.h</span>
<a href="#l52.3"></a><span id="l52.3" class="difflineat">@@ -61,35 +61,35 @@ public: // state is public because the e</span>
<a href="#l52.4"></a><span id="l52.4">   // } ----- end attribute methods -----</span>
<a href="#l52.5"></a><span id="l52.5"> </span>
<a href="#l52.6"></a><span id="l52.6">   // { ----- begin table iteration methods -----</span>
<a href="#l52.7"></a><span id="l52.7">   NS_IMETHOD NextTable( // get table at next position in the db</span>
<a href="#l52.8"></a><span id="l52.8">     nsIMdbEnv* ev, // context</span>
<a href="#l52.9"></a><span id="l52.9">     nsIMdbTable** acqTable) override; // the next table in the iteration</span>
<a href="#l52.10"></a><span id="l52.10">   // } ----- end table iteration methods -----</span>
<a href="#l52.11"></a><span id="l52.11">   morkStore*    mPortTableCursor_Store;  // weak ref to store</span>
<a href="#l52.12"></a><span id="l52.12" class="difflineminus">-  </span>
<a href="#l52.13"></a><span id="l52.13" class="difflineplus">+</span>
<a href="#l52.14"></a><span id="l52.14">   mdb_scope     mPortTableCursor_RowScope;</span>
<a href="#l52.15"></a><span id="l52.15">   mdb_kind      mPortTableCursor_TableKind;</span>
<a href="#l52.16"></a><span id="l52.16" class="difflineminus">-  </span>
<a href="#l52.17"></a><span id="l52.17" class="difflineplus">+</span>
<a href="#l52.18"></a><span id="l52.18">   // We only care if LastTable is non-nil, so it is not refcounted;</span>
<a href="#l52.19"></a><span id="l52.19">   // so you must never access table state or methods using LastTable:</span>
<a href="#l52.20"></a><span id="l52.20" class="difflineminus">-  </span>
<a href="#l52.21"></a><span id="l52.21" class="difflineplus">+</span>
<a href="#l52.22"></a><span id="l52.22">   morkTable* mPortTableCursor_LastTable; // nil or last table (no refcount)</span>
<a href="#l52.23"></a><span id="l52.23">   morkRowSpace* mPortTableCursor_RowSpace; // current space (strong ref)</span>
<a href="#l52.24"></a><span id="l52.24"> </span>
<a href="#l52.25"></a><span id="l52.25">   morkRowSpaceMapIter mPortTableCursor_SpaceIter; // iter over spaces</span>
<a href="#l52.26"></a><span id="l52.26" class="difflineminus">-  morkTableMapIter    mPortTableCursor_TableIter; // iter over tables </span>
<a href="#l52.27"></a><span id="l52.27" class="difflineminus">-  </span>
<a href="#l52.28"></a><span id="l52.28" class="difflineplus">+  morkTableMapIter    mPortTableCursor_TableIter; // iter over tables</span>
<a href="#l52.29"></a><span id="l52.29" class="difflineplus">+</span>
<a href="#l52.30"></a><span id="l52.30">   // these booleans indicate when the table or space iterator is exhausted:</span>
<a href="#l52.31"></a><span id="l52.31" class="difflineminus">-  </span>
<a href="#l52.32"></a><span id="l52.32" class="difflineplus">+</span>
<a href="#l52.33"></a><span id="l52.33">   mork_bool           mPortTableCursor_TablesDidEnd; // no more tables?</span>
<a href="#l52.34"></a><span id="l52.34">   mork_bool           mPortTableCursor_SpacesDidEnd; // no more spaces?</span>
<a href="#l52.35"></a><span id="l52.35">   mork_u1             mPortTableCursor_Pad[ 2 ]; // for u4 alignment</span>
<a href="#l52.36"></a><span id="l52.36" class="difflineminus">-   </span>
<a href="#l52.37"></a><span id="l52.37" class="difflineplus">+</span>
<a href="#l52.38"></a><span id="l52.38"> // { ===== begin morkNode interface =====</span>
<a href="#l52.39"></a><span id="l52.39"> public: // morkNode virtual methods</span>
<a href="#l52.40"></a><span id="l52.40">   virtual void CloseMorkNode(morkEnv* ev) override; // ClosePortTableCursor()</span>
<a href="#l52.41"></a><span id="l52.41"> </span>
<a href="#l52.42"></a><span id="l52.42"> public: // morkPortTableCursor construction &amp; destruction</span>
<a href="#l52.43"></a><span id="l52.43">   morkPortTableCursor(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l52.44"></a><span id="l52.44">     nsIMdbHeap* ioHeap, morkStore* ioStore, mdb_scope inRowScope,</span>
<a href="#l52.45"></a><span id="l52.45">       mdb_kind inTableKind, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l52.46"></a><span id="l52.46" class="difflineat">@@ -123,17 +123,17 @@ public: // other cursor methods</span>
<a href="#l52.47"></a><span id="l52.47"> </span>
<a href="#l52.48"></a><span id="l52.48">   mork_bool SetRowScope(morkEnv* ev, mork_scope inRowScope);</span>
<a href="#l52.49"></a><span id="l52.49">   mork_bool SetTableKind(morkEnv* ev, mork_kind inTableKind);</span>
<a href="#l52.50"></a><span id="l52.50"> </span>
<a href="#l52.51"></a><span id="l52.51"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l52.52"></a><span id="l52.52">   static void SlotWeakPortTableCursor(morkPortTableCursor* me,</span>
<a href="#l52.53"></a><span id="l52.53">     morkEnv* ev, morkPortTableCursor** ioSlot)</span>
<a href="#l52.54"></a><span id="l52.54">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l52.55"></a><span id="l52.55" class="difflineminus">-  </span>
<a href="#l52.56"></a><span id="l52.56" class="difflineplus">+</span>
<a href="#l52.57"></a><span id="l52.57">   static void SlotStrongPortTableCursor(morkPortTableCursor* me,</span>
<a href="#l52.58"></a><span id="l52.58">     morkEnv* ev, morkPortTableCursor** ioSlot)</span>
<a href="#l52.59"></a><span id="l52.59">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l52.60"></a><span id="l52.60"> };</span>
<a href="#l52.61"></a><span id="l52.61"> </span>
<a href="#l52.62"></a><span id="l52.62"> </span>
<a href="#l52.63"></a><span id="l52.63"> </span>
<a href="#l52.64"></a><span id="l52.64"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l53.1"></a><span id="l53.1" class="difflineminus">--- a/db/mork/src/morkProbeMap.cpp</span>
<a href="#l53.2"></a><span id="l53.2" class="difflineplus">+++ b/db/mork/src/morkProbeMap.cpp</span>
<a href="#l53.3"></a><span id="l53.3" class="difflineat">@@ -63,17 +63,17 @@</span>
<a href="#l53.4"></a><span id="l53.4"> #endif</span>
<a href="#l53.5"></a><span id="l53.5"> </span>
<a href="#l53.6"></a><span id="l53.6"> /*============================================================================*/</span>
<a href="#l53.7"></a><span id="l53.7"> /* morkMapScratch */</span>
<a href="#l53.8"></a><span id="l53.8"> </span>
<a href="#l53.9"></a><span id="l53.9"> void morkMapScratch::halt_map_scratch(morkEnv* ev)</span>
<a href="#l53.10"></a><span id="l53.10"> {</span>
<a href="#l53.11"></a><span id="l53.11">   nsIMdbHeap* heap = sMapScratch_Heap;</span>
<a href="#l53.12"></a><span id="l53.12" class="difflineminus">-  </span>
<a href="#l53.13"></a><span id="l53.13" class="difflineplus">+</span>
<a href="#l53.14"></a><span id="l53.14">   if ( heap )</span>
<a href="#l53.15"></a><span id="l53.15">   {</span>
<a href="#l53.16"></a><span id="l53.16">     if ( sMapScratch_Keys )</span>
<a href="#l53.17"></a><span id="l53.17">       heap-&gt;Free(ev-&gt;AsMdbEnv(), sMapScratch_Keys);</span>
<a href="#l53.18"></a><span id="l53.18">     if ( sMapScratch_Vals )</span>
<a href="#l53.19"></a><span id="l53.19">       heap-&gt;Free(ev-&gt;AsMdbEnv(), sMapScratch_Vals);</span>
<a href="#l53.20"></a><span id="l53.20">   }</span>
<a href="#l53.21"></a><span id="l53.21"> }</span>
<a href="#l53.22"></a><span id="l53.22" class="difflineat">@@ -108,47 +108,47 @@ void morkProbeMap::MapValIsNotIPError(mo</span>
<a href="#l53.23"></a><span id="l53.23"> {</span>
<a href="#l53.24"></a><span id="l53.24">   ev-&gt;NewError(&quot;not sMap_ValIsIP&quot;);</span>
<a href="#l53.25"></a><span id="l53.25"> }</span>
<a href="#l53.26"></a><span id="l53.26"> </span>
<a href="#l53.27"></a><span id="l53.27"> void morkProbeMap::rehash_old_map(morkEnv* ev, morkMapScratch* ioScratch)</span>
<a href="#l53.28"></a><span id="l53.28"> {</span>
<a href="#l53.29"></a><span id="l53.29">   mork_size keySize = sMap_KeySize; // size of every key bucket</span>
<a href="#l53.30"></a><span id="l53.30">   mork_size valSize = sMap_ValSize; // size of every associated value</span>
<a href="#l53.31"></a><span id="l53.31" class="difflineminus">-  </span>
<a href="#l53.32"></a><span id="l53.32" class="difflineplus">+</span>
<a href="#l53.33"></a><span id="l53.33">   mork_count slots = sMap_Slots; // number of new buckets</span>
<a href="#l53.34"></a><span id="l53.34">   mork_u1* keys = sMap_Keys; // destination for rehashed keys</span>
<a href="#l53.35"></a><span id="l53.35">   mork_u1* vals = sMap_Vals; // destination for any copied values</span>
<a href="#l53.36"></a><span id="l53.36" class="difflineminus">-  </span>
<a href="#l53.37"></a><span id="l53.37" class="difflineplus">+</span>
<a href="#l53.38"></a><span id="l53.38">   mork_bool keyIsIP = ( keys &amp;&amp; keySize == sizeof(mork_ip) &amp;&amp; sMap_KeyIsIP );</span>
<a href="#l53.39"></a><span id="l53.39">   mork_bool valIsIP = ( vals &amp;&amp; valSize == sizeof(mork_ip) &amp;&amp; sMap_ValIsIP );</span>
<a href="#l53.40"></a><span id="l53.40"> </span>
<a href="#l53.41"></a><span id="l53.41">   mork_count oldSlots = ioScratch-&gt;sMapScratch_Slots; // sMap_Slots</span>
<a href="#l53.42"></a><span id="l53.42">   mork_u1* oldKeys = ioScratch-&gt;sMapScratch_Keys; // sMap_Keys</span>
<a href="#l53.43"></a><span id="l53.43">   mork_u1* oldVals = ioScratch-&gt;sMapScratch_Vals; // sMap_Vals</span>
<a href="#l53.44"></a><span id="l53.44">   mork_u1* end = oldKeys + (keySize * oldSlots); // one byte past last key</span>
<a href="#l53.45"></a><span id="l53.45" class="difflineminus">-  </span>
<a href="#l53.46"></a><span id="l53.46" class="difflineplus">+</span>
<a href="#l53.47"></a><span id="l53.47">   mork_fill fill = 0; // let's count the actual fill for a double check</span>
<a href="#l53.48"></a><span id="l53.48" class="difflineminus">-  </span>
<a href="#l53.49"></a><span id="l53.49" class="difflineplus">+</span>
<a href="#l53.50"></a><span id="l53.50">   while ( oldKeys &lt; end ) // another old key bucket to rehash if non-nil?</span>
<a href="#l53.51"></a><span id="l53.51">   {</span>
<a href="#l53.52"></a><span id="l53.52">     if ( !this-&gt;ProbeMapIsKeyNil(ev, oldKeys) ) // need to rehash?</span>
<a href="#l53.53"></a><span id="l53.53">     {</span>
<a href="#l53.54"></a><span id="l53.54">       ++fill; // this had better match sMap_Fill when we are all done</span>
<a href="#l53.55"></a><span id="l53.55">       mork_u4 hash = this-&gt;ProbeMapHashMapKey(ev, oldKeys);</span>
<a href="#l53.56"></a><span id="l53.56"> </span>
<a href="#l53.57"></a><span id="l53.57">       mork_pos i = hash % slots;   // target hash bucket</span>
<a href="#l53.58"></a><span id="l53.58">       mork_pos startPos = i;       // remember start to detect</span>
<a href="#l53.59"></a><span id="l53.59" class="difflineminus">-      </span>
<a href="#l53.60"></a><span id="l53.60" class="difflineplus">+</span>
<a href="#l53.61"></a><span id="l53.61">       mork_u1* k = keys + (i * keySize);</span>
<a href="#l53.62"></a><span id="l53.62">       while ( !this-&gt;ProbeMapIsKeyNil(ev, k) )</span>
<a href="#l53.63"></a><span id="l53.63">       {</span>
<a href="#l53.64"></a><span id="l53.64">         if ( ++i &gt;= (mork_pos)slots ) // advanced past end? need to wrap around now?</span>
<a href="#l53.65"></a><span id="l53.65">           i = 0; // wrap around to first slot in map's hash table</span>
<a href="#l53.66"></a><span id="l53.66" class="difflineminus">-          </span>
<a href="#l53.67"></a><span id="l53.67" class="difflineplus">+</span>
<a href="#l53.68"></a><span id="l53.68">         if ( i == startPos ) // no void slots were found anywhere in map?</span>
<a href="#l53.69"></a><span id="l53.69">         {</span>
<a href="#l53.70"></a><span id="l53.70">           this-&gt;WrapWithNoVoidSlotError(ev); // should never happen</span>
<a href="#l53.71"></a><span id="l53.71">           return; // this is bad, and we can't go on with the rehash</span>
<a href="#l53.72"></a><span id="l53.72">         }</span>
<a href="#l53.73"></a><span id="l53.73">         k = keys + (i * keySize);</span>
<a href="#l53.74"></a><span id="l53.74">       }</span>
<a href="#l53.75"></a><span id="l53.75">       if ( keyIsIP ) // int special case?</span>
<a href="#l53.76"></a><span id="l53.76" class="difflineat">@@ -178,77 +178,77 @@ void morkProbeMap::rehash_old_map(morkEn</span>
<a href="#l53.77"></a><span id="l53.77"> </span>
<a href="#l53.78"></a><span id="l53.78"> mork_bool morkProbeMap::grow_probe_map(morkEnv* ev)</span>
<a href="#l53.79"></a><span id="l53.79"> {</span>
<a href="#l53.80"></a><span id="l53.80">   if ( sMap_Heap ) // can we grow the map?</span>
<a href="#l53.81"></a><span id="l53.81">   {</span>
<a href="#l53.82"></a><span id="l53.82">     mork_num newSlots = ((sMap_Slots * 4) / 3) + 1; // +25%</span>
<a href="#l53.83"></a><span id="l53.83">     morkMapScratch old; // a place to temporarily hold all the old arrays</span>
<a href="#l53.84"></a><span id="l53.84">     if ( this-&gt;new_slots(ev, &amp;old, newSlots) ) // have more?</span>
<a href="#l53.85"></a><span id="l53.85" class="difflineminus">-    {      </span>
<a href="#l53.86"></a><span id="l53.86" class="difflineplus">+    {</span>
<a href="#l53.87"></a><span id="l53.87">       ++sMap_Seed; // note the map has changed</span>
<a href="#l53.88"></a><span id="l53.88">       this-&gt;rehash_old_map(ev, &amp;old);</span>
<a href="#l53.89"></a><span id="l53.89" class="difflineminus">-      </span>
<a href="#l53.90"></a><span id="l53.90" class="difflineminus">-      if ( ev-&gt;Good() ) </span>
<a href="#l53.91"></a><span id="l53.91" class="difflineplus">+</span>
<a href="#l53.92"></a><span id="l53.92" class="difflineplus">+      if ( ev-&gt;Good() )</span>
<a href="#l53.93"></a><span id="l53.93">       {</span>
<a href="#l53.94"></a><span id="l53.94">         mork_count slots = sMap_Slots;</span>
<a href="#l53.95"></a><span id="l53.95">         mork_num emptyReserve = (slots / 7) + 1; // keep this many empty</span>
<a href="#l53.96"></a><span id="l53.96">         mork_fill maxFill = slots - emptyReserve; // new max occupancy</span>
<a href="#l53.97"></a><span id="l53.97">         if ( maxFill &gt; sMap_Fill ) // new max is bigger than old occupancy?</span>
<a href="#l53.98"></a><span id="l53.98">           sProbeMap_MaxFill = maxFill; // we can install new max for fill</span>
<a href="#l53.99"></a><span id="l53.99">         else</span>
<a href="#l53.100"></a><span id="l53.100">           this-&gt;GrowFailsMaxFillError(ev); // we have invariant failure</span>
<a href="#l53.101"></a><span id="l53.101">       }</span>
<a href="#l53.102"></a><span id="l53.102" class="difflineminus">-      </span>
<a href="#l53.103"></a><span id="l53.103" class="difflineplus">+</span>
<a href="#l53.104"></a><span id="l53.104">       if ( ev-&gt;Bad() ) // rehash failed? need to revert map to last state?</span>
<a href="#l53.105"></a><span id="l53.105">         this-&gt;revert_map(ev, &amp;old); // swap the vectors back again</span>
<a href="#l53.106"></a><span id="l53.106"> </span>
<a href="#l53.107"></a><span id="l53.107">       old.halt_map_scratch(ev); // remember to free the old arrays</span>
<a href="#l53.108"></a><span id="l53.108">     }</span>
<a href="#l53.109"></a><span id="l53.109">   }</span>
<a href="#l53.110"></a><span id="l53.110">   else ev-&gt;OutOfMemoryError();</span>
<a href="#l53.111"></a><span id="l53.111" class="difflineminus">-  </span>
<a href="#l53.112"></a><span id="l53.112" class="difflineplus">+</span>
<a href="#l53.113"></a><span id="l53.113">   return ev-&gt;Good();</span>
<a href="#l53.114"></a><span id="l53.114"> }</span>
<a href="#l53.115"></a><span id="l53.115"> </span>
<a href="#l53.116"></a><span id="l53.116"> void morkProbeMap::revert_map(morkEnv* ev, morkMapScratch* ioScratch)</span>
<a href="#l53.117"></a><span id="l53.117"> {</span>
<a href="#l53.118"></a><span id="l53.118" class="difflineminus">-  mork_count tempSlots = ioScratch-&gt;sMapScratch_Slots; // sMap_Slots  </span>
<a href="#l53.119"></a><span id="l53.119" class="difflineplus">+  mork_count tempSlots = ioScratch-&gt;sMapScratch_Slots; // sMap_Slots</span>
<a href="#l53.120"></a><span id="l53.120">   mork_u1* tempKeys = ioScratch-&gt;sMapScratch_Keys;     // sMap_Keys</span>
<a href="#l53.121"></a><span id="l53.121">   mork_u1* tempVals = ioScratch-&gt;sMapScratch_Vals;     // sMap_Vals</span>
<a href="#l53.122"></a><span id="l53.122" class="difflineminus">-  </span>
<a href="#l53.123"></a><span id="l53.123" class="difflineplus">+</span>
<a href="#l53.124"></a><span id="l53.124">   ioScratch-&gt;sMapScratch_Slots = sMap_Slots;</span>
<a href="#l53.125"></a><span id="l53.125">   ioScratch-&gt;sMapScratch_Keys = sMap_Keys;</span>
<a href="#l53.126"></a><span id="l53.126">   ioScratch-&gt;sMapScratch_Vals = sMap_Vals;</span>
<a href="#l53.127"></a><span id="l53.127" class="difflineminus">-  </span>
<a href="#l53.128"></a><span id="l53.128" class="difflineplus">+</span>
<a href="#l53.129"></a><span id="l53.129">   sMap_Slots = tempSlots;</span>
<a href="#l53.130"></a><span id="l53.130">   sMap_Keys = tempKeys;</span>
<a href="#l53.131"></a><span id="l53.131">   sMap_Vals = tempVals;</span>
<a href="#l53.132"></a><span id="l53.132"> }</span>
<a href="#l53.133"></a><span id="l53.133"> </span>
<a href="#l53.134"></a><span id="l53.134"> void morkProbeMap::put_probe_kv(morkEnv* ev,</span>
<a href="#l53.135"></a><span id="l53.135">   const void* inAppKey, const void* inAppVal, mork_pos inPos)</span>
<a href="#l53.136"></a><span id="l53.136"> {</span>
<a href="#l53.137"></a><span id="l53.137">   mork_u1* mapVal = 0;</span>
<a href="#l53.138"></a><span id="l53.138">   mork_u1* mapKey = 0;</span>
<a href="#l53.139"></a><span id="l53.139"> </span>
<a href="#l53.140"></a><span id="l53.140">   mork_num valSize = sMap_ValSize;</span>
<a href="#l53.141"></a><span id="l53.141">   if ( valSize &amp;&amp; inAppVal ) // map holds values? caller sends value?</span>
<a href="#l53.142"></a><span id="l53.142">   {</span>
<a href="#l53.143"></a><span id="l53.143">     mork_u1* val = sMap_Vals + (valSize * inPos);</span>
<a href="#l53.144"></a><span id="l53.144" class="difflineminus">-    if ( valSize == sizeof(mork_ip) &amp;&amp; sMap_ValIsIP ) // int special case? </span>
<a href="#l53.145"></a><span id="l53.145" class="difflineplus">+    if ( valSize == sizeof(mork_ip) &amp;&amp; sMap_ValIsIP ) // int special case?</span>
<a href="#l53.146"></a><span id="l53.146">       *((mork_ip*) val) = *((const mork_ip*) inAppVal);</span>
<a href="#l53.147"></a><span id="l53.147">     else</span>
<a href="#l53.148"></a><span id="l53.148">       mapVal = val; // show possible need to call ProbeMapPushIn()</span>
<a href="#l53.149"></a><span id="l53.149">   }</span>
<a href="#l53.150"></a><span id="l53.150" class="difflineminus">-  if ( inAppKey ) // caller sends the key? </span>
<a href="#l53.151"></a><span id="l53.151" class="difflineplus">+  if ( inAppKey ) // caller sends the key?</span>
<a href="#l53.152"></a><span id="l53.152">   {</span>
<a href="#l53.153"></a><span id="l53.153">     mork_num keySize = sMap_KeySize;</span>
<a href="#l53.154"></a><span id="l53.154">     mork_u1* key = sMap_Keys + (keySize * inPos);</span>
<a href="#l53.155"></a><span id="l53.155" class="difflineminus">-    if ( keySize == sizeof(mork_ip) &amp;&amp; sMap_KeyIsIP ) // int special case? </span>
<a href="#l53.156"></a><span id="l53.156" class="difflineplus">+    if ( keySize == sizeof(mork_ip) &amp;&amp; sMap_KeyIsIP ) // int special case?</span>
<a href="#l53.157"></a><span id="l53.157">       *((mork_ip*) key) = *((const mork_ip*) inAppKey);</span>
<a href="#l53.158"></a><span id="l53.158">     else</span>
<a href="#l53.159"></a><span id="l53.159">       mapKey = key; // show possible need to call ProbeMapPushIn()</span>
<a href="#l53.160"></a><span id="l53.160">   }</span>
<a href="#l53.161"></a><span id="l53.161">   else</span>
<a href="#l53.162"></a><span id="l53.162">     ev-&gt;NilPointerError();</span>
<a href="#l53.163"></a><span id="l53.163"> </span>
<a href="#l53.164"></a><span id="l53.164">   if ( (  inAppVal &amp;&amp; mapVal ) || ( inAppKey &amp;&amp; mapKey ) )</span>
<a href="#l53.165"></a><span id="l53.165" class="difflineat">@@ -263,26 +263,26 @@ void morkProbeMap::get_probe_kv(morkEnv*</span>
<a href="#l53.166"></a><span id="l53.166"> {</span>
<a href="#l53.167"></a><span id="l53.167">   const mork_u1* mapVal = 0;</span>
<a href="#l53.168"></a><span id="l53.168">   const mork_u1* mapKey = 0;</span>
<a href="#l53.169"></a><span id="l53.169"> </span>
<a href="#l53.170"></a><span id="l53.170">   mork_num valSize = sMap_ValSize;</span>
<a href="#l53.171"></a><span id="l53.171">   if ( valSize &amp;&amp; outAppVal ) // map holds values? caller wants value?</span>
<a href="#l53.172"></a><span id="l53.172">   {</span>
<a href="#l53.173"></a><span id="l53.173">     const mork_u1* val = sMap_Vals + (valSize * inPos);</span>
<a href="#l53.174"></a><span id="l53.174" class="difflineminus">-    if ( valSize == sizeof(mork_ip) &amp;&amp; sMap_ValIsIP ) // int special case? </span>
<a href="#l53.175"></a><span id="l53.175" class="difflineplus">+    if ( valSize == sizeof(mork_ip) &amp;&amp; sMap_ValIsIP ) // int special case?</span>
<a href="#l53.176"></a><span id="l53.176">       *((mork_ip*) outAppVal) = *((const mork_ip*) val);</span>
<a href="#l53.177"></a><span id="l53.177">     else</span>
<a href="#l53.178"></a><span id="l53.178">       mapVal = val; // show possible need to call ProbeMapPullOut()</span>
<a href="#l53.179"></a><span id="l53.179">   }</span>
<a href="#l53.180"></a><span id="l53.180" class="difflineminus">-  if ( outAppKey ) // caller wants the key? </span>
<a href="#l53.181"></a><span id="l53.181" class="difflineplus">+  if ( outAppKey ) // caller wants the key?</span>
<a href="#l53.182"></a><span id="l53.182">   {</span>
<a href="#l53.183"></a><span id="l53.183">     mork_num keySize = sMap_KeySize;</span>
<a href="#l53.184"></a><span id="l53.184">     const mork_u1* key = sMap_Keys + (keySize * inPos);</span>
<a href="#l53.185"></a><span id="l53.185" class="difflineminus">-    if ( keySize == sizeof(mork_ip) &amp;&amp; sMap_KeyIsIP ) // int special case? </span>
<a href="#l53.186"></a><span id="l53.186" class="difflineplus">+    if ( keySize == sizeof(mork_ip) &amp;&amp; sMap_KeyIsIP ) // int special case?</span>
<a href="#l53.187"></a><span id="l53.187">       *((mork_ip*) outAppKey) = *((const mork_ip*) key);</span>
<a href="#l53.188"></a><span id="l53.188">     else</span>
<a href="#l53.189"></a><span id="l53.189">       mapKey = key; // show possible need to call ProbeMapPullOut()</span>
<a href="#l53.190"></a><span id="l53.190">   }</span>
<a href="#l53.191"></a><span id="l53.191">   if ( ( outAppVal &amp;&amp; mapVal ) || ( outAppKey &amp;&amp; mapKey ) )</span>
<a href="#l53.192"></a><span id="l53.192">     this-&gt;ProbeMapPullOut(ev, mapKey, mapVal, outAppKey, outAppVal);</span>
<a href="#l53.193"></a><span id="l53.193"> }</span>
<a href="#l53.194"></a><span id="l53.194"> </span>
<a href="#l53.195"></a><span id="l53.195" class="difflineat">@@ -290,42 +290,42 @@ mork_test</span>
<a href="#l53.196"></a><span id="l53.196"> morkProbeMap::find_key_pos(morkEnv* ev, const void* inAppKey,</span>
<a href="#l53.197"></a><span id="l53.197">   mork_u4 inHash, mork_pos* outPos) const</span>
<a href="#l53.198"></a><span id="l53.198"> {</span>
<a href="#l53.199"></a><span id="l53.199">   mork_u1* k = sMap_Keys;        // array of keys, each of size sMap_KeySize</span>
<a href="#l53.200"></a><span id="l53.200">   mork_num size = sMap_KeySize;  // number of bytes in each key</span>
<a href="#l53.201"></a><span id="l53.201">   mork_count slots = sMap_Slots; // total number of key buckets</span>
<a href="#l53.202"></a><span id="l53.202">   mork_pos i = inHash % slots;   // target hash bucket</span>
<a href="#l53.203"></a><span id="l53.203">   mork_pos startPos = i;         // remember start to detect</span>
<a href="#l53.204"></a><span id="l53.204" class="difflineminus">-  </span>
<a href="#l53.205"></a><span id="l53.205" class="difflineplus">+</span>
<a href="#l53.206"></a><span id="l53.206">   mork_test outTest = this-&gt;MapTest(ev, k + (i * size), inAppKey);</span>
<a href="#l53.207"></a><span id="l53.207">   while ( outTest == morkTest_kMiss )</span>
<a href="#l53.208"></a><span id="l53.208">   {</span>
<a href="#l53.209"></a><span id="l53.209">     if ( ++i &gt;= (mork_pos)slots ) // advancing goes beyond end? need to wrap around now?</span>
<a href="#l53.210"></a><span id="l53.210">       i = 0; // wrap around to first slot in map's hash table</span>
<a href="#l53.211"></a><span id="l53.211" class="difflineminus">-      </span>
<a href="#l53.212"></a><span id="l53.212" class="difflineplus">+</span>
<a href="#l53.213"></a><span id="l53.213">     if ( i == startPos ) // no void slots were found anywhere in map?</span>
<a href="#l53.214"></a><span id="l53.214">     {</span>
<a href="#l53.215"></a><span id="l53.215">       this-&gt;WrapWithNoVoidSlotError(ev); // should never happen</span>
<a href="#l53.216"></a><span id="l53.216">       break; // end loop on kMiss; note caller expects either kVoid or kHit</span>
<a href="#l53.217"></a><span id="l53.217">     }</span>
<a href="#l53.218"></a><span id="l53.218">     outTest = this-&gt;MapTest(ev, k + (i * size), inAppKey);</span>
<a href="#l53.219"></a><span id="l53.219">   }</span>
<a href="#l53.220"></a><span id="l53.220">   *outPos = i;</span>
<a href="#l53.221"></a><span id="l53.221" class="difflineminus">-  </span>
<a href="#l53.222"></a><span id="l53.222" class="difflineplus">+</span>
<a href="#l53.223"></a><span id="l53.223">   return outTest;</span>
<a href="#l53.224"></a><span id="l53.224"> }</span>
<a href="#l53.225"></a><span id="l53.225" class="difflineminus">- </span>
<a href="#l53.226"></a><span id="l53.226" class="difflineplus">+</span>
<a href="#l53.227"></a><span id="l53.227"> void morkProbeMap::probe_map_lazy_init(morkEnv* ev)</span>
<a href="#l53.228"></a><span id="l53.228"> {</span>
<a href="#l53.229"></a><span id="l53.229">   if ( this-&gt;need_lazy_init() &amp;&amp; sMap_Fill == 0 ) // pending lazy action?</span>
<a href="#l53.230"></a><span id="l53.230">   {</span>
<a href="#l53.231"></a><span id="l53.231">     // The constructor cannot successfully call virtual ProbeMapClearKey(),</span>
<a href="#l53.232"></a><span id="l53.232">     // so we lazily do so now, when we add the first member to the map.</span>
<a href="#l53.233"></a><span id="l53.233" class="difflineminus">-    </span>
<a href="#l53.234"></a><span id="l53.234" class="difflineplus">+</span>
<a href="#l53.235"></a><span id="l53.235">     mork_u1* keys = sMap_Keys;</span>
<a href="#l53.236"></a><span id="l53.236">     if ( keys ) // okay to call lazy virtual clear method on new map keys?</span>
<a href="#l53.237"></a><span id="l53.237">     {</span>
<a href="#l53.238"></a><span id="l53.238">       if ( sProbeMap_ZeroIsClearKey ) // zero is good enough to clear keys?</span>
<a href="#l53.239"></a><span id="l53.239">       {</span>
<a href="#l53.240"></a><span id="l53.240">         mork_num keyVolume = sMap_Slots * sMap_KeySize;</span>
<a href="#l53.241"></a><span id="l53.241">         if ( keyVolume )</span>
<a href="#l53.242"></a><span id="l53.242">           MORK_MEMSET(keys, 0, keyVolume);</span>
<a href="#l53.243"></a><span id="l53.243" class="difflineat">@@ -340,93 +340,93 @@ void morkProbeMap::probe_map_lazy_init(m</span>
<a href="#l53.244"></a><span id="l53.244"> }</span>
<a href="#l53.245"></a><span id="l53.245"> </span>
<a href="#l53.246"></a><span id="l53.246"> mork_bool</span>
<a href="#l53.247"></a><span id="l53.247"> morkProbeMap::MapAtPut(morkEnv* ev,</span>
<a href="#l53.248"></a><span id="l53.248">   const void* inAppKey, const void* inAppVal,</span>
<a href="#l53.249"></a><span id="l53.249">   void* outAppKey, void* outAppVal)</span>
<a href="#l53.250"></a><span id="l53.250"> {</span>
<a href="#l53.251"></a><span id="l53.251">   mork_bool outPut = morkBool_kFalse;</span>
<a href="#l53.252"></a><span id="l53.252" class="difflineminus">-  </span>
<a href="#l53.253"></a><span id="l53.253" class="difflineplus">+</span>
<a href="#l53.254"></a><span id="l53.254">   if ( this-&gt;GoodProbeMap() ) /* looks good? */</span>
<a href="#l53.255"></a><span id="l53.255">   {</span>
<a href="#l53.256"></a><span id="l53.256">     if ( this-&gt;need_lazy_init() &amp;&amp; sMap_Fill == 0 ) // pending lazy action?</span>
<a href="#l53.257"></a><span id="l53.257">       this-&gt;probe_map_lazy_init(ev);</span>
<a href="#l53.258"></a><span id="l53.258" class="difflineminus">-          </span>
<a href="#l53.259"></a><span id="l53.259" class="difflineplus">+</span>
<a href="#l53.260"></a><span id="l53.260">     if ( ev-&gt;Good() )</span>
<a href="#l53.261"></a><span id="l53.261">     {</span>
<a href="#l53.262"></a><span id="l53.262">       mork_pos slotPos = 0;</span>
<a href="#l53.263"></a><span id="l53.263">       mork_u4 hash = this-&gt;MapHash(ev, inAppKey);</span>
<a href="#l53.264"></a><span id="l53.264">       mork_test test = this-&gt;find_key_pos(ev, inAppKey, hash, &amp;slotPos);</span>
<a href="#l53.265"></a><span id="l53.265">       outPut = ( test == morkTest_kHit );</span>
<a href="#l53.266"></a><span id="l53.266"> </span>
<a href="#l53.267"></a><span id="l53.267">       if ( outPut ) // replacing an old assoc? no change in member count?</span>
<a href="#l53.268"></a><span id="l53.268">       {</span>
<a href="#l53.269"></a><span id="l53.269">         if ( outAppKey || outAppVal ) /* copy old before cobber? */</span>
<a href="#l53.270"></a><span id="l53.270">           this-&gt;get_probe_kv(ev, outAppKey, outAppVal, slotPos);</span>
<a href="#l53.271"></a><span id="l53.271">       }</span>
<a href="#l53.272"></a><span id="l53.272">       else // adding a new assoc increases membership by one</span>
<a href="#l53.273"></a><span id="l53.273">       {</span>
<a href="#l53.274"></a><span id="l53.274">         ++sMap_Fill; /* one more member in the collection */</span>
<a href="#l53.275"></a><span id="l53.275">       }</span>
<a href="#l53.276"></a><span id="l53.276" class="difflineminus">-      </span>
<a href="#l53.277"></a><span id="l53.277" class="difflineplus">+</span>
<a href="#l53.278"></a><span id="l53.278">       if ( test != morkTest_kMiss ) /* found slot to hold new assoc? */</span>
<a href="#l53.279"></a><span id="l53.279">       {</span>
<a href="#l53.280"></a><span id="l53.280">         ++sMap_Seed; /* note the map has changed */</span>
<a href="#l53.281"></a><span id="l53.281">         this-&gt;put_probe_kv(ev, inAppKey, inAppVal, slotPos);</span>
<a href="#l53.282"></a><span id="l53.282">       }</span>
<a href="#l53.283"></a><span id="l53.283">     }</span>
<a href="#l53.284"></a><span id="l53.284">   }</span>
<a href="#l53.285"></a><span id="l53.285">   else this-&gt;ProbeMapBadTagError(ev);</span>
<a href="#l53.286"></a><span id="l53.286" class="difflineminus">-  </span>
<a href="#l53.287"></a><span id="l53.287" class="difflineplus">+</span>
<a href="#l53.288"></a><span id="l53.288">   return outPut;</span>
<a href="#l53.289"></a><span id="l53.289"> }</span>
<a href="#l53.290"></a><span id="l53.290" class="difflineminus">-    </span>
<a href="#l53.291"></a><span id="l53.291" class="difflineplus">+</span>
<a href="#l53.292"></a><span id="l53.292"> mork_bool</span>
<a href="#l53.293"></a><span id="l53.293"> morkProbeMap::MapAt(morkEnv* ev, const void* inAppKey,</span>
<a href="#l53.294"></a><span id="l53.294">     void* outAppKey, void* outAppVal)</span>
<a href="#l53.295"></a><span id="l53.295"> {</span>
<a href="#l53.296"></a><span id="l53.296">   if ( this-&gt;GoodProbeMap() ) /* looks good? */</span>
<a href="#l53.297"></a><span id="l53.297">   {</span>
<a href="#l53.298"></a><span id="l53.298">     if ( this-&gt;need_lazy_init() &amp;&amp; sMap_Fill == 0 ) // pending lazy action?</span>
<a href="#l53.299"></a><span id="l53.299">       this-&gt;probe_map_lazy_init(ev);</span>
<a href="#l53.300"></a><span id="l53.300" class="difflineminus">-          </span>
<a href="#l53.301"></a><span id="l53.301" class="difflineplus">+</span>
<a href="#l53.302"></a><span id="l53.302">     mork_pos slotPos = 0;</span>
<a href="#l53.303"></a><span id="l53.303">     mork_u4 hash = this-&gt;MapHash(ev, inAppKey);</span>
<a href="#l53.304"></a><span id="l53.304">     mork_test test = this-&gt;find_key_pos(ev, inAppKey, hash, &amp;slotPos);</span>
<a href="#l53.305"></a><span id="l53.305">     if ( test == morkTest_kHit ) /* found an assoc pair for inAppKey? */</span>
<a href="#l53.306"></a><span id="l53.306">     {</span>
<a href="#l53.307"></a><span id="l53.307">       this-&gt;get_probe_kv(ev, outAppKey, outAppVal, slotPos);</span>
<a href="#l53.308"></a><span id="l53.308">       return morkBool_kTrue;</span>
<a href="#l53.309"></a><span id="l53.309">     }</span>
<a href="#l53.310"></a><span id="l53.310">   }</span>
<a href="#l53.311"></a><span id="l53.311">   else this-&gt;ProbeMapBadTagError(ev);</span>
<a href="#l53.312"></a><span id="l53.312" class="difflineminus">-  </span>
<a href="#l53.313"></a><span id="l53.313" class="difflineplus">+</span>
<a href="#l53.314"></a><span id="l53.314">   return morkBool_kFalse;</span>
<a href="#l53.315"></a><span id="l53.315"> }</span>
<a href="#l53.316"></a><span id="l53.316" class="difflineminus">-    </span>
<a href="#l53.317"></a><span id="l53.317" class="difflineplus">+</span>
<a href="#l53.318"></a><span id="l53.318"> mork_num</span>
<a href="#l53.319"></a><span id="l53.319"> morkProbeMap::MapCutAll(morkEnv* ev)</span>
<a href="#l53.320"></a><span id="l53.320"> {</span>
<a href="#l53.321"></a><span id="l53.321">   mork_num outCutAll = 0;</span>
<a href="#l53.322"></a><span id="l53.322" class="difflineminus">-  </span>
<a href="#l53.323"></a><span id="l53.323" class="difflineplus">+</span>
<a href="#l53.324"></a><span id="l53.324">   if ( this-&gt;GoodProbeMap() ) /* looks good? */</span>
<a href="#l53.325"></a><span id="l53.325">   {</span>
<a href="#l53.326"></a><span id="l53.326">     outCutAll = sMap_Fill; /* number of members cut, which is all of them */</span>
<a href="#l53.327"></a><span id="l53.327" class="difflineminus">-    </span>
<a href="#l53.328"></a><span id="l53.328" class="difflineplus">+</span>
<a href="#l53.329"></a><span id="l53.329">     if ( sMap_Keys &amp;&amp; !sProbeMap_ZeroIsClearKey )</span>
<a href="#l53.330"></a><span id="l53.330">       this-&gt;ProbeMapClearKey(ev, sMap_Keys, sMap_Slots);</span>
<a href="#l53.331"></a><span id="l53.331"> </span>
<a href="#l53.332"></a><span id="l53.332">     sMap_Fill = 0; /* map now has no members */</span>
<a href="#l53.333"></a><span id="l53.333">   }</span>
<a href="#l53.334"></a><span id="l53.334">   else this-&gt;ProbeMapBadTagError(ev);</span>
<a href="#l53.335"></a><span id="l53.335" class="difflineminus">-  </span>
<a href="#l53.336"></a><span id="l53.336" class="difflineplus">+</span>
<a href="#l53.337"></a><span id="l53.337">   return outCutAll;</span>
<a href="#l53.338"></a><span id="l53.338"> }</span>
<a href="#l53.339"></a><span id="l53.339" class="difflineminus">-    </span>
<a href="#l53.340"></a><span id="l53.340" class="difflineplus">+</span>
<a href="#l53.341"></a><span id="l53.341"> // { ===== node interface =====</span>
<a href="#l53.342"></a><span id="l53.342"> </span>
<a href="#l53.343"></a><span id="l53.343"> /*virtual*/</span>
<a href="#l53.344"></a><span id="l53.344"> morkProbeMap::~morkProbeMap() // assert NodeStop() finished earlier</span>
<a href="#l53.345"></a><span id="l53.345"> {</span>
<a href="#l53.346"></a><span id="l53.346">   MORK_ASSERT(sMap_Keys==0);</span>
<a href="#l53.347"></a><span id="l53.347">   MORK_ASSERT(sProbeMap_Tag==0);</span>
<a href="#l53.348"></a><span id="l53.348"> }</span>
<a href="#l53.349"></a><span id="l53.349" class="difflineat">@@ -450,31 +450,31 @@ void morkProbeMap::CloseProbeMap(morkEnv</span>
<a href="#l53.350"></a><span id="l53.350">       if ( heap ) // able to free map arrays?</span>
<a href="#l53.351"></a><span id="l53.351">       {</span>
<a href="#l53.352"></a><span id="l53.352">         void* block = sMap_Keys;</span>
<a href="#l53.353"></a><span id="l53.353">         if ( block )</span>
<a href="#l53.354"></a><span id="l53.354">         {</span>
<a href="#l53.355"></a><span id="l53.355">           heap-&gt;Free(ev-&gt;AsMdbEnv(), block);</span>
<a href="#l53.356"></a><span id="l53.356">           sMap_Keys = 0;</span>
<a href="#l53.357"></a><span id="l53.357">         }</span>
<a href="#l53.358"></a><span id="l53.358" class="difflineminus">-          </span>
<a href="#l53.359"></a><span id="l53.359" class="difflineplus">+</span>
<a href="#l53.360"></a><span id="l53.360">         block = sMap_Vals;</span>
<a href="#l53.361"></a><span id="l53.361">         if ( block )</span>
<a href="#l53.362"></a><span id="l53.362">         {</span>
<a href="#l53.363"></a><span id="l53.363">           heap-&gt;Free(ev-&gt;AsMdbEnv(), block);</span>
<a href="#l53.364"></a><span id="l53.364">           sMap_Vals = 0;</span>
<a href="#l53.365"></a><span id="l53.365">         }</span>
<a href="#l53.366"></a><span id="l53.366">       }</span>
<a href="#l53.367"></a><span id="l53.367">       sMap_Keys = 0;</span>
<a href="#l53.368"></a><span id="l53.368">       sMap_Vals = 0;</span>
<a href="#l53.369"></a><span id="l53.369" class="difflineminus">-      </span>
<a href="#l53.370"></a><span id="l53.370" class="difflineplus">+</span>
<a href="#l53.371"></a><span id="l53.371">       this-&gt;CloseNode(ev);</span>
<a href="#l53.372"></a><span id="l53.372">       sProbeMap_Tag = 0;</span>
<a href="#l53.373"></a><span id="l53.373">       sProbeMap_MaxFill = 0;</span>
<a href="#l53.374"></a><span id="l53.374" class="difflineminus">-      </span>
<a href="#l53.375"></a><span id="l53.375" class="difflineplus">+</span>
<a href="#l53.376"></a><span id="l53.376">       this-&gt;MarkShut();</span>
<a href="#l53.377"></a><span id="l53.377">     }</span>
<a href="#l53.378"></a><span id="l53.378">     else</span>
<a href="#l53.379"></a><span id="l53.379">       this-&gt;NonNodeError(ev);</span>
<a href="#l53.380"></a><span id="l53.380"> }</span>
<a href="#l53.381"></a><span id="l53.381"> </span>
<a href="#l53.382"></a><span id="l53.382"> void*</span>
<a href="#l53.383"></a><span id="l53.383"> morkProbeMap::clear_alloc(morkEnv* ev, mork_size inSize)</span>
<a href="#l53.384"></a><span id="l53.384" class="difflineat">@@ -486,17 +486,17 @@ morkProbeMap::clear_alloc(morkEnv* ev, m</span>
<a href="#l53.385"></a><span id="l53.385">     if (NS_SUCCEEDED(heap-&gt;Alloc(ev-&gt;AsMdbEnv(), inSize, (void**) &amp;p)) &amp;&amp; p )</span>
<a href="#l53.386"></a><span id="l53.386">     {</span>
<a href="#l53.387"></a><span id="l53.387">       MORK_MEMSET(p, 0, inSize);</span>
<a href="#l53.388"></a><span id="l53.388">       return p;</span>
<a href="#l53.389"></a><span id="l53.389">     }</span>
<a href="#l53.390"></a><span id="l53.390">   }</span>
<a href="#l53.391"></a><span id="l53.391">   else</span>
<a href="#l53.392"></a><span id="l53.392">     ev-&gt;NilPointerError();</span>
<a href="#l53.393"></a><span id="l53.393" class="difflineminus">-    </span>
<a href="#l53.394"></a><span id="l53.394" class="difflineplus">+</span>
<a href="#l53.395"></a><span id="l53.395">   return (void*) 0;</span>
<a href="#l53.396"></a><span id="l53.396"> }</span>
<a href="#l53.397"></a><span id="l53.397"> </span>
<a href="#l53.398"></a><span id="l53.398"> /*| map_new_keys: allocate an array of inSlots new keys filled with zero.</span>
<a href="#l53.399"></a><span id="l53.399"> **| (cf IronDoc's FeHashTable_new_keys())</span>
<a href="#l53.400"></a><span id="l53.400"> |*/</span>
<a href="#l53.401"></a><span id="l53.401"> mork_u1*</span>
<a href="#l53.402"></a><span id="l53.402"> morkProbeMap::map_new_keys(morkEnv* ev, mork_num inSlots)</span>
<a href="#l53.403"></a><span id="l53.403" class="difflineat">@@ -558,112 +558,112 @@ void morkProbeMap::init_probe_map(morkEn</span>
<a href="#l53.404"></a><span id="l53.404">   if ( ev-&gt;Good() )</span>
<a href="#l53.405"></a><span id="l53.405">   {</span>
<a href="#l53.406"></a><span id="l53.406">     morkMapScratch old;</span>
<a href="#l53.407"></a><span id="l53.407"> </span>
<a href="#l53.408"></a><span id="l53.408">     if ( inSlots &lt; 7 ) // capacity too small?</span>
<a href="#l53.409"></a><span id="l53.409">       inSlots = 7; // increase to reasonable minimum</span>
<a href="#l53.410"></a><span id="l53.410">     else if ( inSlots &gt; (128 * 1024) ) // requested capacity too big?</span>
<a href="#l53.411"></a><span id="l53.411">       inSlots = (128 * 1024); // decrease to reasonable maximum</span>
<a href="#l53.412"></a><span id="l53.412" class="difflineminus">-      </span>
<a href="#l53.413"></a><span id="l53.413" class="difflineplus">+</span>
<a href="#l53.414"></a><span id="l53.414">     if ( this-&gt;new_slots(ev, &amp;old, inSlots) )</span>
<a href="#l53.415"></a><span id="l53.415">       sProbeMap_Tag = morkProbeMap_kTag;</span>
<a href="#l53.416"></a><span id="l53.416" class="difflineminus">-      </span>
<a href="#l53.417"></a><span id="l53.417" class="difflineplus">+</span>
<a href="#l53.418"></a><span id="l53.418">     mork_count slots = sMap_Slots;</span>
<a href="#l53.419"></a><span id="l53.419">     mork_num emptyReserve = (slots / 7) + 1; // keep this many empty</span>
<a href="#l53.420"></a><span id="l53.420">     sProbeMap_MaxFill = slots - emptyReserve;</span>
<a href="#l53.421"></a><span id="l53.421"> </span>
<a href="#l53.422"></a><span id="l53.422">     MORK_MEMSET(&amp;old, 0, sizeof(morkMapScratch)); // don't bother halting</span>
<a href="#l53.423"></a><span id="l53.423">   }</span>
<a href="#l53.424"></a><span id="l53.424"> }</span>
<a href="#l53.425"></a><span id="l53.425"> </span>
<a href="#l53.426"></a><span id="l53.426"> mork_bool</span>
<a href="#l53.427"></a><span id="l53.427"> morkProbeMap::new_slots(morkEnv* ev, morkMapScratch* old, mork_num inSlots)</span>
<a href="#l53.428"></a><span id="l53.428"> {</span>
<a href="#l53.429"></a><span id="l53.429">   mork_bool outNew = morkBool_kFalse;</span>
<a href="#l53.430"></a><span id="l53.430" class="difflineminus">-  </span>
<a href="#l53.431"></a><span id="l53.431" class="difflineplus">+</span>
<a href="#l53.432"></a><span id="l53.432">   // Note we cannot successfully call virtual ProbeMapClearKey() when we</span>
<a href="#l53.433"></a><span id="l53.433">   // call new_slots() inside the constructor; so we leave this problem</span>
<a href="#l53.434"></a><span id="l53.434">   // to the caller.  (The constructor will call ProbeMapClearKey() later</span>
<a href="#l53.435"></a><span id="l53.435">   // after setting a suitable lazy flag to show this action is pending.)</span>
<a href="#l53.436"></a><span id="l53.436" class="difflineminus">-    </span>
<a href="#l53.437"></a><span id="l53.437" class="difflineplus">+</span>
<a href="#l53.438"></a><span id="l53.438">   // allocate every new array before we continue:</span>
<a href="#l53.439"></a><span id="l53.439">   mork_u1* newKeys = this-&gt;map_new_keys(ev, inSlots);</span>
<a href="#l53.440"></a><span id="l53.440">   mork_u1* newVals = this-&gt;map_new_vals(ev, inSlots);</span>
<a href="#l53.441"></a><span id="l53.441" class="difflineminus">-  </span>
<a href="#l53.442"></a><span id="l53.442" class="difflineplus">+</span>
<a href="#l53.443"></a><span id="l53.443">   // okay for newVals to be null when values are zero sized?</span>
<a href="#l53.444"></a><span id="l53.444">   mork_bool okayValues = ( newVals || !sMap_ValSize );</span>
<a href="#l53.445"></a><span id="l53.445" class="difflineminus">-  </span>
<a href="#l53.446"></a><span id="l53.446" class="difflineplus">+</span>
<a href="#l53.447"></a><span id="l53.447">   if ( newKeys &amp;&amp; okayValues )</span>
<a href="#l53.448"></a><span id="l53.448">   {</span>
<a href="#l53.449"></a><span id="l53.449">     outNew = morkBool_kTrue; // we created every array needed</span>
<a href="#l53.450"></a><span id="l53.450"> </span>
<a href="#l53.451"></a><span id="l53.451">     // init mapScratch using slots from current map:</span>
<a href="#l53.452"></a><span id="l53.452">     old-&gt;sMapScratch_Heap = sMap_Heap;</span>
<a href="#l53.453"></a><span id="l53.453" class="difflineminus">-    </span>
<a href="#l53.454"></a><span id="l53.454" class="difflineplus">+</span>
<a href="#l53.455"></a><span id="l53.455">     old-&gt;sMapScratch_Slots = sMap_Slots;</span>
<a href="#l53.456"></a><span id="l53.456">     old-&gt;sMapScratch_Keys = sMap_Keys;</span>
<a href="#l53.457"></a><span id="l53.457">     old-&gt;sMapScratch_Vals = sMap_Vals;</span>
<a href="#l53.458"></a><span id="l53.458" class="difflineminus">-    </span>
<a href="#l53.459"></a><span id="l53.459" class="difflineplus">+</span>
<a href="#l53.460"></a><span id="l53.460">     // replace all map array slots using the newly allocated members:</span>
<a href="#l53.461"></a><span id="l53.461">     ++sMap_Seed; // the map has changed</span>
<a href="#l53.462"></a><span id="l53.462">     sMap_Keys = newKeys;</span>
<a href="#l53.463"></a><span id="l53.463">     sMap_Vals = newVals;</span>
<a href="#l53.464"></a><span id="l53.464">     sMap_Slots = inSlots;</span>
<a href="#l53.465"></a><span id="l53.465">   }</span>
<a href="#l53.466"></a><span id="l53.466">   else // free any allocations if only partially successful</span>
<a href="#l53.467"></a><span id="l53.467">   {</span>
<a href="#l53.468"></a><span id="l53.468">     nsIMdbHeap* heap = sMap_Heap;</span>
<a href="#l53.469"></a><span id="l53.469">     if ( newKeys )</span>
<a href="#l53.470"></a><span id="l53.470">       heap-&gt;Free(ev-&gt;AsMdbEnv(), newKeys);</span>
<a href="#l53.471"></a><span id="l53.471">     if ( newVals )</span>
<a href="#l53.472"></a><span id="l53.472">       heap-&gt;Free(ev-&gt;AsMdbEnv(), newVals);</span>
<a href="#l53.473"></a><span id="l53.473" class="difflineminus">-    </span>
<a href="#l53.474"></a><span id="l53.474" class="difflineplus">+</span>
<a href="#l53.475"></a><span id="l53.475">     MORK_MEMSET(old, 0, sizeof(morkMapScratch)); // zap scratch space</span>
<a href="#l53.476"></a><span id="l53.476">   }</span>
<a href="#l53.477"></a><span id="l53.477" class="difflineminus">-  </span>
<a href="#l53.478"></a><span id="l53.478" class="difflineplus">+</span>
<a href="#l53.479"></a><span id="l53.479">   return outNew;</span>
<a href="#l53.480"></a><span id="l53.480"> }</span>
<a href="#l53.481"></a><span id="l53.481"> </span>
<a href="#l53.482"></a><span id="l53.482"> void</span>
<a href="#l53.483"></a><span id="l53.483"> morkProbeMap::clear_probe_map(morkEnv* ev, nsIMdbHeap* ioMapHeap)</span>
<a href="#l53.484"></a><span id="l53.484"> {</span>
<a href="#l53.485"></a><span id="l53.485">   sProbeMap_Tag = 0;</span>
<a href="#l53.486"></a><span id="l53.486">   sMap_Seed = 0;</span>
<a href="#l53.487"></a><span id="l53.487">   sMap_Slots = 0;</span>
<a href="#l53.488"></a><span id="l53.488">   sMap_Fill = 0;</span>
<a href="#l53.489"></a><span id="l53.489">   sMap_Keys = 0;</span>
<a href="#l53.490"></a><span id="l53.490">   sMap_Vals = 0;</span>
<a href="#l53.491"></a><span id="l53.491">   sProbeMap_MaxFill = 0;</span>
<a href="#l53.492"></a><span id="l53.492" class="difflineminus">-  </span>
<a href="#l53.493"></a><span id="l53.493" class="difflineplus">+</span>
<a href="#l53.494"></a><span id="l53.494">   sMap_Heap = ioMapHeap;</span>
<a href="#l53.495"></a><span id="l53.495">   if ( !ioMapHeap )</span>
<a href="#l53.496"></a><span id="l53.496">     ev-&gt;NilPointerError();</span>
<a href="#l53.497"></a><span id="l53.497"> }</span>
<a href="#l53.498"></a><span id="l53.498"> </span>
<a href="#l53.499"></a><span id="l53.499"> morkProbeMap::morkProbeMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l53.500"></a><span id="l53.500">   nsIMdbHeap* ioNodeHeap,</span>
<a href="#l53.501"></a><span id="l53.501">   mork_size inKeySize, mork_size inValSize,</span>
<a href="#l53.502"></a><span id="l53.502">   nsIMdbHeap* ioMapHeap, mork_size inSlots,</span>
<a href="#l53.503"></a><span id="l53.503">   mork_bool inZeroIsClearKey)</span>
<a href="#l53.504"></a><span id="l53.504" class="difflineminus">-  </span>
<a href="#l53.505"></a><span id="l53.505" class="difflineplus">+</span>
<a href="#l53.506"></a><span id="l53.506"> : morkNode(ev, inUsage, ioNodeHeap)</span>
<a href="#l53.507"></a><span id="l53.507"> , sMap_Heap( ioMapHeap )</span>
<a href="#l53.508"></a><span id="l53.508" class="difflineminus">-    </span>
<a href="#l53.509"></a><span id="l53.509" class="difflineplus">+</span>
<a href="#l53.510"></a><span id="l53.510"> , sMap_Keys( 0 )</span>
<a href="#l53.511"></a><span id="l53.511"> , sMap_Vals( 0 )</span>
<a href="#l53.512"></a><span id="l53.512" class="difflineminus">-  </span>
<a href="#l53.513"></a><span id="l53.513" class="difflineplus">+</span>
<a href="#l53.514"></a><span id="l53.514"> , sMap_Seed( 0 )   // change count of members or structure</span>
<a href="#l53.515"></a><span id="l53.515" class="difflineminus">-    </span>
<a href="#l53.516"></a><span id="l53.516" class="difflineplus">+</span>
<a href="#l53.517"></a><span id="l53.517"> , sMap_Slots( 0 )  // count of slots in the hash table</span>
<a href="#l53.518"></a><span id="l53.518"> , sMap_Fill( 0 )   // number of used slots in the hash table</span>
<a href="#l53.519"></a><span id="l53.519"> </span>
<a href="#l53.520"></a><span id="l53.520"> , sMap_KeySize( 0 ) // size of each key (cannot be zero)</span>
<a href="#l53.521"></a><span id="l53.521"> , sMap_ValSize( 0 ) // size of each val (zero allowed)</span>
<a href="#l53.522"></a><span id="l53.522" class="difflineminus">-  </span>
<a href="#l53.523"></a><span id="l53.523" class="difflineplus">+</span>
<a href="#l53.524"></a><span id="l53.524"> , sMap_KeyIsIP( morkBool_kFalse ) // sMap_KeySize == sizeof(mork_ip)</span>
<a href="#l53.525"></a><span id="l53.525"> , sMap_ValIsIP( morkBool_kFalse ) // sMap_ValSize == sizeof(mork_ip)</span>
<a href="#l53.526"></a><span id="l53.526"> </span>
<a href="#l53.527"></a><span id="l53.527"> , sProbeMap_MaxFill( 0 )</span>
<a href="#l53.528"></a><span id="l53.528"> , sProbeMap_LazyClearOnAdd( 0 )</span>
<a href="#l53.529"></a><span id="l53.529"> , sProbeMap_ZeroIsClearKey( inZeroIsClearKey )</span>
<a href="#l53.530"></a><span id="l53.530"> , sProbeMap_Tag( 0 )</span>
<a href="#l53.531"></a><span id="l53.531"> {</span>
<a href="#l53.532"></a><span id="l53.532" class="difflineat">@@ -671,28 +671,28 @@ morkProbeMap::morkProbeMap(morkEnv* ev, </span>
<a href="#l53.533"></a><span id="l53.533">   // call init_probe_map() inside the constructor; so we leave this problem</span>
<a href="#l53.534"></a><span id="l53.534">   // to the caller.  (The constructor will call ProbeMapClearKey() later</span>
<a href="#l53.535"></a><span id="l53.535">   // after setting a suitable lazy flag to show this action is pending.)</span>
<a href="#l53.536"></a><span id="l53.536"> </span>
<a href="#l53.537"></a><span id="l53.537">   if ( ev-&gt;Good() )</span>
<a href="#l53.538"></a><span id="l53.538">   {</span>
<a href="#l53.539"></a><span id="l53.539">     this-&gt;clear_probe_map(ev, ioMapHeap);</span>
<a href="#l53.540"></a><span id="l53.540">     if ( ev-&gt;Good() )</span>
<a href="#l53.541"></a><span id="l53.541" class="difflineminus">-    {      </span>
<a href="#l53.542"></a><span id="l53.542" class="difflineplus">+    {</span>
<a href="#l53.543"></a><span id="l53.543">       sMap_KeySize = inKeySize;</span>
<a href="#l53.544"></a><span id="l53.544">       sMap_ValSize = inValSize;</span>
<a href="#l53.545"></a><span id="l53.545">       sMap_KeyIsIP = ( inKeySize == sizeof(mork_ip) );</span>
<a href="#l53.546"></a><span id="l53.546">       sMap_ValIsIP = ( inValSize == sizeof(mork_ip) );</span>
<a href="#l53.547"></a><span id="l53.547" class="difflineminus">-      </span>
<a href="#l53.548"></a><span id="l53.548" class="difflineplus">+</span>
<a href="#l53.549"></a><span id="l53.549">       this-&gt;init_probe_map(ev, inSlots);</span>
<a href="#l53.550"></a><span id="l53.550">       if ( ev-&gt;Good() )</span>
<a href="#l53.551"></a><span id="l53.551">       {</span>
<a href="#l53.552"></a><span id="l53.552">         if ( !inZeroIsClearKey ) // must lazy clear later with virtual method?</span>
<a href="#l53.553"></a><span id="l53.553">           sProbeMap_LazyClearOnAdd = morkProbeMap_kLazyClearOnAdd;</span>
<a href="#l53.554"></a><span id="l53.554" class="difflineminus">-          </span>
<a href="#l53.555"></a><span id="l53.555" class="difflineplus">+</span>
<a href="#l53.556"></a><span id="l53.556">         mNode_Derived = morkDerived_kProbeMap;</span>
<a href="#l53.557"></a><span id="l53.557">       }</span>
<a href="#l53.558"></a><span id="l53.558">     }</span>
<a href="#l53.559"></a><span id="l53.559">   }</span>
<a href="#l53.560"></a><span id="l53.560"> }</span>
<a href="#l53.561"></a><span id="l53.561"> </span>
<a href="#l53.562"></a><span id="l53.562"> /*============================================================================*/</span>
<a href="#l53.563"></a><span id="l53.563"> </span>
<a href="#l53.564"></a><span id="l53.564" class="difflineat">@@ -706,17 +706,17 @@ morkProbeMap::MapTest(morkEnv* ev,</span>
<a href="#l53.565"></a><span id="l53.565">   //   the bit pattern representation might be different in such cases.</span>
<a href="#l53.566"></a><span id="l53.566">   // morkTest_kHit means that inMapKey equals inAppKey (and this had better</span>
<a href="#l53.567"></a><span id="l53.567">   //   also imply that hash(inMapKey) == hash(inAppKey)).</span>
<a href="#l53.568"></a><span id="l53.568">   // morkTest_kMiss means that inMapKey does NOT equal inAppKey (but this</span>
<a href="#l53.569"></a><span id="l53.569">   //   implies nothing at all about hash(inMapKey) and hash(inAppKey)).</span>
<a href="#l53.570"></a><span id="l53.570">   // morkTest_kVoid means that inMapKey is not a valid key bit pattern,</span>
<a href="#l53.571"></a><span id="l53.571">   //   which means that key slot in the map is not being used.  Note that</span>
<a href="#l53.572"></a><span id="l53.572">   //   kVoid is only expected as a return value in morkProbeMap subclasses,</span>
<a href="#l53.573"></a><span id="l53.573" class="difflineminus">-  //   because morkProbeMap must ask whether a key slot is used or not. </span>
<a href="#l53.574"></a><span id="l53.574" class="difflineplus">+  //   because morkProbeMap must ask whether a key slot is used or not.</span>
<a href="#l53.575"></a><span id="l53.575">   //   morkChainMap however, always knows when a key slot is used, so only</span>
<a href="#l53.576"></a><span id="l53.576">   //   key slots expected to have valid bit patterns will be presented to</span>
<a href="#l53.577"></a><span id="l53.577">   //   the MapTest() methods for morkChainMap subclasses.</span>
<a href="#l53.578"></a><span id="l53.578">   //</span>
<a href="#l53.579"></a><span id="l53.579">   // NOTE: it is very important that subclasses correctly return the value</span>
<a href="#l53.580"></a><span id="l53.580">   // morkTest_kVoid whenever the slot for inMapKey contains a bit pattern</span>
<a href="#l53.581"></a><span id="l53.581">   // that means the slot is not being used, because this is the only way a</span>
<a href="#l53.582"></a><span id="l53.582">   // probe map can terminate an unsuccessful search for a key in the map.</span>
<a href="#l53.583"></a><span id="l53.583" class="difflineat">@@ -921,17 +921,17 @@ morkProbeMapIter::morkProbeMapIter(morkE</span>
<a href="#l53.584"></a><span id="l53.584"> , sProbeMapIter_HereIx( morkProbeMapIter_kBeforeIx )</span>
<a href="#l53.585"></a><span id="l53.585"> {</span>
<a href="#l53.586"></a><span id="l53.586">   if ( ioMap )</span>
<a href="#l53.587"></a><span id="l53.587">   {</span>
<a href="#l53.588"></a><span id="l53.588">     if ( ioMap-&gt;GoodProbeMap() )</span>
<a href="#l53.589"></a><span id="l53.589">     {</span>
<a href="#l53.590"></a><span id="l53.590">       if ( ioMap-&gt;need_lazy_init() ) // pending lazy action?</span>
<a href="#l53.591"></a><span id="l53.591">         ioMap-&gt;probe_map_lazy_init(ev);</span>
<a href="#l53.592"></a><span id="l53.592" class="difflineminus">-        </span>
<a href="#l53.593"></a><span id="l53.593" class="difflineplus">+</span>
<a href="#l53.594"></a><span id="l53.594">       sProbeMapIter_Map = ioMap;</span>
<a href="#l53.595"></a><span id="l53.595">       sProbeMapIter_Seed = ioMap-&gt;sMap_Seed;</span>
<a href="#l53.596"></a><span id="l53.596">     }</span>
<a href="#l53.597"></a><span id="l53.597">     else ioMap-&gt;ProbeMapBadTagError(ev);</span>
<a href="#l53.598"></a><span id="l53.598">   }</span>
<a href="#l53.599"></a><span id="l53.599">   else ev-&gt;NilPointerError();</span>
<a href="#l53.600"></a><span id="l53.600"> }</span>
<a href="#l53.601"></a><span id="l53.601"> </span>
<a href="#l53.602"></a><span id="l53.602" class="difflineat">@@ -961,107 +961,107 @@ void morkProbeMapIter::InitProbeMapIter(</span>
<a href="#l53.603"></a><span id="l53.603">   sProbeMapIter_HereIx = morkProbeMapIter_kBeforeIx;</span>
<a href="#l53.604"></a><span id="l53.604"> </span>
<a href="#l53.605"></a><span id="l53.605">   if ( ioMap )</span>
<a href="#l53.606"></a><span id="l53.606">   {</span>
<a href="#l53.607"></a><span id="l53.607">     if ( ioMap-&gt;GoodProbeMap() )</span>
<a href="#l53.608"></a><span id="l53.608">     {</span>
<a href="#l53.609"></a><span id="l53.609">       if ( ioMap-&gt;need_lazy_init() ) // pending lazy action?</span>
<a href="#l53.610"></a><span id="l53.610">         ioMap-&gt;probe_map_lazy_init(ev);</span>
<a href="#l53.611"></a><span id="l53.611" class="difflineminus">-        </span>
<a href="#l53.612"></a><span id="l53.612" class="difflineplus">+</span>
<a href="#l53.613"></a><span id="l53.613">       sProbeMapIter_Map = ioMap;</span>
<a href="#l53.614"></a><span id="l53.614">       sProbeMapIter_Seed = ioMap-&gt;sMap_Seed;</span>
<a href="#l53.615"></a><span id="l53.615">     }</span>
<a href="#l53.616"></a><span id="l53.616">     else ioMap-&gt;ProbeMapBadTagError(ev);</span>
<a href="#l53.617"></a><span id="l53.617">   }</span>
<a href="#l53.618"></a><span id="l53.618">   else ev-&gt;NilPointerError();</span>
<a href="#l53.619"></a><span id="l53.619"> }</span>
<a href="#l53.620"></a><span id="l53.620" class="difflineminus">- </span>
<a href="#l53.621"></a><span id="l53.621" class="difflineplus">+</span>
<a href="#l53.622"></a><span id="l53.622"> mork_bool morkProbeMapIter::IterFirst(morkEnv* ev,</span>
<a href="#l53.623"></a><span id="l53.623">   void* outAppKey, void* outAppVal)</span>
<a href="#l53.624"></a><span id="l53.624"> {</span>
<a href="#l53.625"></a><span id="l53.625">   sProbeMapIter_HereIx = morkProbeMapIter_kAfterIx; // default to done</span>
<a href="#l53.626"></a><span id="l53.626">   morkProbeMap* map = sProbeMapIter_Map;</span>
<a href="#l53.627"></a><span id="l53.627" class="difflineminus">-  </span>
<a href="#l53.628"></a><span id="l53.628" class="difflineplus">+</span>
<a href="#l53.629"></a><span id="l53.629">   if ( map &amp;&amp; map-&gt;GoodProbeMap() ) /* looks good? */</span>
<a href="#l53.630"></a><span id="l53.630">   {</span>
<a href="#l53.631"></a><span id="l53.631">     sProbeMapIter_Seed = map-&gt;sMap_Seed; /* sync the seeds */</span>
<a href="#l53.632"></a><span id="l53.632" class="difflineminus">-    </span>
<a href="#l53.633"></a><span id="l53.633" class="difflineplus">+</span>
<a href="#l53.634"></a><span id="l53.634">     mork_u1* k = map-&gt;sMap_Keys;  // array of keys, each of size sMap_KeySize</span>
<a href="#l53.635"></a><span id="l53.635">     mork_num size = map-&gt;sMap_KeySize;  // number of bytes in each key</span>
<a href="#l53.636"></a><span id="l53.636">     mork_count slots = map-&gt;sMap_Slots; // total number of key buckets</span>
<a href="#l53.637"></a><span id="l53.637">     mork_pos here = 0;  // first hash bucket</span>
<a href="#l53.638"></a><span id="l53.638" class="difflineminus">-    </span>
<a href="#l53.639"></a><span id="l53.639" class="difflineplus">+</span>
<a href="#l53.640"></a><span id="l53.640">     while ( here &lt; (mork_pos)slots )</span>
<a href="#l53.641"></a><span id="l53.641">     {</span>
<a href="#l53.642"></a><span id="l53.642">       if ( !map-&gt;ProbeMapIsKeyNil(ev, k + (here * size)) )</span>
<a href="#l53.643"></a><span id="l53.643">       {</span>
<a href="#l53.644"></a><span id="l53.644">         map-&gt;get_probe_kv(ev, outAppKey, outAppVal, here);</span>
<a href="#l53.645"></a><span id="l53.645" class="difflineminus">-        </span>
<a href="#l53.646"></a><span id="l53.646" class="difflineplus">+</span>
<a href="#l53.647"></a><span id="l53.647">         sProbeMapIter_HereIx = (mork_i4) here;</span>
<a href="#l53.648"></a><span id="l53.648">         return morkBool_kTrue;</span>
<a href="#l53.649"></a><span id="l53.649">       }</span>
<a href="#l53.650"></a><span id="l53.650">       ++here; // next bucket</span>
<a href="#l53.651"></a><span id="l53.651" class="difflineminus">-    } </span>
<a href="#l53.652"></a><span id="l53.652" class="difflineplus">+    }</span>
<a href="#l53.653"></a><span id="l53.653">   }</span>
<a href="#l53.654"></a><span id="l53.654">   else map-&gt;ProbeMapBadTagError(ev);</span>
<a href="#l53.655"></a><span id="l53.655"> </span>
<a href="#l53.656"></a><span id="l53.656">   return morkBool_kFalse;</span>
<a href="#l53.657"></a><span id="l53.657"> }</span>
<a href="#l53.658"></a><span id="l53.658"> </span>
<a href="#l53.659"></a><span id="l53.659"> mork_bool morkProbeMapIter::IterNext(morkEnv* ev,</span>
<a href="#l53.660"></a><span id="l53.660">   void* outAppKey, void* outAppVal)</span>
<a href="#l53.661"></a><span id="l53.661"> {</span>
<a href="#l53.662"></a><span id="l53.662">   morkProbeMap* map = sProbeMapIter_Map;</span>
<a href="#l53.663"></a><span id="l53.663" class="difflineminus">-  </span>
<a href="#l53.664"></a><span id="l53.664" class="difflineplus">+</span>
<a href="#l53.665"></a><span id="l53.665">   if ( map &amp;&amp; map-&gt;GoodProbeMap() ) /* looks good? */</span>
<a href="#l53.666"></a><span id="l53.666" class="difflineminus">-  {    </span>
<a href="#l53.667"></a><span id="l53.667" class="difflineplus">+  {</span>
<a href="#l53.668"></a><span id="l53.668">     if ( sProbeMapIter_Seed == map-&gt;sMap_Seed ) /* in sync? */</span>
<a href="#l53.669"></a><span id="l53.669">     {</span>
<a href="#l53.670"></a><span id="l53.670">       if ( sProbeMapIter_HereIx != morkProbeMapIter_kAfterIx )</span>
<a href="#l53.671"></a><span id="l53.671">       {</span>
<a href="#l53.672"></a><span id="l53.672">         mork_pos here = (mork_pos) sProbeMapIter_HereIx;</span>
<a href="#l53.673"></a><span id="l53.673">         if ( sProbeMapIter_HereIx &lt; 0 )</span>
<a href="#l53.674"></a><span id="l53.674">           here = 0;</span>
<a href="#l53.675"></a><span id="l53.675">         else</span>
<a href="#l53.676"></a><span id="l53.676">           ++here;</span>
<a href="#l53.677"></a><span id="l53.677" class="difflineminus">-          </span>
<a href="#l53.678"></a><span id="l53.678" class="difflineplus">+</span>
<a href="#l53.679"></a><span id="l53.679">         sProbeMapIter_HereIx = morkProbeMapIter_kAfterIx; // default to done</span>
<a href="#l53.680"></a><span id="l53.680"> </span>
<a href="#l53.681"></a><span id="l53.681">         mork_u1* k = map-&gt;sMap_Keys;  // key array, each of size sMap_KeySize</span>
<a href="#l53.682"></a><span id="l53.682">         mork_num size = map-&gt;sMap_KeySize;  // number of bytes in each key</span>
<a href="#l53.683"></a><span id="l53.683">         mork_count slots = map-&gt;sMap_Slots; // total number of key buckets</span>
<a href="#l53.684"></a><span id="l53.684" class="difflineminus">-        </span>
<a href="#l53.685"></a><span id="l53.685" class="difflineplus">+</span>
<a href="#l53.686"></a><span id="l53.686">         while ( here &lt; (mork_pos)slots )</span>
<a href="#l53.687"></a><span id="l53.687">         {</span>
<a href="#l53.688"></a><span id="l53.688">           if ( !map-&gt;ProbeMapIsKeyNil(ev, k + (here * size)) )</span>
<a href="#l53.689"></a><span id="l53.689">           {</span>
<a href="#l53.690"></a><span id="l53.690">             map-&gt;get_probe_kv(ev, outAppKey, outAppVal, here);</span>
<a href="#l53.691"></a><span id="l53.691" class="difflineminus">-            </span>
<a href="#l53.692"></a><span id="l53.692" class="difflineplus">+</span>
<a href="#l53.693"></a><span id="l53.693">             sProbeMapIter_HereIx = (mork_i4) here;</span>
<a href="#l53.694"></a><span id="l53.694">             return morkBool_kTrue;</span>
<a href="#l53.695"></a><span id="l53.695">           }</span>
<a href="#l53.696"></a><span id="l53.696">           ++here; // next bucket</span>
<a href="#l53.697"></a><span id="l53.697" class="difflineminus">-        } </span>
<a href="#l53.698"></a><span id="l53.698" class="difflineplus">+        }</span>
<a href="#l53.699"></a><span id="l53.699">       }</span>
<a href="#l53.700"></a><span id="l53.700">     }</span>
<a href="#l53.701"></a><span id="l53.701">     else map-&gt;MapSeedOutOfSyncError(ev);</span>
<a href="#l53.702"></a><span id="l53.702">   }</span>
<a href="#l53.703"></a><span id="l53.703">   else map-&gt;ProbeMapBadTagError(ev);</span>
<a href="#l53.704"></a><span id="l53.704"> </span>
<a href="#l53.705"></a><span id="l53.705">   return morkBool_kFalse;</span>
<a href="#l53.706"></a><span id="l53.706"> }</span>
<a href="#l53.707"></a><span id="l53.707"> </span>
<a href="#l53.708"></a><span id="l53.708"> mork_bool morkProbeMapIter::IterHere(morkEnv* ev,</span>
<a href="#l53.709"></a><span id="l53.709">   void* outAppKey, void* outAppVal)</span>
<a href="#l53.710"></a><span id="l53.710"> {</span>
<a href="#l53.711"></a><span id="l53.711">   morkProbeMap* map = sProbeMapIter_Map;</span>
<a href="#l53.712"></a><span id="l53.712" class="difflineminus">-  </span>
<a href="#l53.713"></a><span id="l53.713" class="difflineplus">+</span>
<a href="#l53.714"></a><span id="l53.714">   if ( map &amp;&amp; map-&gt;GoodProbeMap() ) /* looks good? */</span>
<a href="#l53.715"></a><span id="l53.715" class="difflineminus">-  {    </span>
<a href="#l53.716"></a><span id="l53.716" class="difflineplus">+  {</span>
<a href="#l53.717"></a><span id="l53.717">     if ( sProbeMapIter_Seed == map-&gt;sMap_Seed ) /* in sync? */</span>
<a href="#l53.718"></a><span id="l53.718">     {</span>
<a href="#l53.719"></a><span id="l53.719">       mork_pos here = (mork_pos) sProbeMapIter_HereIx;</span>
<a href="#l53.720"></a><span id="l53.720">       mork_count slots = map-&gt;sMap_Slots; // total number of key buckets</span>
<a href="#l53.721"></a><span id="l53.721">       if ( sProbeMapIter_HereIx &gt;= 0 &amp;&amp; (here &lt; (mork_pos)slots))</span>
<a href="#l53.722"></a><span id="l53.722">       {</span>
<a href="#l53.723"></a><span id="l53.723">         mork_u1* k = map-&gt;sMap_Keys;  // key array, each of size sMap_KeySize</span>
<a href="#l53.724"></a><span id="l53.724">         mork_num size = map-&gt;sMap_KeySize;  // number of bytes in each key</span>
<a href="#l53.725"></a><span id="l53.725" class="difflineat">@@ -1080,43 +1080,43 @@ mork_bool morkProbeMapIter::IterHere(mor</span>
<a href="#l53.726"></a><span id="l53.726">   return morkBool_kFalse;</span>
<a href="#l53.727"></a><span id="l53.727"> }</span>
<a href="#l53.728"></a><span id="l53.728"> </span>
<a href="#l53.729"></a><span id="l53.729"> mork_change*</span>
<a href="#l53.730"></a><span id="l53.730"> morkProbeMapIter::First(morkEnv* ev, void* outKey, void* outVal)</span>
<a href="#l53.731"></a><span id="l53.731"> {</span>
<a href="#l53.732"></a><span id="l53.732">   if ( this-&gt;IterFirst(ev, outKey, outVal) )</span>
<a href="#l53.733"></a><span id="l53.733">     return &amp;sProbeMapIter_Change;</span>
<a href="#l53.734"></a><span id="l53.734" class="difflineminus">-  </span>
<a href="#l53.735"></a><span id="l53.735" class="difflineplus">+</span>
<a href="#l53.736"></a><span id="l53.736">   return (mork_change*) 0;</span>
<a href="#l53.737"></a><span id="l53.737"> }</span>
<a href="#l53.738"></a><span id="l53.738"> </span>
<a href="#l53.739"></a><span id="l53.739"> mork_change*</span>
<a href="#l53.740"></a><span id="l53.740"> morkProbeMapIter::Next(morkEnv* ev, void* outKey, void* outVal)</span>
<a href="#l53.741"></a><span id="l53.741"> {</span>
<a href="#l53.742"></a><span id="l53.742">   if ( this-&gt;IterNext(ev, outKey, outVal) )</span>
<a href="#l53.743"></a><span id="l53.743">     return &amp;sProbeMapIter_Change;</span>
<a href="#l53.744"></a><span id="l53.744" class="difflineminus">-  </span>
<a href="#l53.745"></a><span id="l53.745" class="difflineplus">+</span>
<a href="#l53.746"></a><span id="l53.746">   return (mork_change*) 0;</span>
<a href="#l53.747"></a><span id="l53.747"> }</span>
<a href="#l53.748"></a><span id="l53.748"> </span>
<a href="#l53.749"></a><span id="l53.749"> mork_change*</span>
<a href="#l53.750"></a><span id="l53.750"> morkProbeMapIter::Here(morkEnv* ev, void* outKey, void* outVal)</span>
<a href="#l53.751"></a><span id="l53.751"> {</span>
<a href="#l53.752"></a><span id="l53.752">   if ( this-&gt;IterHere(ev, outKey, outVal) )</span>
<a href="#l53.753"></a><span id="l53.753">     return &amp;sProbeMapIter_Change;</span>
<a href="#l53.754"></a><span id="l53.754" class="difflineminus">-  </span>
<a href="#l53.755"></a><span id="l53.755" class="difflineplus">+</span>
<a href="#l53.756"></a><span id="l53.756">   return (mork_change*) 0;</span>
<a href="#l53.757"></a><span id="l53.757"> }</span>
<a href="#l53.758"></a><span id="l53.758"> </span>
<a href="#l53.759"></a><span id="l53.759"> mork_change*</span>
<a href="#l53.760"></a><span id="l53.760"> morkProbeMapIter::CutHere(morkEnv* ev, void* outKey, void* outVal)</span>
<a href="#l53.761"></a><span id="l53.761"> {</span>
<a href="#l53.762"></a><span id="l53.762">   morkProbeMap::ProbeMapCutError(ev);</span>
<a href="#l53.763"></a><span id="l53.763" class="difflineminus">-  </span>
<a href="#l53.764"></a><span id="l53.764" class="difflineplus">+</span>
<a href="#l53.765"></a><span id="l53.765">   return (mork_change*) 0;</span>
<a href="#l53.766"></a><span id="l53.766"> }</span>
<a href="#l53.767"></a><span id="l53.767"> </span>
<a href="#l53.768"></a><span id="l53.768"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l53.769"></a><span id="l53.769"> </span>
<a href="#l53.770"></a><span id="l53.770"> // NOTE: the following methods ONLY work for sMap_ValIsIP pointer values.</span>
<a href="#l53.771"></a><span id="l53.771"> // (Note the implied assumption that zero is never a good value pattern.)</span>
<a href="#l53.772"></a><span id="l53.772"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l54.1"></a><span id="l54.1" class="difflineminus">--- a/db/mork/src/morkProbeMap.h</span>
<a href="#l54.2"></a><span id="l54.2" class="difflineplus">+++ b/db/mork/src/morkProbeMap.h</span>
<a href="#l54.3"></a><span id="l54.3" class="difflineat">@@ -52,126 +52,126 @@</span>
<a href="#l54.4"></a><span id="l54.4"> #endif</span>
<a href="#l54.5"></a><span id="l54.5"> </span>
<a href="#l54.6"></a><span id="l54.6"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l54.7"></a><span id="l54.7"> </span>
<a href="#l54.8"></a><span id="l54.8"> class morkMapScratch { // utility class used by map subclasses</span>
<a href="#l54.9"></a><span id="l54.9"> public:</span>
<a href="#l54.10"></a><span id="l54.10">   nsIMdbHeap*  sMapScratch_Heap;     // cached sMap_Heap</span>
<a href="#l54.11"></a><span id="l54.11">   mork_count   sMapScratch_Slots;    // cached sMap_Slots</span>
<a href="#l54.12"></a><span id="l54.12" class="difflineminus">-  </span>
<a href="#l54.13"></a><span id="l54.13" class="difflineplus">+</span>
<a href="#l54.14"></a><span id="l54.14">   mork_u1*     sMapScratch_Keys;     // cached sMap_Keys</span>
<a href="#l54.15"></a><span id="l54.15">   mork_u1*     sMapScratch_Vals;     // cached sMap_Vals</span>
<a href="#l54.16"></a><span id="l54.16" class="difflineminus">-  </span>
<a href="#l54.17"></a><span id="l54.17" class="difflineplus">+</span>
<a href="#l54.18"></a><span id="l54.18"> public:</span>
<a href="#l54.19"></a><span id="l54.19">   void halt_map_scratch(morkEnv* ev);</span>
<a href="#l54.20"></a><span id="l54.20"> };</span>
<a href="#l54.21"></a><span id="l54.21"> </span>
<a href="#l54.22"></a><span id="l54.22"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l54.23"></a><span id="l54.23"> </span>
<a href="#l54.24"></a><span id="l54.24"> #define morkDerived_kProbeMap   0x7072 /* ascii 'pr' */</span>
<a href="#l54.25"></a><span id="l54.25"> #define morkProbeMap_kTag     0x70724D50 /* ascii 'prMP' */</span>
<a href="#l54.26"></a><span id="l54.26"> </span>
<a href="#l54.27"></a><span id="l54.27"> #define morkProbeMap_kLazyClearOnAdd ((mork_u1) 'c')</span>
<a href="#l54.28"></a><span id="l54.28" class="difflineminus">- </span>
<a href="#l54.29"></a><span id="l54.29" class="difflineplus">+</span>
<a href="#l54.30"></a><span id="l54.30"> class morkProbeMap: public morkNode {</span>
<a href="#l54.31"></a><span id="l54.31"> </span>
<a href="#l54.32"></a><span id="l54.32"> protected:</span>
<a href="#l54.33"></a><span id="l54.33"> </span>
<a href="#l54.34"></a><span id="l54.34"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l54.35"></a><span id="l54.35">   // nsIMdbHeap*       mNode_Heap;</span>
<a href="#l54.36"></a><span id="l54.36"> </span>
<a href="#l54.37"></a><span id="l54.37">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l54.38"></a><span id="l54.38">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l54.39"></a><span id="l54.39" class="difflineminus">-  </span>
<a href="#l54.40"></a><span id="l54.40" class="difflineplus">+</span>
<a href="#l54.41"></a><span id="l54.41">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l54.42"></a><span id="l54.42">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l54.43"></a><span id="l54.43">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l54.44"></a><span id="l54.44">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l54.45"></a><span id="l54.45" class="difflineminus">-  </span>
<a href="#l54.46"></a><span id="l54.46" class="difflineplus">+</span>
<a href="#l54.47"></a><span id="l54.47">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l54.48"></a><span id="l54.48">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l54.49"></a><span id="l54.49"> </span>
<a href="#l54.50"></a><span id="l54.50"> protected:</span>
<a href="#l54.51"></a><span id="l54.51">   // { begin morkMap slots</span>
<a href="#l54.52"></a><span id="l54.52">   nsIMdbHeap* sMap_Heap; // strong ref to heap allocating all space</span>
<a href="#l54.53"></a><span id="l54.53" class="difflineminus">-    </span>
<a href="#l54.54"></a><span id="l54.54" class="difflineplus">+</span>
<a href="#l54.55"></a><span id="l54.55">   mork_u1*    sMap_Keys;</span>
<a href="#l54.56"></a><span id="l54.56">   mork_u1*    sMap_Vals;</span>
<a href="#l54.57"></a><span id="l54.57" class="difflineminus">-  </span>
<a href="#l54.58"></a><span id="l54.58" class="difflineplus">+</span>
<a href="#l54.59"></a><span id="l54.59">   mork_count  sMap_Seed;   // change count of members or structure</span>
<a href="#l54.60"></a><span id="l54.60" class="difflineminus">-    </span>
<a href="#l54.61"></a><span id="l54.61" class="difflineplus">+</span>
<a href="#l54.62"></a><span id="l54.62">   mork_count  sMap_Slots;  // count of slots in the hash table</span>
<a href="#l54.63"></a><span id="l54.63">   mork_fill   sMap_Fill;   // number of used slots in the hash table</span>
<a href="#l54.64"></a><span id="l54.64"> </span>
<a href="#l54.65"></a><span id="l54.65">   mork_size   sMap_KeySize; // size of each key (cannot be zero)</span>
<a href="#l54.66"></a><span id="l54.66">   mork_size   sMap_ValSize; // size of each val (zero allowed)</span>
<a href="#l54.67"></a><span id="l54.67" class="difflineminus">-  </span>
<a href="#l54.68"></a><span id="l54.68" class="difflineplus">+</span>
<a href="#l54.69"></a><span id="l54.69">   mork_bool   sMap_KeyIsIP;     // sMap_KeySize == sizeof(mork_ip)</span>
<a href="#l54.70"></a><span id="l54.70">   mork_bool   sMap_ValIsIP;     // sMap_ValSize == sizeof(mork_ip)</span>
<a href="#l54.71"></a><span id="l54.71">   mork_u1     sMap_Pad[ 2 ];    // for u4 alignment</span>
<a href="#l54.72"></a><span id="l54.72">   // } end morkMap slots</span>
<a href="#l54.73"></a><span id="l54.73" class="difflineminus">-    </span>
<a href="#l54.74"></a><span id="l54.74" class="difflineplus">+</span>
<a href="#l54.75"></a><span id="l54.75">   friend class morkProbeMapIter; // for access to protected slots</span>
<a href="#l54.76"></a><span id="l54.76"> </span>
<a href="#l54.77"></a><span id="l54.77"> public: // getters</span>
<a href="#l54.78"></a><span id="l54.78">   mork_count  MapSeed() const { return sMap_Seed; }</span>
<a href="#l54.79"></a><span id="l54.79" class="difflineminus">-    </span>
<a href="#l54.80"></a><span id="l54.80" class="difflineplus">+</span>
<a href="#l54.81"></a><span id="l54.81">   mork_count  MapSlots() const { return sMap_Slots; }</span>
<a href="#l54.82"></a><span id="l54.82">   mork_fill   MapFill() const { return sMap_Fill; }</span>
<a href="#l54.83"></a><span id="l54.83"> </span>
<a href="#l54.84"></a><span id="l54.84">   mork_size   MapKeySize() const { return sMap_KeySize; }</span>
<a href="#l54.85"></a><span id="l54.85">   mork_size   MapValSize() const { return sMap_ValSize; }</span>
<a href="#l54.86"></a><span id="l54.86" class="difflineminus">-  </span>
<a href="#l54.87"></a><span id="l54.87" class="difflineplus">+</span>
<a href="#l54.88"></a><span id="l54.88">   mork_bool   MapKeyIsIP() const { return sMap_KeyIsIP; }</span>
<a href="#l54.89"></a><span id="l54.89">   mork_bool   MapValIsIP() const { return sMap_ValIsIP; }</span>
<a href="#l54.90"></a><span id="l54.90"> </span>
<a href="#l54.91"></a><span id="l54.91"> protected: // slots</span>
<a href="#l54.92"></a><span id="l54.92">   // { begin morkProbeMap slots</span>
<a href="#l54.93"></a><span id="l54.93" class="difflineminus">-   </span>
<a href="#l54.94"></a><span id="l54.94" class="difflineplus">+</span>
<a href="#l54.95"></a><span id="l54.95">   mork_fill   sProbeMap_MaxFill; // max sMap_Fill before map must grow</span>
<a href="#l54.96"></a><span id="l54.96" class="difflineminus">-  </span>
<a href="#l54.97"></a><span id="l54.97" class="difflineplus">+</span>
<a href="#l54.98"></a><span id="l54.98">   mork_u1     sProbeMap_LazyClearOnAdd; // true if kLazyClearOnAdd</span>
<a href="#l54.99"></a><span id="l54.99">   mork_bool   sProbeMap_ZeroIsClearKey; // zero is adequate to clear keys</span>
<a href="#l54.100"></a><span id="l54.100">   mork_u1     sProbeMap_Pad[ 2 ]; // for u4 alignment</span>
<a href="#l54.101"></a><span id="l54.101" class="difflineminus">-  </span>
<a href="#l54.102"></a><span id="l54.102" class="difflineminus">-  mork_u4     sProbeMap_Tag; </span>
<a href="#l54.103"></a><span id="l54.103" class="difflineminus">- </span>
<a href="#l54.104"></a><span id="l54.104" class="difflineplus">+</span>
<a href="#l54.105"></a><span id="l54.105" class="difflineplus">+  mork_u4     sProbeMap_Tag;</span>
<a href="#l54.106"></a><span id="l54.106" class="difflineplus">+</span>
<a href="#l54.107"></a><span id="l54.107">   // } end morkProbeMap slots</span>
<a href="#l54.108"></a><span id="l54.108" class="difflineminus">-    </span>
<a href="#l54.109"></a><span id="l54.109" class="difflineplus">+</span>
<a href="#l54.110"></a><span id="l54.110"> public: // lazy clear on add</span>
<a href="#l54.111"></a><span id="l54.111"> </span>
<a href="#l54.112"></a><span id="l54.112" class="difflineminus">-  mork_bool need_lazy_init() const </span>
<a href="#l54.113"></a><span id="l54.113" class="difflineplus">+  mork_bool need_lazy_init() const</span>
<a href="#l54.114"></a><span id="l54.114">   { return sProbeMap_LazyClearOnAdd == morkProbeMap_kLazyClearOnAdd; }</span>
<a href="#l54.115"></a><span id="l54.115"> </span>
<a href="#l54.116"></a><span id="l54.116"> public: // typing</span>
<a href="#l54.117"></a><span id="l54.117">   mork_bool   GoodProbeMap() const</span>
<a href="#l54.118"></a><span id="l54.118">   { return sProbeMap_Tag == morkProbeMap_kTag; }</span>
<a href="#l54.119"></a><span id="l54.119" class="difflineminus">-    </span>
<a href="#l54.120"></a><span id="l54.120" class="difflineplus">+</span>
<a href="#l54.121"></a><span id="l54.121"> protected: // utilities</span>
<a href="#l54.122"></a><span id="l54.122"> </span>
<a href="#l54.123"></a><span id="l54.123">   void* clear_alloc(morkEnv* ev, mork_size inSize);</span>
<a href="#l54.124"></a><span id="l54.124"> </span>
<a href="#l54.125"></a><span id="l54.125">   mork_u1*    map_new_vals(morkEnv* ev, mork_num inSlots);</span>
<a href="#l54.126"></a><span id="l54.126">   mork_u1*    map_new_keys(morkEnv* ev, mork_num inSlots);</span>
<a href="#l54.127"></a><span id="l54.127"> </span>
<a href="#l54.128"></a><span id="l54.128">   void clear_probe_map(morkEnv* ev, nsIMdbHeap* ioMapHeap);</span>
<a href="#l54.129"></a><span id="l54.129">   void init_probe_map(morkEnv* ev, mork_size inSlots);</span>
<a href="#l54.130"></a><span id="l54.130">   void probe_map_lazy_init(morkEnv* ev);</span>
<a href="#l54.131"></a><span id="l54.131"> </span>
<a href="#l54.132"></a><span id="l54.132">   mork_bool new_slots(morkEnv* ev, morkMapScratch* old, mork_num inSlots);</span>
<a href="#l54.133"></a><span id="l54.133" class="difflineminus">-  </span>
<a href="#l54.134"></a><span id="l54.134" class="difflineplus">+</span>
<a href="#l54.135"></a><span id="l54.135">   mork_test find_key_pos(morkEnv* ev, const void* inAppKey,</span>
<a href="#l54.136"></a><span id="l54.136">     mork_u4 inHash, mork_pos* outPos) const;</span>
<a href="#l54.137"></a><span id="l54.137" class="difflineminus">-  </span>
<a href="#l54.138"></a><span id="l54.138" class="difflineplus">+</span>
<a href="#l54.139"></a><span id="l54.139">   void put_probe_kv(morkEnv* ev,</span>
<a href="#l54.140"></a><span id="l54.140">     const void* inAppKey, const void* inAppVal, mork_pos inPos);</span>
<a href="#l54.141"></a><span id="l54.141">   void get_probe_kv(morkEnv* ev,</span>
<a href="#l54.142"></a><span id="l54.142">     void* outAppKey, void* outAppVal, mork_pos inPos) const;</span>
<a href="#l54.143"></a><span id="l54.143" class="difflineminus">-    </span>
<a href="#l54.144"></a><span id="l54.144" class="difflineplus">+</span>
<a href="#l54.145"></a><span id="l54.145">   mork_bool grow_probe_map(morkEnv* ev);</span>
<a href="#l54.146"></a><span id="l54.146">   void      rehash_old_map(morkEnv* ev, morkMapScratch* ioScratch);</span>
<a href="#l54.147"></a><span id="l54.147">   void      revert_map(morkEnv* ev, morkMapScratch* ioScratch);</span>
<a href="#l54.148"></a><span id="l54.148"> </span>
<a href="#l54.149"></a><span id="l54.149"> public: // errors</span>
<a href="#l54.150"></a><span id="l54.150">   void ProbeMapBadTagError(morkEnv* ev) const;</span>
<a href="#l54.151"></a><span id="l54.151">   void WrapWithNoVoidSlotError(morkEnv* ev) const;</span>
<a href="#l54.152"></a><span id="l54.152">   void GrowFailsMaxFillError(morkEnv* ev) const;</span>
<a href="#l54.153"></a><span id="l54.153" class="difflineat">@@ -198,41 +198,41 @@ public:</span>
<a href="#l54.154"></a><span id="l54.154">     //   the bit pattern representation might be different in such cases.</span>
<a href="#l54.155"></a><span id="l54.155">     // morkTest_kHit means that inMapKey equals inAppKey (and this had better</span>
<a href="#l54.156"></a><span id="l54.156">     //   also imply that hash(inMapKey) == hash(inAppKey)).</span>
<a href="#l54.157"></a><span id="l54.157">     // morkTest_kMiss means that inMapKey does NOT equal inAppKey (but this</span>
<a href="#l54.158"></a><span id="l54.158">     //   implies nothing at all about hash(inMapKey) and hash(inAppKey)).</span>
<a href="#l54.159"></a><span id="l54.159">     // morkTest_kVoid means that inMapKey is not a valid key bit pattern,</span>
<a href="#l54.160"></a><span id="l54.160">     //   which means that key slot in the map is not being used.  Note that</span>
<a href="#l54.161"></a><span id="l54.161">     //   kVoid is only expected as a return value in morkProbeMap subclasses,</span>
<a href="#l54.162"></a><span id="l54.162" class="difflineminus">-    //   because morkProbeMap must ask whether a key slot is used or not. </span>
<a href="#l54.163"></a><span id="l54.163" class="difflineplus">+    //   because morkProbeMap must ask whether a key slot is used or not.</span>
<a href="#l54.164"></a><span id="l54.164">     //   morkChainMap however, always knows when a key slot is used, so only</span>
<a href="#l54.165"></a><span id="l54.165">     //   key slots expected to have valid bit patterns will be presented to</span>
<a href="#l54.166"></a><span id="l54.166">     //   the MapTest() methods for morkChainMap subclasses.</span>
<a href="#l54.167"></a><span id="l54.167">     //</span>
<a href="#l54.168"></a><span id="l54.168">     // NOTE: it is very important that subclasses correctly return the value</span>
<a href="#l54.169"></a><span id="l54.169">     // morkTest_kVoid whenever the slot for inMapKey contains a bit pattern</span>
<a href="#l54.170"></a><span id="l54.170">     // that means the slot is not being used, because this is the only way a</span>
<a href="#l54.171"></a><span id="l54.171">     // probe map can terminate an unsuccessful search for a key in the map.</span>
<a href="#l54.172"></a><span id="l54.172"> </span>
<a href="#l54.173"></a><span id="l54.173">   virtual mork_u4 // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l54.174"></a><span id="l54.174">   MapHash(morkEnv* ev, const void* inAppKey) const;</span>
<a href="#l54.175"></a><span id="l54.175"> </span>
<a href="#l54.176"></a><span id="l54.176">   virtual mork_bool</span>
<a href="#l54.177"></a><span id="l54.177">   MapAtPut(morkEnv* ev, const void* inAppKey, const void* inAppVal,</span>
<a href="#l54.178"></a><span id="l54.178">     void* outAppKey, void* outAppVal);</span>
<a href="#l54.179"></a><span id="l54.179" class="difflineminus">-    </span>
<a href="#l54.180"></a><span id="l54.180" class="difflineplus">+</span>
<a href="#l54.181"></a><span id="l54.181">   virtual mork_bool</span>
<a href="#l54.182"></a><span id="l54.182">   MapAt(morkEnv* ev, const void* inAppKey, void* outAppKey, void* outAppVal);</span>
<a href="#l54.183"></a><span id="l54.183" class="difflineminus">-    </span>
<a href="#l54.184"></a><span id="l54.184" class="difflineplus">+</span>
<a href="#l54.185"></a><span id="l54.185">   virtual mork_num</span>
<a href="#l54.186"></a><span id="l54.186">   MapCutAll(morkEnv* ev);</span>
<a href="#l54.187"></a><span id="l54.187">   // } ===== end morkMap methods =====</span>
<a href="#l54.188"></a><span id="l54.188"> </span>
<a href="#l54.189"></a><span id="l54.189" class="difflineminus">-    </span>
<a href="#l54.190"></a><span id="l54.190" class="difflineplus">+</span>
<a href="#l54.191"></a><span id="l54.191">   // { ===== begin morkProbeMap methods =====</span>
<a href="#l54.192"></a><span id="l54.192"> public:</span>
<a href="#l54.193"></a><span id="l54.193"> </span>
<a href="#l54.194"></a><span id="l54.194">   virtual mork_u4</span>
<a href="#l54.195"></a><span id="l54.195">   ProbeMapHashMapKey(morkEnv* ev, const void* inMapKey) const;</span>
<a href="#l54.196"></a><span id="l54.196">     // ProbeMapHashMapKey() does logically the same thing as MapHash(), and</span>
<a href="#l54.197"></a><span id="l54.197">     // the default implementation actually calls virtual MapHash().  However,</span>
<a href="#l54.198"></a><span id="l54.198">     // Subclasses must override this method whenever the formats of keys in</span>
<a href="#l54.199"></a><span id="l54.199" class="difflineat">@@ -322,110 +322,110 @@ public:</span>
<a href="#l54.200"></a><span id="l54.200">     // call to either MapAtPut() or MapAt(), while inMapKey and inMapVal are</span>
<a href="#l54.201"></a><span id="l54.201">     // determined by how the map currently positions the target key in the map.</span>
<a href="#l54.202"></a><span id="l54.202">     //</span>
<a href="#l54.203"></a><span id="l54.203">     // Note any key or val parameter can be a null pointer, in which case</span>
<a href="#l54.204"></a><span id="l54.204">     // this method must do nothing with those parameters.  In particular, do</span>
<a href="#l54.205"></a><span id="l54.205">     // no key move at all when either inMapKey or outAppKey is nil, and do</span>
<a href="#l54.206"></a><span id="l54.206">     // no val move at all when either inMapVal or outAppVal is nil.  Note that</span>
<a href="#l54.207"></a><span id="l54.207">     // inMapVal should always be nil when this-&gt;MapValSize() is nil.</span>
<a href="#l54.208"></a><span id="l54.208" class="difflineminus">-  </span>
<a href="#l54.209"></a><span id="l54.209" class="difflineplus">+</span>
<a href="#l54.210"></a><span id="l54.210">   // } ===== end morkProbeMap methods =====</span>
<a href="#l54.211"></a><span id="l54.211" class="difflineminus">-    </span>
<a href="#l54.212"></a><span id="l54.212" class="difflineminus">-  </span>
<a href="#l54.213"></a><span id="l54.213" class="difflineplus">+</span>
<a href="#l54.214"></a><span id="l54.214" class="difflineplus">+</span>
<a href="#l54.215"></a><span id="l54.215"> // { ===== begin morkNode interface =====</span>
<a href="#l54.216"></a><span id="l54.216"> public: // morkNode virtual methods</span>
<a href="#l54.217"></a><span id="l54.217">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseProbeMap() only if open</span>
<a href="#l54.218"></a><span id="l54.218">   virtual ~morkProbeMap(); // assert that CloseProbeMap() executed earlier</span>
<a href="#l54.219"></a><span id="l54.219" class="difflineminus">-  </span>
<a href="#l54.220"></a><span id="l54.220" class="difflineplus">+</span>
<a href="#l54.221"></a><span id="l54.221"> public: // morkProbeMap construction &amp; destruction</span>
<a href="#l54.222"></a><span id="l54.222">   morkProbeMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l54.223"></a><span id="l54.223">   nsIMdbHeap* ioNodeHeap,</span>
<a href="#l54.224"></a><span id="l54.224">   mork_size inKeySize, mork_size inValSize,</span>
<a href="#l54.225"></a><span id="l54.225">   nsIMdbHeap* ioMapHeap, mork_size inSlots,</span>
<a href="#l54.226"></a><span id="l54.226">   mork_bool inZeroIsClearKey);</span>
<a href="#l54.227"></a><span id="l54.227" class="difflineminus">-  </span>
<a href="#l54.228"></a><span id="l54.228" class="difflineminus">-  void CloseProbeMap(morkEnv* ev); // called by </span>
<a href="#l54.229"></a><span id="l54.229" class="difflineminus">-  </span>
<a href="#l54.230"></a><span id="l54.230" class="difflineplus">+</span>
<a href="#l54.231"></a><span id="l54.231" class="difflineplus">+  void CloseProbeMap(morkEnv* ev); // called by</span>
<a href="#l54.232"></a><span id="l54.232" class="difflineplus">+</span>
<a href="#l54.233"></a><span id="l54.233"> public: // dynamic type identification</span>
<a href="#l54.234"></a><span id="l54.234">   mork_bool IsProbeMap() const</span>
<a href="#l54.235"></a><span id="l54.235">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kProbeMap; }</span>
<a href="#l54.236"></a><span id="l54.236"> // } ===== end morkNode methods =====</span>
<a href="#l54.237"></a><span id="l54.237"> </span>
<a href="#l54.238"></a><span id="l54.238"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l54.239"></a><span id="l54.239">   static void SlotWeakMap(morkMap* me,</span>
<a href="#l54.240"></a><span id="l54.240">     morkEnv* ev, morkMap** ioSlot)</span>
<a href="#l54.241"></a><span id="l54.241">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l54.242"></a><span id="l54.242" class="difflineminus">-  </span>
<a href="#l54.243"></a><span id="l54.243" class="difflineplus">+</span>
<a href="#l54.244"></a><span id="l54.244">   static void SlotStrongMap(morkMap* me,</span>
<a href="#l54.245"></a><span id="l54.245">     morkEnv* ev, morkMap** ioSlot)</span>
<a href="#l54.246"></a><span id="l54.246">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l54.247"></a><span id="l54.247"> };</span>
<a href="#l54.248"></a><span id="l54.248"> </span>
<a href="#l54.249"></a><span id="l54.249"> /*============================================================================*/</span>
<a href="#l54.250"></a><span id="l54.250"> /* morkProbeMapIter */</span>
<a href="#l54.251"></a><span id="l54.251"> </span>
<a href="#l54.252"></a><span id="l54.252"> #define morkProbeMapIter_kBeforeIx ((mork_i4) -1) /* before first member */</span>
<a href="#l54.253"></a><span id="l54.253"> #define morkProbeMapIter_kAfterIx  ((mork_i4) -2) /* after last member */</span>
<a href="#l54.254"></a><span id="l54.254"> </span>
<a href="#l54.255"></a><span id="l54.255"> class morkProbeMapIter {</span>
<a href="#l54.256"></a><span id="l54.256"> </span>
<a href="#l54.257"></a><span id="l54.257"> protected:</span>
<a href="#l54.258"></a><span id="l54.258">   morkProbeMap* sProbeMapIter_Map;      // nonref</span>
<a href="#l54.259"></a><span id="l54.259">   mork_num      sProbeMapIter_Seed;     // iter's cached copy of map's seed</span>
<a href="#l54.260"></a><span id="l54.260" class="difflineminus">-  </span>
<a href="#l54.261"></a><span id="l54.261" class="difflineplus">+</span>
<a href="#l54.262"></a><span id="l54.262">   mork_i4       sProbeMapIter_HereIx;</span>
<a href="#l54.263"></a><span id="l54.263" class="difflineminus">-  </span>
<a href="#l54.264"></a><span id="l54.264" class="difflineplus">+</span>
<a href="#l54.265"></a><span id="l54.265">   mork_change   sProbeMapIter_Change;   // morkMapIter API simulation dummy</span>
<a href="#l54.266"></a><span id="l54.266">   mork_u1       sProbeMapIter_Pad[ 3 ]; // for u4 alignment</span>
<a href="#l54.267"></a><span id="l54.267" class="difflineminus">-  </span>
<a href="#l54.268"></a><span id="l54.268" class="difflineplus">+</span>
<a href="#l54.269"></a><span id="l54.269"> public:</span>
<a href="#l54.270"></a><span id="l54.270">   morkProbeMapIter(morkEnv* ev, morkProbeMap* ioMap);</span>
<a href="#l54.271"></a><span id="l54.271">   void CloseMapIter(morkEnv* ev);</span>
<a href="#l54.272"></a><span id="l54.272" class="difflineminus">- </span>
<a href="#l54.273"></a><span id="l54.273" class="difflineplus">+</span>
<a href="#l54.274"></a><span id="l54.274">   morkProbeMapIter( ); // zero most slots; caller must call InitProbeMapIter()</span>
<a href="#l54.275"></a><span id="l54.275"> </span>
<a href="#l54.276"></a><span id="l54.276"> protected: // protected so subclasses must provide suitable typesafe inlines:</span>
<a href="#l54.277"></a><span id="l54.277"> </span>
<a href="#l54.278"></a><span id="l54.278">   void InitProbeMapIter(morkEnv* ev, morkProbeMap* ioMap);</span>
<a href="#l54.279"></a><span id="l54.279" class="difflineminus">-   </span>
<a href="#l54.280"></a><span id="l54.280" class="difflineplus">+</span>
<a href="#l54.281"></a><span id="l54.281">   void InitMapIter(morkEnv* ev, morkProbeMap* ioMap) // morkMapIter compatibility</span>
<a href="#l54.282"></a><span id="l54.282">   { this-&gt;InitProbeMapIter(ev, ioMap); }</span>
<a href="#l54.283"></a><span id="l54.283" class="difflineminus">-   </span>
<a href="#l54.284"></a><span id="l54.284" class="difflineplus">+</span>
<a href="#l54.285"></a><span id="l54.285">   mork_bool IterFirst(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l54.286"></a><span id="l54.286">   mork_bool IterNext(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l54.287"></a><span id="l54.287">   mork_bool IterHere(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l54.288"></a><span id="l54.288" class="difflineminus">-   </span>
<a href="#l54.289"></a><span id="l54.289" class="difflineplus">+</span>
<a href="#l54.290"></a><span id="l54.290">   // NOTE: the following methods ONLY work for sMap_ValIsIP pointer values.</span>
<a href="#l54.291"></a><span id="l54.291">   // (Note the implied assumption that zero is never a good value pattern.)</span>
<a href="#l54.292"></a><span id="l54.292" class="difflineminus">-  </span>
<a href="#l54.293"></a><span id="l54.293" class="difflineplus">+</span>
<a href="#l54.294"></a><span id="l54.294">   void*     IterFirstVal(morkEnv* ev, void* outKey);</span>
<a href="#l54.295"></a><span id="l54.295">   // equivalent to { void* v=0; this-&gt;IterFirst(ev, outKey, &amp;v); return v; }</span>
<a href="#l54.296"></a><span id="l54.296" class="difflineminus">-  </span>
<a href="#l54.297"></a><span id="l54.297" class="difflineplus">+</span>
<a href="#l54.298"></a><span id="l54.298">   void*     IterNextVal(morkEnv* ev, void* outKey);</span>
<a href="#l54.299"></a><span id="l54.299">   // equivalent to { void* v=0; this-&gt;IterNext(ev, outKey, &amp;v); return v; }</span>
<a href="#l54.300"></a><span id="l54.300"> </span>
<a href="#l54.301"></a><span id="l54.301">   void*     IterHereVal(morkEnv* ev, void* outKey);</span>
<a href="#l54.302"></a><span id="l54.302">   // equivalent to { void* v=0; this-&gt;IterHere(ev, outKey, &amp;v); return v; }</span>
<a href="#l54.303"></a><span id="l54.303"> </span>
<a href="#l54.304"></a><span id="l54.304">   // NOTE: the following methods ONLY work for sMap_KeyIsIP pointer values.</span>
<a href="#l54.305"></a><span id="l54.305">   // (Note the implied assumption that zero is never a good key pattern.)</span>
<a href="#l54.306"></a><span id="l54.306" class="difflineminus">-  </span>
<a href="#l54.307"></a><span id="l54.307" class="difflineplus">+</span>
<a href="#l54.308"></a><span id="l54.308">   void*     IterFirstKey(morkEnv* ev);</span>
<a href="#l54.309"></a><span id="l54.309">   // equivalent to { void* k=0; this-&gt;IterFirst(ev, &amp;k, 0); return k; }</span>
<a href="#l54.310"></a><span id="l54.310" class="difflineminus">-  </span>
<a href="#l54.311"></a><span id="l54.311" class="difflineplus">+</span>
<a href="#l54.312"></a><span id="l54.312">   void*     IterNextKey(morkEnv* ev);</span>
<a href="#l54.313"></a><span id="l54.313">   // equivalent to { void* k=0; this-&gt;IterNext(ev, &amp;k, 0); return k; }</span>
<a href="#l54.314"></a><span id="l54.314"> </span>
<a href="#l54.315"></a><span id="l54.315">   void*     IterHereKey(morkEnv* ev);</span>
<a href="#l54.316"></a><span id="l54.316">   // equivalent to { void* k=0; this-&gt;IterHere(ev, &amp;k, 0); return k; }</span>
<a href="#l54.317"></a><span id="l54.317"> </span>
<a href="#l54.318"></a><span id="l54.318" class="difflineminus">-public: // simulation of the morkMapIter API for morkMap compatibility:  </span>
<a href="#l54.319"></a><span id="l54.319" class="difflineplus">+public: // simulation of the morkMapIter API for morkMap compatibility:</span>
<a href="#l54.320"></a><span id="l54.320">   mork_change* First(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l54.321"></a><span id="l54.321">   mork_change* Next(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l54.322"></a><span id="l54.322">   mork_change* Here(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l54.323"></a><span id="l54.323" class="difflineminus">-  </span>
<a href="#l54.324"></a><span id="l54.324" class="difflineplus">+</span>
<a href="#l54.325"></a><span id="l54.325">   mork_change* CutHere(morkEnv* ev, void* outKey, void* outVal);</span>
<a href="#l54.326"></a><span id="l54.326"> };</span>
<a href="#l54.327"></a><span id="l54.327"> </span>
<a href="#l54.328"></a><span id="l54.328"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l54.329"></a><span id="l54.329"> </span>
<a href="#l54.330"></a><span id="l54.330"> #endif /* _MORKPROBEMAP_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l55.1"></a><span id="l55.1" class="difflineminus">--- a/db/mork/src/morkQuickSort.h</span>
<a href="#l55.2"></a><span id="l55.2" class="difflineplus">+++ b/db/mork/src/morkQuickSort.h</span>
<a href="#l55.3"></a><span id="l55.3" class="difflineat">@@ -14,12 +14,12 @@</span>
<a href="#l55.4"></a><span id="l55.4"> #include &quot;mork.h&quot;</span>
<a href="#l55.5"></a><span id="l55.5"> #endif</span>
<a href="#l55.6"></a><span id="l55.6"> </span>
<a href="#l55.7"></a><span id="l55.7"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l55.8"></a><span id="l55.8"> </span>
<a href="#l55.9"></a><span id="l55.9"> extern void</span>
<a href="#l55.10"></a><span id="l55.10"> morkQuickSort(mork_u1* ioVec, mork_u4 inCount, mork_u4 inSize,</span>
<a href="#l55.11"></a><span id="l55.11">   mdbAny_Order inOrder, void* ioClosure);</span>
<a href="#l55.12"></a><span id="l55.12" class="difflineminus">- </span>
<a href="#l55.13"></a><span id="l55.13" class="difflineplus">+</span>
<a href="#l55.14"></a><span id="l55.14"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l55.15"></a><span id="l55.15"> </span>
<a href="#l55.16"></a><span id="l55.16"> #endif /* _MORKQUICKSORT_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l56.1"></a><span id="l56.1" class="difflineminus">--- a/db/mork/src/morkRow.cpp</span>
<a href="#l56.2"></a><span id="l56.2" class="difflineplus">+++ b/db/mork/src/morkRow.cpp</span>
<a href="#l56.3"></a><span id="l56.3" class="difflineat">@@ -57,17 +57,17 @@</span>
<a href="#l56.4"></a><span id="l56.4"> // notifications regarding row changes:</span>
<a href="#l56.5"></a><span id="l56.5"> </span>
<a href="#l56.6"></a><span id="l56.6"> void morkRow::NoteRowAddCol(morkEnv* ev, mork_column inColumn)</span>
<a href="#l56.7"></a><span id="l56.7"> {</span>
<a href="#l56.8"></a><span id="l56.8">   if ( !this-&gt;IsRowRewrite() )</span>
<a href="#l56.9"></a><span id="l56.9">   {</span>
<a href="#l56.10"></a><span id="l56.10">     mork_delta newDelta;</span>
<a href="#l56.11"></a><span id="l56.11">     morkDelta_Init(newDelta, inColumn, morkChange_kAdd);</span>
<a href="#l56.12"></a><span id="l56.12" class="difflineminus">-    </span>
<a href="#l56.13"></a><span id="l56.13" class="difflineplus">+</span>
<a href="#l56.14"></a><span id="l56.14">     if ( newDelta != mRow_Delta ) // not repeating existing data?</span>
<a href="#l56.15"></a><span id="l56.15">     {</span>
<a href="#l56.16"></a><span id="l56.16">       if ( this-&gt;HasRowDelta() ) // already have one change recorded?</span>
<a href="#l56.17"></a><span id="l56.17">         this-&gt;SetRowRewrite(); // just plan to write all row cells</span>
<a href="#l56.18"></a><span id="l56.18">       else</span>
<a href="#l56.19"></a><span id="l56.19">         this-&gt;SetRowDelta(inColumn, morkChange_kAdd);</span>
<a href="#l56.20"></a><span id="l56.20">     }</span>
<a href="#l56.21"></a><span id="l56.21">   }</span>
<a href="#l56.22"></a><span id="l56.22" class="difflineat">@@ -76,17 +76,17 @@ void morkRow::NoteRowAddCol(morkEnv* ev,</span>
<a href="#l56.23"></a><span id="l56.23"> }</span>
<a href="#l56.24"></a><span id="l56.24"> </span>
<a href="#l56.25"></a><span id="l56.25"> void morkRow::NoteRowCutCol(morkEnv* ev, mork_column inColumn)</span>
<a href="#l56.26"></a><span id="l56.26"> {</span>
<a href="#l56.27"></a><span id="l56.27">   if ( !this-&gt;IsRowRewrite() )</span>
<a href="#l56.28"></a><span id="l56.28">   {</span>
<a href="#l56.29"></a><span id="l56.29">     mork_delta newDelta;</span>
<a href="#l56.30"></a><span id="l56.30">     morkDelta_Init(newDelta, inColumn, morkChange_kCut);</span>
<a href="#l56.31"></a><span id="l56.31" class="difflineminus">-    </span>
<a href="#l56.32"></a><span id="l56.32" class="difflineplus">+</span>
<a href="#l56.33"></a><span id="l56.33">     if ( newDelta != mRow_Delta ) // not repeating existing data?</span>
<a href="#l56.34"></a><span id="l56.34">     {</span>
<a href="#l56.35"></a><span id="l56.35">       if ( this-&gt;HasRowDelta() ) // already have one change recorded?</span>
<a href="#l56.36"></a><span id="l56.36">         this-&gt;SetRowRewrite(); // just plan to write all row cells</span>
<a href="#l56.37"></a><span id="l56.37">       else</span>
<a href="#l56.38"></a><span id="l56.38">         this-&gt;SetRowDelta(inColumn, morkChange_kCut);</span>
<a href="#l56.39"></a><span id="l56.39">     }</span>
<a href="#l56.40"></a><span id="l56.40">   }</span>
<a href="#l56.41"></a><span id="l56.41" class="difflineat">@@ -118,17 +118,17 @@ morkRow::AddRowGcUse(morkEnv* ev)</span>
<a href="#l56.42"></a><span id="l56.42"> {</span>
<a href="#l56.43"></a><span id="l56.43">   if ( this-&gt;IsRow() )</span>
<a href="#l56.44"></a><span id="l56.44">   {</span>
<a href="#l56.45"></a><span id="l56.45">     if ( mRow_GcUses &lt; morkRow_kMaxGcUses ) // not already maxed out?</span>
<a href="#l56.46"></a><span id="l56.46">       ++mRow_GcUses;</span>
<a href="#l56.47"></a><span id="l56.47">   }</span>
<a href="#l56.48"></a><span id="l56.48">   else</span>
<a href="#l56.49"></a><span id="l56.49">     this-&gt;NonRowTypeError(ev);</span>
<a href="#l56.50"></a><span id="l56.50" class="difflineminus">-    </span>
<a href="#l56.51"></a><span id="l56.51" class="difflineplus">+</span>
<a href="#l56.52"></a><span id="l56.52">   return mRow_GcUses;</span>
<a href="#l56.53"></a><span id="l56.53"> }</span>
<a href="#l56.54"></a><span id="l56.54"> </span>
<a href="#l56.55"></a><span id="l56.55"> mork_u2</span>
<a href="#l56.56"></a><span id="l56.56"> morkRow::CutRowGcUse(morkEnv* ev)</span>
<a href="#l56.57"></a><span id="l56.57"> {</span>
<a href="#l56.58"></a><span id="l56.58">   if ( this-&gt;IsRow() )</span>
<a href="#l56.59"></a><span id="l56.59">   {</span>
<a href="#l56.60"></a><span id="l56.60" class="difflineat">@@ -137,17 +137,17 @@ morkRow::CutRowGcUse(morkEnv* ev)</span>
<a href="#l56.61"></a><span id="l56.61">       if ( mRow_GcUses &lt; morkRow_kMaxGcUses ) // not frozen at max?</span>
<a href="#l56.62"></a><span id="l56.62">         --mRow_GcUses;</span>
<a href="#l56.63"></a><span id="l56.63">     }</span>
<a href="#l56.64"></a><span id="l56.64">     else</span>
<a href="#l56.65"></a><span id="l56.65">       this-&gt;GcUsesUnderflowWarning(ev);</span>
<a href="#l56.66"></a><span id="l56.66">   }</span>
<a href="#l56.67"></a><span id="l56.67">   else</span>
<a href="#l56.68"></a><span id="l56.68">     this-&gt;NonRowTypeError(ev);</span>
<a href="#l56.69"></a><span id="l56.69" class="difflineminus">-    </span>
<a href="#l56.70"></a><span id="l56.70" class="difflineplus">+</span>
<a href="#l56.71"></a><span id="l56.71">   return mRow_GcUses;</span>
<a href="#l56.72"></a><span id="l56.72"> }</span>
<a href="#l56.73"></a><span id="l56.73"> </span>
<a href="#l56.74"></a><span id="l56.74"> /*static*/ void</span>
<a href="#l56.75"></a><span id="l56.75"> morkRow::GcUsesUnderflowWarning(morkEnv* ev)</span>
<a href="#l56.76"></a><span id="l56.76"> {</span>
<a href="#l56.77"></a><span id="l56.77">   ev-&gt;NewWarning(&quot;mRow_GcUses underflow&quot;);</span>
<a href="#l56.78"></a><span id="l56.78"> }</span>
<a href="#l56.79"></a><span id="l56.79" class="difflineat">@@ -201,17 +201,17 @@ morkRow::InitRow(morkEnv* ev, const mdbO</span>
<a href="#l56.80"></a><span id="l56.80"> </span>
<a href="#l56.81"></a><span id="l56.81">         mRow_Length = (mork_u2) inLength;</span>
<a href="#l56.82"></a><span id="l56.82">         mRow_Seed = (mork_u2) (mork_ip) this; // &quot;random&quot; assignment</span>
<a href="#l56.83"></a><span id="l56.83"> </span>
<a href="#l56.84"></a><span id="l56.84">         mRow_GcUses = 0;</span>
<a href="#l56.85"></a><span id="l56.85">         mRow_Pad = 0;</span>
<a href="#l56.86"></a><span id="l56.86">         mRow_Flags = 0;</span>
<a href="#l56.87"></a><span id="l56.87">         mRow_Tag = morkRow_kTag;</span>
<a href="#l56.88"></a><span id="l56.88" class="difflineminus">-        </span>
<a href="#l56.89"></a><span id="l56.89" class="difflineplus">+</span>
<a href="#l56.90"></a><span id="l56.90">         morkZone* zone = &amp;ioSpace-&gt;mSpace_Store-&gt;mStore_Zone;</span>
<a href="#l56.91"></a><span id="l56.91"> </span>
<a href="#l56.92"></a><span id="l56.92">         if ( inLength )</span>
<a href="#l56.93"></a><span id="l56.93">           mRow_Cells = ioPool-&gt;NewCells(ev, inLength, zone);</span>
<a href="#l56.94"></a><span id="l56.94"> </span>
<a href="#l56.95"></a><span id="l56.95">         if ( this-&gt;MaybeDirtySpaceStoreAndRow() ) // new row might dirty store</span>
<a href="#l56.96"></a><span id="l56.96">         {</span>
<a href="#l56.97"></a><span id="l56.97">           this-&gt;SetRowRewrite();</span>
<a href="#l56.98"></a><span id="l56.98" class="difflineat">@@ -286,17 +286,17 @@ morkRow::CountOverlap(morkEnv* ev, morkC</span>
<a href="#l56.99"></a><span id="l56.99">   mork_count outCount = 0;</span>
<a href="#l56.100"></a><span id="l56.100">   mork_pos pos = 0; // needed by GetCell()</span>
<a href="#l56.101"></a><span id="l56.101">   morkCell* cells = ioVector;</span>
<a href="#l56.102"></a><span id="l56.102">   morkCell* end = cells + inFill;</span>
<a href="#l56.103"></a><span id="l56.103">   --cells; // prepare for preincrement</span>
<a href="#l56.104"></a><span id="l56.104">   while ( ++cells &lt; end &amp;&amp; ev-&gt;Good() )</span>
<a href="#l56.105"></a><span id="l56.105">   {</span>
<a href="#l56.106"></a><span id="l56.106">     mork_column col = cells-&gt;GetColumn();</span>
<a href="#l56.107"></a><span id="l56.107" class="difflineminus">-    </span>
<a href="#l56.108"></a><span id="l56.108" class="difflineplus">+</span>
<a href="#l56.109"></a><span id="l56.109">     morkCell* old = this-&gt;GetCell(ev, col, &amp;pos);</span>
<a href="#l56.110"></a><span id="l56.110">     if ( old ) // same column?</span>
<a href="#l56.111"></a><span id="l56.111">     {</span>
<a href="#l56.112"></a><span id="l56.112">       mork_change newChg = cells-&gt;GetChange();</span>
<a href="#l56.113"></a><span id="l56.113">       mork_change oldChg = old-&gt;GetChange();</span>
<a href="#l56.114"></a><span id="l56.114">       if ( newChg != morkChange_kCut || oldChg != newChg ) // not cut+cut?</span>
<a href="#l56.115"></a><span id="l56.115">       {</span>
<a href="#l56.116"></a><span id="l56.116">         if ( cells-&gt;mCell_Atom != old-&gt;mCell_Atom ) // not same atom?</span>
<a href="#l56.117"></a><span id="l56.117" class="difflineat">@@ -316,17 +316,17 @@ morkRow::MergeCells(morkEnv* ev, morkCel</span>
<a href="#l56.118"></a><span id="l56.118">   // inOldRowFill is the old value of mRow_Length, and inOverlap is the</span>
<a href="#l56.119"></a><span id="l56.119">   // number of cells in the intersection that must be updated.</span>
<a href="#l56.120"></a><span id="l56.120"> {</span>
<a href="#l56.121"></a><span id="l56.121">   morkCell* newCells = mRow_Cells + inOldRowFill; // 1st new cell in row</span>
<a href="#l56.122"></a><span id="l56.122">   morkCell* newEnd = newCells + mRow_Length; // one past last cell</span>
<a href="#l56.123"></a><span id="l56.123"> </span>
<a href="#l56.124"></a><span id="l56.124">   morkCell* srcCells = ioVector;</span>
<a href="#l56.125"></a><span id="l56.125">   morkCell* srcEnd = srcCells + inVecLength;</span>
<a href="#l56.126"></a><span id="l56.126" class="difflineminus">-  </span>
<a href="#l56.127"></a><span id="l56.127" class="difflineplus">+</span>
<a href="#l56.128"></a><span id="l56.128">   --srcCells; // prepare for preincrement</span>
<a href="#l56.129"></a><span id="l56.129">   while ( ++srcCells &lt; srcEnd &amp;&amp; ev-&gt;Good() )</span>
<a href="#l56.130"></a><span id="l56.130">   {</span>
<a href="#l56.131"></a><span id="l56.131">     mork_change srcChg = srcCells-&gt;GetChange();</span>
<a href="#l56.132"></a><span id="l56.132">     if ( srcChg != morkChange_kDup ) // anything to be done?</span>
<a href="#l56.133"></a><span id="l56.133">     {</span>
<a href="#l56.134"></a><span id="l56.134">       morkCell* dstCell = 0;</span>
<a href="#l56.135"></a><span id="l56.135">       if ( inOverlap )</span>
<a href="#l56.136"></a><span id="l56.136" class="difflineat">@@ -358,22 +358,22 @@ morkRow::MergeCells(morkEnv* ev, morkCel</span>
<a href="#l56.137"></a><span id="l56.137"> void</span>
<a href="#l56.138"></a><span id="l56.138"> morkRow::TakeCells(morkEnv* ev, morkCell* ioVector, mork_fill inVecLength,</span>
<a href="#l56.139"></a><span id="l56.139">   morkStore* ioStore)</span>
<a href="#l56.140"></a><span id="l56.140"> {</span>
<a href="#l56.141"></a><span id="l56.141">   if ( ioVector &amp;&amp; inVecLength &amp;&amp; ev-&gt;Good() )</span>
<a href="#l56.142"></a><span id="l56.142">   {</span>
<a href="#l56.143"></a><span id="l56.143">     ++mRow_Seed; // intend to change structure of mRow_Cells</span>
<a href="#l56.144"></a><span id="l56.144">     mork_size length = (mork_size) mRow_Length;</span>
<a href="#l56.145"></a><span id="l56.145" class="difflineminus">-    </span>
<a href="#l56.146"></a><span id="l56.146" class="difflineplus">+</span>
<a href="#l56.147"></a><span id="l56.147">     mork_count overlap = this-&gt;CountOverlap(ev, ioVector, inVecLength);</span>
<a href="#l56.148"></a><span id="l56.148"> </span>
<a href="#l56.149"></a><span id="l56.149">     mork_size growth = inVecLength - overlap; // cells to add</span>
<a href="#l56.150"></a><span id="l56.150">     mork_size newLength = length + growth;</span>
<a href="#l56.151"></a><span id="l56.151" class="difflineminus">-    </span>
<a href="#l56.152"></a><span id="l56.152" class="difflineplus">+</span>
<a href="#l56.153"></a><span id="l56.153">     if ( growth &amp;&amp; ev-&gt;Good() ) // need to add any cells?</span>
<a href="#l56.154"></a><span id="l56.154">     {</span>
<a href="#l56.155"></a><span id="l56.155">       morkZone* zone = &amp;ioStore-&gt;mStore_Zone;</span>
<a href="#l56.156"></a><span id="l56.156">       morkPool* pool = ioStore-&gt;StorePool();</span>
<a href="#l56.157"></a><span id="l56.157">       if ( !pool-&gt;AddRowCells(ev, this, length + growth, zone) )</span>
<a href="#l56.158"></a><span id="l56.158">         ev-&gt;NewError(&quot;cannot take cells&quot;);</span>
<a href="#l56.159"></a><span id="l56.159">     }</span>
<a href="#l56.160"></a><span id="l56.160">     if ( ev-&gt;Good() )</span>
<a href="#l56.161"></a><span id="l56.161" class="difflineat">@@ -392,17 +392,17 @@ mork_bool morkRow::MaybeDirtySpaceStoreA</span>
<a href="#l56.162"></a><span id="l56.162">   if ( rowSpace )</span>
<a href="#l56.163"></a><span id="l56.163">   {</span>
<a href="#l56.164"></a><span id="l56.164">     morkStore* store = rowSpace-&gt;mSpace_Store;</span>
<a href="#l56.165"></a><span id="l56.165">     if ( store &amp;&amp; store-&gt;mStore_CanDirty )</span>
<a href="#l56.166"></a><span id="l56.166">     {</span>
<a href="#l56.167"></a><span id="l56.167">       store-&gt;SetStoreDirty();</span>
<a href="#l56.168"></a><span id="l56.168">       rowSpace-&gt;mSpace_CanDirty = morkBool_kTrue;</span>
<a href="#l56.169"></a><span id="l56.169">     }</span>
<a href="#l56.170"></a><span id="l56.170" class="difflineminus">-    </span>
<a href="#l56.171"></a><span id="l56.171" class="difflineplus">+</span>
<a href="#l56.172"></a><span id="l56.172">     if ( rowSpace-&gt;mSpace_CanDirty )</span>
<a href="#l56.173"></a><span id="l56.173">     {</span>
<a href="#l56.174"></a><span id="l56.174">       this-&gt;SetRowDirty();</span>
<a href="#l56.175"></a><span id="l56.175">       rowSpace-&gt;SetRowSpaceDirty();</span>
<a href="#l56.176"></a><span id="l56.176">       return morkBool_kTrue;</span>
<a href="#l56.177"></a><span id="l56.177">     }</span>
<a href="#l56.178"></a><span id="l56.178">   }</span>
<a href="#l56.179"></a><span id="l56.179">   return morkBool_kFalse;</span>
<a href="#l56.180"></a><span id="l56.180" class="difflineat">@@ -412,40 +412,40 @@ morkCell*</span>
<a href="#l56.181"></a><span id="l56.181"> morkRow::NewCell(morkEnv* ev, mdb_column inColumn,</span>
<a href="#l56.182"></a><span id="l56.182">   mork_pos* outPos, morkStore* ioStore)</span>
<a href="#l56.183"></a><span id="l56.183"> {</span>
<a href="#l56.184"></a><span id="l56.184">   ++mRow_Seed; // intend to change structure of mRow_Cells</span>
<a href="#l56.185"></a><span id="l56.185">   mork_size length = (mork_size) mRow_Length;</span>
<a href="#l56.186"></a><span id="l56.186">   *outPos = (mork_pos) length;</span>
<a href="#l56.187"></a><span id="l56.187">   morkPool* pool = ioStore-&gt;StorePool();</span>
<a href="#l56.188"></a><span id="l56.188">   morkZone* zone = &amp;ioStore-&gt;mStore_Zone;</span>
<a href="#l56.189"></a><span id="l56.189" class="difflineminus">-  </span>
<a href="#l56.190"></a><span id="l56.190" class="difflineplus">+</span>
<a href="#l56.191"></a><span id="l56.191">   mork_bool canDirty = this-&gt;MaybeDirtySpaceStoreAndRow();</span>
<a href="#l56.192"></a><span id="l56.192" class="difflineminus">-  </span>
<a href="#l56.193"></a><span id="l56.193" class="difflineplus">+</span>
<a href="#l56.194"></a><span id="l56.194">   if ( pool-&gt;AddRowCells(ev, this, length + 1, zone) )</span>
<a href="#l56.195"></a><span id="l56.195">   {</span>
<a href="#l56.196"></a><span id="l56.196">     morkCell* cell = mRow_Cells + length;</span>
<a href="#l56.197"></a><span id="l56.197">     // next line equivalent to inline morkCell::SetCellDirty():</span>
<a href="#l56.198"></a><span id="l56.198">     if ( canDirty )</span>
<a href="#l56.199"></a><span id="l56.199">       cell-&gt;SetCellColumnDirty(inColumn);</span>
<a href="#l56.200"></a><span id="l56.200">     else</span>
<a href="#l56.201"></a><span id="l56.201">       cell-&gt;SetCellColumnClean(inColumn);</span>
<a href="#l56.202"></a><span id="l56.202" class="difflineminus">-      </span>
<a href="#l56.203"></a><span id="l56.203" class="difflineplus">+</span>
<a href="#l56.204"></a><span id="l56.204">     if ( canDirty &amp;&amp; !this-&gt;IsRowRewrite() )</span>
<a href="#l56.205"></a><span id="l56.205">       this-&gt;NoteRowAddCol(ev, inColumn);</span>
<a href="#l56.206"></a><span id="l56.206" class="difflineminus">-      </span>
<a href="#l56.207"></a><span id="l56.207" class="difflineplus">+</span>
<a href="#l56.208"></a><span id="l56.208">     return cell;</span>
<a href="#l56.209"></a><span id="l56.209">   }</span>
<a href="#l56.210"></a><span id="l56.210" class="difflineminus">-    </span>
<a href="#l56.211"></a><span id="l56.211" class="difflineplus">+</span>
<a href="#l56.212"></a><span id="l56.212">   return (morkCell*) 0;</span>
<a href="#l56.213"></a><span id="l56.213"> }</span>
<a href="#l56.214"></a><span id="l56.214"> </span>
<a href="#l56.215"></a><span id="l56.215"> </span>
<a href="#l56.216"></a><span id="l56.216"> </span>
<a href="#l56.217"></a><span id="l56.217" class="difflineminus">-void morkRow::SeekColumn(morkEnv* ev, mdb_pos inPos, </span>
<a href="#l56.218"></a><span id="l56.218" class="difflineplus">+void morkRow::SeekColumn(morkEnv* ev, mdb_pos inPos,</span>
<a href="#l56.219"></a><span id="l56.219">   mdb_column* outColumn, mdbYarn* outYarn)</span>
<a href="#l56.220"></a><span id="l56.220"> {</span>
<a href="#l56.221"></a><span id="l56.221">   morkCell* cells = mRow_Cells;</span>
<a href="#l56.222"></a><span id="l56.222">   if ( cells &amp;&amp; inPos &lt; mRow_Length &amp;&amp; inPos &gt;= 0 )</span>
<a href="#l56.223"></a><span id="l56.223">   {</span>
<a href="#l56.224"></a><span id="l56.224">     morkCell* c = cells + inPos;</span>
<a href="#l56.225"></a><span id="l56.225">     if ( outColumn )</span>
<a href="#l56.226"></a><span id="l56.226">     	*outColumn = c-&gt;GetColumn();</span>
<a href="#l56.227"></a><span id="l56.227" class="difflineat">@@ -584,17 +584,17 @@ morkRow::EmptyAllCells(morkEnv* ev)</span>
<a href="#l56.228"></a><span id="l56.228">       {</span>
<a href="#l56.229"></a><span id="l56.229">         if ( cells-&gt;mCell_Atom )</span>
<a href="#l56.230"></a><span id="l56.230">           cells-&gt;SetAtom(ev, (morkAtom*) 0, pool);</span>
<a href="#l56.231"></a><span id="l56.231">       }</span>
<a href="#l56.232"></a><span id="l56.232">     }</span>
<a href="#l56.233"></a><span id="l56.233">   }</span>
<a href="#l56.234"></a><span id="l56.234"> }</span>
<a href="#l56.235"></a><span id="l56.235"> </span>
<a href="#l56.236"></a><span id="l56.236" class="difflineminus">-void </span>
<a href="#l56.237"></a><span id="l56.237" class="difflineplus">+void</span>
<a href="#l56.238"></a><span id="l56.238"> morkRow::cut_all_index_entries(morkEnv* ev)</span>
<a href="#l56.239"></a><span id="l56.239"> {</span>
<a href="#l56.240"></a><span id="l56.240">   morkRowSpace* rowSpace = mRow_Space;</span>
<a href="#l56.241"></a><span id="l56.241">   if ( rowSpace-&gt;mRowSpace_IndexCount ) // any indexes?</span>
<a href="#l56.242"></a><span id="l56.242">   {</span>
<a href="#l56.243"></a><span id="l56.243">     morkCell* cells = mRow_Cells;</span>
<a href="#l56.244"></a><span id="l56.244">     if ( cells )</span>
<a href="#l56.245"></a><span id="l56.245">     {</span>
<a href="#l56.246"></a><span id="l56.246" class="difflineat">@@ -628,59 +628,59 @@ morkRow::CutAllColumns(morkEnv* ev)</span>
<a href="#l56.247"></a><span id="l56.247">     if ( this-&gt;MaybeDirtySpaceStoreAndRow() )</span>
<a href="#l56.248"></a><span id="l56.248">     {</span>
<a href="#l56.249"></a><span id="l56.249">       this-&gt;SetRowRewrite();</span>
<a href="#l56.250"></a><span id="l56.250">       this-&gt;NoteRowSetAll(ev);</span>
<a href="#l56.251"></a><span id="l56.251">     }</span>
<a href="#l56.252"></a><span id="l56.252">     morkRowSpace* rowSpace = mRow_Space;</span>
<a href="#l56.253"></a><span id="l56.253">     if ( rowSpace-&gt;mRowSpace_IndexCount ) // any indexes?</span>
<a href="#l56.254"></a><span id="l56.254">       this-&gt;cut_all_index_entries(ev);</span>
<a href="#l56.255"></a><span id="l56.255" class="difflineminus">-  </span>
<a href="#l56.256"></a><span id="l56.256" class="difflineplus">+</span>
<a href="#l56.257"></a><span id="l56.257">     morkPool* pool = store-&gt;StorePool();</span>
<a href="#l56.258"></a><span id="l56.258">     pool-&gt;CutRowCells(ev, this, /*newSize*/ 0, &amp;store-&gt;mStore_Zone);</span>
<a href="#l56.259"></a><span id="l56.259">   }</span>
<a href="#l56.260"></a><span id="l56.260"> }</span>
<a href="#l56.261"></a><span id="l56.261"> </span>
<a href="#l56.262"></a><span id="l56.262"> void</span>
<a href="#l56.263"></a><span id="l56.263"> morkRow::SetRow(morkEnv* ev, const morkRow* inSourceRow)</span>
<a href="#l56.264"></a><span id="l56.264" class="difflineminus">-{  </span>
<a href="#l56.265"></a><span id="l56.265" class="difflineplus">+{</span>
<a href="#l56.266"></a><span id="l56.266">   // note inSourceRow might be in another DB, with a different store...</span>
<a href="#l56.267"></a><span id="l56.267">   morkStore* store = this-&gt;GetRowSpaceStore(ev);</span>
<a href="#l56.268"></a><span id="l56.268">   morkStore* srcStore = inSourceRow-&gt;GetRowSpaceStore(ev);</span>
<a href="#l56.269"></a><span id="l56.269">   if ( store &amp;&amp; srcStore )</span>
<a href="#l56.270"></a><span id="l56.270">   {</span>
<a href="#l56.271"></a><span id="l56.271">     if ( this-&gt;MaybeDirtySpaceStoreAndRow() )</span>
<a href="#l56.272"></a><span id="l56.272">     {</span>
<a href="#l56.273"></a><span id="l56.273">       this-&gt;SetRowRewrite();</span>
<a href="#l56.274"></a><span id="l56.274">       this-&gt;NoteRowSetAll(ev);</span>
<a href="#l56.275"></a><span id="l56.275">     }</span>
<a href="#l56.276"></a><span id="l56.276">     morkRowSpace* rowSpace = mRow_Space;</span>
<a href="#l56.277"></a><span id="l56.277">     mork_count indexes = rowSpace-&gt;mRowSpace_IndexCount; // any indexes?</span>
<a href="#l56.278"></a><span id="l56.278" class="difflineminus">-    </span>
<a href="#l56.279"></a><span id="l56.279" class="difflineplus">+</span>
<a href="#l56.280"></a><span id="l56.280">     mork_bool sameStore = ( store == srcStore ); // identical stores?</span>
<a href="#l56.281"></a><span id="l56.281">     morkPool* pool = store-&gt;StorePool();</span>
<a href="#l56.282"></a><span id="l56.282">     if ( pool-&gt;CutRowCells(ev, this, /*newSize*/ 0, &amp;store-&gt;mStore_Zone) )</span>
<a href="#l56.283"></a><span id="l56.283">     {</span>
<a href="#l56.284"></a><span id="l56.284">       mork_fill fill = inSourceRow-&gt;mRow_Length;</span>
<a href="#l56.285"></a><span id="l56.285">       if ( pool-&gt;AddRowCells(ev, this, fill, &amp;store-&gt;mStore_Zone) )</span>
<a href="#l56.286"></a><span id="l56.286">       {</span>
<a href="#l56.287"></a><span id="l56.287">         morkCell* dst = mRow_Cells;</span>
<a href="#l56.288"></a><span id="l56.288">         morkCell* dstEnd = dst + mRow_Length;</span>
<a href="#l56.289"></a><span id="l56.289" class="difflineminus">-        </span>
<a href="#l56.290"></a><span id="l56.290" class="difflineplus">+</span>
<a href="#l56.291"></a><span id="l56.291">         const morkCell* src = inSourceRow-&gt;mRow_Cells;</span>
<a href="#l56.292"></a><span id="l56.292">         const morkCell* srcEnd = src + fill;</span>
<a href="#l56.293"></a><span id="l56.293">         --dst; --src; // prepare both for preincrement:</span>
<a href="#l56.294"></a><span id="l56.294" class="difflineminus">-        </span>
<a href="#l56.295"></a><span id="l56.295" class="difflineplus">+</span>
<a href="#l56.296"></a><span id="l56.296">         while ( ++dst &lt; dstEnd &amp;&amp; ++src &lt; srcEnd &amp;&amp; ev-&gt;Good() )</span>
<a href="#l56.297"></a><span id="l56.297">         {</span>
<a href="#l56.298"></a><span id="l56.298">           morkAtom* atom = src-&gt;mCell_Atom;</span>
<a href="#l56.299"></a><span id="l56.299">           mork_column dstCol = src-&gt;GetColumn();</span>
<a href="#l56.300"></a><span id="l56.300">           // Note we modify the mCell_Atom slot directly instead of using</span>
<a href="#l56.301"></a><span id="l56.301">           // morkCell::SetAtom(), because we know it starts equal to nil.</span>
<a href="#l56.302"></a><span id="l56.302" class="difflineminus">-          </span>
<a href="#l56.303"></a><span id="l56.303" class="difflineplus">+</span>
<a href="#l56.304"></a><span id="l56.304">           if ( sameStore ) // source and dest in same store?</span>
<a href="#l56.305"></a><span id="l56.305">           {</span>
<a href="#l56.306"></a><span id="l56.306">             // next line equivalent to inline morkCell::SetCellDirty():</span>
<a href="#l56.307"></a><span id="l56.307">             dst-&gt;SetCellColumnDirty(dstCol);</span>
<a href="#l56.308"></a><span id="l56.308">             dst-&gt;mCell_Atom = atom;</span>
<a href="#l56.309"></a><span id="l56.309">             if ( atom ) // another ref to non-nil atom?</span>
<a href="#l56.310"></a><span id="l56.310">               atom-&gt;AddCellUse(ev);</span>
<a href="#l56.311"></a><span id="l56.311">           }</span>
<a href="#l56.312"></a><span id="l56.312" class="difflineat">@@ -770,65 +770,65 @@ morkRow::GetRowSpaceStore(morkEnv* ev) c</span>
<a href="#l56.313"></a><span id="l56.313">       else</span>
<a href="#l56.314"></a><span id="l56.314">         store-&gt;NonStoreTypeError(ev);</span>
<a href="#l56.315"></a><span id="l56.315">     }</span>
<a href="#l56.316"></a><span id="l56.316">     else</span>
<a href="#l56.317"></a><span id="l56.317">       ev-&gt;NilPointerError();</span>
<a href="#l56.318"></a><span id="l56.318">   }</span>
<a href="#l56.319"></a><span id="l56.319">   else</span>
<a href="#l56.320"></a><span id="l56.320">     ev-&gt;NilPointerError();</span>
<a href="#l56.321"></a><span id="l56.321" class="difflineminus">-    </span>
<a href="#l56.322"></a><span id="l56.322" class="difflineplus">+</span>
<a href="#l56.323"></a><span id="l56.323">   return (morkStore*) 0;</span>
<a href="#l56.324"></a><span id="l56.324"> }</span>
<a href="#l56.325"></a><span id="l56.325"> </span>
<a href="#l56.326"></a><span id="l56.326"> void morkRow::CutColumn(morkEnv* ev, mdb_column inColumn)</span>
<a href="#l56.327"></a><span id="l56.327"> {</span>
<a href="#l56.328"></a><span id="l56.328">   mork_pos pos = -1;</span>
<a href="#l56.329"></a><span id="l56.329">   morkCell* cell = this-&gt;GetCell(ev, inColumn, &amp;pos);</span>
<a href="#l56.330"></a><span id="l56.330" class="difflineminus">-  if ( cell ) </span>
<a href="#l56.331"></a><span id="l56.331" class="difflineplus">+  if ( cell )</span>
<a href="#l56.332"></a><span id="l56.332">   {</span>
<a href="#l56.333"></a><span id="l56.333">     morkStore* store = this-&gt;GetRowSpaceStore(ev);</span>
<a href="#l56.334"></a><span id="l56.334">     if ( store )</span>
<a href="#l56.335"></a><span id="l56.335">     {</span>
<a href="#l56.336"></a><span id="l56.336">       if ( this-&gt;MaybeDirtySpaceStoreAndRow() &amp;&amp; !this-&gt;IsRowRewrite() )</span>
<a href="#l56.337"></a><span id="l56.337">         this-&gt;NoteRowCutCol(ev, inColumn);</span>
<a href="#l56.338"></a><span id="l56.338" class="difflineminus">-        </span>
<a href="#l56.339"></a><span id="l56.339" class="difflineplus">+</span>
<a href="#l56.340"></a><span id="l56.340">       morkRowSpace* rowSpace = mRow_Space;</span>
<a href="#l56.341"></a><span id="l56.341">       morkAtomRowMap* map = ( rowSpace-&gt;mRowSpace_IndexCount )?</span>
<a href="#l56.342"></a><span id="l56.342">         rowSpace-&gt;FindMap(ev, inColumn) : (morkAtomRowMap*) 0;</span>
<a href="#l56.343"></a><span id="l56.343">       if ( map ) // this row attribute is indexed by row space?</span>
<a href="#l56.344"></a><span id="l56.344">       {</span>
<a href="#l56.345"></a><span id="l56.345">         morkAtom* oldAtom = cell-&gt;mCell_Atom;</span>
<a href="#l56.346"></a><span id="l56.346">         if ( oldAtom ) // need to cut an entry from the index?</span>
<a href="#l56.347"></a><span id="l56.347">         {</span>
<a href="#l56.348"></a><span id="l56.348">           mork_aid oldAid = oldAtom-&gt;GetBookAtomAid();</span>
<a href="#l56.349"></a><span id="l56.349">           if ( oldAid ) // cut old row attribute from row index in space?</span>
<a href="#l56.350"></a><span id="l56.350">             map-&gt;CutAid(ev, oldAid);</span>
<a href="#l56.351"></a><span id="l56.351">         }</span>
<a href="#l56.352"></a><span id="l56.352">       }</span>
<a href="#l56.353"></a><span id="l56.353" class="difflineminus">-      </span>
<a href="#l56.354"></a><span id="l56.354" class="difflineplus">+</span>
<a href="#l56.355"></a><span id="l56.355">       morkPool* pool = store-&gt;StorePool();</span>
<a href="#l56.356"></a><span id="l56.356">       cell-&gt;SetAtom(ev, (morkAtom*) 0, pool);</span>
<a href="#l56.357"></a><span id="l56.357" class="difflineminus">-      </span>
<a href="#l56.358"></a><span id="l56.358" class="difflineplus">+</span>
<a href="#l56.359"></a><span id="l56.359">       mork_fill fill = mRow_Length; // should not be zero</span>
<a href="#l56.360"></a><span id="l56.360">       MORK_ASSERT(fill);</span>
<a href="#l56.361"></a><span id="l56.361">       if ( fill ) // index &lt; fill for last cell exists?</span>
<a href="#l56.362"></a><span id="l56.362">       {</span>
<a href="#l56.363"></a><span id="l56.363">         mork_fill last = fill - 1; // index of last cell in row</span>
<a href="#l56.364"></a><span id="l56.364" class="difflineminus">-        </span>
<a href="#l56.365"></a><span id="l56.365" class="difflineplus">+</span>
<a href="#l56.366"></a><span id="l56.366">         if ( pos &lt; (mork_pos)last ) // need to move cells following cut cell?</span>
<a href="#l56.367"></a><span id="l56.367">         {</span>
<a href="#l56.368"></a><span id="l56.368">           morkCell* lastCell = mRow_Cells + last;</span>
<a href="#l56.369"></a><span id="l56.369">           mork_count after = last - pos; // cell count after cut cell</span>
<a href="#l56.370"></a><span id="l56.370">           morkCell* next = cell + 1; // next cell after cut cell</span>
<a href="#l56.371"></a><span id="l56.371">           MORK_MEMMOVE(cell, next, after * sizeof(morkCell));</span>
<a href="#l56.372"></a><span id="l56.372">           lastCell-&gt;SetColumnAndChange(0, 0);</span>
<a href="#l56.373"></a><span id="l56.373">           lastCell-&gt;mCell_Atom = 0;</span>
<a href="#l56.374"></a><span id="l56.374">         }</span>
<a href="#l56.375"></a><span id="l56.375" class="difflineminus">-        </span>
<a href="#l56.376"></a><span id="l56.376" class="difflineplus">+</span>
<a href="#l56.377"></a><span id="l56.377">         if ( ev-&gt;Good() )</span>
<a href="#l56.378"></a><span id="l56.378">           pool-&gt;CutRowCells(ev, this, fill - 1, &amp;store-&gt;mStore_Zone);</span>
<a href="#l56.379"></a><span id="l56.379">       }</span>
<a href="#l56.380"></a><span id="l56.380">     }</span>
<a href="#l56.381"></a><span id="l56.381">   }</span>
<a href="#l56.382"></a><span id="l56.382"> }</span>
<a href="#l56.383"></a><span id="l56.383"> </span>
<a href="#l56.384"></a><span id="l56.384"> morkAtom* morkRow::GetColumnAtom(morkEnv* ev, mdb_column inColumn)</span>
<a href="#l56.385"></a><span id="l56.385" class="difflineat">@@ -848,38 +848,38 @@ void morkRow::AddColumn(morkEnv* ev, mdb</span>
<a href="#l56.386"></a><span id="l56.386"> {</span>
<a href="#l56.387"></a><span id="l56.387">   if ( ev-&gt;Good() )</span>
<a href="#l56.388"></a><span id="l56.388">   {</span>
<a href="#l56.389"></a><span id="l56.389">     mork_pos pos = -1;</span>
<a href="#l56.390"></a><span id="l56.390">     morkCell* cell = this-&gt;GetCell(ev, inColumn, &amp;pos);</span>
<a href="#l56.391"></a><span id="l56.391">     morkCell* oldCell = cell; // need to know later whether new</span>
<a href="#l56.392"></a><span id="l56.392">     if ( !cell ) // column does not yet exist?</span>
<a href="#l56.393"></a><span id="l56.393">       cell = this-&gt;NewCell(ev, inColumn, &amp;pos, ioStore);</span>
<a href="#l56.394"></a><span id="l56.394" class="difflineminus">-    </span>
<a href="#l56.395"></a><span id="l56.395" class="difflineplus">+</span>
<a href="#l56.396"></a><span id="l56.396">     if ( cell )</span>
<a href="#l56.397"></a><span id="l56.397">     {</span>
<a href="#l56.398"></a><span id="l56.398">       morkAtom* oldAtom = cell-&gt;mCell_Atom;</span>
<a href="#l56.399"></a><span id="l56.399"> </span>
<a href="#l56.400"></a><span id="l56.400">       morkAtom* atom = ioStore-&gt;YarnToAtom(ev, inYarn, true /* create */);</span>
<a href="#l56.401"></a><span id="l56.401">       if ( atom &amp;&amp; atom != oldAtom )</span>
<a href="#l56.402"></a><span id="l56.402">       {</span>
<a href="#l56.403"></a><span id="l56.403">         morkRowSpace* rowSpace = mRow_Space;</span>
<a href="#l56.404"></a><span id="l56.404">         morkAtomRowMap* map = ( rowSpace-&gt;mRowSpace_IndexCount )?</span>
<a href="#l56.405"></a><span id="l56.405">           rowSpace-&gt;FindMap(ev, inColumn) : (morkAtomRowMap*) 0;</span>
<a href="#l56.406"></a><span id="l56.406" class="difflineminus">-        </span>
<a href="#l56.407"></a><span id="l56.407" class="difflineplus">+</span>
<a href="#l56.408"></a><span id="l56.408">         if ( map ) // inColumn is indexed by row space?</span>
<a href="#l56.409"></a><span id="l56.409">         {</span>
<a href="#l56.410"></a><span id="l56.410">           if ( oldAtom &amp;&amp; oldAtom != atom ) // cut old cell from index?</span>
<a href="#l56.411"></a><span id="l56.411">           {</span>
<a href="#l56.412"></a><span id="l56.412">             mork_aid oldAid = oldAtom-&gt;GetBookAtomAid();</span>
<a href="#l56.413"></a><span id="l56.413">             if ( oldAid ) // cut old row attribute from row index in space?</span>
<a href="#l56.414"></a><span id="l56.414">               map-&gt;CutAid(ev, oldAid);</span>
<a href="#l56.415"></a><span id="l56.415">           }</span>
<a href="#l56.416"></a><span id="l56.416">         }</span>
<a href="#l56.417"></a><span id="l56.417" class="difflineminus">-        </span>
<a href="#l56.418"></a><span id="l56.418" class="difflineplus">+</span>
<a href="#l56.419"></a><span id="l56.419">         cell-&gt;SetAtom(ev, atom, ioStore-&gt;StorePool()); // refcounts atom</span>
<a href="#l56.420"></a><span id="l56.420"> </span>
<a href="#l56.421"></a><span id="l56.421">         if ( oldCell ) // we changed a pre-existing cell in the row?</span>
<a href="#l56.422"></a><span id="l56.422">         {</span>
<a href="#l56.423"></a><span id="l56.423">           ++mRow_Seed;</span>
<a href="#l56.424"></a><span id="l56.424">           if ( this-&gt;MaybeDirtySpaceStoreAndRow() &amp;&amp; !this-&gt;IsRowRewrite() )</span>
<a href="#l56.425"></a><span id="l56.425">             this-&gt;NoteRowAddCol(ev, inColumn);</span>
<a href="#l56.426"></a><span id="l56.426">         }</span>
<a href="#l56.427"></a><span id="l56.427" class="difflineat">@@ -905,17 +905,17 @@ morkRow::NewRowCellCursor(morkEnv* ev, m</span>
<a href="#l56.428"></a><span id="l56.428">     if ( store )</span>
<a href="#l56.429"></a><span id="l56.429">     {</span>
<a href="#l56.430"></a><span id="l56.430">       morkRowObject* rowObj = this-&gt;AcquireRowObject(ev, store);</span>
<a href="#l56.431"></a><span id="l56.431">       if ( rowObj )</span>
<a href="#l56.432"></a><span id="l56.432">       {</span>
<a href="#l56.433"></a><span id="l56.433">         nsIMdbHeap* heap = store-&gt;mPort_Heap;</span>
<a href="#l56.434"></a><span id="l56.434">         morkRowCellCursor* cursor = new(*heap, ev)</span>
<a href="#l56.435"></a><span id="l56.435">           morkRowCellCursor(ev, morkUsage::kHeap, heap, rowObj);</span>
<a href="#l56.436"></a><span id="l56.436" class="difflineminus">-         </span>
<a href="#l56.437"></a><span id="l56.437" class="difflineplus">+</span>
<a href="#l56.438"></a><span id="l56.438">         if ( cursor )</span>
<a href="#l56.439"></a><span id="l56.439">         {</span>
<a href="#l56.440"></a><span id="l56.440">           if ( ev-&gt;Good() )</span>
<a href="#l56.441"></a><span id="l56.441">           {</span>
<a href="#l56.442"></a><span id="l56.442">             cursor-&gt;mRowCellCursor_Col = inPos;</span>
<a href="#l56.443"></a><span id="l56.443">             outCursor = cursor;</span>
<a href="#l56.444"></a><span id="l56.444">           }</span>
<a href="#l56.445"></a><span id="l56.445">           else</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l57.1"></a><span id="l57.1" class="difflineminus">--- a/db/mork/src/morkRow.h</span>
<a href="#l57.2"></a><span id="l57.2" class="difflineplus">+++ b/db/mork/src/morkRow.h</span>
<a href="#l57.3"></a><span id="l57.3" class="difflineat">@@ -29,40 +29,40 @@ class nsIMdbCell;</span>
<a href="#l57.4"></a><span id="l57.4"> #define morkRow_kNotedBit   ((mork_u1) (1 &lt;&lt; 0)) /* space has change notes */</span>
<a href="#l57.5"></a><span id="l57.5"> #define morkRow_kRewriteBit ((mork_u1) (1 &lt;&lt; 1)) /* must rewrite all cells */</span>
<a href="#l57.6"></a><span id="l57.6"> #define morkRow_kDirtyBit   ((mork_u1) (1 &lt;&lt; 2)) /* row has been changed */</span>
<a href="#l57.7"></a><span id="l57.7"> </span>
<a href="#l57.8"></a><span id="l57.8"> class morkRow{ // row of cells</span>
<a href="#l57.9"></a><span id="l57.9"> </span>
<a href="#l57.10"></a><span id="l57.10"> public: // state is public because the entire Mork system is private</span>
<a href="#l57.11"></a><span id="l57.11"> </span>
<a href="#l57.12"></a><span id="l57.12" class="difflineminus">-  morkRowSpace*   mRow_Space;  // mRow_Space-&gt;SpaceScope() is the row scope </span>
<a href="#l57.13"></a><span id="l57.13" class="difflineplus">+  morkRowSpace*   mRow_Space;  // mRow_Space-&gt;SpaceScope() is the row scope</span>
<a href="#l57.14"></a><span id="l57.14">   morkRowObject*  mRow_Object; // refcount &amp; other state for object sharing</span>
<a href="#l57.15"></a><span id="l57.15">   morkCell*       mRow_Cells;</span>
<a href="#l57.16"></a><span id="l57.16">   mdbOid          mRow_Oid;</span>
<a href="#l57.17"></a><span id="l57.17" class="difflineminus">-  </span>
<a href="#l57.18"></a><span id="l57.18" class="difflineplus">+</span>
<a href="#l57.19"></a><span id="l57.19">   mork_delta      mRow_Delta;   // space to note a single column change</span>
<a href="#l57.20"></a><span id="l57.20"> </span>
<a href="#l57.21"></a><span id="l57.21" class="difflineminus">-  mork_u2         mRow_Length;     // physical count of cells in mRow_Cells </span>
<a href="#l57.22"></a><span id="l57.22" class="difflineplus">+  mork_u2         mRow_Length;     // physical count of cells in mRow_Cells</span>
<a href="#l57.23"></a><span id="l57.23">   mork_u2         mRow_Seed;       // count changes in mRow_Cells structure</span>
<a href="#l57.24"></a><span id="l57.24"> </span>
<a href="#l57.25"></a><span id="l57.25">   mork_u1         mRow_GcUses;  // persistent references from tables</span>
<a href="#l57.26"></a><span id="l57.26">   mork_u1         mRow_Pad;     // for u1 alignment</span>
<a href="#l57.27"></a><span id="l57.27">   mork_u1         mRow_Flags;   // one-byte flags slot</span>
<a href="#l57.28"></a><span id="l57.28">   mork_u1         mRow_Tag;     // one-byte tag (need u4 alignment pad)</span>
<a href="#l57.29"></a><span id="l57.29"> </span>
<a href="#l57.30"></a><span id="l57.30"> public: // interpreting mRow_Delta</span>
<a href="#l57.31"></a><span id="l57.31" class="difflineminus">-  </span>
<a href="#l57.32"></a><span id="l57.32" class="difflineplus">+</span>
<a href="#l57.33"></a><span id="l57.33">   mork_bool HasRowDelta() const { return ( mRow_Delta != 0 ); }</span>
<a href="#l57.34"></a><span id="l57.34" class="difflineminus">-  </span>
<a href="#l57.35"></a><span id="l57.35" class="difflineplus">+</span>
<a href="#l57.36"></a><span id="l57.36">   void ClearRowDelta() { mRow_Delta = 0; }</span>
<a href="#l57.37"></a><span id="l57.37" class="difflineminus">-  </span>
<a href="#l57.38"></a><span id="l57.38" class="difflineplus">+</span>
<a href="#l57.39"></a><span id="l57.39">   void SetRowDelta(mork_column inCol, mork_change inChange)</span>
<a href="#l57.40"></a><span id="l57.40">   { morkDelta_Init(mRow_Delta, inCol, inChange); }</span>
<a href="#l57.41"></a><span id="l57.41" class="difflineminus">-  </span>
<a href="#l57.42"></a><span id="l57.42" class="difflineplus">+</span>
<a href="#l57.43"></a><span id="l57.43">   mork_column  GetDeltaColumn() const { return morkDelta_Column(mRow_Delta); }</span>
<a href="#l57.44"></a><span id="l57.44">   mork_change  GetDeltaChange() const { return morkDelta_Change(mRow_Delta); }</span>
<a href="#l57.45"></a><span id="l57.45"> </span>
<a href="#l57.46"></a><span id="l57.46"> public: // noting row changes</span>
<a href="#l57.47"></a><span id="l57.47"> </span>
<a href="#l57.48"></a><span id="l57.48">   void NoteRowSetAll(morkEnv* ev);</span>
<a href="#l57.49"></a><span id="l57.49">   void NoteRowSetCol(morkEnv* ev, mork_column inCol);</span>
<a href="#l57.50"></a><span id="l57.50">   void NoteRowAddCol(morkEnv* ev, mork_column inCol);</span>
<a href="#l57.51"></a><span id="l57.51" class="difflineat">@@ -72,48 +72,48 @@ public: // flags bit twiddling</span>
<a href="#l57.52"></a><span id="l57.52"> </span>
<a href="#l57.53"></a><span id="l57.53">   void SetRowNoted() { mRow_Flags |= morkRow_kNotedBit; }</span>
<a href="#l57.54"></a><span id="l57.54">   void SetRowRewrite() { mRow_Flags |= morkRow_kRewriteBit; }</span>
<a href="#l57.55"></a><span id="l57.55">   void SetRowDirty() { mRow_Flags |= morkRow_kDirtyBit; }</span>
<a href="#l57.56"></a><span id="l57.56"> </span>
<a href="#l57.57"></a><span id="l57.57">   void ClearRowNoted() { mRow_Flags &amp;= (mork_u1) ~morkRow_kNotedBit; }</span>
<a href="#l57.58"></a><span id="l57.58">   void ClearRowRewrite() { mRow_Flags &amp;= (mork_u1) ~morkRow_kRewriteBit; }</span>
<a href="#l57.59"></a><span id="l57.59">   void SetRowClean() { mRow_Flags = 0; mRow_Delta = 0; }</span>
<a href="#l57.60"></a><span id="l57.60" class="difflineminus">-  </span>
<a href="#l57.61"></a><span id="l57.61" class="difflineplus">+</span>
<a href="#l57.62"></a><span id="l57.62">   mork_bool IsRowNoted() const</span>
<a href="#l57.63"></a><span id="l57.63">   { return ( mRow_Flags &amp; morkRow_kNotedBit ) != 0; }</span>
<a href="#l57.64"></a><span id="l57.64" class="difflineminus">-  </span>
<a href="#l57.65"></a><span id="l57.65" class="difflineplus">+</span>
<a href="#l57.66"></a><span id="l57.66">   mork_bool IsRowRewrite() const</span>
<a href="#l57.67"></a><span id="l57.67">   { return ( mRow_Flags &amp; morkRow_kRewriteBit ) != 0; }</span>
<a href="#l57.68"></a><span id="l57.68" class="difflineminus">-   </span>
<a href="#l57.69"></a><span id="l57.69" class="difflineplus">+</span>
<a href="#l57.70"></a><span id="l57.70">   mork_bool IsRowClean() const</span>
<a href="#l57.71"></a><span id="l57.71">   { return ( mRow_Flags &amp; morkRow_kDirtyBit ) == 0; }</span>
<a href="#l57.72"></a><span id="l57.72" class="difflineminus">-  </span>
<a href="#l57.73"></a><span id="l57.73" class="difflineplus">+</span>
<a href="#l57.74"></a><span id="l57.74">   mork_bool IsRowDirty() const</span>
<a href="#l57.75"></a><span id="l57.75">   { return ( mRow_Flags &amp; morkRow_kDirtyBit ) != 0; }</span>
<a href="#l57.76"></a><span id="l57.76" class="difflineminus">-  </span>
<a href="#l57.77"></a><span id="l57.77" class="difflineplus">+</span>
<a href="#l57.78"></a><span id="l57.78">   mork_bool IsRowUsed() const</span>
<a href="#l57.79"></a><span id="l57.79">   { return mRow_GcUses != 0; }</span>
<a href="#l57.80"></a><span id="l57.80"> </span>
<a href="#l57.81"></a><span id="l57.81"> public: // other row methods</span>
<a href="#l57.82"></a><span id="l57.82">   morkRow( ) { }</span>
<a href="#l57.83"></a><span id="l57.83">   morkRow(const mdbOid* inOid) :mRow_Oid(*inOid) { }</span>
<a href="#l57.84"></a><span id="l57.84">   void InitRow(morkEnv* ev, const mdbOid* inOid, morkRowSpace* ioSpace,</span>
<a href="#l57.85"></a><span id="l57.85">     mork_size inLength, morkPool* ioPool);</span>
<a href="#l57.86"></a><span id="l57.86">     // if inLength is nonzero, cells will be allocated from ioPool</span>
<a href="#l57.87"></a><span id="l57.87"> </span>
<a href="#l57.88"></a><span id="l57.88">   morkRowObject* AcquireRowObject(morkEnv* ev, morkStore* ioStore);</span>
<a href="#l57.89"></a><span id="l57.89">   nsIMdbRow* AcquireRowHandle(morkEnv* ev, morkStore* ioStore);</span>
<a href="#l57.90"></a><span id="l57.90">   nsIMdbCell* AcquireCellHandle(morkEnv* ev, morkCell* ioCell,</span>
<a href="#l57.91"></a><span id="l57.91">     mdb_column inColumn, mork_pos inPos);</span>
<a href="#l57.92"></a><span id="l57.92" class="difflineminus">-  </span>
<a href="#l57.93"></a><span id="l57.93" class="difflineplus">+</span>
<a href="#l57.94"></a><span id="l57.94">   mork_u2 AddRowGcUse(morkEnv* ev);</span>
<a href="#l57.95"></a><span id="l57.95">   mork_u2 CutRowGcUse(morkEnv* ev);</span>
<a href="#l57.96"></a><span id="l57.96"> </span>
<a href="#l57.97"></a><span id="l57.97" class="difflineminus">-  </span>
<a href="#l57.98"></a><span id="l57.98" class="difflineplus">+</span>
<a href="#l57.99"></a><span id="l57.99">   mork_bool MaybeDirtySpaceStoreAndRow();</span>
<a href="#l57.100"></a><span id="l57.100"> </span>
<a href="#l57.101"></a><span id="l57.101"> public: // internal row methods</span>
<a href="#l57.102"></a><span id="l57.102"> </span>
<a href="#l57.103"></a><span id="l57.103">   void cut_all_index_entries(morkEnv* ev);</span>
<a href="#l57.104"></a><span id="l57.104"> </span>
<a href="#l57.105"></a><span id="l57.105">   // void cut_cell_from_space_index(morkEnv* ev, morkCell* ioCell);</span>
<a href="#l57.106"></a><span id="l57.106"> </span>
<a href="#l57.107"></a><span id="l57.107" class="difflineat">@@ -158,23 +158,23 @@ public: // external row methods</span>
<a href="#l57.108"></a><span id="l57.108"> </span>
<a href="#l57.109"></a><span id="l57.109">   void AddColumn(morkEnv* ev, mdb_column inColumn,</span>
<a href="#l57.110"></a><span id="l57.110">     const mdbYarn* inYarn, morkStore* ioStore);</span>
<a href="#l57.111"></a><span id="l57.111"> </span>
<a href="#l57.112"></a><span id="l57.112">   morkAtom* GetColumnAtom(morkEnv* ev, mdb_column inColumn);</span>
<a href="#l57.113"></a><span id="l57.113"> </span>
<a href="#l57.114"></a><span id="l57.114">   void NextColumn(morkEnv* ev, mdb_column* ioColumn, mdbYarn* outYarn);</span>
<a href="#l57.115"></a><span id="l57.115"> </span>
<a href="#l57.116"></a><span id="l57.116" class="difflineminus">-  void SeekColumn(morkEnv* ev, mdb_pos inPos, </span>
<a href="#l57.117"></a><span id="l57.117" class="difflineplus">+  void SeekColumn(morkEnv* ev, mdb_pos inPos,</span>
<a href="#l57.118"></a><span id="l57.118"> 	  mdb_column* outColumn, mdbYarn* outYarn);</span>
<a href="#l57.119"></a><span id="l57.119"> </span>
<a href="#l57.120"></a><span id="l57.120">   void CutColumn(morkEnv* ev, mdb_column inColumn);</span>
<a href="#l57.121"></a><span id="l57.121"> </span>
<a href="#l57.122"></a><span id="l57.122">   morkRowCellCursor* NewRowCellCursor(morkEnv* ev, mdb_pos inPos);</span>
<a href="#l57.123"></a><span id="l57.123" class="difflineminus">-  </span>
<a href="#l57.124"></a><span id="l57.124" class="difflineplus">+</span>
<a href="#l57.125"></a><span id="l57.125">   void EmptyAllCells(morkEnv* ev);</span>
<a href="#l57.126"></a><span id="l57.126">   void AddRow(morkEnv* ev, const morkRow* inSourceRow);</span>
<a href="#l57.127"></a><span id="l57.127">   void SetRow(morkEnv* ev, const morkRow* inSourceRow);</span>
<a href="#l57.128"></a><span id="l57.128">   void CutAllColumns(morkEnv* ev);</span>
<a href="#l57.129"></a><span id="l57.129"> </span>
<a href="#l57.130"></a><span id="l57.130">   void OnZeroRowGcUse(morkEnv* ev);</span>
<a href="#l57.131"></a><span id="l57.131">   // OnZeroRowGcUse() is called when CutRowGcUse() returns zero.</span>
<a href="#l57.132"></a><span id="l57.132"> </span>
<a href="#l57.133"></a><span id="l57.133" class="difflineat">@@ -188,26 +188,26 @@ public: // hash and equal</span>
<a href="#l57.134"></a><span id="l57.134">   {</span>
<a href="#l57.135"></a><span id="l57.135">     return (mRow_Oid.mOid_Scope &lt;&lt; 16) ^ mRow_Oid.mOid_Id;</span>
<a href="#l57.136"></a><span id="l57.136">   }</span>
<a href="#l57.137"></a><span id="l57.137"> </span>
<a href="#l57.138"></a><span id="l57.138">   mork_bool EqualRow(const morkRow* ioRow) const</span>
<a href="#l57.139"></a><span id="l57.139">   {</span>
<a href="#l57.140"></a><span id="l57.140">     return</span>
<a href="#l57.141"></a><span id="l57.141">     (</span>
<a href="#l57.142"></a><span id="l57.142" class="difflineminus">-      ( mRow_Oid.mOid_Scope == ioRow-&gt;mRow_Oid.mOid_Scope ) </span>
<a href="#l57.143"></a><span id="l57.143" class="difflineplus">+      ( mRow_Oid.mOid_Scope == ioRow-&gt;mRow_Oid.mOid_Scope )</span>
<a href="#l57.144"></a><span id="l57.144">       &amp;&amp; ( mRow_Oid.mOid_Id == ioRow-&gt;mRow_Oid.mOid_Id )</span>
<a href="#l57.145"></a><span id="l57.145">     );</span>
<a href="#l57.146"></a><span id="l57.146">   }</span>
<a href="#l57.147"></a><span id="l57.147"> </span>
<a href="#l57.148"></a><span id="l57.148">   mork_bool EqualOid(const mdbOid* ioOid) const</span>
<a href="#l57.149"></a><span id="l57.149">   {</span>
<a href="#l57.150"></a><span id="l57.150">     return</span>
<a href="#l57.151"></a><span id="l57.151">     (</span>
<a href="#l57.152"></a><span id="l57.152" class="difflineminus">-      ( mRow_Oid.mOid_Scope == ioOid-&gt;mOid_Scope ) </span>
<a href="#l57.153"></a><span id="l57.153" class="difflineplus">+      ( mRow_Oid.mOid_Scope == ioOid-&gt;mOid_Scope )</span>
<a href="#l57.154"></a><span id="l57.154">       &amp;&amp; ( mRow_Oid.mOid_Id == ioOid-&gt;mOid_Id )</span>
<a href="#l57.155"></a><span id="l57.155">     );</span>
<a href="#l57.156"></a><span id="l57.156">   }</span>
<a href="#l57.157"></a><span id="l57.157"> </span>
<a href="#l57.158"></a><span id="l57.158"> public: // errors</span>
<a href="#l57.159"></a><span id="l57.159">   static void ZeroColumnError(morkEnv* ev);</span>
<a href="#l57.160"></a><span id="l57.160">   static void LengthBeyondMaxError(morkEnv* ev);</span>
<a href="#l57.161"></a><span id="l57.161">   static void NilCellsError(morkEnv* ev);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l58.1"></a><span id="l58.1" class="difflineminus">--- a/db/mork/src/morkRowCellCursor.cpp</span>
<a href="#l58.2"></a><span id="l58.2" class="difflineplus">+++ b/db/mork/src/morkRowCellCursor.cpp</span>
<a href="#l58.3"></a><span id="l58.3" class="difflineat">@@ -36,17 +36,17 @@</span>
<a href="#l58.4"></a><span id="l58.4"> #endif</span>
<a href="#l58.5"></a><span id="l58.5"> </span>
<a href="#l58.6"></a><span id="l58.6"> #ifndef _MORKROW_</span>
<a href="#l58.7"></a><span id="l58.7"> #include &quot;morkRow.h&quot;</span>
<a href="#l58.8"></a><span id="l58.8"> #endif</span>
<a href="#l58.9"></a><span id="l58.9"> </span>
<a href="#l58.10"></a><span id="l58.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l58.11"></a><span id="l58.11"> </span>
<a href="#l58.12"></a><span id="l58.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l58.13"></a><span id="l58.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l58.14"></a><span id="l58.14"> // { ===== begin morkNode interface =====</span>
<a href="#l58.15"></a><span id="l58.15"> </span>
<a href="#l58.16"></a><span id="l58.16"> /*public virtual*/ void</span>
<a href="#l58.17"></a><span id="l58.17"> morkRowCellCursor::CloseMorkNode(morkEnv* ev) // CloseRowCellCursor() only if open</span>
<a href="#l58.18"></a><span id="l58.18"> {</span>
<a href="#l58.19"></a><span id="l58.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l58.20"></a><span id="l58.20">   {</span>
<a href="#l58.21"></a><span id="l58.21">     this-&gt;MarkClosing();</span>
<a href="#l58.22"></a><span id="l58.22" class="difflineat">@@ -76,17 +76,17 @@ morkRowCellCursor::morkRowCellCursor(mor</span>
<a href="#l58.23"></a><span id="l58.23">     {</span>
<a href="#l58.24"></a><span id="l58.24">       morkRow* row = ioRowObject-&gt;mRowObject_Row;</span>
<a href="#l58.25"></a><span id="l58.25">       if ( row )</span>
<a href="#l58.26"></a><span id="l58.26">       {</span>
<a href="#l58.27"></a><span id="l58.27">         if ( row-&gt;IsRow() )</span>
<a href="#l58.28"></a><span id="l58.28">         {</span>
<a href="#l58.29"></a><span id="l58.29">           mCursor_Pos = -1;</span>
<a href="#l58.30"></a><span id="l58.30">           mCursor_Seed = row-&gt;mRow_Seed;</span>
<a href="#l58.31"></a><span id="l58.31" class="difflineminus">-          </span>
<a href="#l58.32"></a><span id="l58.32" class="difflineplus">+</span>
<a href="#l58.33"></a><span id="l58.33">           morkRowObject::SlotStrongRowObject(ioRowObject, ev,</span>
<a href="#l58.34"></a><span id="l58.34">             &amp;mRowCellCursor_RowObject);</span>
<a href="#l58.35"></a><span id="l58.35">           if ( ev-&gt;Good() )</span>
<a href="#l58.36"></a><span id="l58.36">             mNode_Derived = morkDerived_kRowCellCursor;</span>
<a href="#l58.37"></a><span id="l58.37">         }</span>
<a href="#l58.38"></a><span id="l58.38">         else</span>
<a href="#l58.39"></a><span id="l58.39">           row-&gt;NonRowTypeError(ev);</span>
<a href="#l58.40"></a><span id="l58.40">       }</span>
<a href="#l58.41"></a><span id="l58.41" class="difflineat">@@ -96,33 +96,33 @@ morkRowCellCursor::morkRowCellCursor(mor</span>
<a href="#l58.42"></a><span id="l58.42">     else</span>
<a href="#l58.43"></a><span id="l58.43">       ev-&gt;NilPointerError();</span>
<a href="#l58.44"></a><span id="l58.44">   }</span>
<a href="#l58.45"></a><span id="l58.45"> }</span>
<a href="#l58.46"></a><span id="l58.46"> </span>
<a href="#l58.47"></a><span id="l58.47"> NS_IMPL_ISUPPORTS_INHERITED(morkRowCellCursor, morkCursor, nsIMdbRowCellCursor)</span>
<a href="#l58.48"></a><span id="l58.48"> </span>
<a href="#l58.49"></a><span id="l58.49"> /*public non-poly*/ void</span>
<a href="#l58.50"></a><span id="l58.50" class="difflineminus">-morkRowCellCursor::CloseRowCellCursor(morkEnv* ev) </span>
<a href="#l58.51"></a><span id="l58.51" class="difflineplus">+morkRowCellCursor::CloseRowCellCursor(morkEnv* ev)</span>
<a href="#l58.52"></a><span id="l58.52"> {</span>
<a href="#l58.53"></a><span id="l58.53">     if ( this-&gt;IsNode() )</span>
<a href="#l58.54"></a><span id="l58.54">     {</span>
<a href="#l58.55"></a><span id="l58.55">       mCursor_Pos = -1;</span>
<a href="#l58.56"></a><span id="l58.56">       mCursor_Seed = 0;</span>
<a href="#l58.57"></a><span id="l58.57">       morkRowObject::SlotStrongRowObject((morkRowObject*) 0, ev,</span>
<a href="#l58.58"></a><span id="l58.58">         &amp;mRowCellCursor_RowObject);</span>
<a href="#l58.59"></a><span id="l58.59">       this-&gt;CloseCursor(ev);</span>
<a href="#l58.60"></a><span id="l58.60">       this-&gt;MarkShut();</span>
<a href="#l58.61"></a><span id="l58.61">     }</span>
<a href="#l58.62"></a><span id="l58.62">     else</span>
<a href="#l58.63"></a><span id="l58.63">       this-&gt;NonNodeError(ev);</span>
<a href="#l58.64"></a><span id="l58.64"> }</span>
<a href="#l58.65"></a><span id="l58.65"> </span>
<a href="#l58.66"></a><span id="l58.66"> // } ===== end morkNode methods =====</span>
<a href="#l58.67"></a><span id="l58.67" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l58.68"></a><span id="l58.68" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l58.69"></a><span id="l58.69"> </span>
<a href="#l58.70"></a><span id="l58.70"> /*static*/ void</span>
<a href="#l58.71"></a><span id="l58.71"> morkRowCellCursor::NilRowObjectError(morkEnv* ev)</span>
<a href="#l58.72"></a><span id="l58.72"> {</span>
<a href="#l58.73"></a><span id="l58.73">   ev-&gt;NewError(&quot;nil mRowCellCursor_RowObject&quot;);</span>
<a href="#l58.74"></a><span id="l58.74"> }</span>
<a href="#l58.75"></a><span id="l58.75"> </span>
<a href="#l58.76"></a><span id="l58.76"> /*static*/ void</span>
<a href="#l58.77"></a><span id="l58.77" class="difflineat">@@ -146,20 +146,20 @@ morkRowCellCursor::SetRow(nsIMdbEnv* mev</span>
<a href="#l58.78"></a><span id="l58.78">     morkStore* store = row-&gt;GetRowSpaceStore(ev);</span>
<a href="#l58.79"></a><span id="l58.79">     if ( store )</span>
<a href="#l58.80"></a><span id="l58.80">     {</span>
<a href="#l58.81"></a><span id="l58.81">       morkRowObject* rowObj = row-&gt;AcquireRowObject(ev, store);</span>
<a href="#l58.82"></a><span id="l58.82">       if ( rowObj )</span>
<a href="#l58.83"></a><span id="l58.83">       {</span>
<a href="#l58.84"></a><span id="l58.84">         morkRowObject::SlotStrongRowObject((morkRowObject*) 0, ev,</span>
<a href="#l58.85"></a><span id="l58.85">           &amp;mRowCellCursor_RowObject);</span>
<a href="#l58.86"></a><span id="l58.86" class="difflineminus">-          </span>
<a href="#l58.87"></a><span id="l58.87" class="difflineplus">+</span>
<a href="#l58.88"></a><span id="l58.88">         mRowCellCursor_RowObject = rowObj; // take this strong ref</span>
<a href="#l58.89"></a><span id="l58.89">         mCursor_Seed = row-&gt;mRow_Seed;</span>
<a href="#l58.90"></a><span id="l58.90" class="difflineminus">-        </span>
<a href="#l58.91"></a><span id="l58.91" class="difflineplus">+</span>
<a href="#l58.92"></a><span id="l58.92">         row-&gt;GetCell(ev, mRowCellCursor_Col, &amp;mCursor_Pos);</span>
<a href="#l58.93"></a><span id="l58.93">       }</span>
<a href="#l58.94"></a><span id="l58.94">     }</span>
<a href="#l58.95"></a><span id="l58.95">     outErr = ev-&gt;AsErr();</span>
<a href="#l58.96"></a><span id="l58.96">   }</span>
<a href="#l58.97"></a><span id="l58.97">   return outErr;</span>
<a href="#l58.98"></a><span id="l58.98"> }</span>
<a href="#l58.99"></a><span id="l58.99"> </span>
<a href="#l58.100"></a><span id="l58.100" class="difflineat">@@ -209,17 +209,17 @@ morkRowCellCursor::MakeCell( // get cell</span>
<a href="#l58.101"></a><span id="l58.101">     outErr = ev-&gt;AsErr();</span>
<a href="#l58.102"></a><span id="l58.102">   }</span>
<a href="#l58.103"></a><span id="l58.103">   if ( acqCell )</span>
<a href="#l58.104"></a><span id="l58.104">     *acqCell = outCell;</span>
<a href="#l58.105"></a><span id="l58.105">    if ( outPos )</span>
<a href="#l58.106"></a><span id="l58.106">      *outPos = pos;</span>
<a href="#l58.107"></a><span id="l58.107">    if ( outColumn )</span>
<a href="#l58.108"></a><span id="l58.108">      *outColumn = col;</span>
<a href="#l58.109"></a><span id="l58.109" class="difflineminus">-     </span>
<a href="#l58.110"></a><span id="l58.110" class="difflineplus">+</span>
<a href="#l58.111"></a><span id="l58.111">   return outErr;</span>
<a href="#l58.112"></a><span id="l58.112"> }</span>
<a href="#l58.113"></a><span id="l58.113"> // } ----- end cell creation methods -----</span>
<a href="#l58.114"></a><span id="l58.114"> </span>
<a href="#l58.115"></a><span id="l58.115"> // { ----- begin cell seeking methods -----</span>
<a href="#l58.116"></a><span id="l58.116"> NS_IMETHODIMP</span>
<a href="#l58.117"></a><span id="l58.117"> morkRowCellCursor::SeekCell( // same as SetRow() followed by MakeCell()</span>
<a href="#l58.118"></a><span id="l58.118">   nsIMdbEnv* mev, // context</span>
<a href="#l58.119"></a><span id="l58.119" class="difflineat">@@ -258,21 +258,21 @@ morkRowCellCursor::NextCell( // get next</span>
<a href="#l58.120"></a><span id="l58.120">   {</span>
<a href="#l58.121"></a><span id="l58.121">     *acqCell = nullptr;</span>
<a href="#l58.122"></a><span id="l58.122">     pos = -1;</span>
<a href="#l58.123"></a><span id="l58.123">   }</span>
<a href="#l58.124"></a><span id="l58.124">  if ( outPos )</span>
<a href="#l58.125"></a><span id="l58.125">    *outPos = pos;</span>
<a href="#l58.126"></a><span id="l58.126">  if ( outColumn )</span>
<a href="#l58.127"></a><span id="l58.127">    *outColumn = col;</span>
<a href="#l58.128"></a><span id="l58.128" class="difflineminus">-     </span>
<a href="#l58.129"></a><span id="l58.129" class="difflineplus">+</span>
<a href="#l58.130"></a><span id="l58.130">   mRowCellCursor_Col = pos;</span>
<a href="#l58.131"></a><span id="l58.131">   return NS_OK;</span>
<a href="#l58.132"></a><span id="l58.132"> }</span>
<a href="#l58.133"></a><span id="l58.133" class="difflineminus">-  </span>
<a href="#l58.134"></a><span id="l58.134" class="difflineplus">+</span>
<a href="#l58.135"></a><span id="l58.135"> NS_IMETHODIMP</span>
<a href="#l58.136"></a><span id="l58.136"> morkRowCellCursor::PickNextCell( // get next cell in row within filter set</span>
<a href="#l58.137"></a><span id="l58.137">   nsIMdbEnv* mev, // context</span>
<a href="#l58.138"></a><span id="l58.138">   nsIMdbCell* ioCell, // changes to the next cell in the iteration</span>
<a href="#l58.139"></a><span id="l58.139">   const mdbColumnSet* inFilterSet, // col set of actual caller interest</span>
<a href="#l58.140"></a><span id="l58.140">   mdb_column* outColumn, // column for this particular cell</span>
<a href="#l58.141"></a><span id="l58.141">   mdb_pos* outPos)</span>
<a href="#l58.142"></a><span id="l58.142"> // Note that inFilterSet should not have too many (many more than 10?)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l59.1"></a><span id="l59.1" class="difflineminus">--- a/db/mork/src/morkRowCellCursor.h</span>
<a href="#l59.2"></a><span id="l59.2" class="difflineplus">+++ b/db/mork/src/morkRowCellCursor.h</span>
<a href="#l59.3"></a><span id="l59.3" class="difflineat">@@ -76,17 +76,17 @@ public: // morkRowCellCursor constructio</span>
<a href="#l59.4"></a><span id="l59.4">   // } ----- end cell seeking methods -----</span>
<a href="#l59.5"></a><span id="l59.5"> </span>
<a href="#l59.6"></a><span id="l59.6">   // { ----- begin cell iteration methods -----</span>
<a href="#l59.7"></a><span id="l59.7">   NS_IMETHOD NextCell( // get next cell in the row</span>
<a href="#l59.8"></a><span id="l59.8">     nsIMdbEnv* ev, // context</span>
<a href="#l59.9"></a><span id="l59.9">     nsIMdbCell** acqCell, // changes to the next cell in the iteration</span>
<a href="#l59.10"></a><span id="l59.10">     mdb_column* outColumn, // column for this particular cell</span>
<a href="#l59.11"></a><span id="l59.11">     mdb_pos* outPos) override; // position of cell in row sequence</span>
<a href="#l59.12"></a><span id="l59.12" class="difflineminus">-    </span>
<a href="#l59.13"></a><span id="l59.13" class="difflineplus">+</span>
<a href="#l59.14"></a><span id="l59.14">   NS_IMETHOD PickNextCell( // get next cell in row within filter set</span>
<a href="#l59.15"></a><span id="l59.15">     nsIMdbEnv* ev, // context</span>
<a href="#l59.16"></a><span id="l59.16">     nsIMdbCell* ioCell, // changes to the next cell in the iteration</span>
<a href="#l59.17"></a><span id="l59.17">     const mdbColumnSet* inFilterSet, // col set of actual caller interest</span>
<a href="#l59.18"></a><span id="l59.18">     mdb_column* outColumn, // column for this particular cell</span>
<a href="#l59.19"></a><span id="l59.19">     mdb_pos* outPos) override; // position of cell in row sequence</span>
<a href="#l59.20"></a><span id="l59.20"> </span>
<a href="#l59.21"></a><span id="l59.21">   // Note that inFilterSet should not have too many (many more than 10?)</span>
<a href="#l59.22"></a><span id="l59.22" class="difflineat">@@ -108,17 +108,17 @@ public: // dynamic type identification</span>
<a href="#l59.23"></a><span id="l59.23"> public: // errors</span>
<a href="#l59.24"></a><span id="l59.24">   static void NilRowObjectError(morkEnv* ev);</span>
<a href="#l59.25"></a><span id="l59.25">   static void NonRowCellCursorTypeError(morkEnv* ev);</span>
<a href="#l59.26"></a><span id="l59.26"> </span>
<a href="#l59.27"></a><span id="l59.27"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l59.28"></a><span id="l59.28">   static void SlotWeakRowCellCursor(morkRowCellCursor* me,</span>
<a href="#l59.29"></a><span id="l59.29">     morkEnv* ev, morkRowCellCursor** ioSlot)</span>
<a href="#l59.30"></a><span id="l59.30">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l59.31"></a><span id="l59.31" class="difflineminus">-  </span>
<a href="#l59.32"></a><span id="l59.32" class="difflineplus">+</span>
<a href="#l59.33"></a><span id="l59.33">   static void SlotStrongRowCellCursor(morkRowCellCursor* me,</span>
<a href="#l59.34"></a><span id="l59.34">     morkEnv* ev, morkRowCellCursor** ioSlot)</span>
<a href="#l59.35"></a><span id="l59.35">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l59.36"></a><span id="l59.36"> };</span>
<a href="#l59.37"></a><span id="l59.37"> </span>
<a href="#l59.38"></a><span id="l59.38"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l59.39"></a><span id="l59.39"> </span>
<a href="#l59.40"></a><span id="l59.40"> #endif /* _MORKROWCELLCURSOR_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l60.1"></a><span id="l60.1" class="difflineminus">--- a/db/mork/src/morkRowMap.cpp</span>
<a href="#l60.2"></a><span id="l60.2" class="difflineplus">+++ b/db/mork/src/morkRowMap.cpp</span>
<a href="#l60.3"></a><span id="l60.3" class="difflineat">@@ -28,17 +28,17 @@</span>
<a href="#l60.4"></a><span id="l60.4"> #endif</span>
<a href="#l60.5"></a><span id="l60.5"> </span>
<a href="#l60.6"></a><span id="l60.6"> #ifndef _MORKROW_</span>
<a href="#l60.7"></a><span id="l60.7"> #include &quot;morkRow.h&quot;</span>
<a href="#l60.8"></a><span id="l60.8"> #endif</span>
<a href="#l60.9"></a><span id="l60.9"> </span>
<a href="#l60.10"></a><span id="l60.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l60.11"></a><span id="l60.11"> </span>
<a href="#l60.12"></a><span id="l60.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l60.13"></a><span id="l60.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l60.14"></a><span id="l60.14"> // { ===== begin morkNode interface =====</span>
<a href="#l60.15"></a><span id="l60.15"> </span>
<a href="#l60.16"></a><span id="l60.16"> /*public virtual*/ void</span>
<a href="#l60.17"></a><span id="l60.17"> morkRowMap::CloseMorkNode(morkEnv* ev) // CloseRowMap() only if open</span>
<a href="#l60.18"></a><span id="l60.18"> {</span>
<a href="#l60.19"></a><span id="l60.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l60.20"></a><span id="l60.20">   {</span>
<a href="#l60.21"></a><span id="l60.21">     this-&gt;MarkClosing();</span>
<a href="#l60.22"></a><span id="l60.22" class="difflineat">@@ -72,95 +72,95 @@ morkRowMap::CloseRowMap(morkEnv* ev) // </span>
<a href="#l60.23"></a><span id="l60.23">       this-&gt;CloseMap(ev);</span>
<a href="#l60.24"></a><span id="l60.24">       this-&gt;MarkShut();</span>
<a href="#l60.25"></a><span id="l60.25">     }</span>
<a href="#l60.26"></a><span id="l60.26">     else</span>
<a href="#l60.27"></a><span id="l60.27">       this-&gt;NonNodeError(ev);</span>
<a href="#l60.28"></a><span id="l60.28"> }</span>
<a href="#l60.29"></a><span id="l60.29"> </span>
<a href="#l60.30"></a><span id="l60.30"> // } ===== end morkNode methods =====</span>
<a href="#l60.31"></a><span id="l60.31" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l60.32"></a><span id="l60.32" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l60.33"></a><span id="l60.33"> </span>
<a href="#l60.34"></a><span id="l60.34"> </span>
<a href="#l60.35"></a><span id="l60.35"> // { ===== begin morkMap poly interface =====</span>
<a href="#l60.36"></a><span id="l60.36" class="difflineminus">-/*virtual*/ mork_bool // </span>
<a href="#l60.37"></a><span id="l60.37" class="difflineplus">+/*virtual*/ mork_bool //</span>
<a href="#l60.38"></a><span id="l60.38"> morkRowMap::Equal(morkEnv* ev, const void* inKeyA,</span>
<a href="#l60.39"></a><span id="l60.39">   const void* inKeyB) const</span>
<a href="#l60.40"></a><span id="l60.40"> {</span>
<a href="#l60.41"></a><span id="l60.41">   MORK_USED_1(ev);</span>
<a href="#l60.42"></a><span id="l60.42">   return (*(const morkRow**) inKeyA)-&gt;EqualRow(*(const morkRow**) inKeyB);</span>
<a href="#l60.43"></a><span id="l60.43"> }</span>
<a href="#l60.44"></a><span id="l60.44"> </span>
<a href="#l60.45"></a><span id="l60.45" class="difflineminus">-/*virtual*/ mork_u4 // </span>
<a href="#l60.46"></a><span id="l60.46" class="difflineplus">+/*virtual*/ mork_u4 //</span>
<a href="#l60.47"></a><span id="l60.47"> morkRowMap::Hash(morkEnv* ev, const void* inKey) const</span>
<a href="#l60.48"></a><span id="l60.48"> {</span>
<a href="#l60.49"></a><span id="l60.49">   MORK_USED_1(ev);</span>
<a href="#l60.50"></a><span id="l60.50">   return (*(const morkRow**) inKey)-&gt;HashRow();</span>
<a href="#l60.51"></a><span id="l60.51"> }</span>
<a href="#l60.52"></a><span id="l60.52"> // } ===== end morkMap poly interface =====</span>
<a href="#l60.53"></a><span id="l60.53"> </span>
<a href="#l60.54"></a><span id="l60.54"> </span>
<a href="#l60.55"></a><span id="l60.55"> mork_bool</span>
<a href="#l60.56"></a><span id="l60.56"> morkRowMap::AddRow(morkEnv* ev, morkRow* ioRow)</span>
<a href="#l60.57"></a><span id="l60.57"> {</span>
<a href="#l60.58"></a><span id="l60.58">   if ( ev-&gt;Good() )</span>
<a href="#l60.59"></a><span id="l60.59">   {</span>
<a href="#l60.60"></a><span id="l60.60" class="difflineminus">-    this-&gt;Put(ev, &amp;ioRow, /*val*/ (void*) 0, </span>
<a href="#l60.61"></a><span id="l60.61" class="difflineplus">+    this-&gt;Put(ev, &amp;ioRow, /*val*/ (void*) 0,</span>
<a href="#l60.62"></a><span id="l60.62">       /*key*/ (void*) 0, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l60.63"></a><span id="l60.63">   }</span>
<a href="#l60.64"></a><span id="l60.64">   return ev-&gt;Good();</span>
<a href="#l60.65"></a><span id="l60.65"> }</span>
<a href="#l60.66"></a><span id="l60.66"> </span>
<a href="#l60.67"></a><span id="l60.67"> morkRow*</span>
<a href="#l60.68"></a><span id="l60.68"> morkRowMap::CutOid(morkEnv* ev, const mdbOid* inOid)</span>
<a href="#l60.69"></a><span id="l60.69"> {</span>
<a href="#l60.70"></a><span id="l60.70">   morkRow row(inOid);</span>
<a href="#l60.71"></a><span id="l60.71">   morkRow* key = &amp;row;</span>
<a href="#l60.72"></a><span id="l60.72">   morkRow* oldKey = 0;</span>
<a href="#l60.73"></a><span id="l60.73">   this-&gt;Cut(ev, &amp;key, &amp;oldKey, /*val*/ (void*) 0,</span>
<a href="#l60.74"></a><span id="l60.74">     (mork_change**) 0);</span>
<a href="#l60.75"></a><span id="l60.75" class="difflineminus">-    </span>
<a href="#l60.76"></a><span id="l60.76" class="difflineplus">+</span>
<a href="#l60.77"></a><span id="l60.77">   return oldKey;</span>
<a href="#l60.78"></a><span id="l60.78"> }</span>
<a href="#l60.79"></a><span id="l60.79"> </span>
<a href="#l60.80"></a><span id="l60.80"> morkRow*</span>
<a href="#l60.81"></a><span id="l60.81"> morkRowMap::CutRow(morkEnv* ev, const morkRow* ioRow)</span>
<a href="#l60.82"></a><span id="l60.82"> {</span>
<a href="#l60.83"></a><span id="l60.83">   morkRow* oldKey = 0;</span>
<a href="#l60.84"></a><span id="l60.84">   this-&gt;Cut(ev, &amp;ioRow, &amp;oldKey, /*val*/ (void*) 0,</span>
<a href="#l60.85"></a><span id="l60.85">     (mork_change**) 0);</span>
<a href="#l60.86"></a><span id="l60.86" class="difflineminus">-    </span>
<a href="#l60.87"></a><span id="l60.87" class="difflineplus">+</span>
<a href="#l60.88"></a><span id="l60.88">   return oldKey;</span>
<a href="#l60.89"></a><span id="l60.89"> }</span>
<a href="#l60.90"></a><span id="l60.90"> </span>
<a href="#l60.91"></a><span id="l60.91"> morkRow*</span>
<a href="#l60.92"></a><span id="l60.92"> morkRowMap::GetOid(morkEnv* ev, const mdbOid* inOid)</span>
<a href="#l60.93"></a><span id="l60.93"> {</span>
<a href="#l60.94"></a><span id="l60.94">   morkRow row(inOid);</span>
<a href="#l60.95"></a><span id="l60.95">   morkRow* key = &amp;row;</span>
<a href="#l60.96"></a><span id="l60.96">   morkRow* oldKey = 0;</span>
<a href="#l60.97"></a><span id="l60.97">   this-&gt;Get(ev, &amp;key, &amp;oldKey, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l60.98"></a><span id="l60.98" class="difflineminus">-  </span>
<a href="#l60.99"></a><span id="l60.99" class="difflineplus">+</span>
<a href="#l60.100"></a><span id="l60.100">   return oldKey;</span>
<a href="#l60.101"></a><span id="l60.101"> }</span>
<a href="#l60.102"></a><span id="l60.102"> </span>
<a href="#l60.103"></a><span id="l60.103"> morkRow*</span>
<a href="#l60.104"></a><span id="l60.104"> morkRowMap::GetRow(morkEnv* ev, const morkRow* ioRow)</span>
<a href="#l60.105"></a><span id="l60.105"> {</span>
<a href="#l60.106"></a><span id="l60.106">   morkRow* oldKey = 0;</span>
<a href="#l60.107"></a><span id="l60.107">   this-&gt;Get(ev, &amp;ioRow, &amp;oldKey, /*val*/ (void*) 0, (mork_change**) 0);</span>
<a href="#l60.108"></a><span id="l60.108" class="difflineminus">-  </span>
<a href="#l60.109"></a><span id="l60.109" class="difflineplus">+</span>
<a href="#l60.110"></a><span id="l60.110">   return oldKey;</span>
<a href="#l60.111"></a><span id="l60.111"> }</span>
<a href="#l60.112"></a><span id="l60.112"> </span>
<a href="#l60.113"></a><span id="l60.113"> </span>
<a href="#l60.114"></a><span id="l60.114"> </span>
<a href="#l60.115"></a><span id="l60.115"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l60.116"></a><span id="l60.116"> </span>
<a href="#l60.117"></a><span id="l60.117" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l60.118"></a><span id="l60.118" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l60.119"></a><span id="l60.119"> // { ===== begin morkNode interface =====</span>
<a href="#l60.120"></a><span id="l60.120"> </span>
<a href="#l60.121"></a><span id="l60.121"> /*public virtual*/ void</span>
<a href="#l60.122"></a><span id="l60.122"> morkRowProbeMap::CloseMorkNode(morkEnv* ev) // CloseRowProbeMap() only if open</span>
<a href="#l60.123"></a><span id="l60.123"> {</span>
<a href="#l60.124"></a><span id="l60.124">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l60.125"></a><span id="l60.125">   {</span>
<a href="#l60.126"></a><span id="l60.126">     this-&gt;MarkClosing();</span>
<a href="#l60.127"></a><span id="l60.127" class="difflineat">@@ -175,17 +175,17 @@ morkRowProbeMap::~morkRowProbeMap() // a</span>
<a href="#l60.128"></a><span id="l60.128">   MORK_ASSERT(this-&gt;IsShutNode());</span>
<a href="#l60.129"></a><span id="l60.129"> }</span>
<a href="#l60.130"></a><span id="l60.130"> </span>
<a href="#l60.131"></a><span id="l60.131"> /*public non-poly*/</span>
<a href="#l60.132"></a><span id="l60.132"> morkRowProbeMap::morkRowProbeMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l60.133"></a><span id="l60.133">   nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap, mork_size inSlots)</span>
<a href="#l60.134"></a><span id="l60.134"> : morkProbeMap(ev, inUsage,  ioHeap,</span>
<a href="#l60.135"></a><span id="l60.135">   /*inKeySize*/ sizeof(morkRow*), /*inValSize*/ 0,</span>
<a href="#l60.136"></a><span id="l60.136" class="difflineminus">-  ioSlotHeap, inSlots, </span>
<a href="#l60.137"></a><span id="l60.137" class="difflineplus">+  ioSlotHeap, inSlots,</span>
<a href="#l60.138"></a><span id="l60.138">   /*inHoldChanges*/ morkBool_kTrue)</span>
<a href="#l60.139"></a><span id="l60.139"> {</span>
<a href="#l60.140"></a><span id="l60.140">   if ( ev-&gt;Good() )</span>
<a href="#l60.141"></a><span id="l60.141">     mNode_Derived = morkDerived_kRowProbeMap;</span>
<a href="#l60.142"></a><span id="l60.142"> }</span>
<a href="#l60.143"></a><span id="l60.143"> </span>
<a href="#l60.144"></a><span id="l60.144"> /*public non-poly*/ void</span>
<a href="#l60.145"></a><span id="l60.145"> morkRowProbeMap::CloseRowProbeMap(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l60.146"></a><span id="l60.146" class="difflineat">@@ -195,17 +195,17 @@ morkRowProbeMap::CloseRowProbeMap(morkEn</span>
<a href="#l60.147"></a><span id="l60.147">       this-&gt;CloseProbeMap(ev);</span>
<a href="#l60.148"></a><span id="l60.148">       this-&gt;MarkShut();</span>
<a href="#l60.149"></a><span id="l60.149">     }</span>
<a href="#l60.150"></a><span id="l60.150">     else</span>
<a href="#l60.151"></a><span id="l60.151">       this-&gt;NonNodeError(ev);</span>
<a href="#l60.152"></a><span id="l60.152"> }</span>
<a href="#l60.153"></a><span id="l60.153"> </span>
<a href="#l60.154"></a><span id="l60.154"> // } ===== end morkNode methods =====</span>
<a href="#l60.155"></a><span id="l60.155" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l60.156"></a><span id="l60.156" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l60.157"></a><span id="l60.157"> </span>
<a href="#l60.158"></a><span id="l60.158"> /*virtual*/ mork_test // hit(a,b) implies hash(a) == hash(b)</span>
<a href="#l60.159"></a><span id="l60.159"> morkRowProbeMap::MapTest(morkEnv* ev, const void* inMapKey,</span>
<a href="#l60.160"></a><span id="l60.160">   const void* inAppKey) const</span>
<a href="#l60.161"></a><span id="l60.161"> {</span>
<a href="#l60.162"></a><span id="l60.162">   MORK_USED_1(ev);</span>
<a href="#l60.163"></a><span id="l60.163">   const morkRow* key = *(const morkRow**) inMapKey;</span>
<a href="#l60.164"></a><span id="l60.164">   if ( key )</span>
<a href="#l60.165"></a><span id="l60.165" class="difflineat">@@ -225,17 +225,17 @@ morkRowProbeMap::MapHash(morkEnv* ev, co</span>
<a href="#l60.166"></a><span id="l60.166">     return key-&gt;HashRow();</span>
<a href="#l60.167"></a><span id="l60.167">   else</span>
<a href="#l60.168"></a><span id="l60.168">   {</span>
<a href="#l60.169"></a><span id="l60.169">     ev-&gt;NilPointerWarning();</span>
<a href="#l60.170"></a><span id="l60.170">     return 0;</span>
<a href="#l60.171"></a><span id="l60.171">   }</span>
<a href="#l60.172"></a><span id="l60.172"> }</span>
<a href="#l60.173"></a><span id="l60.173"> </span>
<a href="#l60.174"></a><span id="l60.174" class="difflineminus">-/*virtual*/ mork_u4 </span>
<a href="#l60.175"></a><span id="l60.175" class="difflineplus">+/*virtual*/ mork_u4</span>
<a href="#l60.176"></a><span id="l60.176"> morkRowProbeMap::ProbeMapHashMapKey(morkEnv* ev,</span>
<a href="#l60.177"></a><span id="l60.177">   const void* inMapKey) const</span>
<a href="#l60.178"></a><span id="l60.178"> {</span>
<a href="#l60.179"></a><span id="l60.179">   const morkRow* key = *(const morkRow**) inMapKey;</span>
<a href="#l60.180"></a><span id="l60.180">   if ( key )</span>
<a href="#l60.181"></a><span id="l60.181">     return key-&gt;HashRow();</span>
<a href="#l60.182"></a><span id="l60.182">   else</span>
<a href="#l60.183"></a><span id="l60.183">   {</span>
<a href="#l60.184"></a><span id="l60.184" class="difflineat">@@ -244,54 +244,54 @@ morkRowProbeMap::ProbeMapHashMapKey(mork</span>
<a href="#l60.185"></a><span id="l60.185">   }</span>
<a href="#l60.186"></a><span id="l60.186"> }</span>
<a href="#l60.187"></a><span id="l60.187"> </span>
<a href="#l60.188"></a><span id="l60.188"> mork_bool</span>
<a href="#l60.189"></a><span id="l60.189"> morkRowProbeMap::AddRow(morkEnv* ev, morkRow* ioRow)</span>
<a href="#l60.190"></a><span id="l60.190"> {</span>
<a href="#l60.191"></a><span id="l60.191">   if ( ev-&gt;Good() )</span>
<a href="#l60.192"></a><span id="l60.192">   {</span>
<a href="#l60.193"></a><span id="l60.193" class="difflineminus">-    this-&gt;MapAtPut(ev, &amp;ioRow, /*val*/ (void*) 0, </span>
<a href="#l60.194"></a><span id="l60.194" class="difflineplus">+    this-&gt;MapAtPut(ev, &amp;ioRow, /*val*/ (void*) 0,</span>
<a href="#l60.195"></a><span id="l60.195">       /*key*/ (void*) 0, /*val*/ (void*) 0);</span>
<a href="#l60.196"></a><span id="l60.196">   }</span>
<a href="#l60.197"></a><span id="l60.197">   return ev-&gt;Good();</span>
<a href="#l60.198"></a><span id="l60.198"> }</span>
<a href="#l60.199"></a><span id="l60.199"> </span>
<a href="#l60.200"></a><span id="l60.200"> morkRow*</span>
<a href="#l60.201"></a><span id="l60.201"> morkRowProbeMap::CutOid(morkEnv* ev, const mdbOid* inOid)</span>
<a href="#l60.202"></a><span id="l60.202"> {</span>
<a href="#l60.203"></a><span id="l60.203">   MORK_USED_1(inOid);</span>
<a href="#l60.204"></a><span id="l60.204">   morkProbeMap::ProbeMapCutError(ev);</span>
<a href="#l60.205"></a><span id="l60.205" class="difflineminus">-    </span>
<a href="#l60.206"></a><span id="l60.206" class="difflineplus">+</span>
<a href="#l60.207"></a><span id="l60.207">   return 0;</span>
<a href="#l60.208"></a><span id="l60.208"> }</span>
<a href="#l60.209"></a><span id="l60.209"> </span>
<a href="#l60.210"></a><span id="l60.210"> morkRow*</span>
<a href="#l60.211"></a><span id="l60.211"> morkRowProbeMap::CutRow(morkEnv* ev, const morkRow* ioRow)</span>
<a href="#l60.212"></a><span id="l60.212"> {</span>
<a href="#l60.213"></a><span id="l60.213">   MORK_USED_1(ioRow);</span>
<a href="#l60.214"></a><span id="l60.214">   morkProbeMap::ProbeMapCutError(ev);</span>
<a href="#l60.215"></a><span id="l60.215" class="difflineminus">-    </span>
<a href="#l60.216"></a><span id="l60.216" class="difflineplus">+</span>
<a href="#l60.217"></a><span id="l60.217">   return 0;</span>
<a href="#l60.218"></a><span id="l60.218"> }</span>
<a href="#l60.219"></a><span id="l60.219"> </span>
<a href="#l60.220"></a><span id="l60.220"> morkRow*</span>
<a href="#l60.221"></a><span id="l60.221"> morkRowProbeMap::GetOid(morkEnv* ev, const mdbOid* inOid)</span>
<a href="#l60.222"></a><span id="l60.222"> {</span>
<a href="#l60.223"></a><span id="l60.223">   morkRow row(inOid);</span>
<a href="#l60.224"></a><span id="l60.224">   morkRow* key = &amp;row;</span>
<a href="#l60.225"></a><span id="l60.225">   morkRow* oldKey = 0;</span>
<a href="#l60.226"></a><span id="l60.226">   this-&gt;MapAt(ev, &amp;key, &amp;oldKey, /*val*/ (void*) 0);</span>
<a href="#l60.227"></a><span id="l60.227" class="difflineminus">-  </span>
<a href="#l60.228"></a><span id="l60.228" class="difflineplus">+</span>
<a href="#l60.229"></a><span id="l60.229">   return oldKey;</span>
<a href="#l60.230"></a><span id="l60.230"> }</span>
<a href="#l60.231"></a><span id="l60.231"> </span>
<a href="#l60.232"></a><span id="l60.232"> morkRow*</span>
<a href="#l60.233"></a><span id="l60.233"> morkRowProbeMap::GetRow(morkEnv* ev, const morkRow* ioRow)</span>
<a href="#l60.234"></a><span id="l60.234"> {</span>
<a href="#l60.235"></a><span id="l60.235">   morkRow* oldKey = 0;</span>
<a href="#l60.236"></a><span id="l60.236">   this-&gt;MapAt(ev, &amp;ioRow, &amp;oldKey, /*val*/ (void*) 0);</span>
<a href="#l60.237"></a><span id="l60.237" class="difflineminus">-  </span>
<a href="#l60.238"></a><span id="l60.238" class="difflineplus">+</span>
<a href="#l60.239"></a><span id="l60.239">   return oldKey;</span>
<a href="#l60.240"></a><span id="l60.240"> }</span>
<a href="#l60.241"></a><span id="l60.241"> </span>
<a href="#l60.242"></a><span id="l60.242"> </span>
<a href="#l60.243"></a><span id="l60.243"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l61.1"></a><span id="l61.1" class="difflineminus">--- a/db/mork/src/morkRowMap.h</span>
<a href="#l61.2"></a><span id="l61.2" class="difflineplus">+++ b/db/mork/src/morkRowMap.h</span>
<a href="#l61.3"></a><span id="l61.3" class="difflineat">@@ -29,17 +29,17 @@</span>
<a href="#l61.4"></a><span id="l61.4"> /*| morkRowMap: maps a set of morkRow by contained Oid</span>
<a href="#l61.5"></a><span id="l61.5"> |*/</span>
<a href="#l61.6"></a><span id="l61.6"> class morkRowMap : public morkMap { // for mapping row IDs to rows</span>
<a href="#l61.7"></a><span id="l61.7"> </span>
<a href="#l61.8"></a><span id="l61.8"> // { ===== begin morkNode interface =====</span>
<a href="#l61.9"></a><span id="l61.9"> public: // morkNode virtual methods</span>
<a href="#l61.10"></a><span id="l61.10">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseRowMap() only if open</span>
<a href="#l61.11"></a><span id="l61.11">   virtual ~morkRowMap(); // assert that CloseRowMap() executed earlier</span>
<a href="#l61.12"></a><span id="l61.12" class="difflineminus">-  </span>
<a href="#l61.13"></a><span id="l61.13" class="difflineplus">+</span>
<a href="#l61.14"></a><span id="l61.14"> public: // morkMap construction &amp; destruction</span>
<a href="#l61.15"></a><span id="l61.15">   morkRowMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l61.16"></a><span id="l61.16">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap, mork_size inSlots);</span>
<a href="#l61.17"></a><span id="l61.17">   void CloseRowMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l61.18"></a><span id="l61.18"> </span>
<a href="#l61.19"></a><span id="l61.19"> public: // dynamic type identification</span>
<a href="#l61.20"></a><span id="l61.20">   mork_bool IsRowMap() const</span>
<a href="#l61.21"></a><span id="l61.21">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kRowMap; }</span>
<a href="#l61.22"></a><span id="l61.22" class="difflineat">@@ -60,54 +60,54 @@ public: // other map methods</span>
<a href="#l61.23"></a><span id="l61.23">   mork_bool AddRow(morkEnv* ev, morkRow* ioRow);</span>
<a href="#l61.24"></a><span id="l61.24">   // AddRow() returns ev-&gt;Good()</span>
<a href="#l61.25"></a><span id="l61.25"> </span>
<a href="#l61.26"></a><span id="l61.26">   morkRow*  CutOid(morkEnv* ev, const mdbOid* inOid);</span>
<a href="#l61.27"></a><span id="l61.27">   // CutRid() returns the row removed equal to inRid, if there was one</span>
<a href="#l61.28"></a><span id="l61.28"> </span>
<a href="#l61.29"></a><span id="l61.29">   morkRow*  CutRow(morkEnv* ev, const morkRow* ioRow);</span>
<a href="#l61.30"></a><span id="l61.30">   // CutRow() returns the row removed equal to ioRow, if there was one</span>
<a href="#l61.31"></a><span id="l61.31" class="difflineminus">-  </span>
<a href="#l61.32"></a><span id="l61.32" class="difflineplus">+</span>
<a href="#l61.33"></a><span id="l61.33">   morkRow*  GetOid(morkEnv* ev, const mdbOid* inOid);</span>
<a href="#l61.34"></a><span id="l61.34">   // GetOid() returns the row equal to inRid, or else nil</span>
<a href="#l61.35"></a><span id="l61.35" class="difflineminus">-  </span>
<a href="#l61.36"></a><span id="l61.36" class="difflineplus">+</span>
<a href="#l61.37"></a><span id="l61.37">   morkRow*  GetRow(morkEnv* ev, const morkRow* ioRow);</span>
<a href="#l61.38"></a><span id="l61.38">   // GetRow() returns the row equal to ioRow, or else nil</span>
<a href="#l61.39"></a><span id="l61.39" class="difflineminus">-  </span>
<a href="#l61.40"></a><span id="l61.40" class="difflineplus">+</span>
<a href="#l61.41"></a><span id="l61.41">   // note the rows are owned elsewhere, usuall by morkRowSpace</span>
<a href="#l61.42"></a><span id="l61.42"> </span>
<a href="#l61.43"></a><span id="l61.43"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l61.44"></a><span id="l61.44">   static void SlotWeakRowMap(morkRowMap* me,</span>
<a href="#l61.45"></a><span id="l61.45">     morkEnv* ev, morkRowMap** ioSlot)</span>
<a href="#l61.46"></a><span id="l61.46">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l61.47"></a><span id="l61.47" class="difflineminus">-  </span>
<a href="#l61.48"></a><span id="l61.48" class="difflineplus">+</span>
<a href="#l61.49"></a><span id="l61.49">   static void SlotStrongRowMap(morkRowMap* me,</span>
<a href="#l61.50"></a><span id="l61.50">     morkEnv* ev, morkRowMap** ioSlot)</span>
<a href="#l61.51"></a><span id="l61.51">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l61.52"></a><span id="l61.52"> };</span>
<a href="#l61.53"></a><span id="l61.53"> </span>
<a href="#l61.54"></a><span id="l61.54"> class morkRowMapIter: public morkMapIter{ // typesafe wrapper class</span>
<a href="#l61.55"></a><span id="l61.55"> </span>
<a href="#l61.56"></a><span id="l61.56"> public:</span>
<a href="#l61.57"></a><span id="l61.57">   morkRowMapIter(morkEnv* ev, morkRowMap* ioMap)</span>
<a href="#l61.58"></a><span id="l61.58">   : morkMapIter(ev, ioMap) { }</span>
<a href="#l61.59"></a><span id="l61.59" class="difflineminus">- </span>
<a href="#l61.60"></a><span id="l61.60" class="difflineplus">+</span>
<a href="#l61.61"></a><span id="l61.61">   morkRowMapIter( ) : morkMapIter()  { }</span>
<a href="#l61.62"></a><span id="l61.62">   void InitRowMapIter(morkEnv* ev, morkRowMap* ioMap)</span>
<a href="#l61.63"></a><span id="l61.63">   { this-&gt;InitMapIter(ev, ioMap); }</span>
<a href="#l61.64"></a><span id="l61.64" class="difflineminus">-   </span>
<a href="#l61.65"></a><span id="l61.65" class="difflineplus">+</span>
<a href="#l61.66"></a><span id="l61.66">   mork_change* FirstRow(morkEnv* ev, morkRow** outRowPtr)</span>
<a href="#l61.67"></a><span id="l61.67">   { return this-&gt;First(ev, outRowPtr, /*val*/ (void*) 0); }</span>
<a href="#l61.68"></a><span id="l61.68" class="difflineminus">-  </span>
<a href="#l61.69"></a><span id="l61.69" class="difflineplus">+</span>
<a href="#l61.70"></a><span id="l61.70">   mork_change* NextRow(morkEnv* ev, morkRow** outRowPtr)</span>
<a href="#l61.71"></a><span id="l61.71">   { return this-&gt;Next(ev, outRowPtr, /*val*/ (void*) 0); }</span>
<a href="#l61.72"></a><span id="l61.72" class="difflineminus">-  </span>
<a href="#l61.73"></a><span id="l61.73" class="difflineplus">+</span>
<a href="#l61.74"></a><span id="l61.74">   mork_change* HereRow(morkEnv* ev, morkRow** outRowPtr)</span>
<a href="#l61.75"></a><span id="l61.75">   { return this-&gt;Here(ev, outRowPtr, /*val*/ (void*) 0); }</span>
<a href="#l61.76"></a><span id="l61.76" class="difflineminus">-  </span>
<a href="#l61.77"></a><span id="l61.77" class="difflineplus">+</span>
<a href="#l61.78"></a><span id="l61.78">   mork_change* CutHereRow(morkEnv* ev, morkRow** outRowPtr)</span>
<a href="#l61.79"></a><span id="l61.79">   { return this-&gt;CutHere(ev, outRowPtr, /*val*/ (void*) 0); }</span>
<a href="#l61.80"></a><span id="l61.80"> };</span>
<a href="#l61.81"></a><span id="l61.81"> </span>
<a href="#l61.82"></a><span id="l61.82"> </span>
<a href="#l61.83"></a><span id="l61.83"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l61.84"></a><span id="l61.84"> </span>
<a href="#l61.85"></a><span id="l61.85"> #define morkDerived_kRowProbeMap  /*i*/ 0x726D /* ascii 'rm' */</span>
<a href="#l61.86"></a><span id="l61.86" class="difflineat">@@ -115,17 +115,17 @@ public:</span>
<a href="#l61.87"></a><span id="l61.87"> /*| morkRowProbeMap: maps a set of morkRow by contained Oid</span>
<a href="#l61.88"></a><span id="l61.88"> |*/</span>
<a href="#l61.89"></a><span id="l61.89"> class morkRowProbeMap : public morkProbeMap { // for mapping row IDs to rows</span>
<a href="#l61.90"></a><span id="l61.90"> </span>
<a href="#l61.91"></a><span id="l61.91"> // { ===== begin morkNode interface =====</span>
<a href="#l61.92"></a><span id="l61.92"> public: // morkNode virtual methods</span>
<a href="#l61.93"></a><span id="l61.93">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseRowProbeMap() only if open</span>
<a href="#l61.94"></a><span id="l61.94">   virtual ~morkRowProbeMap(); // assert CloseRowProbeMap() executed earlier</span>
<a href="#l61.95"></a><span id="l61.95" class="difflineminus">-  </span>
<a href="#l61.96"></a><span id="l61.96" class="difflineplus">+</span>
<a href="#l61.97"></a><span id="l61.97"> public: // morkMap construction &amp; destruction</span>
<a href="#l61.98"></a><span id="l61.98">   morkRowProbeMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l61.99"></a><span id="l61.99">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap, mork_size inSlots);</span>
<a href="#l61.100"></a><span id="l61.100">   void CloseRowProbeMap(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l61.101"></a><span id="l61.101"> </span>
<a href="#l61.102"></a><span id="l61.102"> public: // dynamic type identification</span>
<a href="#l61.103"></a><span id="l61.103">   mork_bool IsRowMap() const</span>
<a href="#l61.104"></a><span id="l61.104">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kRowMap; }</span>
<a href="#l61.105"></a><span id="l61.105" class="difflineat">@@ -159,53 +159,53 @@ public: // other map methods</span>
<a href="#l61.106"></a><span id="l61.106">   mork_bool AddRow(morkEnv* ev, morkRow* ioRow);</span>
<a href="#l61.107"></a><span id="l61.107">   // AddRow() returns ev-&gt;Good()</span>
<a href="#l61.108"></a><span id="l61.108"> </span>
<a href="#l61.109"></a><span id="l61.109">   morkRow*  CutOid(morkEnv* ev, const mdbOid* inOid);</span>
<a href="#l61.110"></a><span id="l61.110">   // CutRid() returns the row removed equal to inRid, if there was one</span>
<a href="#l61.111"></a><span id="l61.111"> </span>
<a href="#l61.112"></a><span id="l61.112">   morkRow*  CutRow(morkEnv* ev, const morkRow* ioRow);</span>
<a href="#l61.113"></a><span id="l61.113">   // CutRow() returns the row removed equal to ioRow, if there was one</span>
<a href="#l61.114"></a><span id="l61.114" class="difflineminus">-  </span>
<a href="#l61.115"></a><span id="l61.115" class="difflineplus">+</span>
<a href="#l61.116"></a><span id="l61.116">   morkRow*  GetOid(morkEnv* ev, const mdbOid* inOid);</span>
<a href="#l61.117"></a><span id="l61.117">   // GetOid() returns the row equal to inRid, or else nil</span>
<a href="#l61.118"></a><span id="l61.118" class="difflineminus">-  </span>
<a href="#l61.119"></a><span id="l61.119" class="difflineplus">+</span>
<a href="#l61.120"></a><span id="l61.120">   morkRow*  GetRow(morkEnv* ev, const morkRow* ioRow);</span>
<a href="#l61.121"></a><span id="l61.121">   // GetRow() returns the row equal to ioRow, or else nil</span>
<a href="#l61.122"></a><span id="l61.122" class="difflineminus">-  </span>
<a href="#l61.123"></a><span id="l61.123" class="difflineplus">+</span>
<a href="#l61.124"></a><span id="l61.124">   // note the rows are owned elsewhere, usuall by morkRowSpace</span>
<a href="#l61.125"></a><span id="l61.125"> </span>
<a href="#l61.126"></a><span id="l61.126"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l61.127"></a><span id="l61.127">   static void SlotWeakRowProbeMap(morkRowProbeMap* me,</span>
<a href="#l61.128"></a><span id="l61.128">     morkEnv* ev, morkRowProbeMap** ioSlot)</span>
<a href="#l61.129"></a><span id="l61.129">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l61.130"></a><span id="l61.130" class="difflineminus">-  </span>
<a href="#l61.131"></a><span id="l61.131" class="difflineplus">+</span>
<a href="#l61.132"></a><span id="l61.132">   static void SlotStrongRowProbeMap(morkRowProbeMap* me,</span>
<a href="#l61.133"></a><span id="l61.133">     morkEnv* ev, morkRowProbeMap** ioSlot)</span>
<a href="#l61.134"></a><span id="l61.134">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l61.135"></a><span id="l61.135"> };</span>
<a href="#l61.136"></a><span id="l61.136"> </span>
<a href="#l61.137"></a><span id="l61.137"> class morkRowProbeMapIter: public morkProbeMapIter{ // typesafe wrapper class</span>
<a href="#l61.138"></a><span id="l61.138"> </span>
<a href="#l61.139"></a><span id="l61.139"> public:</span>
<a href="#l61.140"></a><span id="l61.140">   morkRowProbeMapIter(morkEnv* ev, morkRowProbeMap* ioMap)</span>
<a href="#l61.141"></a><span id="l61.141">   : morkProbeMapIter(ev, ioMap) { }</span>
<a href="#l61.142"></a><span id="l61.142" class="difflineminus">- </span>
<a href="#l61.143"></a><span id="l61.143" class="difflineplus">+</span>
<a href="#l61.144"></a><span id="l61.144">   morkRowProbeMapIter( ) : morkProbeMapIter()  { }</span>
<a href="#l61.145"></a><span id="l61.145">   void InitRowMapIter(morkEnv* ev, morkRowProbeMap* ioMap)</span>
<a href="#l61.146"></a><span id="l61.146">   { this-&gt;InitMapIter(ev, ioMap); }</span>
<a href="#l61.147"></a><span id="l61.147" class="difflineminus">-   </span>
<a href="#l61.148"></a><span id="l61.148" class="difflineplus">+</span>
<a href="#l61.149"></a><span id="l61.149">   mork_change* FirstRow(morkEnv* ev, morkRow** outRowPtr)</span>
<a href="#l61.150"></a><span id="l61.150">   { return this-&gt;First(ev, outRowPtr, /*val*/ (void*) 0); }</span>
<a href="#l61.151"></a><span id="l61.151" class="difflineminus">-  </span>
<a href="#l61.152"></a><span id="l61.152" class="difflineplus">+</span>
<a href="#l61.153"></a><span id="l61.153">   mork_change* NextRow(morkEnv* ev, morkRow** outRowPtr)</span>
<a href="#l61.154"></a><span id="l61.154">   { return this-&gt;Next(ev, outRowPtr, /*val*/ (void*) 0); }</span>
<a href="#l61.155"></a><span id="l61.155" class="difflineminus">-  </span>
<a href="#l61.156"></a><span id="l61.156" class="difflineplus">+</span>
<a href="#l61.157"></a><span id="l61.157">   mork_change* HereRow(morkEnv* ev, morkRow** outRowPtr)</span>
<a href="#l61.158"></a><span id="l61.158">   { return this-&gt;Here(ev, outRowPtr, /*val*/ (void*) 0); }</span>
<a href="#l61.159"></a><span id="l61.159" class="difflineminus">-  </span>
<a href="#l61.160"></a><span id="l61.160" class="difflineplus">+</span>
<a href="#l61.161"></a><span id="l61.161">   mork_change* CutHereRow(morkEnv* ev, morkRow** outRowPtr)</span>
<a href="#l61.162"></a><span id="l61.162">   { return this-&gt;CutHere(ev, outRowPtr, /*val*/ (void*) 0); }</span>
<a href="#l61.163"></a><span id="l61.163"> };</span>
<a href="#l61.164"></a><span id="l61.164"> </span>
<a href="#l61.165"></a><span id="l61.165"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l61.166"></a><span id="l61.166"> </span>
<a href="#l61.167"></a><span id="l61.167"> #endif /* _MORKROWMAP_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l62.1"></a><span id="l62.1" class="difflineminus">--- a/db/mork/src/morkRowObject.cpp</span>
<a href="#l62.2"></a><span id="l62.2" class="difflineplus">+++ b/db/mork/src/morkRowObject.cpp</span>
<a href="#l62.3"></a><span id="l62.3" class="difflineat">@@ -36,17 +36,17 @@</span>
<a href="#l62.4"></a><span id="l62.4"> #endif</span>
<a href="#l62.5"></a><span id="l62.5"> </span>
<a href="#l62.6"></a><span id="l62.6"> #ifndef _MORKROW_</span>
<a href="#l62.7"></a><span id="l62.7"> #include &quot;morkRow.h&quot;</span>
<a href="#l62.8"></a><span id="l62.8"> #endif</span>
<a href="#l62.9"></a><span id="l62.9"> </span>
<a href="#l62.10"></a><span id="l62.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l62.11"></a><span id="l62.11"> </span>
<a href="#l62.12"></a><span id="l62.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l62.13"></a><span id="l62.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l62.14"></a><span id="l62.14"> // { ===== begin morkNode interface =====</span>
<a href="#l62.15"></a><span id="l62.15"> </span>
<a href="#l62.16"></a><span id="l62.16"> /*public virtual*/ void</span>
<a href="#l62.17"></a><span id="l62.17"> morkRowObject::CloseMorkNode(morkEnv* ev) // CloseRowObject() only if open</span>
<a href="#l62.18"></a><span id="l62.18"> {</span>
<a href="#l62.19"></a><span id="l62.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l62.20"></a><span id="l62.20">   {</span>
<a href="#l62.21"></a><span id="l62.21">     this-&gt;MarkClosing();</span>
<a href="#l62.22"></a><span id="l62.22" class="difflineat">@@ -71,17 +71,17 @@ morkRowObject::morkRowObject(morkEnv* ev</span>
<a href="#l62.23"></a><span id="l62.23"> , mRowObject_Store( 0 )</span>
<a href="#l62.24"></a><span id="l62.24"> {</span>
<a href="#l62.25"></a><span id="l62.25">   if ( ev-&gt;Good() )</span>
<a href="#l62.26"></a><span id="l62.26">   {</span>
<a href="#l62.27"></a><span id="l62.27">     if ( ioRow &amp;&amp; ioStore )</span>
<a href="#l62.28"></a><span id="l62.28">     {</span>
<a href="#l62.29"></a><span id="l62.29">       mRowObject_Row = ioRow;</span>
<a href="#l62.30"></a><span id="l62.30">       mRowObject_Store = ioStore; // morkRowObjects don't ref-cnt the owning store.</span>
<a href="#l62.31"></a><span id="l62.31" class="difflineminus">-      </span>
<a href="#l62.32"></a><span id="l62.32" class="difflineplus">+</span>
<a href="#l62.33"></a><span id="l62.33">       if ( ev-&gt;Good() )</span>
<a href="#l62.34"></a><span id="l62.34">         mNode_Derived = morkDerived_kRowObject;</span>
<a href="#l62.35"></a><span id="l62.35">     }</span>
<a href="#l62.36"></a><span id="l62.36">     else</span>
<a href="#l62.37"></a><span id="l62.37">       ev-&gt;NilPointerError();</span>
<a href="#l62.38"></a><span id="l62.38">   }</span>
<a href="#l62.39"></a><span id="l62.39"> }</span>
<a href="#l62.40"></a><span id="l62.40"> </span>
<a href="#l62.41"></a><span id="l62.41" class="difflineat">@@ -129,22 +129,22 @@ morkRowObject::GetPort(nsIMdbEnv* mev,</span>
<a href="#l62.42"></a><span id="l62.42">     if ( rowSpace &amp;&amp; rowSpace-&gt;mSpace_Store )</span>
<a href="#l62.43"></a><span id="l62.43">     {</span>
<a href="#l62.44"></a><span id="l62.44">       morkStore* store = mRowObject_Row-&gt;GetRowSpaceStore(ev);</span>
<a href="#l62.45"></a><span id="l62.45">       if ( store )</span>
<a href="#l62.46"></a><span id="l62.46">         outPort = store-&gt;AcquireStoreHandle(ev);</span>
<a href="#l62.47"></a><span id="l62.47">     }</span>
<a href="#l62.48"></a><span id="l62.48">     else</span>
<a href="#l62.49"></a><span id="l62.49">       ev-&gt;NilPointerError();</span>
<a href="#l62.50"></a><span id="l62.50" class="difflineminus">-      </span>
<a href="#l62.51"></a><span id="l62.51" class="difflineplus">+</span>
<a href="#l62.52"></a><span id="l62.52">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.53"></a><span id="l62.53">   }</span>
<a href="#l62.54"></a><span id="l62.54">   if ( acqPort )</span>
<a href="#l62.55"></a><span id="l62.55">     *acqPort = outPort;</span>
<a href="#l62.56"></a><span id="l62.56" class="difflineminus">-    </span>
<a href="#l62.57"></a><span id="l62.57" class="difflineplus">+</span>
<a href="#l62.58"></a><span id="l62.58">   return outErr;</span>
<a href="#l62.59"></a><span id="l62.59"> }</span>
<a href="#l62.60"></a><span id="l62.60"> // } ----- end attribute methods -----</span>
<a href="#l62.61"></a><span id="l62.61"> </span>
<a href="#l62.62"></a><span id="l62.62"> // { ----- begin cursor methods -----</span>
<a href="#l62.63"></a><span id="l62.63"> NS_IMETHODIMP</span>
<a href="#l62.64"></a><span id="l62.64"> morkRowObject::GetCursor( // make a cursor starting iter at inMemberPos</span>
<a href="#l62.65"></a><span id="l62.65">   nsIMdbEnv* mev, // context</span>
<a href="#l62.66"></a><span id="l62.66" class="difflineat">@@ -228,17 +228,17 @@ morkRowObject::AddColumn( // make sure a</span>
<a href="#l62.67"></a><span id="l62.67">   const mdbYarn* inYarn)</span>
<a href="#l62.68"></a><span id="l62.68"> {</span>
<a href="#l62.69"></a><span id="l62.69">   nsresult outErr = NS_ERROR_FAILURE;</span>
<a href="#l62.70"></a><span id="l62.70">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l62.71"></a><span id="l62.71">   if ( ev )</span>
<a href="#l62.72"></a><span id="l62.72">   {</span>
<a href="#l62.73"></a><span id="l62.73">     if ( mRowObject_Store &amp;&amp; mRowObject_Row)</span>
<a href="#l62.74"></a><span id="l62.74">       mRowObject_Row-&gt;AddColumn(ev, inColumn, inYarn, mRowObject_Store);</span>
<a href="#l62.75"></a><span id="l62.75" class="difflineminus">-      </span>
<a href="#l62.76"></a><span id="l62.76" class="difflineplus">+</span>
<a href="#l62.77"></a><span id="l62.77">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.78"></a><span id="l62.78">   }</span>
<a href="#l62.79"></a><span id="l62.79">   return outErr;</span>
<a href="#l62.80"></a><span id="l62.80"> }</span>
<a href="#l62.81"></a><span id="l62.81"> </span>
<a href="#l62.82"></a><span id="l62.82"> NS_IMETHODIMP</span>
<a href="#l62.83"></a><span id="l62.83"> morkRowObject::CutColumn( // make sure a column is absent from the row</span>
<a href="#l62.84"></a><span id="l62.84">   nsIMdbEnv* mev, // context</span>
<a href="#l62.85"></a><span id="l62.85" class="difflineat">@@ -291,22 +291,22 @@ morkRowObject::NewCell( // get cell for </span>
<a href="#l62.86"></a><span id="l62.86">         yarn.mYarn_Size = 0;</span>
<a href="#l62.87"></a><span id="l62.87">         yarn.mYarn_More = 0;</span>
<a href="#l62.88"></a><span id="l62.88">         yarn.mYarn_Form = 0;</span>
<a href="#l62.89"></a><span id="l62.89">         yarn.mYarn_Grow = 0;</span>
<a href="#l62.90"></a><span id="l62.90">         AddColumn(ev, inColumn, &amp;yarn);</span>
<a href="#l62.91"></a><span id="l62.91">         GetCell(mev, inColumn, acqCell);</span>
<a href="#l62.92"></a><span id="l62.92">       }</span>
<a href="#l62.93"></a><span id="l62.93">     }</span>
<a href="#l62.94"></a><span id="l62.94" class="difflineminus">-      </span>
<a href="#l62.95"></a><span id="l62.95" class="difflineplus">+</span>
<a href="#l62.96"></a><span id="l62.96">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.97"></a><span id="l62.97">   }</span>
<a href="#l62.98"></a><span id="l62.98">   return outErr;</span>
<a href="#l62.99"></a><span id="l62.99"> }</span>
<a href="#l62.100"></a><span id="l62.100" class="difflineminus">-  </span>
<a href="#l62.101"></a><span id="l62.101" class="difflineplus">+</span>
<a href="#l62.102"></a><span id="l62.102"> NS_IMETHODIMP</span>
<a href="#l62.103"></a><span id="l62.103"> morkRowObject::AddCell( // copy a cell from another row to this row</span>
<a href="#l62.104"></a><span id="l62.104">   nsIMdbEnv* mev, // context</span>
<a href="#l62.105"></a><span id="l62.105">   const nsIMdbCell* inCell)</span>
<a href="#l62.106"></a><span id="l62.106"> {</span>
<a href="#l62.107"></a><span id="l62.107">   nsresult outErr = NS_OK;</span>
<a href="#l62.108"></a><span id="l62.108">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l62.109"></a><span id="l62.109">   if ( ev )</span>
<a href="#l62.110"></a><span id="l62.110" class="difflineat">@@ -342,17 +342,17 @@ morkRowObject::AddCell( // copy a cell f</span>
<a href="#l62.111"></a><span id="l62.111">       else</span>
<a href="#l62.112"></a><span id="l62.112">         ev-&gt;NilPointerError();</span>
<a href="#l62.113"></a><span id="l62.113">     }</span>
<a href="#l62.114"></a><span id="l62.114"> </span>
<a href="#l62.115"></a><span id="l62.115">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.116"></a><span id="l62.116">   }</span>
<a href="#l62.117"></a><span id="l62.117">   return outErr;</span>
<a href="#l62.118"></a><span id="l62.118"> }</span>
<a href="#l62.119"></a><span id="l62.119" class="difflineminus">-  </span>
<a href="#l62.120"></a><span id="l62.120" class="difflineplus">+</span>
<a href="#l62.121"></a><span id="l62.121"> NS_IMETHODIMP</span>
<a href="#l62.122"></a><span id="l62.122"> morkRowObject::GetCell( // find a cell in this row</span>
<a href="#l62.123"></a><span id="l62.123">   nsIMdbEnv* mev, // context</span>
<a href="#l62.124"></a><span id="l62.124">   mdb_column inColumn, // column to find</span>
<a href="#l62.125"></a><span id="l62.125">   nsIMdbCell** acqCell)</span>
<a href="#l62.126"></a><span id="l62.126"> {</span>
<a href="#l62.127"></a><span id="l62.127">   nsresult outErr = NS_OK;</span>
<a href="#l62.128"></a><span id="l62.128">   nsIMdbCell* outCell = 0;</span>
<a href="#l62.129"></a><span id="l62.129" class="difflineat">@@ -366,24 +366,24 @@ morkRowObject::GetCell( // find a cell i</span>
<a href="#l62.130"></a><span id="l62.130">       morkCell* cell = mRowObject_Row-&gt;GetCell(ev, inColumn, &amp;pos);</span>
<a href="#l62.131"></a><span id="l62.131">       if ( cell )</span>
<a href="#l62.132"></a><span id="l62.132">       {</span>
<a href="#l62.133"></a><span id="l62.133">         outCell = mRowObject_Row-&gt;AcquireCellHandle(ev, cell, inColumn, pos);</span>
<a href="#l62.134"></a><span id="l62.134">       }</span>
<a href="#l62.135"></a><span id="l62.135">     }</span>
<a href="#l62.136"></a><span id="l62.136">     else</span>
<a href="#l62.137"></a><span id="l62.137">       mRowObject_Row-&gt;ZeroColumnError(ev);</span>
<a href="#l62.138"></a><span id="l62.138" class="difflineminus">-      </span>
<a href="#l62.139"></a><span id="l62.139" class="difflineplus">+</span>
<a href="#l62.140"></a><span id="l62.140">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.141"></a><span id="l62.141">   }</span>
<a href="#l62.142"></a><span id="l62.142">   if ( acqCell )</span>
<a href="#l62.143"></a><span id="l62.143">     *acqCell = outCell;</span>
<a href="#l62.144"></a><span id="l62.144">   return outErr;</span>
<a href="#l62.145"></a><span id="l62.145"> }</span>
<a href="#l62.146"></a><span id="l62.146" class="difflineminus">-  </span>
<a href="#l62.147"></a><span id="l62.147" class="difflineplus">+</span>
<a href="#l62.148"></a><span id="l62.148"> NS_IMETHODIMP</span>
<a href="#l62.149"></a><span id="l62.149"> morkRowObject::EmptyAllCells( // make all cells in row empty of content</span>
<a href="#l62.150"></a><span id="l62.150">   nsIMdbEnv* mev)</span>
<a href="#l62.151"></a><span id="l62.151"> {</span>
<a href="#l62.152"></a><span id="l62.152">   nsresult outErr = NS_OK;</span>
<a href="#l62.153"></a><span id="l62.153">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l62.154"></a><span id="l62.154">   if ( ev )</span>
<a href="#l62.155"></a><span id="l62.155">   {</span>
<a href="#l62.156"></a><span id="l62.156" class="difflineat">@@ -408,17 +408,17 @@ morkRowObject::AddRow( // add all cells </span>
<a href="#l62.157"></a><span id="l62.157"> //    if ( unsafeSource-&gt;CanUseRow(mev, morkBool_kFalse, &amp;outErr, &amp;source) )</span>
<a href="#l62.158"></a><span id="l62.158">     {</span>
<a href="#l62.159"></a><span id="l62.159">       mRowObject_Row-&gt;AddRow(ev, unsafeSource);</span>
<a href="#l62.160"></a><span id="l62.160">     }</span>
<a href="#l62.161"></a><span id="l62.161">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.162"></a><span id="l62.162">   }</span>
<a href="#l62.163"></a><span id="l62.163">   return outErr;</span>
<a href="#l62.164"></a><span id="l62.164"> }</span>
<a href="#l62.165"></a><span id="l62.165" class="difflineminus">-  </span>
<a href="#l62.166"></a><span id="l62.166" class="difflineplus">+</span>
<a href="#l62.167"></a><span id="l62.167"> NS_IMETHODIMP</span>
<a href="#l62.168"></a><span id="l62.168"> morkRowObject::SetRow( // make exact duplicate of another row</span>
<a href="#l62.169"></a><span id="l62.169">   nsIMdbEnv* mev, // context</span>
<a href="#l62.170"></a><span id="l62.170">   nsIMdbRow* ioSourceRow)</span>
<a href="#l62.171"></a><span id="l62.171"> {</span>
<a href="#l62.172"></a><span id="l62.172">   nsresult outErr = NS_OK;</span>
<a href="#l62.173"></a><span id="l62.173">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l62.174"></a><span id="l62.174">   if ( ev )</span>
<a href="#l62.175"></a><span id="l62.175" class="difflineat">@@ -443,39 +443,39 @@ morkRowObject::SetCellYarn( // synonym f</span>
<a href="#l62.176"></a><span id="l62.176">   const mdbYarn* inYarn)</span>
<a href="#l62.177"></a><span id="l62.177"> {</span>
<a href="#l62.178"></a><span id="l62.178">   nsresult outErr = NS_OK;</span>
<a href="#l62.179"></a><span id="l62.179">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l62.180"></a><span id="l62.180">   if ( ev )</span>
<a href="#l62.181"></a><span id="l62.181">   {</span>
<a href="#l62.182"></a><span id="l62.182">     if ( mRowObject_Store )</span>
<a href="#l62.183"></a><span id="l62.183">       AddColumn(ev, inColumn, inYarn);</span>
<a href="#l62.184"></a><span id="l62.184" class="difflineminus">-      </span>
<a href="#l62.185"></a><span id="l62.185" class="difflineplus">+</span>
<a href="#l62.186"></a><span id="l62.186">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.187"></a><span id="l62.187">   }</span>
<a href="#l62.188"></a><span id="l62.188">   return outErr;</span>
<a href="#l62.189"></a><span id="l62.189"> }</span>
<a href="#l62.190"></a><span id="l62.190"> NS_IMETHODIMP</span>
<a href="#l62.191"></a><span id="l62.191"> morkRowObject::GetCellYarn(</span>
<a href="#l62.192"></a><span id="l62.192">   nsIMdbEnv* mev, // context</span>
<a href="#l62.193"></a><span id="l62.193" class="difflineminus">-  mdb_column inColumn, // column to read </span>
<a href="#l62.194"></a><span id="l62.194" class="difflineminus">-  mdbYarn* outYarn)  // writes some yarn slots </span>
<a href="#l62.195"></a><span id="l62.195" class="difflineplus">+  mdb_column inColumn, // column to read</span>
<a href="#l62.196"></a><span id="l62.196" class="difflineplus">+  mdbYarn* outYarn)  // writes some yarn slots</span>
<a href="#l62.197"></a><span id="l62.197"> // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l62.198"></a><span id="l62.198"> {</span>
<a href="#l62.199"></a><span id="l62.199">   nsresult outErr = NS_OK;</span>
<a href="#l62.200"></a><span id="l62.200">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l62.201"></a><span id="l62.201">   if ( ev )</span>
<a href="#l62.202"></a><span id="l62.202">   {</span>
<a href="#l62.203"></a><span id="l62.203">     if ( mRowObject_Store &amp;&amp; mRowObject_Row)</span>
<a href="#l62.204"></a><span id="l62.204">     {</span>
<a href="#l62.205"></a><span id="l62.205">       morkAtom* atom = mRowObject_Row-&gt;GetColumnAtom(ev, inColumn);</span>
<a href="#l62.206"></a><span id="l62.206">       atom-&gt;GetYarn(outYarn);</span>
<a href="#l62.207"></a><span id="l62.207">       // note nil atom works and sets yarn correctly</span>
<a href="#l62.208"></a><span id="l62.208">     }</span>
<a href="#l62.209"></a><span id="l62.209" class="difflineminus">-      </span>
<a href="#l62.210"></a><span id="l62.210" class="difflineplus">+</span>
<a href="#l62.211"></a><span id="l62.211">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.212"></a><span id="l62.212">   }</span>
<a href="#l62.213"></a><span id="l62.213">   return outErr;</span>
<a href="#l62.214"></a><span id="l62.214"> }</span>
<a href="#l62.215"></a><span id="l62.215"> </span>
<a href="#l62.216"></a><span id="l62.216"> NS_IMETHODIMP</span>
<a href="#l62.217"></a><span id="l62.217"> morkRowObject::AliasCellYarn(</span>
<a href="#l62.218"></a><span id="l62.218">   nsIMdbEnv* mev, // context</span>
<a href="#l62.219"></a><span id="l62.219" class="difflineat">@@ -495,17 +495,17 @@ morkRowObject::AliasCellYarn(</span>
<a href="#l62.220"></a><span id="l62.220">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.221"></a><span id="l62.221">   }</span>
<a href="#l62.222"></a><span id="l62.222">   return outErr;</span>
<a href="#l62.223"></a><span id="l62.223"> }</span>
<a href="#l62.224"></a><span id="l62.224"> </span>
<a href="#l62.225"></a><span id="l62.225"> NS_IMETHODIMP</span>
<a href="#l62.226"></a><span id="l62.226"> morkRowObject::NextCellYarn(nsIMdbEnv* mev, // iterative version of GetCellYarn()</span>
<a href="#l62.227"></a><span id="l62.227">   mdb_column* ioColumn, // next column to read</span>
<a href="#l62.228"></a><span id="l62.228" class="difflineminus">-  mdbYarn* outYarn)  // writes some yarn slots </span>
<a href="#l62.229"></a><span id="l62.229" class="difflineplus">+  mdbYarn* outYarn)  // writes some yarn slots</span>
<a href="#l62.230"></a><span id="l62.230"> // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l62.231"></a><span id="l62.231"> //</span>
<a href="#l62.232"></a><span id="l62.232"> // The ioColumn argument is an inout parameter which initially contains the</span>
<a href="#l62.233"></a><span id="l62.233"> // last column accessed and returns the next column corresponding to the</span>
<a href="#l62.234"></a><span id="l62.234"> // content read into the yarn.  Callers should start with a zero column</span>
<a href="#l62.235"></a><span id="l62.235"> // value to say 'no previous column', which causes the first column to be</span>
<a href="#l62.236"></a><span id="l62.236"> // read.  Then the value returned in ioColumn is perfect for the next call</span>
<a href="#l62.237"></a><span id="l62.237"> // to NextCellYarn(), since it will then be the previous column accessed.</span>
<a href="#l62.238"></a><span id="l62.238" class="difflineat">@@ -515,17 +515,17 @@ morkRowObject::NextCellYarn(nsIMdbEnv* m</span>
<a href="#l62.239"></a><span id="l62.239"> // So iterating over cells starts and ends with a zero column token.</span>
<a href="#l62.240"></a><span id="l62.240"> {</span>
<a href="#l62.241"></a><span id="l62.241">   nsresult outErr = NS_OK;</span>
<a href="#l62.242"></a><span id="l62.242">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l62.243"></a><span id="l62.243">   if ( ev )</span>
<a href="#l62.244"></a><span id="l62.244">   {</span>
<a href="#l62.245"></a><span id="l62.245">     if ( mRowObject_Store &amp;&amp; mRowObject_Row)</span>
<a href="#l62.246"></a><span id="l62.246">       mRowObject_Row-&gt;NextColumn(ev, ioColumn, outYarn);</span>
<a href="#l62.247"></a><span id="l62.247" class="difflineminus">-      </span>
<a href="#l62.248"></a><span id="l62.248" class="difflineplus">+</span>
<a href="#l62.249"></a><span id="l62.249">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.250"></a><span id="l62.250">   }</span>
<a href="#l62.251"></a><span id="l62.251">   return outErr;</span>
<a href="#l62.252"></a><span id="l62.252"> }</span>
<a href="#l62.253"></a><span id="l62.253"> </span>
<a href="#l62.254"></a><span id="l62.254"> NS_IMETHODIMP</span>
<a href="#l62.255"></a><span id="l62.255"> morkRowObject::SeekCellYarn( // resembles nsIMdbRowCellCursor::SeekCell()</span>
<a href="#l62.256"></a><span id="l62.256">   nsIMdbEnv* mev, // context</span>
<a href="#l62.257"></a><span id="l62.257" class="difflineat">@@ -539,17 +539,17 @@ morkRowObject::SeekCellYarn( // resemble</span>
<a href="#l62.258"></a><span id="l62.258"> </span>
<a href="#l62.259"></a><span id="l62.259"> {</span>
<a href="#l62.260"></a><span id="l62.260">   nsresult outErr = NS_OK;</span>
<a href="#l62.261"></a><span id="l62.261">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l62.262"></a><span id="l62.262">   if ( ev )</span>
<a href="#l62.263"></a><span id="l62.263">   {</span>
<a href="#l62.264"></a><span id="l62.264">     if ( mRowObject_Store &amp;&amp; mRowObject_Row)</span>
<a href="#l62.265"></a><span id="l62.265">       mRowObject_Row-&gt;SeekColumn(ev, inPos, outColumn, outYarn);</span>
<a href="#l62.266"></a><span id="l62.266" class="difflineminus">-      </span>
<a href="#l62.267"></a><span id="l62.267" class="difflineplus">+</span>
<a href="#l62.268"></a><span id="l62.268">     outErr = ev-&gt;AsErr();</span>
<a href="#l62.269"></a><span id="l62.269">   }</span>
<a href="#l62.270"></a><span id="l62.270">   return outErr;</span>
<a href="#l62.271"></a><span id="l62.271"> }</span>
<a href="#l62.272"></a><span id="l62.272"> </span>
<a href="#l62.273"></a><span id="l62.273"> // } ----- end blob methods -----</span>
<a href="#l62.274"></a><span id="l62.274"> </span>
<a href="#l62.275"></a><span id="l62.275"> </span>
<a href="#l62.276"></a><span id="l62.276" class="difflineat">@@ -568,29 +568,29 @@ morkRowObject::CloseRowObject(morkEnv* e</span>
<a href="#l62.277"></a><span id="l62.277">       this-&gt;MarkShut();</span>
<a href="#l62.278"></a><span id="l62.278"> </span>
<a href="#l62.279"></a><span id="l62.279">       if ( row )</span>
<a href="#l62.280"></a><span id="l62.280">       {</span>
<a href="#l62.281"></a><span id="l62.281">         MORK_ASSERT(row-&gt;mRow_Object == this);</span>
<a href="#l62.282"></a><span id="l62.282">         if ( row-&gt;mRow_Object == this )</span>
<a href="#l62.283"></a><span id="l62.283">         {</span>
<a href="#l62.284"></a><span id="l62.284">           row-&gt;mRow_Object = 0; // just nil this slot -- cut ref down below</span>
<a href="#l62.285"></a><span id="l62.285" class="difflineminus">-          </span>
<a href="#l62.286"></a><span id="l62.286" class="difflineplus">+</span>
<a href="#l62.287"></a><span id="l62.287">           mRowObject_Store = 0; // morkRowObjects don't ref-cnt the owning store.</span>
<a href="#l62.288"></a><span id="l62.288" class="difflineminus">-            </span>
<a href="#l62.289"></a><span id="l62.289" class="difflineplus">+</span>
<a href="#l62.290"></a><span id="l62.290">           this-&gt;CutWeakRef(ev-&gt;AsMdbEnv()); // do last, because it might self destroy</span>
<a href="#l62.291"></a><span id="l62.291">         }</span>
<a href="#l62.292"></a><span id="l62.292">       }</span>
<a href="#l62.293"></a><span id="l62.293">     }</span>
<a href="#l62.294"></a><span id="l62.294">     else</span>
<a href="#l62.295"></a><span id="l62.295">       this-&gt;NonNodeError(ev);</span>
<a href="#l62.296"></a><span id="l62.296"> }</span>
<a href="#l62.297"></a><span id="l62.297"> </span>
<a href="#l62.298"></a><span id="l62.298"> // } ===== end morkNode methods =====</span>
<a href="#l62.299"></a><span id="l62.299" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l62.300"></a><span id="l62.300" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l62.301"></a><span id="l62.301"> </span>
<a href="#l62.302"></a><span id="l62.302"> /*static*/ void</span>
<a href="#l62.303"></a><span id="l62.303"> morkRowObject::NonRowObjectTypeError(morkEnv* ev)</span>
<a href="#l62.304"></a><span id="l62.304"> {</span>
<a href="#l62.305"></a><span id="l62.305">   ev-&gt;NewError(&quot;non morkRowObject&quot;);</span>
<a href="#l62.306"></a><span id="l62.306"> }</span>
<a href="#l62.307"></a><span id="l62.307"> </span>
<a href="#l62.308"></a><span id="l62.308"> /*static*/ void</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l63.1"></a><span id="l63.1" class="difflineminus">--- a/db/mork/src/morkRowObject.h</span>
<a href="#l63.2"></a><span id="l63.2" class="difflineplus">+++ b/db/mork/src/morkRowObject.h</span>
<a href="#l63.3"></a><span id="l63.3" class="difflineat">@@ -18,20 +18,20 @@</span>
<a href="#l63.4"></a><span id="l63.4"> </span>
<a href="#l63.5"></a><span id="l63.5"> class nsIMdbRow;</span>
<a href="#l63.6"></a><span id="l63.6"> #define morkDerived_kRowObject  /*i*/ 0x724F /* ascii 'rO' */</span>
<a href="#l63.7"></a><span id="l63.7"> </span>
<a href="#l63.8"></a><span id="l63.8"> class morkRowObject : public morkObject, public nsIMdbRow  { //</span>
<a href="#l63.9"></a><span id="l63.9"> </span>
<a href="#l63.10"></a><span id="l63.10"> public: // state is public because the entire Mork system is private</span>
<a href="#l63.11"></a><span id="l63.11">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l63.12"></a><span id="l63.12" class="difflineminus">-  </span>
<a href="#l63.13"></a><span id="l63.13" class="difflineplus">+</span>
<a href="#l63.14"></a><span id="l63.14">   morkRow*    mRowObject_Row;     // non-refcounted alias to morkRow</span>
<a href="#l63.15"></a><span id="l63.15">   morkStore*  mRowObject_Store;   // non-refcounted ptr to store containing row</span>
<a href="#l63.16"></a><span id="l63.16" class="difflineminus">-  </span>
<a href="#l63.17"></a><span id="l63.17" class="difflineplus">+</span>
<a href="#l63.18"></a><span id="l63.18"> // { ===== begin morkNode interface =====</span>
<a href="#l63.19"></a><span id="l63.19"> public: // morkNode virtual methods</span>
<a href="#l63.20"></a><span id="l63.20">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseRowObject() only if open</span>
<a href="#l63.21"></a><span id="l63.21"> </span>
<a href="#l63.22"></a><span id="l63.22"> public: // morkRowObject construction &amp; destruction</span>
<a href="#l63.23"></a><span id="l63.23">   morkRowObject(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l63.24"></a><span id="l63.24">     nsIMdbHeap* ioHeap, morkRow* ioRow, morkStore* ioStore);</span>
<a href="#l63.25"></a><span id="l63.25">   void CloseRowObject(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l63.26"></a><span id="l63.26" class="difflineat">@@ -115,34 +115,34 @@ public: // morkRowObject construction &amp; </span>
<a href="#l63.27"></a><span id="l63.27">     nsIMdbEnv* ev, // context</span>
<a href="#l63.28"></a><span id="l63.28">     nsIMdbRow* ioSourceRow) override; // row to union with</span>
<a href="#l63.29"></a><span id="l63.29"> </span>
<a href="#l63.30"></a><span id="l63.30">   NS_IMETHOD SetRow( // make exact duplicate of another row</span>
<a href="#l63.31"></a><span id="l63.31">     nsIMdbEnv* ev, // context</span>
<a href="#l63.32"></a><span id="l63.32">     nsIMdbRow* ioSourceRow) override; // row to duplicate</span>
<a href="#l63.33"></a><span id="l63.33">   // } ----- end row methods -----</span>
<a href="#l63.34"></a><span id="l63.34"> </span>
<a href="#l63.35"></a><span id="l63.35" class="difflineminus">-  // { ----- begin blob methods -----  </span>
<a href="#l63.36"></a><span id="l63.36" class="difflineplus">+  // { ----- begin blob methods -----</span>
<a href="#l63.37"></a><span id="l63.37">   NS_IMETHOD SetCellYarn(nsIMdbEnv* ev, // synonym for AddColumn()</span>
<a href="#l63.38"></a><span id="l63.38">     mdb_column inColumn, // column to write</span>
<a href="#l63.39"></a><span id="l63.39">     const mdbYarn* inYarn) override;   // reads from yarn slots</span>
<a href="#l63.40"></a><span id="l63.40">   // make this text object contain content from the yarn's buffer</span>
<a href="#l63.41"></a><span id="l63.41"> </span>
<a href="#l63.42"></a><span id="l63.42" class="difflineminus">-  NS_IMETHOD GetCellYarn(nsIMdbEnv* ev, </span>
<a href="#l63.43"></a><span id="l63.43" class="difflineminus">-    mdb_column inColumn, // column to read </span>
<a href="#l63.44"></a><span id="l63.44" class="difflineminus">-    mdbYarn* outYarn) override;  // writes some yarn slots </span>
<a href="#l63.45"></a><span id="l63.45" class="difflineplus">+  NS_IMETHOD GetCellYarn(nsIMdbEnv* ev,</span>
<a href="#l63.46"></a><span id="l63.46" class="difflineplus">+    mdb_column inColumn, // column to read</span>
<a href="#l63.47"></a><span id="l63.47" class="difflineplus">+    mdbYarn* outYarn) override;  // writes some yarn slots</span>
<a href="#l63.48"></a><span id="l63.48">   // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l63.49"></a><span id="l63.49"> </span>
<a href="#l63.50"></a><span id="l63.50" class="difflineminus">-  NS_IMETHOD AliasCellYarn(nsIMdbEnv* ev, </span>
<a href="#l63.51"></a><span id="l63.51" class="difflineplus">+  NS_IMETHOD AliasCellYarn(nsIMdbEnv* ev,</span>
<a href="#l63.52"></a><span id="l63.52">     mdb_column inColumn, // column to alias</span>
<a href="#l63.53"></a><span id="l63.53">     mdbYarn* outYarn) override; // writes ALL yarn slots</span>
<a href="#l63.54"></a><span id="l63.54"> </span>
<a href="#l63.55"></a><span id="l63.55">   NS_IMETHOD NextCellYarn(nsIMdbEnv* ev, // iterative version of GetCellYarn()</span>
<a href="#l63.56"></a><span id="l63.56">     mdb_column* ioColumn, // next column to read</span>
<a href="#l63.57"></a><span id="l63.57" class="difflineminus">-    mdbYarn* outYarn) override;  // writes some yarn slots </span>
<a href="#l63.58"></a><span id="l63.58" class="difflineplus">+    mdbYarn* outYarn) override;  // writes some yarn slots</span>
<a href="#l63.59"></a><span id="l63.59">   // copy content into the yarn buffer, and update mYarn_Fill and mYarn_Form</span>
<a href="#l63.60"></a><span id="l63.60">   //</span>
<a href="#l63.61"></a><span id="l63.61">   // The ioColumn argument is an inout parameter which initially contains the</span>
<a href="#l63.62"></a><span id="l63.62">   // last column accessed and returns the next column corresponding to the</span>
<a href="#l63.63"></a><span id="l63.63">   // content read into the yarn.  Callers should start with a zero column</span>
<a href="#l63.64"></a><span id="l63.64">   // value to say 'no previous column', which causes the first column to be</span>
<a href="#l63.65"></a><span id="l63.65">   // read.  Then the value returned in ioColumn is perfect for the next call</span>
<a href="#l63.66"></a><span id="l63.66">   // to NextCellYarn(), since it will then be the previous column accessed.</span>
<a href="#l63.67"></a><span id="l63.67" class="difflineat">@@ -179,22 +179,22 @@ public: // typing</span>
<a href="#l63.68"></a><span id="l63.68">   static void NonRowObjectTypeError(morkEnv* ev);</span>
<a href="#l63.69"></a><span id="l63.69">   static void NilRowError(morkEnv* ev);</span>
<a href="#l63.70"></a><span id="l63.70">   static void NilStoreError(morkEnv* ev);</span>
<a href="#l63.71"></a><span id="l63.71">   static void RowObjectRowNotSelfError(morkEnv* ev);</span>
<a href="#l63.72"></a><span id="l63.72"> </span>
<a href="#l63.73"></a><span id="l63.73"> public: // other row node methods</span>
<a href="#l63.74"></a><span id="l63.74"> </span>
<a href="#l63.75"></a><span id="l63.75">   nsIMdbRow* AcquireRowHandle(morkEnv* ev); // mObject_Handle</span>
<a href="#l63.76"></a><span id="l63.76" class="difflineminus">-  </span>
<a href="#l63.77"></a><span id="l63.77" class="difflineplus">+</span>
<a href="#l63.78"></a><span id="l63.78"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l63.79"></a><span id="l63.79">   static void SlotWeakRowObject(morkRowObject* me,</span>
<a href="#l63.80"></a><span id="l63.80">     morkEnv* ev, morkRowObject** ioSlot)</span>
<a href="#l63.81"></a><span id="l63.81">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l63.82"></a><span id="l63.82" class="difflineminus">-  </span>
<a href="#l63.83"></a><span id="l63.83" class="difflineplus">+</span>
<a href="#l63.84"></a><span id="l63.84">   static void SlotStrongRowObject(morkRowObject* me,</span>
<a href="#l63.85"></a><span id="l63.85">     morkEnv* ev, morkRowObject** ioSlot)</span>
<a href="#l63.86"></a><span id="l63.86">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l63.87"></a><span id="l63.87"> };</span>
<a href="#l63.88"></a><span id="l63.88"> </span>
<a href="#l63.89"></a><span id="l63.89"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l63.90"></a><span id="l63.90"> </span>
<a href="#l63.91"></a><span id="l63.91"> #endif /* _MORKROWOBJECT_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l64.1"></a><span id="l64.1" class="difflineminus">--- a/db/mork/src/morkRowSpace.cpp</span>
<a href="#l64.2"></a><span id="l64.2" class="difflineplus">+++ b/db/mork/src/morkRowSpace.cpp</span>
<a href="#l64.3"></a><span id="l64.3" class="difflineat">@@ -60,61 +60,61 @@</span>
<a href="#l64.4"></a><span id="l64.4"> #endif</span>
<a href="#l64.5"></a><span id="l64.5"> </span>
<a href="#l64.6"></a><span id="l64.6"> #ifndef _MORKROWOBJECT_</span>
<a href="#l64.7"></a><span id="l64.7"> #include &quot;morkRowObject.h&quot;</span>
<a href="#l64.8"></a><span id="l64.8"> #endif</span>
<a href="#l64.9"></a><span id="l64.9"> </span>
<a href="#l64.10"></a><span id="l64.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l64.11"></a><span id="l64.11"> </span>
<a href="#l64.12"></a><span id="l64.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l64.13"></a><span id="l64.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l64.14"></a><span id="l64.14"> // { ===== begin morkNode interface =====</span>
<a href="#l64.15"></a><span id="l64.15"> </span>
<a href="#l64.16"></a><span id="l64.16"> /*public virtual*/ void</span>
<a href="#l64.17"></a><span id="l64.17"> morkRowSpace::CloseMorkNode(morkEnv* ev) // CloseRowSpace() only if open</span>
<a href="#l64.18"></a><span id="l64.18"> {</span>
<a href="#l64.19"></a><span id="l64.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l64.20"></a><span id="l64.20">   {</span>
<a href="#l64.21"></a><span id="l64.21">     this-&gt;MarkClosing();</span>
<a href="#l64.22"></a><span id="l64.22">     this-&gt;CloseRowSpace(ev);</span>
<a href="#l64.23"></a><span id="l64.23" class="difflineminus">-    this-&gt;MarkShut();  </span>
<a href="#l64.24"></a><span id="l64.24" class="difflineplus">+    this-&gt;MarkShut();</span>
<a href="#l64.25"></a><span id="l64.25">   }</span>
<a href="#l64.26"></a><span id="l64.26"> }</span>
<a href="#l64.27"></a><span id="l64.27"> </span>
<a href="#l64.28"></a><span id="l64.28"> /*public virtual*/</span>
<a href="#l64.29"></a><span id="l64.29"> morkRowSpace::~morkRowSpace() // assert CloseRowSpace() executed earlier</span>
<a href="#l64.30"></a><span id="l64.30"> {</span>
<a href="#l64.31"></a><span id="l64.31">   MORK_ASSERT(this-&gt;IsShutNode());</span>
<a href="#l64.32"></a><span id="l64.32"> }</span>
<a href="#l64.33"></a><span id="l64.33"> </span>
<a href="#l64.34"></a><span id="l64.34"> /*public non-poly*/</span>
<a href="#l64.35"></a><span id="l64.35" class="difflineminus">-morkRowSpace::morkRowSpace(morkEnv* ev, </span>
<a href="#l64.36"></a><span id="l64.36" class="difflineplus">+morkRowSpace::morkRowSpace(morkEnv* ev,</span>
<a href="#l64.37"></a><span id="l64.37">   const morkUsage&amp; inUsage, mork_scope inScope, morkStore* ioStore,</span>
<a href="#l64.38"></a><span id="l64.38">   nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap)</span>
<a href="#l64.39"></a><span id="l64.39"> : morkSpace(ev, inUsage, inScope, ioStore, ioHeap, ioSlotHeap)</span>
<a href="#l64.40"></a><span id="l64.40"> , mRowSpace_SlotHeap( ioSlotHeap )</span>
<a href="#l64.41"></a><span id="l64.41"> , mRowSpace_Rows(ev, morkUsage::kMember, (nsIMdbHeap*) 0, ioSlotHeap,</span>
<a href="#l64.42"></a><span id="l64.42">   morkRowSpace_kStartRowMapSlotCount)</span>
<a href="#l64.43"></a><span id="l64.43"> , mRowSpace_Tables(ev, morkUsage::kMember, (nsIMdbHeap*) 0, ioSlotHeap)</span>
<a href="#l64.44"></a><span id="l64.44"> , mRowSpace_NextTableId( 1 )</span>
<a href="#l64.45"></a><span id="l64.45"> , mRowSpace_NextRowId( 1 )</span>
<a href="#l64.46"></a><span id="l64.46"> </span>
<a href="#l64.47"></a><span id="l64.47"> , mRowSpace_IndexCount( 0 )</span>
<a href="#l64.48"></a><span id="l64.48"> {</span>
<a href="#l64.49"></a><span id="l64.49">   morkAtomRowMap** cache = mRowSpace_IndexCache;</span>
<a href="#l64.50"></a><span id="l64.50">   morkAtomRowMap** cacheEnd = cache + morkRowSpace_kPrimeCacheSize;</span>
<a href="#l64.51"></a><span id="l64.51">   while ( cache &lt; cacheEnd )</span>
<a href="#l64.52"></a><span id="l64.52">     *cache++ = 0; // put nil into every slot of cache table</span>
<a href="#l64.53"></a><span id="l64.53" class="difflineminus">-    </span>
<a href="#l64.54"></a><span id="l64.54" class="difflineplus">+</span>
<a href="#l64.55"></a><span id="l64.55">   if ( ev-&gt;Good() )</span>
<a href="#l64.56"></a><span id="l64.56">   {</span>
<a href="#l64.57"></a><span id="l64.57">     if ( ioSlotHeap )</span>
<a href="#l64.58"></a><span id="l64.58">     {</span>
<a href="#l64.59"></a><span id="l64.59">       mNode_Derived = morkDerived_kRowSpace;</span>
<a href="#l64.60"></a><span id="l64.60" class="difflineminus">-      </span>
<a href="#l64.61"></a><span id="l64.61" class="difflineplus">+</span>
<a href="#l64.62"></a><span id="l64.62">       // the morkSpace base constructor handles any dirty propagation</span>
<a href="#l64.63"></a><span id="l64.63">     }</span>
<a href="#l64.64"></a><span id="l64.64">     else</span>
<a href="#l64.65"></a><span id="l64.65">       ev-&gt;NilPointerError();</span>
<a href="#l64.66"></a><span id="l64.66">   }</span>
<a href="#l64.67"></a><span id="l64.67"> }</span>
<a href="#l64.68"></a><span id="l64.68"> </span>
<a href="#l64.69"></a><span id="l64.69"> /*public non-poly*/ void</span>
<a href="#l64.70"></a><span id="l64.70" class="difflineat">@@ -125,32 +125,32 @@ morkRowSpace::CloseRowSpace(morkEnv* ev)</span>
<a href="#l64.71"></a><span id="l64.71">       morkAtomRowMap** cache = mRowSpace_IndexCache;</span>
<a href="#l64.72"></a><span id="l64.72">       morkAtomRowMap** cacheEnd = cache + morkRowSpace_kPrimeCacheSize;</span>
<a href="#l64.73"></a><span id="l64.73">       --cache; // prepare for preincrement:</span>
<a href="#l64.74"></a><span id="l64.74">       while ( ++cache &lt; cacheEnd )</span>
<a href="#l64.75"></a><span id="l64.75">       {</span>
<a href="#l64.76"></a><span id="l64.76">         if ( *cache )</span>
<a href="#l64.77"></a><span id="l64.77">           morkAtomRowMap::SlotStrongAtomRowMap(0, ev, cache);</span>
<a href="#l64.78"></a><span id="l64.78">       }</span>
<a href="#l64.79"></a><span id="l64.79" class="difflineminus">-      </span>
<a href="#l64.80"></a><span id="l64.80" class="difflineplus">+</span>
<a href="#l64.81"></a><span id="l64.81">       mRowSpace_Tables.CloseMorkNode(ev);</span>
<a href="#l64.82"></a><span id="l64.82" class="difflineminus">-      </span>
<a href="#l64.83"></a><span id="l64.83" class="difflineplus">+</span>
<a href="#l64.84"></a><span id="l64.84">       morkStore* store = mSpace_Store;</span>
<a href="#l64.85"></a><span id="l64.85">       if ( store )</span>
<a href="#l64.86"></a><span id="l64.86">         this-&gt;CutAllRows(ev, &amp;store-&gt;mStore_Pool);</span>
<a href="#l64.87"></a><span id="l64.87" class="difflineminus">-      </span>
<a href="#l64.88"></a><span id="l64.88" class="difflineplus">+</span>
<a href="#l64.89"></a><span id="l64.89">       mRowSpace_Rows.CloseMorkNode(ev);</span>
<a href="#l64.90"></a><span id="l64.90">       this-&gt;CloseSpace(ev);</span>
<a href="#l64.91"></a><span id="l64.91">     }</span>
<a href="#l64.92"></a><span id="l64.92">     else</span>
<a href="#l64.93"></a><span id="l64.93">       this-&gt;NonNodeError(ev);</span>
<a href="#l64.94"></a><span id="l64.94"> }</span>
<a href="#l64.95"></a><span id="l64.95"> </span>
<a href="#l64.96"></a><span id="l64.96"> // } ===== end morkNode methods =====</span>
<a href="#l64.97"></a><span id="l64.97" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l64.98"></a><span id="l64.98" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l64.99"></a><span id="l64.99"> </span>
<a href="#l64.100"></a><span id="l64.100"> /*static*/ void</span>
<a href="#l64.101"></a><span id="l64.101"> morkRowSpace::NonRowSpaceTypeError(morkEnv* ev)</span>
<a href="#l64.102"></a><span id="l64.102"> {</span>
<a href="#l64.103"></a><span id="l64.103">   ev-&gt;NewError(&quot;non morkRowSpace&quot;);</span>
<a href="#l64.104"></a><span id="l64.104"> }</span>
<a href="#l64.105"></a><span id="l64.105"> </span>
<a href="#l64.106"></a><span id="l64.106"> /*static*/ void</span>
<a href="#l64.107"></a><span id="l64.107" class="difflineat">@@ -188,32 +188,32 @@ morkRowSpace::MinusOneRidError(morkEnv* </span>
<a href="#l64.108"></a><span id="l64.108"> //{</span>
<a href="#l64.109"></a><span id="l64.109"> //}</span>
<a href="#l64.110"></a><span id="l64.110"> </span>
<a href="#l64.111"></a><span id="l64.111"> mork_num</span>
<a href="#l64.112"></a><span id="l64.112"> morkRowSpace::CutAllRows(morkEnv* ev, morkPool* ioPool)</span>
<a href="#l64.113"></a><span id="l64.113"> {</span>
<a href="#l64.114"></a><span id="l64.114">   if ( this-&gt;IsRowSpaceClean() )</span>
<a href="#l64.115"></a><span id="l64.115">     this-&gt;MaybeDirtyStoreAndSpace();</span>
<a href="#l64.116"></a><span id="l64.116" class="difflineminus">-  </span>
<a href="#l64.117"></a><span id="l64.117" class="difflineplus">+</span>
<a href="#l64.118"></a><span id="l64.118"> #ifdef MORK_ENABLE_ZONE_ARENAS</span>
<a href="#l64.119"></a><span id="l64.119">   MORK_USED_2(ev, ioPool);</span>
<a href="#l64.120"></a><span id="l64.120">   return 0;</span>
<a href="#l64.121"></a><span id="l64.121"> #else /*MORK_ENABLE_ZONE_ARENAS*/</span>
<a href="#l64.122"></a><span id="l64.122">   mork_num outSlots = mRowSpace_Rows.MapFill();</span>
<a href="#l64.123"></a><span id="l64.123">   morkZone* zone = &amp;mSpace_Store-&gt;mStore_Zone;</span>
<a href="#l64.124"></a><span id="l64.124">   morkRow* r = 0; // old key row in the map</span>
<a href="#l64.125"></a><span id="l64.125">   mork_change* c = 0;</span>
<a href="#l64.126"></a><span id="l64.126"> </span>
<a href="#l64.127"></a><span id="l64.127"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l64.128"></a><span id="l64.128">   morkRowProbeMapIter i(ev, &amp;mRowSpace_Rows);</span>
<a href="#l64.129"></a><span id="l64.129"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l64.130"></a><span id="l64.130">   morkRowMapIter i(ev, &amp;mRowSpace_Rows);</span>
<a href="#l64.131"></a><span id="l64.131"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l64.132"></a><span id="l64.132" class="difflineminus">-  </span>
<a href="#l64.133"></a><span id="l64.133" class="difflineplus">+</span>
<a href="#l64.134"></a><span id="l64.134">   for ( c = i.FirstRow(ev, &amp;r); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l64.135"></a><span id="l64.135">         c = i.NextRow(ev, &amp;r) )</span>
<a href="#l64.136"></a><span id="l64.136">   {</span>
<a href="#l64.137"></a><span id="l64.137">     if ( r )</span>
<a href="#l64.138"></a><span id="l64.138">     {</span>
<a href="#l64.139"></a><span id="l64.139">       if ( r-&gt;IsRow() )</span>
<a href="#l64.140"></a><span id="l64.140">       {</span>
<a href="#l64.141"></a><span id="l64.141">         if ( r-&gt;mRow_Object )</span>
<a href="#l64.142"></a><span id="l64.142" class="difflineat">@@ -223,17 +223,17 @@ morkRowSpace::CutAllRows(morkEnv* ev, mo</span>
<a href="#l64.143"></a><span id="l64.143">         }</span>
<a href="#l64.144"></a><span id="l64.144">         ioPool-&gt;ZapRow(ev, r, zone);</span>
<a href="#l64.145"></a><span id="l64.145">       }</span>
<a href="#l64.146"></a><span id="l64.146">       else</span>
<a href="#l64.147"></a><span id="l64.147">         r-&gt;NonRowTypeWarning(ev);</span>
<a href="#l64.148"></a><span id="l64.148">     }</span>
<a href="#l64.149"></a><span id="l64.149">     else</span>
<a href="#l64.150"></a><span id="l64.150">       ev-&gt;NilPointerError();</span>
<a href="#l64.151"></a><span id="l64.151" class="difflineminus">-    </span>
<a href="#l64.152"></a><span id="l64.152" class="difflineplus">+</span>
<a href="#l64.153"></a><span id="l64.153"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l64.154"></a><span id="l64.154">     // cut nothing from the map</span>
<a href="#l64.155"></a><span id="l64.155"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l64.156"></a><span id="l64.156">     i.CutHereRow(ev, /*key*/ (morkRow**) 0);</span>
<a href="#l64.157"></a><span id="l64.157"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l64.158"></a><span id="l64.158">   }</span>
<a href="#l64.159"></a><span id="l64.159"> </span>
<a href="#l64.160"></a><span id="l64.160">   return outSlots;</span>
<a href="#l64.161"></a><span id="l64.161" class="difflineat">@@ -245,87 +245,87 @@ morkRowSpace::FindTableByKind(morkEnv* e</span>
<a href="#l64.162"></a><span id="l64.162"> {</span>
<a href="#l64.163"></a><span id="l64.163">   if ( inTableKind )</span>
<a href="#l64.164"></a><span id="l64.164">   {</span>
<a href="#l64.165"></a><span id="l64.165"> #ifdef MORK_BEAD_OVER_NODE_MAPS</span>
<a href="#l64.166"></a><span id="l64.166"> </span>
<a href="#l64.167"></a><span id="l64.167">     morkTableMapIter i(ev, &amp;mRowSpace_Tables);</span>
<a href="#l64.168"></a><span id="l64.168">     morkTable* table = i.FirstTable(ev);</span>
<a href="#l64.169"></a><span id="l64.169">     for ( ; table &amp;&amp; ev-&gt;Good(); table = i.NextTable(ev) )</span>
<a href="#l64.170"></a><span id="l64.170" class="difflineminus">-          </span>
<a href="#l64.171"></a><span id="l64.171" class="difflineplus">+</span>
<a href="#l64.172"></a><span id="l64.172"> #else /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l64.173"></a><span id="l64.173">     mork_tid* key = 0; // nil pointer to suppress key access</span>
<a href="#l64.174"></a><span id="l64.174">     morkTable* table = 0; // old table in the map</span>
<a href="#l64.175"></a><span id="l64.175"> </span>
<a href="#l64.176"></a><span id="l64.176">     mork_change* c = 0;</span>
<a href="#l64.177"></a><span id="l64.177">     morkTableMapIter i(ev, &amp;mRowSpace_Tables);</span>
<a href="#l64.178"></a><span id="l64.178">     for ( c = i.FirstTable(ev, key, &amp;table); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l64.179"></a><span id="l64.179">           c = i.NextTable(ev, key, &amp;table) )</span>
<a href="#l64.180"></a><span id="l64.180"> #endif /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l64.181"></a><span id="l64.181">     {</span>
<a href="#l64.182"></a><span id="l64.182">       if ( table-&gt;mTable_Kind == inTableKind )</span>
<a href="#l64.183"></a><span id="l64.183">         return table;</span>
<a href="#l64.184"></a><span id="l64.184">     }</span>
<a href="#l64.185"></a><span id="l64.185">   }</span>
<a href="#l64.186"></a><span id="l64.186">   else</span>
<a href="#l64.187"></a><span id="l64.187">     this-&gt;ZeroKindError(ev);</span>
<a href="#l64.188"></a><span id="l64.188" class="difflineminus">-    </span>
<a href="#l64.189"></a><span id="l64.189" class="difflineplus">+</span>
<a href="#l64.190"></a><span id="l64.190">   return (morkTable*) 0;</span>
<a href="#l64.191"></a><span id="l64.191"> }</span>
<a href="#l64.192"></a><span id="l64.192"> </span>
<a href="#l64.193"></a><span id="l64.193"> morkTable*</span>
<a href="#l64.194"></a><span id="l64.194"> morkRowSpace::NewTableWithTid(morkEnv* ev, mork_tid inTid,</span>
<a href="#l64.195"></a><span id="l64.195">   mork_kind inTableKind,</span>
<a href="#l64.196"></a><span id="l64.196" class="difflineminus">-  const mdbOid* inOptionalMetaRowOid) // can be nil to avoid specifying </span>
<a href="#l64.197"></a><span id="l64.197" class="difflineplus">+  const mdbOid* inOptionalMetaRowOid) // can be nil to avoid specifying</span>
<a href="#l64.198"></a><span id="l64.198"> {</span>
<a href="#l64.199"></a><span id="l64.199">   morkTable* outTable = 0;</span>
<a href="#l64.200"></a><span id="l64.200">   morkStore* store = mSpace_Store;</span>
<a href="#l64.201"></a><span id="l64.201" class="difflineminus">-  </span>
<a href="#l64.202"></a><span id="l64.202" class="difflineplus">+</span>
<a href="#l64.203"></a><span id="l64.203">   if ( inTableKind &amp;&amp; store )</span>
<a href="#l64.204"></a><span id="l64.204">   {</span>
<a href="#l64.205"></a><span id="l64.205">     mdb_bool mustBeUnique = morkBool_kFalse;</span>
<a href="#l64.206"></a><span id="l64.206">     nsIMdbHeap* heap = store-&gt;mPort_Heap;</span>
<a href="#l64.207"></a><span id="l64.207">     morkTable* table = new(*heap, ev)</span>
<a href="#l64.208"></a><span id="l64.208">       morkTable(ev, morkUsage::kHeap, heap, store, heap, this,</span>
<a href="#l64.209"></a><span id="l64.209">         inOptionalMetaRowOid, inTid, inTableKind, mustBeUnique);</span>
<a href="#l64.210"></a><span id="l64.210">     if ( table )</span>
<a href="#l64.211"></a><span id="l64.211">     {</span>
<a href="#l64.212"></a><span id="l64.212">       if ( mRowSpace_Tables.AddTable(ev, table) )</span>
<a href="#l64.213"></a><span id="l64.213">       {</span>
<a href="#l64.214"></a><span id="l64.214">         outTable = table;</span>
<a href="#l64.215"></a><span id="l64.215">         if ( mRowSpace_NextTableId &lt;= inTid )</span>
<a href="#l64.216"></a><span id="l64.216">           mRowSpace_NextTableId = inTid + 1;</span>
<a href="#l64.217"></a><span id="l64.217">       }</span>
<a href="#l64.218"></a><span id="l64.218" class="difflineminus">-        </span>
<a href="#l64.219"></a><span id="l64.219" class="difflineplus">+</span>
<a href="#l64.220"></a><span id="l64.220">       if ( this-&gt;IsRowSpaceClean() &amp;&amp; store-&gt;mStore_CanDirty )</span>
<a href="#l64.221"></a><span id="l64.221">         this-&gt;MaybeDirtyStoreAndSpace(); // morkTable does already</span>
<a href="#l64.222"></a><span id="l64.222"> </span>
<a href="#l64.223"></a><span id="l64.223">     }</span>
<a href="#l64.224"></a><span id="l64.224">   }</span>
<a href="#l64.225"></a><span id="l64.225">   else if ( store )</span>
<a href="#l64.226"></a><span id="l64.226">     this-&gt;ZeroKindError(ev);</span>
<a href="#l64.227"></a><span id="l64.227">   else</span>
<a href="#l64.228"></a><span id="l64.228">     this-&gt;NilSpaceStoreError(ev);</span>
<a href="#l64.229"></a><span id="l64.229" class="difflineminus">-    </span>
<a href="#l64.230"></a><span id="l64.230" class="difflineplus">+</span>
<a href="#l64.231"></a><span id="l64.231">   return outTable;</span>
<a href="#l64.232"></a><span id="l64.232"> }</span>
<a href="#l64.233"></a><span id="l64.233"> </span>
<a href="#l64.234"></a><span id="l64.234"> morkTable*</span>
<a href="#l64.235"></a><span id="l64.235"> morkRowSpace::NewTable(morkEnv* ev, mork_kind inTableKind,</span>
<a href="#l64.236"></a><span id="l64.236">   mdb_bool inMustBeUnique,</span>
<a href="#l64.237"></a><span id="l64.237" class="difflineminus">-  const mdbOid* inOptionalMetaRowOid) // can be nil to avoid specifying </span>
<a href="#l64.238"></a><span id="l64.238" class="difflineplus">+  const mdbOid* inOptionalMetaRowOid) // can be nil to avoid specifying</span>
<a href="#l64.239"></a><span id="l64.239"> {</span>
<a href="#l64.240"></a><span id="l64.240">   morkTable* outTable = 0;</span>
<a href="#l64.241"></a><span id="l64.241">   morkStore* store = mSpace_Store;</span>
<a href="#l64.242"></a><span id="l64.242" class="difflineminus">-  </span>
<a href="#l64.243"></a><span id="l64.243" class="difflineplus">+</span>
<a href="#l64.244"></a><span id="l64.244">   if ( inTableKind &amp;&amp; store )</span>
<a href="#l64.245"></a><span id="l64.245">   {</span>
<a href="#l64.246"></a><span id="l64.246">     if ( inMustBeUnique ) // need to look for existing table first?</span>
<a href="#l64.247"></a><span id="l64.247">       outTable = this-&gt;FindTableByKind(ev, inTableKind);</span>
<a href="#l64.248"></a><span id="l64.248" class="difflineminus">-      </span>
<a href="#l64.249"></a><span id="l64.249" class="difflineplus">+</span>
<a href="#l64.250"></a><span id="l64.250">     if ( !outTable &amp;&amp; ev-&gt;Good() )</span>
<a href="#l64.251"></a><span id="l64.251">     {</span>
<a href="#l64.252"></a><span id="l64.252">       mork_tid id = this-&gt;MakeNewTableId(ev);</span>
<a href="#l64.253"></a><span id="l64.253">       if ( id )</span>
<a href="#l64.254"></a><span id="l64.254">       {</span>
<a href="#l64.255"></a><span id="l64.255">         nsIMdbHeap* heap = mSpace_Store-&gt;mPort_Heap;</span>
<a href="#l64.256"></a><span id="l64.256">         morkTable* table = new(*heap, ev)</span>
<a href="#l64.257"></a><span id="l64.257">           morkTable(ev, morkUsage::kHeap, heap, mSpace_Store, heap, this,</span>
<a href="#l64.258"></a><span id="l64.258" class="difflineat">@@ -342,38 +342,38 @@ morkRowSpace::NewTable(morkEnv* ev, mork</span>
<a href="#l64.259"></a><span id="l64.259">         }</span>
<a href="#l64.260"></a><span id="l64.260">       }</span>
<a href="#l64.261"></a><span id="l64.261">     }</span>
<a href="#l64.262"></a><span id="l64.262">   }</span>
<a href="#l64.263"></a><span id="l64.263">   else if ( store )</span>
<a href="#l64.264"></a><span id="l64.264">     this-&gt;ZeroKindError(ev);</span>
<a href="#l64.265"></a><span id="l64.265">   else</span>
<a href="#l64.266"></a><span id="l64.266">     this-&gt;NilSpaceStoreError(ev);</span>
<a href="#l64.267"></a><span id="l64.267" class="difflineminus">-    </span>
<a href="#l64.268"></a><span id="l64.268" class="difflineplus">+</span>
<a href="#l64.269"></a><span id="l64.269">   return outTable;</span>
<a href="#l64.270"></a><span id="l64.270"> }</span>
<a href="#l64.271"></a><span id="l64.271"> </span>
<a href="#l64.272"></a><span id="l64.272"> mork_tid</span>
<a href="#l64.273"></a><span id="l64.273"> morkRowSpace::MakeNewTableId(morkEnv* ev)</span>
<a href="#l64.274"></a><span id="l64.274"> {</span>
<a href="#l64.275"></a><span id="l64.275">   mork_tid outTid = 0;</span>
<a href="#l64.276"></a><span id="l64.276">   mork_tid id = mRowSpace_NextTableId;</span>
<a href="#l64.277"></a><span id="l64.277">   mork_num count = 9; // try up to eight times</span>
<a href="#l64.278"></a><span id="l64.278" class="difflineminus">-  </span>
<a href="#l64.279"></a><span id="l64.279" class="difflineplus">+</span>
<a href="#l64.280"></a><span id="l64.280">   while ( !outTid &amp;&amp; --count ) // still trying to find an unused table ID?</span>
<a href="#l64.281"></a><span id="l64.281">   {</span>
<a href="#l64.282"></a><span id="l64.282">     if ( !mRowSpace_Tables.GetTable(ev, id) )</span>
<a href="#l64.283"></a><span id="l64.283">       outTid = id;</span>
<a href="#l64.284"></a><span id="l64.284">     else</span>
<a href="#l64.285"></a><span id="l64.285">     {</span>
<a href="#l64.286"></a><span id="l64.286">       MORK_ASSERT(morkBool_kFalse); // alert developer about ID problems</span>
<a href="#l64.287"></a><span id="l64.287">       ++id;</span>
<a href="#l64.288"></a><span id="l64.288">     }</span>
<a href="#l64.289"></a><span id="l64.289">   }</span>
<a href="#l64.290"></a><span id="l64.290" class="difflineminus">-  </span>
<a href="#l64.291"></a><span id="l64.291" class="difflineplus">+</span>
<a href="#l64.292"></a><span id="l64.292">   mRowSpace_NextTableId = id + 1;</span>
<a href="#l64.293"></a><span id="l64.293">   return outTid;</span>
<a href="#l64.294"></a><span id="l64.294"> }</span>
<a href="#l64.295"></a><span id="l64.295"> </span>
<a href="#l64.296"></a><span id="l64.296"> #define MAX_AUTO_ID (morkRow_kMinusOneRid - 2)</span>
<a href="#l64.297"></a><span id="l64.297"> mork_rid</span>
<a href="#l64.298"></a><span id="l64.298"> morkRowSpace::MakeNewRowId(morkEnv* ev)</span>
<a href="#l64.299"></a><span id="l64.299"> {</span>
<a href="#l64.300"></a><span id="l64.300" class="difflineat">@@ -390,70 +390,70 @@ morkRowSpace::MakeNewRowId(morkEnv* ev)</span>
<a href="#l64.301"></a><span id="l64.301">     if ( !mRowSpace_Rows.GetOid(ev, &amp;oid) )</span>
<a href="#l64.302"></a><span id="l64.302">       outRid = id;</span>
<a href="#l64.303"></a><span id="l64.303">     else</span>
<a href="#l64.304"></a><span id="l64.304">     {</span>
<a href="#l64.305"></a><span id="l64.305">       MORK_ASSERT(morkBool_kFalse); // alert developer about ID problems</span>
<a href="#l64.306"></a><span id="l64.306">       ++id;</span>
<a href="#l64.307"></a><span id="l64.307">     }</span>
<a href="#l64.308"></a><span id="l64.308">   }</span>
<a href="#l64.309"></a><span id="l64.309" class="difflineminus">-  </span>
<a href="#l64.310"></a><span id="l64.310" class="difflineplus">+</span>
<a href="#l64.311"></a><span id="l64.311">   if (id &lt; MAX_AUTO_ID)</span>
<a href="#l64.312"></a><span id="l64.312">     mRowSpace_NextRowId = id + 1;</span>
<a href="#l64.313"></a><span id="l64.313">   return outRid;</span>
<a href="#l64.314"></a><span id="l64.314"> }</span>
<a href="#l64.315"></a><span id="l64.315"> </span>
<a href="#l64.316"></a><span id="l64.316"> morkAtomRowMap*</span>
<a href="#l64.317"></a><span id="l64.317"> morkRowSpace::make_index(morkEnv* ev, mork_column inCol)</span>
<a href="#l64.318"></a><span id="l64.318"> {</span>
<a href="#l64.319"></a><span id="l64.319">   morkAtomRowMap* outMap = 0;</span>
<a href="#l64.320"></a><span id="l64.320">   nsIMdbHeap* heap = mRowSpace_SlotHeap;</span>
<a href="#l64.321"></a><span id="l64.321">   if ( heap ) // have expected heap for allocations?</span>
<a href="#l64.322"></a><span id="l64.322">   {</span>
<a href="#l64.323"></a><span id="l64.323">     morkAtomRowMap* map = new(*heap, ev)</span>
<a href="#l64.324"></a><span id="l64.324">       morkAtomRowMap(ev, morkUsage::kHeap, heap, heap, inCol);</span>
<a href="#l64.325"></a><span id="l64.325" class="difflineminus">-    </span>
<a href="#l64.326"></a><span id="l64.326" class="difflineplus">+</span>
<a href="#l64.327"></a><span id="l64.327">     if ( map ) // able to create new map index?</span>
<a href="#l64.328"></a><span id="l64.328">     {</span>
<a href="#l64.329"></a><span id="l64.329">       if ( ev-&gt;Good() ) // no errors during construction?</span>
<a href="#l64.330"></a><span id="l64.330">       {</span>
<a href="#l64.331"></a><span id="l64.331"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l64.332"></a><span id="l64.332">         morkRowProbeMapIter i(ev, &amp;mRowSpace_Rows);</span>
<a href="#l64.333"></a><span id="l64.333"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l64.334"></a><span id="l64.334">         morkRowMapIter i(ev, &amp;mRowSpace_Rows);</span>
<a href="#l64.335"></a><span id="l64.335"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l64.336"></a><span id="l64.336">         mork_change* c = 0;</span>
<a href="#l64.337"></a><span id="l64.337">         morkRow* row = 0;</span>
<a href="#l64.338"></a><span id="l64.338">         mork_aid aidKey = 0;</span>
<a href="#l64.339"></a><span id="l64.339" class="difflineminus">-        </span>
<a href="#l64.340"></a><span id="l64.340" class="difflineplus">+</span>
<a href="#l64.341"></a><span id="l64.341">         for ( c = i.FirstRow(ev, &amp;row); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l64.342"></a><span id="l64.342">               c = i.NextRow(ev, &amp;row) ) // another row in space?</span>
<a href="#l64.343"></a><span id="l64.343">         {</span>
<a href="#l64.344"></a><span id="l64.344">           aidKey = row-&gt;GetCellAtomAid(ev, inCol);</span>
<a href="#l64.345"></a><span id="l64.345">           if ( aidKey ) // row has indexed attribute?</span>
<a href="#l64.346"></a><span id="l64.346">             map-&gt;AddAid(ev, aidKey, row); // include in map</span>
<a href="#l64.347"></a><span id="l64.347">         }</span>
<a href="#l64.348"></a><span id="l64.348">       }</span>
<a href="#l64.349"></a><span id="l64.349">       if ( ev-&gt;Good() ) // no errors constructing index?</span>
<a href="#l64.350"></a><span id="l64.350">         outMap = map; // return from function</span>
<a href="#l64.351"></a><span id="l64.351">       else</span>
<a href="#l64.352"></a><span id="l64.352">         map-&gt;CutStrongRef(ev); // discard map on error</span>
<a href="#l64.353"></a><span id="l64.353">     }</span>
<a href="#l64.354"></a><span id="l64.354">   }</span>
<a href="#l64.355"></a><span id="l64.355">   else</span>
<a href="#l64.356"></a><span id="l64.356">     ev-&gt;NilPointerError();</span>
<a href="#l64.357"></a><span id="l64.357" class="difflineminus">-  </span>
<a href="#l64.358"></a><span id="l64.358" class="difflineplus">+</span>
<a href="#l64.359"></a><span id="l64.359">   return outMap;</span>
<a href="#l64.360"></a><span id="l64.360"> }</span>
<a href="#l64.361"></a><span id="l64.361"> </span>
<a href="#l64.362"></a><span id="l64.362"> morkAtomRowMap*</span>
<a href="#l64.363"></a><span id="l64.363"> morkRowSpace::ForceMap(morkEnv* ev, mork_column inCol)</span>
<a href="#l64.364"></a><span id="l64.364"> {</span>
<a href="#l64.365"></a><span id="l64.365">   morkAtomRowMap* outMap = this-&gt;FindMap(ev, inCol);</span>
<a href="#l64.366"></a><span id="l64.366" class="difflineminus">-  </span>
<a href="#l64.367"></a><span id="l64.367" class="difflineplus">+</span>
<a href="#l64.368"></a><span id="l64.368">   if ( !outMap &amp;&amp; ev-&gt;Good() ) // no such existing index?</span>
<a href="#l64.369"></a><span id="l64.369">   {</span>
<a href="#l64.370"></a><span id="l64.370">     if ( mRowSpace_IndexCount &lt; morkRowSpace_kMaxIndexCount )</span>
<a href="#l64.371"></a><span id="l64.371">     {</span>
<a href="#l64.372"></a><span id="l64.372">       morkAtomRowMap* map = this-&gt;make_index(ev, inCol);</span>
<a href="#l64.373"></a><span id="l64.373">       if ( map ) // created a new index for col?</span>
<a href="#l64.374"></a><span id="l64.374">       {</span>
<a href="#l64.375"></a><span id="l64.375">         mork_count wrap = 0; // count times wrap-around occurs</span>
<a href="#l64.376"></a><span id="l64.376" class="difflineat">@@ -529,17 +529,17 @@ morkRowSpace::FindRow(morkEnv* ev, mork_</span>
<a href="#l64.377"></a><span id="l64.377">     {</span>
<a href="#l64.378"></a><span id="l64.378">       morkAtomRowMap* map = this-&gt;ForceMap(ev, inCol);</span>
<a href="#l64.379"></a><span id="l64.379">       if ( map ) // able to find or create index for col?</span>
<a href="#l64.380"></a><span id="l64.380">       {</span>
<a href="#l64.381"></a><span id="l64.381">         outRow = map-&gt;GetAid(ev, atomAid); // search for row</span>
<a href="#l64.382"></a><span id="l64.382">       }</span>
<a href="#l64.383"></a><span id="l64.383">     }</span>
<a href="#l64.384"></a><span id="l64.384">   }</span>
<a href="#l64.385"></a><span id="l64.385" class="difflineminus">-  </span>
<a href="#l64.386"></a><span id="l64.386" class="difflineplus">+</span>
<a href="#l64.387"></a><span id="l64.387">   return outRow;</span>
<a href="#l64.388"></a><span id="l64.388"> }</span>
<a href="#l64.389"></a><span id="l64.389"> </span>
<a href="#l64.390"></a><span id="l64.390"> morkRow*</span>
<a href="#l64.391"></a><span id="l64.391"> morkRowSpace::NewRowWithOid(morkEnv* ev, const mdbOid* inOid)</span>
<a href="#l64.392"></a><span id="l64.392"> {</span>
<a href="#l64.393"></a><span id="l64.393">   morkRow* outRow = mRowSpace_Rows.GetOid(ev, inOid);</span>
<a href="#l64.394"></a><span id="l64.394">   MORK_ASSERT(outRow==0);</span>
<a href="#l64.395"></a><span id="l64.395" class="difflineat">@@ -548,17 +548,17 @@ morkRowSpace::NewRowWithOid(morkEnv* ev,</span>
<a href="#l64.396"></a><span id="l64.396">     morkStore* store = mSpace_Store;</span>
<a href="#l64.397"></a><span id="l64.397">     if ( store )</span>
<a href="#l64.398"></a><span id="l64.398">     {</span>
<a href="#l64.399"></a><span id="l64.399">       morkPool* pool = this-&gt;GetSpaceStorePool();</span>
<a href="#l64.400"></a><span id="l64.400">       morkRow* row = pool-&gt;NewRow(ev, &amp;store-&gt;mStore_Zone);</span>
<a href="#l64.401"></a><span id="l64.401">       if ( row )</span>
<a href="#l64.402"></a><span id="l64.402">       {</span>
<a href="#l64.403"></a><span id="l64.403">         row-&gt;InitRow(ev, inOid, this, /*length*/ 0, pool);</span>
<a href="#l64.404"></a><span id="l64.404" class="difflineminus">-        </span>
<a href="#l64.405"></a><span id="l64.405" class="difflineplus">+</span>
<a href="#l64.406"></a><span id="l64.406">         if ( ev-&gt;Good() &amp;&amp; mRowSpace_Rows.AddRow(ev, row) )</span>
<a href="#l64.407"></a><span id="l64.407">         {</span>
<a href="#l64.408"></a><span id="l64.408">           outRow = row;</span>
<a href="#l64.409"></a><span id="l64.409">           mork_rid rid = inOid-&gt;mOid_Id;</span>
<a href="#l64.410"></a><span id="l64.410">           if ( mRowSpace_NextRowId &lt;= rid )</span>
<a href="#l64.411"></a><span id="l64.411">             mRowSpace_NextRowId = rid + 1;</span>
<a href="#l64.412"></a><span id="l64.412">         }</span>
<a href="#l64.413"></a><span id="l64.413">         else</span>
<a href="#l64.414"></a><span id="l64.414" class="difflineat">@@ -589,17 +589,17 @@ morkRowSpace::NewRow(morkEnv* ev)</span>
<a href="#l64.415"></a><span id="l64.415">         mdbOid oid;</span>
<a href="#l64.416"></a><span id="l64.416">         oid.mOid_Scope = this-&gt;SpaceScope();</span>
<a href="#l64.417"></a><span id="l64.417">         oid.mOid_Id = id;</span>
<a href="#l64.418"></a><span id="l64.418">         morkPool* pool = this-&gt;GetSpaceStorePool();</span>
<a href="#l64.419"></a><span id="l64.419">         morkRow* row = pool-&gt;NewRow(ev, &amp;store-&gt;mStore_Zone);</span>
<a href="#l64.420"></a><span id="l64.420">         if ( row )</span>
<a href="#l64.421"></a><span id="l64.421">         {</span>
<a href="#l64.422"></a><span id="l64.422">           row-&gt;InitRow(ev, &amp;oid, this, /*length*/ 0, pool);</span>
<a href="#l64.423"></a><span id="l64.423" class="difflineminus">-          </span>
<a href="#l64.424"></a><span id="l64.424" class="difflineplus">+</span>
<a href="#l64.425"></a><span id="l64.425">           if ( ev-&gt;Good() &amp;&amp; mRowSpace_Rows.AddRow(ev, row) )</span>
<a href="#l64.426"></a><span id="l64.426">             outRow = row;</span>
<a href="#l64.427"></a><span id="l64.427">           else</span>
<a href="#l64.428"></a><span id="l64.428">             pool-&gt;ZapRow(ev, row, &amp;store-&gt;mStore_Zone);</span>
<a href="#l64.429"></a><span id="l64.429"> </span>
<a href="#l64.430"></a><span id="l64.430">           if ( this-&gt;IsRowSpaceClean() &amp;&amp; store-&gt;mStore_CanDirty )</span>
<a href="#l64.431"></a><span id="l64.431">             this-&gt;MaybeDirtyStoreAndSpace(); // InitRow() does already</span>
<a href="#l64.432"></a><span id="l64.432">         }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l65.1"></a><span id="l65.1" class="difflineminus">--- a/db/mork/src/morkRowSpace.h</span>
<a href="#l65.2"></a><span id="l65.2" class="difflineplus">+++ b/db/mork/src/morkRowSpace.h</span>
<a href="#l65.3"></a><span id="l65.3" class="difflineat">@@ -46,34 +46,34 @@</span>
<a href="#l65.4"></a><span id="l65.4"> </span>
<a href="#l65.5"></a><span id="l65.5"> #define morkRowSpace_kMaxIndexCount 8 /* no more indexes than this */</span>
<a href="#l65.6"></a><span id="l65.6"> #define morkRowSpace_kPrimeCacheSize 17 /* should be prime number */</span>
<a href="#l65.7"></a><span id="l65.7"> </span>
<a href="#l65.8"></a><span id="l65.8"> class morkAtomRowMap;</span>
<a href="#l65.9"></a><span id="l65.9"> </span>
<a href="#l65.10"></a><span id="l65.10"> /*| morkRowSpace:</span>
<a href="#l65.11"></a><span id="l65.11"> |*/</span>
<a href="#l65.12"></a><span id="l65.12" class="difflineminus">-class morkRowSpace : public morkSpace { // </span>
<a href="#l65.13"></a><span id="l65.13" class="difflineplus">+class morkRowSpace : public morkSpace { //</span>
<a href="#l65.14"></a><span id="l65.14"> </span>
<a href="#l65.15"></a><span id="l65.15"> // public: // slots inherited from morkSpace (meant to inform only)</span>
<a href="#l65.16"></a><span id="l65.16">   // nsIMdbHeap*    mNode_Heap;</span>
<a href="#l65.17"></a><span id="l65.17"> </span>
<a href="#l65.18"></a><span id="l65.18">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l65.19"></a><span id="l65.19">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l65.20"></a><span id="l65.20" class="difflineminus">-  </span>
<a href="#l65.21"></a><span id="l65.21" class="difflineplus">+</span>
<a href="#l65.22"></a><span id="l65.22">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l65.23"></a><span id="l65.23">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l65.24"></a><span id="l65.24">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l65.25"></a><span id="l65.25">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l65.26"></a><span id="l65.26" class="difflineminus">-  </span>
<a href="#l65.27"></a><span id="l65.27" class="difflineplus">+</span>
<a href="#l65.28"></a><span id="l65.28">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l65.29"></a><span id="l65.29">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l65.30"></a><span id="l65.30" class="difflineminus">-  </span>
<a href="#l65.31"></a><span id="l65.31" class="difflineplus">+</span>
<a href="#l65.32"></a><span id="l65.32">   // morkStore*  mSpace_Store; // weak ref to containing store</span>
<a href="#l65.33"></a><span id="l65.33" class="difflineminus">-  </span>
<a href="#l65.34"></a><span id="l65.34" class="difflineplus">+</span>
<a href="#l65.35"></a><span id="l65.35">   // mork_bool   mSpace_DoAutoIDs;    // whether db should assign member IDs</span>
<a href="#l65.36"></a><span id="l65.36">   // mork_bool   mSpace_HaveDoneAutoIDs; // whether actually auto assigned IDs</span>
<a href="#l65.37"></a><span id="l65.37">   // mork_u1     mSpace_Pad[ 2 ];    // pad to u4 alignment</span>
<a href="#l65.38"></a><span id="l65.38"> </span>
<a href="#l65.39"></a><span id="l65.39"> public: // state is public because the entire Mork system is private</span>
<a href="#l65.40"></a><span id="l65.40"> </span>
<a href="#l65.41"></a><span id="l65.41">   nsIMdbHeap*  mRowSpace_SlotHeap;</span>
<a href="#l65.42"></a><span id="l65.42"> </span>
<a href="#l65.43"></a><span id="l65.43" class="difflineat">@@ -81,36 +81,36 @@ public: // state is public because the e</span>
<a href="#l65.44"></a><span id="l65.44">   morkRowProbeMap   mRowSpace_Rows;   // hash table of morkRow instances</span>
<a href="#l65.45"></a><span id="l65.45"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l65.46"></a><span id="l65.46">   morkRowMap   mRowSpace_Rows;   // hash table of morkRow instances</span>
<a href="#l65.47"></a><span id="l65.47"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l65.48"></a><span id="l65.48">   morkTableMap mRowSpace_Tables; // all the tables in this row scope</span>
<a href="#l65.49"></a><span id="l65.49"> </span>
<a href="#l65.50"></a><span id="l65.50">   mork_tid     mRowSpace_NextTableId;  // for auto-assigning table IDs</span>
<a href="#l65.51"></a><span id="l65.51">   mork_rid     mRowSpace_NextRowId;    // for auto-assigning row IDs</span>
<a href="#l65.52"></a><span id="l65.52" class="difflineminus">-  </span>
<a href="#l65.53"></a><span id="l65.53" class="difflineplus">+</span>
<a href="#l65.54"></a><span id="l65.54">   mork_count   mRowSpace_IndexCount; // if nonzero, row indexes exist</span>
<a href="#l65.55"></a><span id="l65.55" class="difflineminus">-    </span>
<a href="#l65.56"></a><span id="l65.56" class="difflineplus">+</span>
<a href="#l65.57"></a><span id="l65.57">   // every nonzero slot in IndexCache is a strong ref to a morkAtomRowMap:</span>
<a href="#l65.58"></a><span id="l65.58">   morkAtomRowMap* mRowSpace_IndexCache[ morkRowSpace_kPrimeCacheSize ];</span>
<a href="#l65.59"></a><span id="l65.59"> </span>
<a href="#l65.60"></a><span id="l65.60">   morkDeque    mRowSpace_TablesByPriority[ morkPriority_kCount ];</span>
<a href="#l65.61"></a><span id="l65.61"> </span>
<a href="#l65.62"></a><span id="l65.62"> public: // more specific dirty methods for row space:</span>
<a href="#l65.63"></a><span id="l65.63">   void SetRowSpaceDirty() { this-&gt;SetNodeDirty(); }</span>
<a href="#l65.64"></a><span id="l65.64">   void SetRowSpaceClean() { this-&gt;SetNodeClean(); }</span>
<a href="#l65.65"></a><span id="l65.65" class="difflineminus">-  </span>
<a href="#l65.66"></a><span id="l65.66" class="difflineplus">+</span>
<a href="#l65.67"></a><span id="l65.67">   mork_bool IsRowSpaceClean() const { return this-&gt;IsNodeClean(); }</span>
<a href="#l65.68"></a><span id="l65.68">   mork_bool IsRowSpaceDirty() const { return this-&gt;IsNodeDirty(); }</span>
<a href="#l65.69"></a><span id="l65.69"> </span>
<a href="#l65.70"></a><span id="l65.70"> // { ===== begin morkNode interface =====</span>
<a href="#l65.71"></a><span id="l65.71"> public: // morkNode virtual methods</span>
<a href="#l65.72"></a><span id="l65.72">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseRowSpace() only if open</span>
<a href="#l65.73"></a><span id="l65.73">   virtual ~morkRowSpace(); // assert that CloseRowSpace() executed earlier</span>
<a href="#l65.74"></a><span id="l65.74" class="difflineminus">-  </span>
<a href="#l65.75"></a><span id="l65.75" class="difflineplus">+</span>
<a href="#l65.76"></a><span id="l65.76"> public: // morkMap construction &amp; destruction</span>
<a href="#l65.77"></a><span id="l65.77">   morkRowSpace(morkEnv* ev, const morkUsage&amp; inUsage, mork_scope inScope,</span>
<a href="#l65.78"></a><span id="l65.78">     morkStore* ioStore, nsIMdbHeap* ioNodeHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l65.79"></a><span id="l65.79">   void CloseRowSpace(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l65.80"></a><span id="l65.80"> </span>
<a href="#l65.81"></a><span id="l65.81"> public: // dynamic type identification</span>
<a href="#l65.82"></a><span id="l65.82">   mork_bool IsRowSpace() const</span>
<a href="#l65.83"></a><span id="l65.83">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kRowSpace; }</span>
<a href="#l65.84"></a><span id="l65.84" class="difflineat">@@ -125,23 +125,23 @@ public: // typing</span>
<a href="#l65.85"></a><span id="l65.85"> </span>
<a href="#l65.86"></a><span id="l65.86">   //static void ExpectAutoIdOnlyError(morkEnv* ev);</span>
<a href="#l65.87"></a><span id="l65.87">   //static void ExpectAutoIdNeverError(morkEnv* ev);</span>
<a href="#l65.88"></a><span id="l65.88"> </span>
<a href="#l65.89"></a><span id="l65.89"> public: // other space methods</span>
<a href="#l65.90"></a><span id="l65.90"> </span>
<a href="#l65.91"></a><span id="l65.91">   mork_num CutAllRows(morkEnv* ev, morkPool* ioPool);</span>
<a href="#l65.92"></a><span id="l65.92">   // CutAllRows() puts all rows and cells back into the pool.</span>
<a href="#l65.93"></a><span id="l65.93" class="difflineminus">-  </span>
<a href="#l65.94"></a><span id="l65.94" class="difflineplus">+</span>
<a href="#l65.95"></a><span id="l65.95">   morkTable* NewTable(morkEnv* ev, mork_kind inTableKind,</span>
<a href="#l65.96"></a><span id="l65.96">     mdb_bool inMustBeUnique, const mdbOid* inOptionalMetaRowOid);</span>
<a href="#l65.97"></a><span id="l65.97" class="difflineminus">-  </span>
<a href="#l65.98"></a><span id="l65.98" class="difflineplus">+</span>
<a href="#l65.99"></a><span id="l65.99">   morkTable* NewTableWithTid(morkEnv* ev, mork_tid inTid,</span>
<a href="#l65.100"></a><span id="l65.100">     mork_kind inTableKind, const mdbOid* inOptionalMetaRowOid);</span>
<a href="#l65.101"></a><span id="l65.101" class="difflineminus">-  </span>
<a href="#l65.102"></a><span id="l65.102" class="difflineplus">+</span>
<a href="#l65.103"></a><span id="l65.103">   morkTable* FindTableByKind(morkEnv* ev, mork_kind inTableKind);</span>
<a href="#l65.104"></a><span id="l65.104">   morkTable* FindTableByTid(morkEnv* ev, mork_tid inTid)</span>
<a href="#l65.105"></a><span id="l65.105">   { return mRowSpace_Tables.GetTable(ev, inTid); }</span>
<a href="#l65.106"></a><span id="l65.106"> </span>
<a href="#l65.107"></a><span id="l65.107">   mork_tid MakeNewTableId(morkEnv* ev);</span>
<a href="#l65.108"></a><span id="l65.108">   mork_rid MakeNewRowId(morkEnv* ev);</span>
<a href="#l65.109"></a><span id="l65.109"> </span>
<a href="#l65.110"></a><span id="l65.110">   // morkRow* FindRowByRid(morkEnv* ev, mork_rid inRid)</span>
<a href="#l65.111"></a><span id="l65.111" class="difflineat">@@ -157,17 +157,17 @@ public: // other space methods</span>
<a href="#l65.112"></a><span id="l65.112"> </span>
<a href="#l65.113"></a><span id="l65.113"> protected: // internal utilities</span>
<a href="#l65.114"></a><span id="l65.114">   morkAtomRowMap* make_index(morkEnv* ev, mork_column inColumn);</span>
<a href="#l65.115"></a><span id="l65.115"> </span>
<a href="#l65.116"></a><span id="l65.116"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l65.117"></a><span id="l65.117">   static void SlotWeakRowSpace(morkRowSpace* me,</span>
<a href="#l65.118"></a><span id="l65.118">     morkEnv* ev, morkRowSpace** ioSlot)</span>
<a href="#l65.119"></a><span id="l65.119">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l65.120"></a><span id="l65.120" class="difflineminus">-  </span>
<a href="#l65.121"></a><span id="l65.121" class="difflineplus">+</span>
<a href="#l65.122"></a><span id="l65.122">   static void SlotStrongRowSpace(morkRowSpace* me,</span>
<a href="#l65.123"></a><span id="l65.123">     morkEnv* ev, morkRowSpace** ioSlot)</span>
<a href="#l65.124"></a><span id="l65.124">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l65.125"></a><span id="l65.125"> };</span>
<a href="#l65.126"></a><span id="l65.126"> </span>
<a href="#l65.127"></a><span id="l65.127"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l65.128"></a><span id="l65.128"> </span>
<a href="#l65.129"></a><span id="l65.129"> #define morkDerived_kRowSpaceMap  /*i*/ 0x725A /* ascii 'rZ' */</span>
<a href="#l65.130"></a><span id="l65.130" class="difflineat">@@ -185,49 +185,49 @@ public:</span>
<a href="#l65.131"></a><span id="l65.131"> public: // other map methods</span>
<a href="#l65.132"></a><span id="l65.132"> </span>
<a href="#l65.133"></a><span id="l65.133">   mork_bool  AddRowSpace(morkEnv* ev, morkRowSpace* ioRowSpace)</span>
<a href="#l65.134"></a><span id="l65.134">   { return this-&gt;AddNode(ev, ioRowSpace-&gt;SpaceScope(), ioRowSpace); }</span>
<a href="#l65.135"></a><span id="l65.135">   // the AddRowSpace() boolean return equals ev-&gt;Good().</span>
<a href="#l65.136"></a><span id="l65.136"> </span>
<a href="#l65.137"></a><span id="l65.137">   mork_bool  CutRowSpace(morkEnv* ev, mork_scope inScope)</span>
<a href="#l65.138"></a><span id="l65.138">   { return this-&gt;CutNode(ev, inScope); }</span>
<a href="#l65.139"></a><span id="l65.139" class="difflineminus">-  // The CutRowSpace() boolean return indicates whether removal happened. </span>
<a href="#l65.140"></a><span id="l65.140" class="difflineminus">-  </span>
<a href="#l65.141"></a><span id="l65.141" class="difflineplus">+  // The CutRowSpace() boolean return indicates whether removal happened.</span>
<a href="#l65.142"></a><span id="l65.142" class="difflineplus">+</span>
<a href="#l65.143"></a><span id="l65.143">   morkRowSpace*  GetRowSpace(morkEnv* ev, mork_scope inScope)</span>
<a href="#l65.144"></a><span id="l65.144">   { return (morkRowSpace*) this-&gt;GetNode(ev, inScope); }</span>
<a href="#l65.145"></a><span id="l65.145">   // Note the returned space does NOT have an increase in refcount for this.</span>
<a href="#l65.146"></a><span id="l65.146"> </span>
<a href="#l65.147"></a><span id="l65.147">   mork_num CutAllRowSpaces(morkEnv* ev)</span>
<a href="#l65.148"></a><span id="l65.148">   { return this-&gt;CutAllNodes(ev); }</span>
<a href="#l65.149"></a><span id="l65.149">   // CutAllRowSpaces() releases all the referenced table values.</span>
<a href="#l65.150"></a><span id="l65.150"> };</span>
<a href="#l65.151"></a><span id="l65.151"> </span>
<a href="#l65.152"></a><span id="l65.152"> class morkRowSpaceMapIter: public morkMapIter{ // typesafe wrapper class</span>
<a href="#l65.153"></a><span id="l65.153"> </span>
<a href="#l65.154"></a><span id="l65.154"> public:</span>
<a href="#l65.155"></a><span id="l65.155">   morkRowSpaceMapIter(morkEnv* ev, morkRowSpaceMap* ioMap)</span>
<a href="#l65.156"></a><span id="l65.156">   : morkMapIter(ev, ioMap) { }</span>
<a href="#l65.157"></a><span id="l65.157" class="difflineminus">- </span>
<a href="#l65.158"></a><span id="l65.158" class="difflineplus">+</span>
<a href="#l65.159"></a><span id="l65.159">   morkRowSpaceMapIter( ) : morkMapIter()  { }</span>
<a href="#l65.160"></a><span id="l65.160">   void InitRowSpaceMapIter(morkEnv* ev, morkRowSpaceMap* ioMap)</span>
<a href="#l65.161"></a><span id="l65.161">   { this-&gt;InitMapIter(ev, ioMap); }</span>
<a href="#l65.162"></a><span id="l65.162" class="difflineminus">-   </span>
<a href="#l65.163"></a><span id="l65.163" class="difflineplus">+</span>
<a href="#l65.164"></a><span id="l65.164">   mork_change*</span>
<a href="#l65.165"></a><span id="l65.165">   FirstRowSpace(morkEnv* ev, mork_scope* outScope, morkRowSpace** outRowSpace)</span>
<a href="#l65.166"></a><span id="l65.166">   { return this-&gt;First(ev, outScope, outRowSpace); }</span>
<a href="#l65.167"></a><span id="l65.167" class="difflineminus">-  </span>
<a href="#l65.168"></a><span id="l65.168" class="difflineplus">+</span>
<a href="#l65.169"></a><span id="l65.169">   mork_change*</span>
<a href="#l65.170"></a><span id="l65.170">   NextRowSpace(morkEnv* ev, mork_scope* outScope, morkRowSpace** outRowSpace)</span>
<a href="#l65.171"></a><span id="l65.171">   { return this-&gt;Next(ev, outScope, outRowSpace); }</span>
<a href="#l65.172"></a><span id="l65.172" class="difflineminus">-  </span>
<a href="#l65.173"></a><span id="l65.173" class="difflineplus">+</span>
<a href="#l65.174"></a><span id="l65.174">   mork_change*</span>
<a href="#l65.175"></a><span id="l65.175">   HereRowSpace(morkEnv* ev, mork_scope* outScope, morkRowSpace** outRowSpace)</span>
<a href="#l65.176"></a><span id="l65.176">   { return this-&gt;Here(ev, outScope, outRowSpace); }</span>
<a href="#l65.177"></a><span id="l65.177" class="difflineminus">-  </span>
<a href="#l65.178"></a><span id="l65.178" class="difflineplus">+</span>
<a href="#l65.179"></a><span id="l65.179">   mork_change*</span>
<a href="#l65.180"></a><span id="l65.180">   CutHereRowSpace(morkEnv* ev, mork_scope* outScope, morkRowSpace** outRowSpace)</span>
<a href="#l65.181"></a><span id="l65.181">   { return this-&gt;CutHere(ev, outScope, outRowSpace); }</span>
<a href="#l65.182"></a><span id="l65.182"> };</span>
<a href="#l65.183"></a><span id="l65.183"> </span>
<a href="#l65.184"></a><span id="l65.184"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l65.185"></a><span id="l65.185"> </span>
<a href="#l65.186"></a><span id="l65.186"> #endif /* _MORKROWSPACE_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l66.1"></a><span id="l66.1" class="difflineminus">--- a/db/mork/src/morkSearchRowCursor.cpp</span>
<a href="#l66.2"></a><span id="l66.2" class="difflineplus">+++ b/db/mork/src/morkSearchRowCursor.cpp</span>
<a href="#l66.3"></a><span id="l66.3" class="difflineat">@@ -40,17 +40,17 @@</span>
<a href="#l66.4"></a><span id="l66.4"> #endif</span>
<a href="#l66.5"></a><span id="l66.5"> </span>
<a href="#l66.6"></a><span id="l66.6"> #ifndef _MORKROW_</span>
<a href="#l66.7"></a><span id="l66.7"> #include &quot;morkRow.h&quot;</span>
<a href="#l66.8"></a><span id="l66.8"> #endif</span>
<a href="#l66.9"></a><span id="l66.9"> </span>
<a href="#l66.10"></a><span id="l66.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l66.11"></a><span id="l66.11"> </span>
<a href="#l66.12"></a><span id="l66.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l66.13"></a><span id="l66.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l66.14"></a><span id="l66.14"> // { ===== begin morkNode interface =====</span>
<a href="#l66.15"></a><span id="l66.15"> </span>
<a href="#l66.16"></a><span id="l66.16"> /*public virtual*/ void</span>
<a href="#l66.17"></a><span id="l66.17"> morkSearchRowCursor::CloseMorkNode(morkEnv* ev) // CloseSearchRowCursor() only if open</span>
<a href="#l66.18"></a><span id="l66.18"> {</span>
<a href="#l66.19"></a><span id="l66.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l66.20"></a><span id="l66.20">   {</span>
<a href="#l66.21"></a><span id="l66.21">     this-&gt;MarkClosing();</span>
<a href="#l66.22"></a><span id="l66.22" class="difflineat">@@ -84,51 +84,51 @@ morkSearchRowCursor::morkSearchRowCursor</span>
<a href="#l66.23"></a><span id="l66.23">       }</span>
<a href="#l66.24"></a><span id="l66.24">     }</span>
<a href="#l66.25"></a><span id="l66.25">     else</span>
<a href="#l66.26"></a><span id="l66.26">       ev-&gt;NilPointerError();</span>
<a href="#l66.27"></a><span id="l66.27">   }</span>
<a href="#l66.28"></a><span id="l66.28"> }</span>
<a href="#l66.29"></a><span id="l66.29"> </span>
<a href="#l66.30"></a><span id="l66.30"> /*public non-poly*/ void</span>
<a href="#l66.31"></a><span id="l66.31" class="difflineminus">-morkSearchRowCursor::CloseSearchRowCursor(morkEnv* ev) </span>
<a href="#l66.32"></a><span id="l66.32" class="difflineplus">+morkSearchRowCursor::CloseSearchRowCursor(morkEnv* ev)</span>
<a href="#l66.33"></a><span id="l66.33"> {</span>
<a href="#l66.34"></a><span id="l66.34">     if ( this-&gt;IsNode() )</span>
<a href="#l66.35"></a><span id="l66.35">     {</span>
<a href="#l66.36"></a><span id="l66.36">       // morkSorting::SlotWeakSorting((morkSorting*) 0, ev, &amp;mSortingRowCursor_Sorting);</span>
<a href="#l66.37"></a><span id="l66.37">       this-&gt;CloseTableRowCursor(ev);</span>
<a href="#l66.38"></a><span id="l66.38">       this-&gt;MarkShut();</span>
<a href="#l66.39"></a><span id="l66.39">     }</span>
<a href="#l66.40"></a><span id="l66.40">     else</span>
<a href="#l66.41"></a><span id="l66.41">       this-&gt;NonNodeError(ev);</span>
<a href="#l66.42"></a><span id="l66.42"> }</span>
<a href="#l66.43"></a><span id="l66.43"> </span>
<a href="#l66.44"></a><span id="l66.44"> // } ===== end morkNode methods =====</span>
<a href="#l66.45"></a><span id="l66.45" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l66.46"></a><span id="l66.46" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l66.47"></a><span id="l66.47"> </span>
<a href="#l66.48"></a><span id="l66.48"> /*static*/ void</span>
<a href="#l66.49"></a><span id="l66.49"> morkSearchRowCursor::NonSearchRowCursorTypeError(morkEnv* ev)</span>
<a href="#l66.50"></a><span id="l66.50"> {</span>
<a href="#l66.51"></a><span id="l66.51">   ev-&gt;NewError(&quot;non morkSearchRowCursor&quot;);</span>
<a href="#l66.52"></a><span id="l66.52"> }</span>
<a href="#l66.53"></a><span id="l66.53"> </span>
<a href="#l66.54"></a><span id="l66.54"> morkUniqRowCursor*</span>
<a href="#l66.55"></a><span id="l66.55"> morkSearchRowCursor::MakeUniqCursor(morkEnv* ev)</span>
<a href="#l66.56"></a><span id="l66.56"> {</span>
<a href="#l66.57"></a><span id="l66.57">   morkUniqRowCursor* outCursor = 0;</span>
<a href="#l66.58"></a><span id="l66.58" class="difflineminus">-  </span>
<a href="#l66.59"></a><span id="l66.59" class="difflineplus">+</span>
<a href="#l66.60"></a><span id="l66.60">   return outCursor;</span>
<a href="#l66.61"></a><span id="l66.61"> }</span>
<a href="#l66.62"></a><span id="l66.62"> </span>
<a href="#l66.63"></a><span id="l66.63"> #if 0</span>
<a href="#l66.64"></a><span id="l66.64"> orkinTableRowCursor*</span>
<a href="#l66.65"></a><span id="l66.65"> morkSearchRowCursor::AcquireUniqueRowCursorHandle(morkEnv* ev)</span>
<a href="#l66.66"></a><span id="l66.66"> {</span>
<a href="#l66.67"></a><span id="l66.67">   orkinTableRowCursor* outCursor = 0;</span>
<a href="#l66.68"></a><span id="l66.68" class="difflineminus">-  </span>
<a href="#l66.69"></a><span id="l66.69" class="difflineplus">+</span>
<a href="#l66.70"></a><span id="l66.70">   morkUniqRowCursor* uniqCursor = this-&gt;MakeUniqCursor(ev);</span>
<a href="#l66.71"></a><span id="l66.71">   if ( uniqCursor )</span>
<a href="#l66.72"></a><span id="l66.72">   {</span>
<a href="#l66.73"></a><span id="l66.73">     outCursor = uniqCursor-&gt;AcquireTableRowCursorHandle(ev);</span>
<a href="#l66.74"></a><span id="l66.74">     uniqCursor-&gt;CutStrongRef(ev);</span>
<a href="#l66.75"></a><span id="l66.75">   }</span>
<a href="#l66.76"></a><span id="l66.76">   return outCursor;</span>
<a href="#l66.77"></a><span id="l66.77"> }</span>
<a href="#l66.78"></a><span id="l66.78" class="difflineat">@@ -149,17 +149,17 @@ morkSearchRowCursor::GetMemberCount(mork</span>
<a href="#l66.79"></a><span id="l66.79">     return 0;</span>
<a href="#l66.80"></a><span id="l66.80"> }</span>
<a href="#l66.81"></a><span id="l66.81"> </span>
<a href="#l66.82"></a><span id="l66.82"> morkRow*</span>
<a href="#l66.83"></a><span id="l66.83"> morkSearchRowCursor::NextRow(morkEnv* ev, mdbOid* outOid, mdb_pos* outPos)</span>
<a href="#l66.84"></a><span id="l66.84"> {</span>
<a href="#l66.85"></a><span id="l66.85">   morkRow* outRow = 0;</span>
<a href="#l66.86"></a><span id="l66.86">   mork_pos pos = -1;</span>
<a href="#l66.87"></a><span id="l66.87" class="difflineminus">-  </span>
<a href="#l66.88"></a><span id="l66.88" class="difflineplus">+</span>
<a href="#l66.89"></a><span id="l66.89">   morkTable* table = mTableRowCursor_Table;</span>
<a href="#l66.90"></a><span id="l66.90">   if ( table )</span>
<a href="#l66.91"></a><span id="l66.91">   {</span>
<a href="#l66.92"></a><span id="l66.92">   }</span>
<a href="#l66.93"></a><span id="l66.93">   else</span>
<a href="#l66.94"></a><span id="l66.94">     ev-&gt;NilPointerError();</span>
<a href="#l66.95"></a><span id="l66.95"> </span>
<a href="#l66.96"></a><span id="l66.96">   *outPos = pos;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l67.1"></a><span id="l67.1" class="difflineminus">--- a/db/mork/src/morkSearchRowCursor.h</span>
<a href="#l67.2"></a><span id="l67.2" class="difflineplus">+++ b/db/mork/src/morkSearchRowCursor.h</span>
<a href="#l67.3"></a><span id="l67.3" class="difflineat">@@ -46,22 +46,22 @@ class morkSearchRowCursor : public morkT</span>
<a href="#l67.4"></a><span id="l67.4">   // mork_seed  mCursor_Seed;</span>
<a href="#l67.5"></a><span id="l67.5">   // mork_pos   mCursor_Pos;</span>
<a href="#l67.6"></a><span id="l67.6">   // mork_bool  mCursor_DoFailOnSeedOutOfSync;</span>
<a href="#l67.7"></a><span id="l67.7">   // mork_u1    mCursor_Pad[ 3 ]; // explicitly pad to u4 alignment</span>
<a href="#l67.8"></a><span id="l67.8"> </span>
<a href="#l67.9"></a><span id="l67.9">   // morkTable*  mTableRowCursor_Table; // weak ref to table</span>
<a href="#l67.10"></a><span id="l67.10"> </span>
<a href="#l67.11"></a><span id="l67.11"> public: // state is public because the entire Mork system is private</span>
<a href="#l67.12"></a><span id="l67.12" class="difflineminus">-    </span>
<a href="#l67.13"></a><span id="l67.13" class="difflineplus">+</span>
<a href="#l67.14"></a><span id="l67.14"> // { ===== begin morkNode interface =====</span>
<a href="#l67.15"></a><span id="l67.15"> public: // morkNode virtual methods</span>
<a href="#l67.16"></a><span id="l67.16">   virtual void CloseMorkNode(morkEnv* ev); // CloseSearchRowCursor()</span>
<a href="#l67.17"></a><span id="l67.17">   virtual ~morkSearchRowCursor(); // assert that close executed earlier</span>
<a href="#l67.18"></a><span id="l67.18" class="difflineminus">-  </span>
<a href="#l67.19"></a><span id="l67.19" class="difflineplus">+</span>
<a href="#l67.20"></a><span id="l67.20"> public: // morkSearchRowCursor construction &amp; destruction</span>
<a href="#l67.21"></a><span id="l67.21">   morkSearchRowCursor(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l67.22"></a><span id="l67.22">     nsIMdbHeap* ioHeap, morkTable* ioTable, mork_pos inRowPos);</span>
<a href="#l67.23"></a><span id="l67.23">   void CloseSearchRowCursor(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l67.24"></a><span id="l67.24"> </span>
<a href="#l67.25"></a><span id="l67.25"> private: // copying is not allowed</span>
<a href="#l67.26"></a><span id="l67.26">   morkSearchRowCursor(const morkSearchRowCursor&amp; other);</span>
<a href="#l67.27"></a><span id="l67.27">   morkSearchRowCursor&amp; operator=(const morkSearchRowCursor&amp; other);</span>
<a href="#l67.28"></a><span id="l67.28" class="difflineat">@@ -89,17 +89,17 @@ public: // other search row cursor metho</span>
<a href="#l67.29"></a><span id="l67.29"> </span>
<a href="#l67.30"></a><span id="l67.30">   // virtual mdb_pos NextRowOid(morkEnv* ev, mdbOid* outOid);</span>
<a href="#l67.31"></a><span id="l67.31">   virtual morkRow* NextRow(morkEnv* ev, mdbOid* outOid, mdb_pos* outPos);</span>
<a href="#l67.32"></a><span id="l67.32"> </span>
<a href="#l67.33"></a><span id="l67.33"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l67.34"></a><span id="l67.34">   static void SlotWeakSearchRowCursor(morkSearchRowCursor* me,</span>
<a href="#l67.35"></a><span id="l67.35">     morkEnv* ev, morkSearchRowCursor** ioSlot)</span>
<a href="#l67.36"></a><span id="l67.36">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l67.37"></a><span id="l67.37" class="difflineminus">-  </span>
<a href="#l67.38"></a><span id="l67.38" class="difflineplus">+</span>
<a href="#l67.39"></a><span id="l67.39">   static void SlotStrongSearchRowCursor(morkSearchRowCursor* me,</span>
<a href="#l67.40"></a><span id="l67.40">     morkEnv* ev, morkSearchRowCursor** ioSlot)</span>
<a href="#l67.41"></a><span id="l67.41">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l67.42"></a><span id="l67.42"> };</span>
<a href="#l67.43"></a><span id="l67.43"> </span>
<a href="#l67.44"></a><span id="l67.44"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l67.45"></a><span id="l67.45"> </span>
<a href="#l67.46"></a><span id="l67.46"> #endif /* _MORKSEARCHROWCURSOR_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l68.1"></a><span id="l68.1" class="difflineminus">--- a/db/mork/src/morkSink.cpp</span>
<a href="#l68.2"></a><span id="l68.2" class="difflineplus">+++ b/db/mork/src/morkSink.cpp</span>
<a href="#l68.3"></a><span id="l68.3" class="difflineat">@@ -127,17 +127,17 @@ morkSpool::SpillPutc(morkEnv* ev, int c)</span>
<a href="#l68.4"></a><span id="l68.4">     }</span>
<a href="#l68.5"></a><span id="l68.5">     else</span>
<a href="#l68.6"></a><span id="l68.6">       coil-&gt;NilBufBodyError(ev);</span>
<a href="#l68.7"></a><span id="l68.7">   }</span>
<a href="#l68.8"></a><span id="l68.8">   else</span>
<a href="#l68.9"></a><span id="l68.9">     this-&gt;NilSpoolCoilError(ev);</span>
<a href="#l68.10"></a><span id="l68.10"> }</span>
<a href="#l68.11"></a><span id="l68.11"> </span>
<a href="#l68.12"></a><span id="l68.12" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l68.13"></a><span id="l68.13" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l68.14"></a><span id="l68.14"> // public: // public non-poly morkSink methods</span>
<a href="#l68.15"></a><span id="l68.15"> </span>
<a href="#l68.16"></a><span id="l68.16"> /*virtual*/</span>
<a href="#l68.17"></a><span id="l68.17"> morkSpool::~morkSpool()</span>
<a href="#l68.18"></a><span id="l68.18"> // Zero all slots to show this sink is disabled, but destroy no memory.</span>
<a href="#l68.19"></a><span id="l68.19"> // Note it is typically unnecessary to flush this coil sink, since all</span>
<a href="#l68.20"></a><span id="l68.20"> // content is written directly to the coil without any buffering.</span>
<a href="#l68.21"></a><span id="l68.21"> {</span>
<a href="#l68.22"></a><span id="l68.22" class="difflineat">@@ -148,17 +148,17 @@ morkSpool::~morkSpool()</span>
<a href="#l68.23"></a><span id="l68.23"> </span>
<a href="#l68.24"></a><span id="l68.24"> morkSpool::morkSpool(morkEnv* ev, morkCoil* ioCoil)</span>
<a href="#l68.25"></a><span id="l68.25"> // After installing the coil, calls Seek(ev, 0) to prepare for writing.</span>
<a href="#l68.26"></a><span id="l68.26"> : morkSink()</span>
<a href="#l68.27"></a><span id="l68.27"> , mSpool_Coil( 0 )</span>
<a href="#l68.28"></a><span id="l68.28"> {</span>
<a href="#l68.29"></a><span id="l68.29">   mSink_At = 0; // set correctly later in Seek()</span>
<a href="#l68.30"></a><span id="l68.30">   mSink_End = 0; // set correctly later in Seek()</span>
<a href="#l68.31"></a><span id="l68.31" class="difflineminus">-  </span>
<a href="#l68.32"></a><span id="l68.32" class="difflineplus">+</span>
<a href="#l68.33"></a><span id="l68.33">   if ( ev-&gt;Good() )</span>
<a href="#l68.34"></a><span id="l68.34">   {</span>
<a href="#l68.35"></a><span id="l68.35">     if ( ioCoil )</span>
<a href="#l68.36"></a><span id="l68.36">     {</span>
<a href="#l68.37"></a><span id="l68.37">       mSpool_Coil = ioCoil;</span>
<a href="#l68.38"></a><span id="l68.38">       this-&gt;Seek(ev, /*pos*/ 0);</span>
<a href="#l68.39"></a><span id="l68.39">     }</span>
<a href="#l68.40"></a><span id="l68.40">     else</span>
<a href="#l68.41"></a><span id="l68.41" class="difflineat">@@ -184,46 +184,46 @@ mork_bool</span>
<a href="#l68.42"></a><span id="l68.42"> morkSpool::Seek(morkEnv* ev, mork_pos inPos)</span>
<a href="#l68.43"></a><span id="l68.43"> // Changed the current write position in coil's buffer to inPos.</span>
<a href="#l68.44"></a><span id="l68.44"> // For example, to start writing the coil from scratch, use inPos==0.</span>
<a href="#l68.45"></a><span id="l68.45"> {</span>
<a href="#l68.46"></a><span id="l68.46">   morkCoil* coil = mSpool_Coil;</span>
<a href="#l68.47"></a><span id="l68.47">   if ( coil )</span>
<a href="#l68.48"></a><span id="l68.48">   {</span>
<a href="#l68.49"></a><span id="l68.49">     mork_size minSize = (mork_size) (inPos + 64);</span>
<a href="#l68.50"></a><span id="l68.50" class="difflineminus">-    </span>
<a href="#l68.51"></a><span id="l68.51" class="difflineplus">+</span>
<a href="#l68.52"></a><span id="l68.52">     if ( coil-&gt;mBlob_Size &lt; minSize )</span>
<a href="#l68.53"></a><span id="l68.53">       coil-&gt;GrowCoil(ev, minSize);</span>
<a href="#l68.54"></a><span id="l68.54" class="difflineminus">-      </span>
<a href="#l68.55"></a><span id="l68.55" class="difflineplus">+</span>
<a href="#l68.56"></a><span id="l68.56">     if ( ev-&gt;Good() )</span>
<a href="#l68.57"></a><span id="l68.57">     {</span>
<a href="#l68.58"></a><span id="l68.58">       coil-&gt;mBuf_Fill = (mork_fill) inPos;</span>
<a href="#l68.59"></a><span id="l68.59">       mork_u1* body = (mork_u1*) coil-&gt;mBuf_Body;</span>
<a href="#l68.60"></a><span id="l68.60">       if ( body )</span>
<a href="#l68.61"></a><span id="l68.61">       {</span>
<a href="#l68.62"></a><span id="l68.62">         mSink_At = body + inPos;</span>
<a href="#l68.63"></a><span id="l68.63">         mSink_End = body + coil-&gt;mBlob_Size;</span>
<a href="#l68.64"></a><span id="l68.64">       }</span>
<a href="#l68.65"></a><span id="l68.65">       else</span>
<a href="#l68.66"></a><span id="l68.66">         coil-&gt;NilBufBodyError(ev);</span>
<a href="#l68.67"></a><span id="l68.67">     }</span>
<a href="#l68.68"></a><span id="l68.68">   }</span>
<a href="#l68.69"></a><span id="l68.69">   else</span>
<a href="#l68.70"></a><span id="l68.70">     this-&gt;NilSpoolCoilError(ev);</span>
<a href="#l68.71"></a><span id="l68.71" class="difflineminus">-    </span>
<a href="#l68.72"></a><span id="l68.72" class="difflineplus">+</span>
<a href="#l68.73"></a><span id="l68.73">   return ev-&gt;Good();</span>
<a href="#l68.74"></a><span id="l68.74"> }</span>
<a href="#l68.75"></a><span id="l68.75"> </span>
<a href="#l68.76"></a><span id="l68.76"> mork_bool</span>
<a href="#l68.77"></a><span id="l68.77"> morkSpool::Write(morkEnv* ev, const void* inBuf, mork_size inSize)</span>
<a href="#l68.78"></a><span id="l68.78"> // write inSize bytes of inBuf to current position inside coil's buffer</span>
<a href="#l68.79"></a><span id="l68.79"> {</span>
<a href="#l68.80"></a><span id="l68.80">   // This method is conceptually very similar to morkStream::Write(),</span>
<a href="#l68.81"></a><span id="l68.81">   // and this code was written while looking at that method for clues.</span>
<a href="#l68.82"></a><span id="l68.82" class="difflineminus">- </span>
<a href="#l68.83"></a><span id="l68.83" class="difflineplus">+</span>
<a href="#l68.84"></a><span id="l68.84">   morkCoil* coil = mSpool_Coil;</span>
<a href="#l68.85"></a><span id="l68.85">   if ( coil )</span>
<a href="#l68.86"></a><span id="l68.86">   {</span>
<a href="#l68.87"></a><span id="l68.87">     mork_u1* body = (mork_u1*) coil-&gt;mBuf_Body;</span>
<a href="#l68.88"></a><span id="l68.88">     if ( body )</span>
<a href="#l68.89"></a><span id="l68.89">     {</span>
<a href="#l68.90"></a><span id="l68.90">       if ( inBuf &amp;&amp; inSize ) // anything to write?</span>
<a href="#l68.91"></a><span id="l68.91">       {</span>
<a href="#l68.92"></a><span id="l68.92" class="difflineat">@@ -267,17 +267,17 @@ morkSpool::Write(morkEnv* ev, const void</span>
<a href="#l68.93"></a><span id="l68.93">           this-&gt;BadSpoolCursorOrderError(ev);</span>
<a href="#l68.94"></a><span id="l68.94">       }</span>
<a href="#l68.95"></a><span id="l68.95">     }</span>
<a href="#l68.96"></a><span id="l68.96">     else</span>
<a href="#l68.97"></a><span id="l68.97">       coil-&gt;NilBufBodyError(ev);</span>
<a href="#l68.98"></a><span id="l68.98">   }</span>
<a href="#l68.99"></a><span id="l68.99">   else</span>
<a href="#l68.100"></a><span id="l68.100">     this-&gt;NilSpoolCoilError(ev);</span>
<a href="#l68.101"></a><span id="l68.101" class="difflineminus">-  </span>
<a href="#l68.102"></a><span id="l68.102" class="difflineplus">+</span>
<a href="#l68.103"></a><span id="l68.103">   return ev-&gt;Good();</span>
<a href="#l68.104"></a><span id="l68.104"> }</span>
<a href="#l68.105"></a><span id="l68.105"> </span>
<a href="#l68.106"></a><span id="l68.106"> mork_bool</span>
<a href="#l68.107"></a><span id="l68.107"> morkSpool::PutString(morkEnv* ev, const char* inString)</span>
<a href="#l68.108"></a><span id="l68.108"> // call Write() with inBuf=inString and inSize=strlen(inString),</span>
<a href="#l68.109"></a><span id="l68.109"> // unless inString is null, in which case we then do nothing at all.</span>
<a href="#l68.110"></a><span id="l68.110"> {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l69.1"></a><span id="l69.1" class="difflineminus">--- a/db/mork/src/morkSink.h</span>
<a href="#l69.2"></a><span id="l69.2" class="difflineplus">+++ b/db/mork/src/morkSink.h</span>
<a href="#l69.3"></a><span id="l69.3" class="difflineat">@@ -45,17 +45,17 @@</span>
<a href="#l69.4"></a><span id="l69.4"> **| where End is beyond the last writable byte, and At is less than or</span>
<a href="#l69.5"></a><span id="l69.5"> **| equal to this point inside the same buffer.  With some kinds of</span>
<a href="#l69.6"></a><span id="l69.6"> **| medium, such as writing to an instance of morkBlob, it is feasible</span>
<a href="#l69.7"></a><span id="l69.7"> **| to point directly into the final resting place for all the content</span>
<a href="#l69.8"></a><span id="l69.8"> **| written to the medium.  Other mediums such as files, which write</span>
<a href="#l69.9"></a><span id="l69.9"> **| only through function calls, will typically need a local buffer</span>
<a href="#l69.10"></a><span id="l69.10"> **| to efficiently accumulate many bytes between such function calls.</span>
<a href="#l69.11"></a><span id="l69.11"> **|</span>
<a href="#l69.12"></a><span id="l69.12" class="difflineminus">-**|| FlushSink: this flush method should move any buffered content to </span>
<a href="#l69.13"></a><span id="l69.13" class="difflineplus">+**|| FlushSink: this flush method should move any buffered content to</span>
<a href="#l69.14"></a><span id="l69.14"> **| its final destination.  For example, for buffered writes to a</span>
<a href="#l69.15"></a><span id="l69.15"> **| string medium, where string methods are function calls and not just</span>
<a href="#l69.16"></a><span id="l69.16"> **| inline macros, it is faster to accumulate many bytes in a small</span>
<a href="#l69.17"></a><span id="l69.17"> **| local buffer and then move these en masse later in a single call.</span>
<a href="#l69.18"></a><span id="l69.18"> **|</span>
<a href="#l69.19"></a><span id="l69.19"> **|| SpillPutc: when At is greater than or equal to End, this means an</span>
<a href="#l69.20"></a><span id="l69.20"> **| underlying buffer has become full, so the buffer must be flushed</span>
<a href="#l69.21"></a><span id="l69.21"> **| before a new byte can be written.  The intention is that SpillPutc()</span>
<a href="#l69.22"></a><span id="l69.22" class="difflineat">@@ -63,42 +63,42 @@</span>
<a href="#l69.23"></a><span id="l69.23"> **| to Putc(), where the flush is expected to make At less then End once</span>
<a href="#l69.24"></a><span id="l69.24"> **| again.  Except that FlushSink() need not make the underlying buffer</span>
<a href="#l69.25"></a><span id="l69.25"> **| any larger, and SpillPutc() typically must make room for more bytes.</span>
<a href="#l69.26"></a><span id="l69.26"> **| Note subclasses might want to guard against the case that both At</span>
<a href="#l69.27"></a><span id="l69.27"> **| and End are null, which happens when a sink is destroyed, which sets</span>
<a href="#l69.28"></a><span id="l69.28"> **| both these pointers to null as an indication the sink is disabled.</span>
<a href="#l69.29"></a><span id="l69.29"> |*/</span>
<a href="#l69.30"></a><span id="l69.30"> class morkSink {</span>
<a href="#l69.31"></a><span id="l69.31" class="difflineminus">-    </span>
<a href="#l69.32"></a><span id="l69.32" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l69.33"></a><span id="l69.33" class="difflineplus">+</span>
<a href="#l69.34"></a><span id="l69.34" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l69.35"></a><span id="l69.35"> public: // public sink virtual methods</span>
<a href="#l69.36"></a><span id="l69.36"> </span>
<a href="#l69.37"></a><span id="l69.37">   virtual void FlushSink(morkEnv* ev) = 0;</span>
<a href="#l69.38"></a><span id="l69.38">   virtual void SpillPutc(morkEnv* ev, int c) = 0;</span>
<a href="#l69.39"></a><span id="l69.39"> </span>
<a href="#l69.40"></a><span id="l69.40" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l69.41"></a><span id="l69.41" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l69.42"></a><span id="l69.42"> public: // member variables</span>
<a href="#l69.43"></a><span id="l69.43"> </span>
<a href="#l69.44"></a><span id="l69.44">   mork_u1*     mSink_At;     // pointer into mSink_Buf</span>
<a href="#l69.45"></a><span id="l69.45">   mork_u1*     mSink_End;    // one byte past last content byte</span>
<a href="#l69.46"></a><span id="l69.46"> </span>
<a href="#l69.47"></a><span id="l69.47"> // define morkSink_kBufSize 256 /* small enough to go on stack */</span>
<a href="#l69.48"></a><span id="l69.48"> </span>
<a href="#l69.49"></a><span id="l69.49">   // mork_u1      mSink_Buf[ morkSink_kBufSize + 4 ];</span>
<a href="#l69.50"></a><span id="l69.50">   // want plus one for any needed end null byte; use plus 4 for alignment</span>
<a href="#l69.51"></a><span id="l69.51" class="difflineminus">-   </span>
<a href="#l69.52"></a><span id="l69.52" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l69.53"></a><span id="l69.53" class="difflineplus">+</span>
<a href="#l69.54"></a><span id="l69.54" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l69.55"></a><span id="l69.55"> public: // public non-poly morkSink methods</span>
<a href="#l69.56"></a><span id="l69.56"> </span>
<a href="#l69.57"></a><span id="l69.57">   virtual ~morkSink(); // zero both At and End; virtual for subclasses</span>
<a href="#l69.58"></a><span id="l69.58">   morkSink() { } // does nothing; subclasses must set At and End suitably</span>
<a href="#l69.59"></a><span id="l69.59"> </span>
<a href="#l69.60"></a><span id="l69.60">   void Putc(morkEnv* ev, int c)</span>
<a href="#l69.61"></a><span id="l69.61" class="difflineminus">-  { </span>
<a href="#l69.62"></a><span id="l69.62" class="difflineplus">+  {</span>
<a href="#l69.63"></a><span id="l69.63">     if ( mSink_At &lt; mSink_End )</span>
<a href="#l69.64"></a><span id="l69.64">       *mSink_At++ = (mork_u1) c;</span>
<a href="#l69.65"></a><span id="l69.65">     else</span>
<a href="#l69.66"></a><span id="l69.66">       this-&gt;SpillPutc(ev, c);</span>
<a href="#l69.67"></a><span id="l69.67">   }</span>
<a href="#l69.68"></a><span id="l69.68"> };</span>
<a href="#l69.69"></a><span id="l69.69"> </span>
<a href="#l69.70"></a><span id="l69.70"> /*| morkSpool: an output sink that efficiently writes individual bytes</span>
<a href="#l69.71"></a><span id="l69.71" class="difflineat">@@ -108,54 +108,54 @@ public: // public non-poly morkSink meth</span>
<a href="#l69.72"></a><span id="l69.72"> **|| Note we do not &quot;own&quot; the coil referenced by mSpool_Coil, and</span>
<a href="#l69.73"></a><span id="l69.73"> **| the lifetime of the coil is expected to equal or exceed that of this</span>
<a href="#l69.74"></a><span id="l69.74"> **| sink by some external means.  Typical usage might involve keeping an</span>
<a href="#l69.75"></a><span id="l69.75"> **| instance of morkCoil and an instance of morkSpool in the same</span>
<a href="#l69.76"></a><span id="l69.76"> **| owning parent object, which uses the spool with the associated coil.</span>
<a href="#l69.77"></a><span id="l69.77"> |*/</span>
<a href="#l69.78"></a><span id="l69.78"> class morkSpool : public morkSink { // for buffered i/o to a morkCoil</span>
<a href="#l69.79"></a><span id="l69.79"> </span>
<a href="#l69.80"></a><span id="l69.80" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l69.81"></a><span id="l69.81" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l69.82"></a><span id="l69.82"> public: // public sink virtual methods</span>
<a href="#l69.83"></a><span id="l69.83"> </span>
<a href="#l69.84"></a><span id="l69.84">   // when morkSink::Putc() moves mSink_At, mSpool_Coil-&gt;mBuf_Fill is wrong:</span>
<a href="#l69.85"></a><span id="l69.85"> </span>
<a href="#l69.86"></a><span id="l69.86">   virtual void FlushSink(morkEnv* ev); // sync mSpool_Coil-&gt;mBuf_Fill</span>
<a href="#l69.87"></a><span id="l69.87">   virtual void SpillPutc(morkEnv* ev, int c); // grow coil and write byte</span>
<a href="#l69.88"></a><span id="l69.88"> </span>
<a href="#l69.89"></a><span id="l69.89" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l69.90"></a><span id="l69.90" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l69.91"></a><span id="l69.91"> public: // member variables</span>
<a href="#l69.92"></a><span id="l69.92">   morkCoil*   mSpool_Coil; // destination medium for written bytes</span>
<a href="#l69.93"></a><span id="l69.93" class="difflineminus">-    </span>
<a href="#l69.94"></a><span id="l69.94" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l69.95"></a><span id="l69.95" class="difflineplus">+</span>
<a href="#l69.96"></a><span id="l69.96" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l69.97"></a><span id="l69.97"> public: // public non-poly morkSink methods</span>
<a href="#l69.98"></a><span id="l69.98"> </span>
<a href="#l69.99"></a><span id="l69.99">   static void BadSpoolCursorOrderError(morkEnv* ev);</span>
<a href="#l69.100"></a><span id="l69.100">   static void NilSpoolCoilError(morkEnv* ev);</span>
<a href="#l69.101"></a><span id="l69.101"> </span>
<a href="#l69.102"></a><span id="l69.102">   virtual ~morkSpool();</span>
<a href="#l69.103"></a><span id="l69.103">   // Zero all slots to show this sink is disabled, but destroy no memory.</span>
<a href="#l69.104"></a><span id="l69.104">   // Note it is typically unnecessary to flush this coil sink, since all</span>
<a href="#l69.105"></a><span id="l69.105">   // content is written directly to the coil without any buffering.</span>
<a href="#l69.106"></a><span id="l69.106" class="difflineminus">-  </span>
<a href="#l69.107"></a><span id="l69.107" class="difflineplus">+</span>
<a href="#l69.108"></a><span id="l69.108">   morkSpool(morkEnv* ev, morkCoil* ioCoil);</span>
<a href="#l69.109"></a><span id="l69.109">   // After installing the coil, calls Seek(ev, 0) to prepare for writing.</span>
<a href="#l69.110"></a><span id="l69.110" class="difflineminus">-  </span>
<a href="#l69.111"></a><span id="l69.111" class="difflineplus">+</span>
<a href="#l69.112"></a><span id="l69.112">   // ----- All boolean return values below are equal to ev-&gt;Good(): -----</span>
<a href="#l69.113"></a><span id="l69.113"> </span>
<a href="#l69.114"></a><span id="l69.114">   mork_bool Seek(morkEnv* ev, mork_pos inPos);</span>
<a href="#l69.115"></a><span id="l69.115">   // Changed the current write position in coil's buffer to inPos.</span>
<a href="#l69.116"></a><span id="l69.116">   // For example, to start writing the coil from scratch, use inPos==0.</span>
<a href="#l69.117"></a><span id="l69.117"> </span>
<a href="#l69.118"></a><span id="l69.118">   mork_bool Write(morkEnv* ev, const void* inBuf, mork_size inSize);</span>
<a href="#l69.119"></a><span id="l69.119">   // write inSize bytes of inBuf to current position inside coil's buffer</span>
<a href="#l69.120"></a><span id="l69.120"> </span>
<a href="#l69.121"></a><span id="l69.121">   mork_bool PutBuf(morkEnv* ev, const morkBuf&amp; inBuffer)</span>
<a href="#l69.122"></a><span id="l69.122">   { return this-&gt;Write(ev, inBuffer.mBuf_Body, inBuffer.mBuf_Fill); }</span>
<a href="#l69.123"></a><span id="l69.123" class="difflineminus">-  </span>
<a href="#l69.124"></a><span id="l69.124" class="difflineplus">+</span>
<a href="#l69.125"></a><span id="l69.125">   mork_bool PutString(morkEnv* ev, const char* inString);</span>
<a href="#l69.126"></a><span id="l69.126">   // call Write() with inBuf=inString and inSize=strlen(inString),</span>
<a href="#l69.127"></a><span id="l69.127">   // unless inString is null, in which case we then do nothing at all.</span>
<a href="#l69.128"></a><span id="l69.128"> };</span>
<a href="#l69.129"></a><span id="l69.129"> </span>
<a href="#l69.130"></a><span id="l69.130"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l69.131"></a><span id="l69.131"> </span>
<a href="#l69.132"></a><span id="l69.132"> #endif /* _MORKSINK_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l70.1"></a><span id="l70.1" class="difflineminus">--- a/db/mork/src/morkSpace.cpp</span>
<a href="#l70.2"></a><span id="l70.2" class="difflineplus">+++ b/db/mork/src/morkSpace.cpp</span>
<a href="#l70.3"></a><span id="l70.3" class="difflineat">@@ -32,17 +32,17 @@</span>
<a href="#l70.4"></a><span id="l70.4"> #endif</span>
<a href="#l70.5"></a><span id="l70.5"> </span>
<a href="#l70.6"></a><span id="l70.6"> #ifndef _MORKSTORE_</span>
<a href="#l70.7"></a><span id="l70.7"> #include &quot;morkStore.h&quot;</span>
<a href="#l70.8"></a><span id="l70.8"> #endif</span>
<a href="#l70.9"></a><span id="l70.9"> </span>
<a href="#l70.10"></a><span id="l70.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l70.11"></a><span id="l70.11"> </span>
<a href="#l70.12"></a><span id="l70.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l70.13"></a><span id="l70.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l70.14"></a><span id="l70.14"> // { ===== begin morkNode interface =====</span>
<a href="#l70.15"></a><span id="l70.15"> </span>
<a href="#l70.16"></a><span id="l70.16"> /*public virtual*/ void</span>
<a href="#l70.17"></a><span id="l70.17"> morkSpace::CloseMorkNode(morkEnv* ev) // CloseSpace() only if open</span>
<a href="#l70.18"></a><span id="l70.18"> {</span>
<a href="#l70.19"></a><span id="l70.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l70.20"></a><span id="l70.20">   {</span>
<a href="#l70.21"></a><span id="l70.21">     this-&gt;MarkClosing();</span>
<a href="#l70.22"></a><span id="l70.22" class="difflineat">@@ -52,17 +52,17 @@ morkSpace::CloseMorkNode(morkEnv* ev) //</span>
<a href="#l70.23"></a><span id="l70.23"> }</span>
<a href="#l70.24"></a><span id="l70.24"> </span>
<a href="#l70.25"></a><span id="l70.25"> /*public virtual*/</span>
<a href="#l70.26"></a><span id="l70.26"> morkSpace::~morkSpace() // assert CloseSpace() executed earlier</span>
<a href="#l70.27"></a><span id="l70.27"> {</span>
<a href="#l70.28"></a><span id="l70.28">   MORK_ASSERT(SpaceScope()==0);</span>
<a href="#l70.29"></a><span id="l70.29">   MORK_ASSERT(mSpace_Store==0);</span>
<a href="#l70.30"></a><span id="l70.30">   MORK_ASSERT(this-&gt;IsShutNode());</span>
<a href="#l70.31"></a><span id="l70.31" class="difflineminus">-}    </span>
<a href="#l70.32"></a><span id="l70.32" class="difflineplus">+}</span>
<a href="#l70.33"></a><span id="l70.33"> </span>
<a href="#l70.34"></a><span id="l70.34"> /*public non-poly*/</span>
<a href="#l70.35"></a><span id="l70.35"> //morkSpace::morkSpace(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l70.36"></a><span id="l70.36"> //  nsIMdbHeap* ioNodeHeap, const morkMapForm&amp; inForm,</span>
<a href="#l70.37"></a><span id="l70.37"> //  nsIMdbHeap* ioSlotHeap)</span>
<a href="#l70.38"></a><span id="l70.38"> //: morkNode(ev, inUsage, ioNodeHeap)</span>
<a href="#l70.39"></a><span id="l70.39"> //, mSpace_Map(ev, morkUsage::kMember, (nsIMdbHeap*) 0, ioSlotHeap)</span>
<a href="#l70.40"></a><span id="l70.40"> //{</span>
<a href="#l70.41"></a><span id="l70.41" class="difflineat">@@ -83,17 +83,17 @@ morkSpace::morkSpace(morkEnv* ev,</span>
<a href="#l70.42"></a><span id="l70.42">   {</span>
<a href="#l70.43"></a><span id="l70.43">     if ( ioStore &amp;&amp; ioSlotHeap )</span>
<a href="#l70.44"></a><span id="l70.44">     {</span>
<a href="#l70.45"></a><span id="l70.45">       morkStore::SlotWeakStore(ioStore, ev, &amp;mSpace_Store);</span>
<a href="#l70.46"></a><span id="l70.46"> </span>
<a href="#l70.47"></a><span id="l70.47">       mSpace_CanDirty = ioStore-&gt;mStore_CanDirty;</span>
<a href="#l70.48"></a><span id="l70.48">       if ( mSpace_CanDirty ) // this new space dirties the store?</span>
<a href="#l70.49"></a><span id="l70.49">         this-&gt;MaybeDirtyStoreAndSpace();</span>
<a href="#l70.50"></a><span id="l70.50" class="difflineminus">-        </span>
<a href="#l70.51"></a><span id="l70.51" class="difflineplus">+</span>
<a href="#l70.52"></a><span id="l70.52">       if ( ev-&gt;Good() )</span>
<a href="#l70.53"></a><span id="l70.53">         mNode_Derived = morkDerived_kSpace;</span>
<a href="#l70.54"></a><span id="l70.54">     }</span>
<a href="#l70.55"></a><span id="l70.55">     else</span>
<a href="#l70.56"></a><span id="l70.56">       ev-&gt;NilPointerError();</span>
<a href="#l70.57"></a><span id="l70.57">   }</span>
<a href="#l70.58"></a><span id="l70.58"> }</span>
<a href="#l70.59"></a><span id="l70.59"> </span>
<a href="#l70.60"></a><span id="l70.60" class="difflineat">@@ -106,25 +106,25 @@ morkSpace::CloseSpace(morkEnv* ev) // ca</span>
<a href="#l70.61"></a><span id="l70.61">       mBead_Color = 0; // this-&gt;CloseBead();</span>
<a href="#l70.62"></a><span id="l70.62">       this-&gt;MarkShut();</span>
<a href="#l70.63"></a><span id="l70.63">     }</span>
<a href="#l70.64"></a><span id="l70.64">     else</span>
<a href="#l70.65"></a><span id="l70.65">       this-&gt;NonNodeError(ev);</span>
<a href="#l70.66"></a><span id="l70.66"> }</span>
<a href="#l70.67"></a><span id="l70.67"> </span>
<a href="#l70.68"></a><span id="l70.68"> // } ===== end morkNode methods =====</span>
<a href="#l70.69"></a><span id="l70.69" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l70.70"></a><span id="l70.70" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l70.71"></a><span id="l70.71"> </span>
<a href="#l70.72"></a><span id="l70.72" class="difflineminus">-/*static*/ void </span>
<a href="#l70.73"></a><span id="l70.73" class="difflineplus">+/*static*/ void</span>
<a href="#l70.74"></a><span id="l70.74"> morkSpace::NonAsciiSpaceScopeName(morkEnv* ev)</span>
<a href="#l70.75"></a><span id="l70.75"> {</span>
<a href="#l70.76"></a><span id="l70.76">   ev-&gt;NewError(&quot;SpaceScope() &gt; 0x7F&quot;);</span>
<a href="#l70.77"></a><span id="l70.77"> }</span>
<a href="#l70.78"></a><span id="l70.78"> </span>
<a href="#l70.79"></a><span id="l70.79" class="difflineminus">-/*static*/ void </span>
<a href="#l70.80"></a><span id="l70.80" class="difflineplus">+/*static*/ void</span>
<a href="#l70.81"></a><span id="l70.81"> morkSpace::NilSpaceStoreError(morkEnv* ev)</span>
<a href="#l70.82"></a><span id="l70.82"> {</span>
<a href="#l70.83"></a><span id="l70.83">   ev-&gt;NewError(&quot;nil mSpace_Store&quot;);</span>
<a href="#l70.84"></a><span id="l70.84"> }</span>
<a href="#l70.85"></a><span id="l70.85"> </span>
<a href="#l70.86"></a><span id="l70.86"> morkPool* morkSpace::GetSpaceStorePool() const</span>
<a href="#l70.87"></a><span id="l70.87"> {</span>
<a href="#l70.88"></a><span id="l70.88">   return &amp;mSpace_Store-&gt;mStore_Pool;</span>
<a href="#l70.89"></a><span id="l70.89" class="difflineat">@@ -133,20 +133,20 @@ morkPool* morkSpace::GetSpaceStorePool()</span>
<a href="#l70.90"></a><span id="l70.90"> mork_bool morkSpace::MaybeDirtyStoreAndSpace()</span>
<a href="#l70.91"></a><span id="l70.91"> {</span>
<a href="#l70.92"></a><span id="l70.92">   morkStore* store = mSpace_Store;</span>
<a href="#l70.93"></a><span id="l70.93">   if ( store &amp;&amp; store-&gt;mStore_CanDirty )</span>
<a href="#l70.94"></a><span id="l70.94">   {</span>
<a href="#l70.95"></a><span id="l70.95">     store-&gt;SetStoreDirty();</span>
<a href="#l70.96"></a><span id="l70.96">     mSpace_CanDirty = morkBool_kTrue;</span>
<a href="#l70.97"></a><span id="l70.97">   }</span>
<a href="#l70.98"></a><span id="l70.98" class="difflineminus">-  </span>
<a href="#l70.99"></a><span id="l70.99" class="difflineplus">+</span>
<a href="#l70.100"></a><span id="l70.100">   if ( mSpace_CanDirty )</span>
<a href="#l70.101"></a><span id="l70.101">   {</span>
<a href="#l70.102"></a><span id="l70.102">     this-&gt;SetSpaceDirty();</span>
<a href="#l70.103"></a><span id="l70.103">     return morkBool_kTrue;</span>
<a href="#l70.104"></a><span id="l70.104">   }</span>
<a href="#l70.105"></a><span id="l70.105" class="difflineminus">-  </span>
<a href="#l70.106"></a><span id="l70.106" class="difflineplus">+</span>
<a href="#l70.107"></a><span id="l70.107">   return morkBool_kFalse;</span>
<a href="#l70.108"></a><span id="l70.108"> }</span>
<a href="#l70.109"></a><span id="l70.109"> </span>
<a href="#l70.110"></a><span id="l70.110"> </span>
<a href="#l70.111"></a><span id="l70.111"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l71.1"></a><span id="l71.1" class="difflineminus">--- a/db/mork/src/morkSpace.h</span>
<a href="#l71.2"></a><span id="l71.2" class="difflineplus">+++ b/db/mork/src/morkSpace.h</span>
<a href="#l71.3"></a><span id="l71.3" class="difflineat">@@ -24,87 +24,87 @@</span>
<a href="#l71.4"></a><span id="l71.4"> </span>
<a href="#l71.5"></a><span id="l71.5"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l71.6"></a><span id="l71.6"> </span>
<a href="#l71.7"></a><span id="l71.7"> #define morkSpace_kInitialSpaceSlots  /*i*/ 1024 /* default */</span>
<a href="#l71.8"></a><span id="l71.8"> #define morkDerived_kSpace  /*i*/ 0x5370 /* ascii 'Sp' */</span>
<a href="#l71.9"></a><span id="l71.9"> </span>
<a href="#l71.10"></a><span id="l71.10"> /*| morkSpace:</span>
<a href="#l71.11"></a><span id="l71.11"> |*/</span>
<a href="#l71.12"></a><span id="l71.12" class="difflineminus">-class morkSpace : public morkBead { // </span>
<a href="#l71.13"></a><span id="l71.13" class="difflineplus">+class morkSpace : public morkBead { //</span>
<a href="#l71.14"></a><span id="l71.14"> </span>
<a href="#l71.15"></a><span id="l71.15"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l71.16"></a><span id="l71.16">   // nsIMdbHeap*       mNode_Heap;</span>
<a href="#l71.17"></a><span id="l71.17"> </span>
<a href="#l71.18"></a><span id="l71.18">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l71.19"></a><span id="l71.19">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l71.20"></a><span id="l71.20" class="difflineminus">-  </span>
<a href="#l71.21"></a><span id="l71.21" class="difflineplus">+</span>
<a href="#l71.22"></a><span id="l71.22">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l71.23"></a><span id="l71.23">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l71.24"></a><span id="l71.24">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l71.25"></a><span id="l71.25">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l71.26"></a><span id="l71.26" class="difflineminus">-  </span>
<a href="#l71.27"></a><span id="l71.27" class="difflineplus">+</span>
<a href="#l71.28"></a><span id="l71.28">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l71.29"></a><span id="l71.29">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l71.30"></a><span id="l71.30"> </span>
<a href="#l71.31"></a><span id="l71.31">   // mork_color      mBead_Color;   // ID for this bead</span>
<a href="#l71.32"></a><span id="l71.32"> </span>
<a href="#l71.33"></a><span id="l71.33"> public: // bead color setter &amp; getter replace obsolete member mTable_Id:</span>
<a href="#l71.34"></a><span id="l71.34"> </span>
<a href="#l71.35"></a><span id="l71.35">   mork_tid     SpaceScope() const { return mBead_Color; }</span>
<a href="#l71.36"></a><span id="l71.36">   void         SetSpaceScope(mork_scope inScope) { mBead_Color = inScope; }</span>
<a href="#l71.37"></a><span id="l71.37"> </span>
<a href="#l71.38"></a><span id="l71.38"> public: // state is public because the entire Mork system is private</span>
<a href="#l71.39"></a><span id="l71.39"> </span>
<a href="#l71.40"></a><span id="l71.40">   morkStore*  mSpace_Store; // weak ref to containing store</span>
<a href="#l71.41"></a><span id="l71.41" class="difflineminus">-    </span>
<a href="#l71.42"></a><span id="l71.42" class="difflineplus">+</span>
<a href="#l71.43"></a><span id="l71.43">   mork_bool   mSpace_DoAutoIDs;    // whether db should assign member IDs</span>
<a href="#l71.44"></a><span id="l71.44">   mork_bool   mSpace_HaveDoneAutoIDs; // whether actually auto assigned IDs</span>
<a href="#l71.45"></a><span id="l71.45">   mork_bool   mSpace_CanDirty; // changes imply the store becomes dirty?</span>
<a href="#l71.46"></a><span id="l71.46">   mork_u1     mSpace_Pad;    // pad to u4 alignment</span>
<a href="#l71.47"></a><span id="l71.47"> </span>
<a href="#l71.48"></a><span id="l71.48"> public: // more specific dirty methods for space:</span>
<a href="#l71.49"></a><span id="l71.49">   void SetSpaceDirty() { this-&gt;SetNodeDirty(); }</span>
<a href="#l71.50"></a><span id="l71.50">   void SetSpaceClean() { this-&gt;SetNodeClean(); }</span>
<a href="#l71.51"></a><span id="l71.51" class="difflineminus">-  </span>
<a href="#l71.52"></a><span id="l71.52" class="difflineplus">+</span>
<a href="#l71.53"></a><span id="l71.53">   mork_bool IsSpaceClean() const { return this-&gt;IsNodeClean(); }</span>
<a href="#l71.54"></a><span id="l71.54">   mork_bool IsSpaceDirty() const { return this-&gt;IsNodeDirty(); }</span>
<a href="#l71.55"></a><span id="l71.55"> </span>
<a href="#l71.56"></a><span id="l71.56"> // { ===== begin morkNode interface =====</span>
<a href="#l71.57"></a><span id="l71.57"> public: // morkNode virtual methods</span>
<a href="#l71.58"></a><span id="l71.58">   virtual void CloseMorkNode(morkEnv* ev); // CloseSpace() only if open</span>
<a href="#l71.59"></a><span id="l71.59">   virtual ~morkSpace(); // assert that CloseSpace() executed earlier</span>
<a href="#l71.60"></a><span id="l71.60" class="difflineminus">-  </span>
<a href="#l71.61"></a><span id="l71.61" class="difflineplus">+</span>
<a href="#l71.62"></a><span id="l71.62"> public: // morkMap construction &amp; destruction</span>
<a href="#l71.63"></a><span id="l71.63">   //morkSpace(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioNodeHeap,</span>
<a href="#l71.64"></a><span id="l71.64">   //  const morkMapForm&amp; inForm, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l71.65"></a><span id="l71.65" class="difflineminus">-  </span>
<a href="#l71.66"></a><span id="l71.66" class="difflineminus">-  morkSpace(morkEnv* ev, const morkUsage&amp; inUsage,mork_scope inScope, </span>
<a href="#l71.67"></a><span id="l71.67" class="difflineplus">+</span>
<a href="#l71.68"></a><span id="l71.68" class="difflineplus">+  morkSpace(morkEnv* ev, const morkUsage&amp; inUsage,mork_scope inScope,</span>
<a href="#l71.69"></a><span id="l71.69">     morkStore* ioStore, nsIMdbHeap* ioNodeHeap, nsIMdbHeap* ioSlotHeap);</span>
<a href="#l71.70"></a><span id="l71.70">   void CloseSpace(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l71.71"></a><span id="l71.71"> </span>
<a href="#l71.72"></a><span id="l71.72"> public: // dynamic type identification</span>
<a href="#l71.73"></a><span id="l71.73">   mork_bool IsSpace() const</span>
<a href="#l71.74"></a><span id="l71.74">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kSpace; }</span>
<a href="#l71.75"></a><span id="l71.75"> // } ===== end morkNode methods =====</span>
<a href="#l71.76"></a><span id="l71.76"> </span>
<a href="#l71.77"></a><span id="l71.77"> public: // other space methods</span>
<a href="#l71.78"></a><span id="l71.78" class="difflineminus">-  </span>
<a href="#l71.79"></a><span id="l71.79" class="difflineplus">+</span>
<a href="#l71.80"></a><span id="l71.80">   mork_bool MaybeDirtyStoreAndSpace();</span>
<a href="#l71.81"></a><span id="l71.81"> </span>
<a href="#l71.82"></a><span id="l71.82">   static void NonAsciiSpaceScopeName(morkEnv* ev);</span>
<a href="#l71.83"></a><span id="l71.83">   static void NilSpaceStoreError(morkEnv* ev);</span>
<a href="#l71.84"></a><span id="l71.84"> </span>
<a href="#l71.85"></a><span id="l71.85">   morkPool* GetSpaceStorePool() const;</span>
<a href="#l71.86"></a><span id="l71.86"> </span>
<a href="#l71.87"></a><span id="l71.87"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l71.88"></a><span id="l71.88">   static void SlotWeakSpace(morkSpace* me,</span>
<a href="#l71.89"></a><span id="l71.89">     morkEnv* ev, morkSpace** ioSlot)</span>
<a href="#l71.90"></a><span id="l71.90">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l71.91"></a><span id="l71.91" class="difflineminus">-  </span>
<a href="#l71.92"></a><span id="l71.92" class="difflineplus">+</span>
<a href="#l71.93"></a><span id="l71.93">   static void SlotStrongSpace(morkSpace* me,</span>
<a href="#l71.94"></a><span id="l71.94">     morkEnv* ev, morkSpace** ioSlot)</span>
<a href="#l71.95"></a><span id="l71.95">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l71.96"></a><span id="l71.96"> };</span>
<a href="#l71.97"></a><span id="l71.97"> </span>
<a href="#l71.98"></a><span id="l71.98"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l71.99"></a><span id="l71.99"> </span>
<a href="#l71.100"></a><span id="l71.100"> #endif /* _MORKSPACE_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l72.1"></a><span id="l72.1" class="difflineminus">--- a/db/mork/src/morkStore.cpp</span>
<a href="#l72.2"></a><span id="l72.2" class="difflineplus">+++ b/db/mork/src/morkStore.cpp</span>
<a href="#l72.3"></a><span id="l72.3" class="difflineat">@@ -1,13 +1,13 @@</span>
<a href="#l72.4"></a><span id="l72.4"> /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-  */</span>
<a href="#l72.5"></a><span id="l72.5"> /* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a href="#l72.6"></a><span id="l72.6">  * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a href="#l72.7"></a><span id="l72.7">  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a href="#l72.8"></a><span id="l72.8" class="difflineminus">-  </span>
<a href="#l72.9"></a><span id="l72.9" class="difflineplus">+</span>
<a href="#l72.10"></a><span id="l72.10"> #ifndef _MDB_</span>
<a href="#l72.11"></a><span id="l72.11"> #include &quot;mdb.h&quot;</span>
<a href="#l72.12"></a><span id="l72.12"> #endif</span>
<a href="#l72.13"></a><span id="l72.13"> </span>
<a href="#l72.14"></a><span id="l72.14"> #ifndef _MORK_</span>
<a href="#l72.15"></a><span id="l72.15"> #include &quot;mork.h&quot;</span>
<a href="#l72.16"></a><span id="l72.16"> #endif</span>
<a href="#l72.17"></a><span id="l72.17"> </span>
<a href="#l72.18"></a><span id="l72.18" class="difflineat">@@ -85,24 +85,24 @@</span>
<a href="#l72.19"></a><span id="l72.19"> #ifndef _MORKPARSER_</span>
<a href="#l72.20"></a><span id="l72.20"> #include &quot;morkParser.h&quot;</span>
<a href="#l72.21"></a><span id="l72.21"> #endif</span>
<a href="#l72.22"></a><span id="l72.22"> </span>
<a href="#l72.23"></a><span id="l72.23"> #include &quot;nsCOMPtr.h&quot;</span>
<a href="#l72.24"></a><span id="l72.24"> </span>
<a href="#l72.25"></a><span id="l72.25"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l72.26"></a><span id="l72.26"> </span>
<a href="#l72.27"></a><span id="l72.27" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l72.28"></a><span id="l72.28" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l72.29"></a><span id="l72.29"> // { ===== begin morkNode interface =====</span>
<a href="#l72.30"></a><span id="l72.30"> </span>
<a href="#l72.31"></a><span id="l72.31"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l72.32"></a><span id="l72.32"> </span>
<a href="#l72.33"></a><span id="l72.33"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l72.34"></a><span id="l72.34"> </span>
<a href="#l72.35"></a><span id="l72.35" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l72.36"></a><span id="l72.36" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l72.37"></a><span id="l72.37"> // { ===== begin morkNode interface =====</span>
<a href="#l72.38"></a><span id="l72.38"> </span>
<a href="#l72.39"></a><span id="l72.39"> /*public virtual*/ void</span>
<a href="#l72.40"></a><span id="l72.40"> morkStore::CloseMorkNode(morkEnv* ev) // ClosePort() only if open</span>
<a href="#l72.41"></a><span id="l72.41"> {</span>
<a href="#l72.42"></a><span id="l72.42">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l72.43"></a><span id="l72.43">   {</span>
<a href="#l72.44"></a><span id="l72.44">     this-&gt;MarkClosing();</span>
<a href="#l72.45"></a><span id="l72.45" class="difflineat">@@ -187,17 +187,17 @@ morkStore::morkStore(morkEnv* ev, const </span>
<a href="#l72.46"></a><span id="l72.46">         mNode_Derived = morkDerived_kPort;</span>
<a href="#l72.47"></a><span id="l72.47">     }</span>
<a href="#l72.48"></a><span id="l72.48">     else</span>
<a href="#l72.49"></a><span id="l72.49">       ev-&gt;NilPointerError();</span>
<a href="#l72.50"></a><span id="l72.50">   }</span>
<a href="#l72.51"></a><span id="l72.51">   if ( ev-&gt;Good() )</span>
<a href="#l72.52"></a><span id="l72.52">   {</span>
<a href="#l72.53"></a><span id="l72.53">     mNode_Derived = morkDerived_kStore;</span>
<a href="#l72.54"></a><span id="l72.54" class="difflineminus">-    </span>
<a href="#l72.55"></a><span id="l72.55" class="difflineplus">+</span>
<a href="#l72.56"></a><span id="l72.56">   }</span>
<a href="#l72.57"></a><span id="l72.57"> }</span>
<a href="#l72.58"></a><span id="l72.58"> </span>
<a href="#l72.59"></a><span id="l72.59"> NS_IMPL_ISUPPORTS_INHERITED(morkStore, morkObject, nsIMdbStore)</span>
<a href="#l72.60"></a><span id="l72.60"> </span>
<a href="#l72.61"></a><span id="l72.61"> /*public non-poly*/ void</span>
<a href="#l72.62"></a><span id="l72.62"> morkStore::CloseStore(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l72.63"></a><span id="l72.63"> {</span>
<a href="#l72.64"></a><span id="l72.64" class="difflineat">@@ -213,95 +213,95 @@ morkStore::CloseStore(morkEnv* ev) // ca</span>
<a href="#l72.65"></a><span id="l72.65">         &amp;mStore_OidAtomSpace);</span>
<a href="#l72.66"></a><span id="l72.66">       morkAtomSpace::SlotStrongAtomSpace((morkAtomSpace*) 0, ev,</span>
<a href="#l72.67"></a><span id="l72.67">         &amp;mStore_GroundAtomSpace);</span>
<a href="#l72.68"></a><span id="l72.68">       morkAtomSpace::SlotStrongAtomSpace((morkAtomSpace*) 0, ev,</span>
<a href="#l72.69"></a><span id="l72.69">         &amp;mStore_GroundColumnSpace);</span>
<a href="#l72.70"></a><span id="l72.70">       mStore_RowSpaces.CloseMorkNode(ev);</span>
<a href="#l72.71"></a><span id="l72.71">       mStore_AtomSpaces.CloseMorkNode(ev);</span>
<a href="#l72.72"></a><span id="l72.72">       morkBuilder::SlotStrongBuilder((morkBuilder*) 0, ev, &amp;mStore_Builder);</span>
<a href="#l72.73"></a><span id="l72.73" class="difflineminus">-      </span>
<a href="#l72.74"></a><span id="l72.74" class="difflineplus">+</span>
<a href="#l72.75"></a><span id="l72.75">       nsIMdbFile_SlotStrongFile((nsIMdbFile*) 0, ev,</span>
<a href="#l72.76"></a><span id="l72.76">         &amp;mStore_File);</span>
<a href="#l72.77"></a><span id="l72.77" class="difflineminus">-      </span>
<a href="#l72.78"></a><span id="l72.78" class="difflineplus">+</span>
<a href="#l72.79"></a><span id="l72.79">       file-&gt;Release();</span>
<a href="#l72.80"></a><span id="l72.80"> </span>
<a href="#l72.81"></a><span id="l72.81">       morkStream::SlotStrongStream((morkStream*) 0, ev, &amp;mStore_InStream);</span>
<a href="#l72.82"></a><span id="l72.82">       morkStream::SlotStrongStream((morkStream*) 0, ev, &amp;mStore_OutStream);</span>
<a href="#l72.83"></a><span id="l72.83"> </span>
<a href="#l72.84"></a><span id="l72.84">       mStore_Pool.CloseMorkNode(ev);</span>
<a href="#l72.85"></a><span id="l72.85">       mStore_Zone.CloseMorkNode(ev);</span>
<a href="#l72.86"></a><span id="l72.86">       this-&gt;ClosePort(ev);</span>
<a href="#l72.87"></a><span id="l72.87">       this-&gt;MarkShut();</span>
<a href="#l72.88"></a><span id="l72.88">     }</span>
<a href="#l72.89"></a><span id="l72.89">     else</span>
<a href="#l72.90"></a><span id="l72.90">       this-&gt;NonNodeError(ev);</span>
<a href="#l72.91"></a><span id="l72.91"> }</span>
<a href="#l72.92"></a><span id="l72.92"> </span>
<a href="#l72.93"></a><span id="l72.93"> // } ===== end morkNode methods =====</span>
<a href="#l72.94"></a><span id="l72.94" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l72.95"></a><span id="l72.95" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l72.96"></a><span id="l72.96"> </span>
<a href="#l72.97"></a><span id="l72.97"> </span>
<a href="#l72.98"></a><span id="l72.98"> mork_bool morkStore::DoPreferLargeOverCompressCommit(morkEnv* ev)</span>
<a href="#l72.99"></a><span id="l72.99" class="difflineminus">-  // true when mStore_CanWriteIncremental &amp;&amp; store has file large enough </span>
<a href="#l72.100"></a><span id="l72.100" class="difflineplus">+  // true when mStore_CanWriteIncremental &amp;&amp; store has file large enough</span>
<a href="#l72.101"></a><span id="l72.101"> {</span>
<a href="#l72.102"></a><span id="l72.102">   nsIMdbFile* file = mStore_File;</span>
<a href="#l72.103"></a><span id="l72.103">   if ( file &amp;&amp; mStore_CanWriteIncremental )</span>
<a href="#l72.104"></a><span id="l72.104">   {</span>
<a href="#l72.105"></a><span id="l72.105">     mdb_pos fileEof = 0;</span>
<a href="#l72.106"></a><span id="l72.106">     file-&gt;Eof(ev-&gt;AsMdbEnv(), &amp;fileEof);</span>
<a href="#l72.107"></a><span id="l72.107">     if ( ev-&gt;Good() &amp;&amp; fileEof &gt; 128 )</span>
<a href="#l72.108"></a><span id="l72.108">       return morkBool_kTrue;</span>
<a href="#l72.109"></a><span id="l72.109">   }</span>
<a href="#l72.110"></a><span id="l72.110">   return morkBool_kFalse;</span>
<a href="#l72.111"></a><span id="l72.111"> }</span>
<a href="#l72.112"></a><span id="l72.112"> </span>
<a href="#l72.113"></a><span id="l72.113"> mork_percent morkStore::PercentOfStoreWasted(morkEnv* ev)</span>
<a href="#l72.114"></a><span id="l72.114"> {</span>
<a href="#l72.115"></a><span id="l72.115">   mork_percent outPercent = 0;</span>
<a href="#l72.116"></a><span id="l72.116">   nsIMdbFile* file = mStore_File;</span>
<a href="#l72.117"></a><span id="l72.117" class="difflineminus">-  </span>
<a href="#l72.118"></a><span id="l72.118" class="difflineplus">+</span>
<a href="#l72.119"></a><span id="l72.119">   if ( file )</span>
<a href="#l72.120"></a><span id="l72.120">   {</span>
<a href="#l72.121"></a><span id="l72.121">     mork_pos firstPos = mStore_FirstCommitGroupPos;</span>
<a href="#l72.122"></a><span id="l72.122">     mork_pos secondPos = mStore_SecondCommitGroupPos;</span>
<a href="#l72.123"></a><span id="l72.123">     if ( firstPos || secondPos )</span>
<a href="#l72.124"></a><span id="l72.124">     {</span>
<a href="#l72.125"></a><span id="l72.125">       if ( firstPos &lt; 512 &amp;&amp; secondPos &gt; firstPos )</span>
<a href="#l72.126"></a><span id="l72.126">         firstPos = secondPos; // better approximation of first commit</span>
<a href="#l72.127"></a><span id="l72.127" class="difflineminus">-        </span>
<a href="#l72.128"></a><span id="l72.128" class="difflineplus">+</span>
<a href="#l72.129"></a><span id="l72.129">       mork_pos fileLength = 0;</span>
<a href="#l72.130"></a><span id="l72.130">       file-&gt;Eof(ev-&gt;AsMdbEnv(), &amp;fileLength); // end of file</span>
<a href="#l72.131"></a><span id="l72.131">       if ( ev-&gt;Good() &amp;&amp; fileLength &gt; firstPos )</span>
<a href="#l72.132"></a><span id="l72.132">       {</span>
<a href="#l72.133"></a><span id="l72.133">         mork_size groupContent = fileLength - firstPos;</span>
<a href="#l72.134"></a><span id="l72.134">         outPercent = ( groupContent * 100 ) / fileLength;</span>
<a href="#l72.135"></a><span id="l72.135">       }</span>
<a href="#l72.136"></a><span id="l72.136">     }</span>
<a href="#l72.137"></a><span id="l72.137">   }</span>
<a href="#l72.138"></a><span id="l72.138">   else</span>
<a href="#l72.139"></a><span id="l72.139">     this-&gt;NilStoreFileError(ev);</span>
<a href="#l72.140"></a><span id="l72.140" class="difflineminus">-    </span>
<a href="#l72.141"></a><span id="l72.141" class="difflineplus">+</span>
<a href="#l72.142"></a><span id="l72.142">   return outPercent;</span>
<a href="#l72.143"></a><span id="l72.143"> }</span>
<a href="#l72.144"></a><span id="l72.144"> </span>
<a href="#l72.145"></a><span id="l72.145"> void</span>
<a href="#l72.146"></a><span id="l72.146"> morkStore::SetStoreAndAllSpacesCanDirty(morkEnv* ev, mork_bool inCanDirty)</span>
<a href="#l72.147"></a><span id="l72.147"> {</span>
<a href="#l72.148"></a><span id="l72.148">   mStore_CanDirty = inCanDirty;</span>
<a href="#l72.149"></a><span id="l72.149" class="difflineminus">-  </span>
<a href="#l72.150"></a><span id="l72.150" class="difflineplus">+</span>
<a href="#l72.151"></a><span id="l72.151">   mork_change* c = 0;</span>
<a href="#l72.152"></a><span id="l72.152">   mork_scope* key = 0; // ignore keys in maps</span>
<a href="#l72.153"></a><span id="l72.153"> </span>
<a href="#l72.154"></a><span id="l72.154">   if ( ev-&gt;Good() )</span>
<a href="#l72.155"></a><span id="l72.155">   {</span>
<a href="#l72.156"></a><span id="l72.156">     morkAtomSpaceMapIter asi(ev, &amp;mStore_AtomSpaces);</span>
<a href="#l72.157"></a><span id="l72.157"> </span>
<a href="#l72.158"></a><span id="l72.158">     morkAtomSpace* atomSpace = 0; // old val node in the map</span>
<a href="#l72.159"></a><span id="l72.159" class="difflineminus">-    </span>
<a href="#l72.160"></a><span id="l72.160" class="difflineplus">+</span>
<a href="#l72.161"></a><span id="l72.161">     for ( c = asi.FirstAtomSpace(ev, key, &amp;atomSpace); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l72.162"></a><span id="l72.162">           c = asi.NextAtomSpace(ev, key, &amp;atomSpace) )</span>
<a href="#l72.163"></a><span id="l72.163">     {</span>
<a href="#l72.164"></a><span id="l72.164">       if ( atomSpace )</span>
<a href="#l72.165"></a><span id="l72.165">       {</span>
<a href="#l72.166"></a><span id="l72.166">         if ( atomSpace-&gt;IsAtomSpace() )</span>
<a href="#l72.167"></a><span id="l72.167">           atomSpace-&gt;mSpace_CanDirty = inCanDirty;</span>
<a href="#l72.168"></a><span id="l72.168">         else</span>
<a href="#l72.169"></a><span id="l72.169" class="difflineat">@@ -311,17 +311,17 @@ morkStore::SetStoreAndAllSpacesCanDirty(</span>
<a href="#l72.170"></a><span id="l72.170">         ev-&gt;NilPointerError();</span>
<a href="#l72.171"></a><span id="l72.171">     }</span>
<a href="#l72.172"></a><span id="l72.172">   }</span>
<a href="#l72.173"></a><span id="l72.173"> </span>
<a href="#l72.174"></a><span id="l72.174">   if ( ev-&gt;Good() )</span>
<a href="#l72.175"></a><span id="l72.175">   {</span>
<a href="#l72.176"></a><span id="l72.176">     morkRowSpaceMapIter rsi(ev, &amp;mStore_RowSpaces);</span>
<a href="#l72.177"></a><span id="l72.177">     morkRowSpace* rowSpace = 0; // old val node in the map</span>
<a href="#l72.178"></a><span id="l72.178" class="difflineminus">-    </span>
<a href="#l72.179"></a><span id="l72.179" class="difflineplus">+</span>
<a href="#l72.180"></a><span id="l72.180">     for ( c = rsi.FirstRowSpace(ev, key, &amp;rowSpace); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l72.181"></a><span id="l72.181">           c = rsi.NextRowSpace(ev, key, &amp;rowSpace) )</span>
<a href="#l72.182"></a><span id="l72.182">     {</span>
<a href="#l72.183"></a><span id="l72.183">       if ( rowSpace )</span>
<a href="#l72.184"></a><span id="l72.184">       {</span>
<a href="#l72.185"></a><span id="l72.185">         if ( rowSpace-&gt;IsRowSpace() )</span>
<a href="#l72.186"></a><span id="l72.186">           rowSpace-&gt;mSpace_CanDirty = inCanDirty;</span>
<a href="#l72.187"></a><span id="l72.187">         else</span>
<a href="#l72.188"></a><span id="l72.188" class="difflineat">@@ -351,51 +351,51 @@ morkStore::StageAliasAsFarBookAtom(morkE</span>
<a href="#l72.189"></a><span id="l72.189"> {</span>
<a href="#l72.190"></a><span id="l72.190">   if ( inMid &amp;&amp; inMid-&gt;mMid_Buf )</span>
<a href="#l72.191"></a><span id="l72.191">   {</span>
<a href="#l72.192"></a><span id="l72.192">     const morkBuf* buf = inMid-&gt;mMid_Buf;</span>
<a href="#l72.193"></a><span id="l72.193">     mork_size length = buf-&gt;mBuf_Fill;</span>
<a href="#l72.194"></a><span id="l72.194">     if ( length &lt;= morkBookAtom_kMaxBodySize )</span>
<a href="#l72.195"></a><span id="l72.195">     {</span>
<a href="#l72.196"></a><span id="l72.196">       mork_aid dummyAid = 1;</span>
<a href="#l72.197"></a><span id="l72.197" class="difflineminus">-      //mStore_BookAtom.InitMaxBookAtom(ev, *buf, </span>
<a href="#l72.198"></a><span id="l72.198" class="difflineplus">+      //mStore_BookAtom.InitMaxBookAtom(ev, *buf,</span>
<a href="#l72.199"></a><span id="l72.199">       //  inForm, ioSpace, dummyAid);</span>
<a href="#l72.200"></a><span id="l72.200" class="difflineminus">-       </span>
<a href="#l72.201"></a><span id="l72.201" class="difflineminus">-      mStore_FarBookAtom.InitFarBookAtom(ev, *buf, </span>
<a href="#l72.202"></a><span id="l72.202" class="difflineplus">+</span>
<a href="#l72.203"></a><span id="l72.203" class="difflineplus">+      mStore_FarBookAtom.InitFarBookAtom(ev, *buf,</span>
<a href="#l72.204"></a><span id="l72.204">         inForm, ioSpace, dummyAid);</span>
<a href="#l72.205"></a><span id="l72.205">       return &amp;mStore_FarBookAtom;</span>
<a href="#l72.206"></a><span id="l72.206">     }</span>
<a href="#l72.207"></a><span id="l72.207">   }</span>
<a href="#l72.208"></a><span id="l72.208">   else</span>
<a href="#l72.209"></a><span id="l72.209">     ev-&gt;NilPointerError();</span>
<a href="#l72.210"></a><span id="l72.210" class="difflineminus">-    </span>
<a href="#l72.211"></a><span id="l72.211" class="difflineplus">+</span>
<a href="#l72.212"></a><span id="l72.212">   return (morkFarBookAtom*) 0;</span>
<a href="#l72.213"></a><span id="l72.213"> }</span>
<a href="#l72.214"></a><span id="l72.214"> </span>
<a href="#l72.215"></a><span id="l72.215"> morkFarBookAtom*</span>
<a href="#l72.216"></a><span id="l72.216"> morkStore::StageYarnAsFarBookAtom(morkEnv* ev, const mdbYarn* inYarn,</span>
<a href="#l72.217"></a><span id="l72.217">    morkAtomSpace* ioSpace)</span>
<a href="#l72.218"></a><span id="l72.218"> {</span>
<a href="#l72.219"></a><span id="l72.219">   if ( inYarn &amp;&amp; inYarn-&gt;mYarn_Buf )</span>
<a href="#l72.220"></a><span id="l72.220">   {</span>
<a href="#l72.221"></a><span id="l72.221">     mork_size length = inYarn-&gt;mYarn_Fill;</span>
<a href="#l72.222"></a><span id="l72.222">     if ( length &lt;= morkBookAtom_kMaxBodySize )</span>
<a href="#l72.223"></a><span id="l72.223">     {</span>
<a href="#l72.224"></a><span id="l72.224">       morkBuf buf(inYarn-&gt;mYarn_Buf, length);</span>
<a href="#l72.225"></a><span id="l72.225">       mork_aid dummyAid = 1;</span>
<a href="#l72.226"></a><span id="l72.226" class="difflineminus">-      //mStore_BookAtom.InitMaxBookAtom(ev, buf, </span>
<a href="#l72.227"></a><span id="l72.227" class="difflineplus">+      //mStore_BookAtom.InitMaxBookAtom(ev, buf,</span>
<a href="#l72.228"></a><span id="l72.228">       //  inYarn-&gt;mYarn_Form, ioSpace, dummyAid);</span>
<a href="#l72.229"></a><span id="l72.229" class="difflineminus">-      mStore_FarBookAtom.InitFarBookAtom(ev, buf, </span>
<a href="#l72.230"></a><span id="l72.230" class="difflineplus">+      mStore_FarBookAtom.InitFarBookAtom(ev, buf,</span>
<a href="#l72.231"></a><span id="l72.231">         inYarn-&gt;mYarn_Form, ioSpace, dummyAid);</span>
<a href="#l72.232"></a><span id="l72.232">       return &amp;mStore_FarBookAtom;</span>
<a href="#l72.233"></a><span id="l72.233">     }</span>
<a href="#l72.234"></a><span id="l72.234">   }</span>
<a href="#l72.235"></a><span id="l72.235">   else</span>
<a href="#l72.236"></a><span id="l72.236">     ev-&gt;NilPointerError();</span>
<a href="#l72.237"></a><span id="l72.237" class="difflineminus">-    </span>
<a href="#l72.238"></a><span id="l72.238" class="difflineplus">+</span>
<a href="#l72.239"></a><span id="l72.239">   return (morkFarBookAtom*) 0;</span>
<a href="#l72.240"></a><span id="l72.240"> }</span>
<a href="#l72.241"></a><span id="l72.241"> </span>
<a href="#l72.242"></a><span id="l72.242"> morkFarBookAtom*</span>
<a href="#l72.243"></a><span id="l72.243"> morkStore::StageStringAsFarBookAtom(morkEnv* ev, const char* inString,</span>
<a href="#l72.244"></a><span id="l72.244">    mork_cscode inForm, morkAtomSpace* ioSpace)</span>
<a href="#l72.245"></a><span id="l72.245"> {</span>
<a href="#l72.246"></a><span id="l72.246">   if ( inString )</span>
<a href="#l72.247"></a><span id="l72.247" class="difflineat">@@ -407,17 +407,17 @@ morkStore::StageStringAsFarBookAtom(mork</span>
<a href="#l72.248"></a><span id="l72.248">       mork_aid dummyAid = 1;</span>
<a href="#l72.249"></a><span id="l72.249">       //mStore_BookAtom.InitMaxBookAtom(ev, buf, inForm, ioSpace, dummyAid);</span>
<a href="#l72.250"></a><span id="l72.250">       mStore_FarBookAtom.InitFarBookAtom(ev, buf, inForm, ioSpace, dummyAid);</span>
<a href="#l72.251"></a><span id="l72.251">       return &amp;mStore_FarBookAtom;</span>
<a href="#l72.252"></a><span id="l72.252">     }</span>
<a href="#l72.253"></a><span id="l72.253">   }</span>
<a href="#l72.254"></a><span id="l72.254">   else</span>
<a href="#l72.255"></a><span id="l72.255">     ev-&gt;NilPointerError();</span>
<a href="#l72.256"></a><span id="l72.256" class="difflineminus">-    </span>
<a href="#l72.257"></a><span id="l72.257" class="difflineplus">+</span>
<a href="#l72.258"></a><span id="l72.258">   return (morkFarBookAtom*) 0;</span>
<a href="#l72.259"></a><span id="l72.259"> }</span>
<a href="#l72.260"></a><span id="l72.260"> </span>
<a href="#l72.261"></a><span id="l72.261"> morkAtomSpace* morkStore::LazyGetOidAtomSpace(morkEnv* ev)</span>
<a href="#l72.262"></a><span id="l72.262"> {</span>
<a href="#l72.263"></a><span id="l72.263">   MORK_USED_1(ev);</span>
<a href="#l72.264"></a><span id="l72.264">   if ( !mStore_OidAtomSpace )</span>
<a href="#l72.265"></a><span id="l72.265">   {</span>
<a href="#l72.266"></a><span id="l72.266" class="difflineat">@@ -426,58 +426,58 @@ morkAtomSpace* morkStore::LazyGetOidAtom</span>
<a href="#l72.267"></a><span id="l72.267"> }</span>
<a href="#l72.268"></a><span id="l72.268"> </span>
<a href="#l72.269"></a><span id="l72.269"> morkAtomSpace* morkStore::LazyGetGroundAtomSpace(morkEnv* ev)</span>
<a href="#l72.270"></a><span id="l72.270"> {</span>
<a href="#l72.271"></a><span id="l72.271">   if ( !mStore_GroundAtomSpace )</span>
<a href="#l72.272"></a><span id="l72.272">   {</span>
<a href="#l72.273"></a><span id="l72.273">     mork_scope atomScope = morkStore_kValueSpaceScope;</span>
<a href="#l72.274"></a><span id="l72.274">     nsIMdbHeap* heap = mPort_Heap;</span>
<a href="#l72.275"></a><span id="l72.275" class="difflineminus">-    morkAtomSpace* space = new(*heap, ev) </span>
<a href="#l72.276"></a><span id="l72.276" class="difflineplus">+    morkAtomSpace* space = new(*heap, ev)</span>
<a href="#l72.277"></a><span id="l72.277">       morkAtomSpace(ev, morkUsage::kHeap, atomScope, this, heap, heap);</span>
<a href="#l72.278"></a><span id="l72.278" class="difflineminus">-      </span>
<a href="#l72.279"></a><span id="l72.279" class="difflineplus">+</span>
<a href="#l72.280"></a><span id="l72.280">     if ( space ) // successful space creation?</span>
<a href="#l72.281"></a><span id="l72.281">     {</span>
<a href="#l72.282"></a><span id="l72.282">       this-&gt;MaybeDirtyStore();</span>
<a href="#l72.283"></a><span id="l72.283" class="difflineminus">-    </span>
<a href="#l72.284"></a><span id="l72.284" class="difflineplus">+</span>
<a href="#l72.285"></a><span id="l72.285">       mStore_GroundAtomSpace = space; // transfer strong ref to this slot</span>
<a href="#l72.286"></a><span id="l72.286">       mStore_AtomSpaces.AddAtomSpace(ev, space);</span>
<a href="#l72.287"></a><span id="l72.287">     }</span>
<a href="#l72.288"></a><span id="l72.288">   }</span>
<a href="#l72.289"></a><span id="l72.289">   return mStore_GroundAtomSpace;</span>
<a href="#l72.290"></a><span id="l72.290"> }</span>
<a href="#l72.291"></a><span id="l72.291"> </span>
<a href="#l72.292"></a><span id="l72.292"> morkAtomSpace* morkStore::LazyGetGroundColumnSpace(morkEnv* ev)</span>
<a href="#l72.293"></a><span id="l72.293"> {</span>
<a href="#l72.294"></a><span id="l72.294">   if ( !mStore_GroundColumnSpace )</span>
<a href="#l72.295"></a><span id="l72.295">   {</span>
<a href="#l72.296"></a><span id="l72.296">     mork_scope atomScope = morkStore_kGroundColumnSpace;</span>
<a href="#l72.297"></a><span id="l72.297">     nsIMdbHeap* heap = mPort_Heap;</span>
<a href="#l72.298"></a><span id="l72.298" class="difflineminus">-    morkAtomSpace* space = new(*heap, ev) </span>
<a href="#l72.299"></a><span id="l72.299" class="difflineplus">+    morkAtomSpace* space = new(*heap, ev)</span>
<a href="#l72.300"></a><span id="l72.300">       morkAtomSpace(ev, morkUsage::kHeap, atomScope, this, heap, heap);</span>
<a href="#l72.301"></a><span id="l72.301" class="difflineminus">-      </span>
<a href="#l72.302"></a><span id="l72.302" class="difflineplus">+</span>
<a href="#l72.303"></a><span id="l72.303">     if ( space ) // successful space creation?</span>
<a href="#l72.304"></a><span id="l72.304">     {</span>
<a href="#l72.305"></a><span id="l72.305">       this-&gt;MaybeDirtyStore();</span>
<a href="#l72.306"></a><span id="l72.306" class="difflineminus">-    </span>
<a href="#l72.307"></a><span id="l72.307" class="difflineplus">+</span>
<a href="#l72.308"></a><span id="l72.308">       mStore_GroundColumnSpace = space; // transfer strong ref to this slot</span>
<a href="#l72.309"></a><span id="l72.309">       mStore_AtomSpaces.AddAtomSpace(ev, space);</span>
<a href="#l72.310"></a><span id="l72.310">     }</span>
<a href="#l72.311"></a><span id="l72.311">   }</span>
<a href="#l72.312"></a><span id="l72.312">   return mStore_GroundColumnSpace;</span>
<a href="#l72.313"></a><span id="l72.313"> }</span>
<a href="#l72.314"></a><span id="l72.314"> </span>
<a href="#l72.315"></a><span id="l72.315"> morkStream* morkStore::LazyGetInStream(morkEnv* ev)</span>
<a href="#l72.316"></a><span id="l72.316"> {</span>
<a href="#l72.317"></a><span id="l72.317">   if ( !mStore_InStream )</span>
<a href="#l72.318"></a><span id="l72.318">   {</span>
<a href="#l72.319"></a><span id="l72.319">     nsIMdbFile* file = mStore_File;</span>
<a href="#l72.320"></a><span id="l72.320">     if ( file )</span>
<a href="#l72.321"></a><span id="l72.321">     {</span>
<a href="#l72.322"></a><span id="l72.322" class="difflineminus">-      morkStream* stream = new(*mPort_Heap, ev) </span>
<a href="#l72.323"></a><span id="l72.323" class="difflineplus">+      morkStream* stream = new(*mPort_Heap, ev)</span>
<a href="#l72.324"></a><span id="l72.324">         morkStream(ev, morkUsage::kHeap, mPort_Heap, file,</span>
<a href="#l72.325"></a><span id="l72.325">           morkStore_kStreamBufSize, /*frozen*/ morkBool_kTrue);</span>
<a href="#l72.326"></a><span id="l72.326">       if ( stream )</span>
<a href="#l72.327"></a><span id="l72.327">       {</span>
<a href="#l72.328"></a><span id="l72.328">         this-&gt;MaybeDirtyStore();</span>
<a href="#l72.329"></a><span id="l72.329">         mStore_InStream = stream; // transfer strong ref to this slot</span>
<a href="#l72.330"></a><span id="l72.330">       }</span>
<a href="#l72.331"></a><span id="l72.331">     }</span>
<a href="#l72.332"></a><span id="l72.332" class="difflineat">@@ -489,17 +489,17 @@ morkStream* morkStore::LazyGetInStream(m</span>
<a href="#l72.333"></a><span id="l72.333"> </span>
<a href="#l72.334"></a><span id="l72.334"> morkStream* morkStore::LazyGetOutStream(morkEnv* ev)</span>
<a href="#l72.335"></a><span id="l72.335"> {</span>
<a href="#l72.336"></a><span id="l72.336">   if ( !mStore_OutStream )</span>
<a href="#l72.337"></a><span id="l72.337">   {</span>
<a href="#l72.338"></a><span id="l72.338">     nsIMdbFile* file = mStore_File;</span>
<a href="#l72.339"></a><span id="l72.339">     if ( file )</span>
<a href="#l72.340"></a><span id="l72.340">     {</span>
<a href="#l72.341"></a><span id="l72.341" class="difflineminus">-      morkStream* stream = new(*mPort_Heap, ev) </span>
<a href="#l72.342"></a><span id="l72.342" class="difflineplus">+      morkStream* stream = new(*mPort_Heap, ev)</span>
<a href="#l72.343"></a><span id="l72.343">         morkStream(ev, morkUsage::kHeap, mPort_Heap, file,</span>
<a href="#l72.344"></a><span id="l72.344">           morkStore_kStreamBufSize, /*frozen*/ morkBool_kFalse);</span>
<a href="#l72.345"></a><span id="l72.345">       if ( stream )</span>
<a href="#l72.346"></a><span id="l72.346">       {</span>
<a href="#l72.347"></a><span id="l72.347">         this-&gt;MaybeDirtyStore();</span>
<a href="#l72.348"></a><span id="l72.348">         mStore_InStream = stream; // transfer strong ref to this slot</span>
<a href="#l72.349"></a><span id="l72.349">       }</span>
<a href="#l72.350"></a><span id="l72.350">     }</span>
<a href="#l72.351"></a><span id="l72.351" class="difflineat">@@ -521,17 +521,17 @@ morkStore::ForgetBuilder(morkEnv* ev)</span>
<a href="#l72.352"></a><span id="l72.352"> morkBuilder* morkStore::LazyGetBuilder(morkEnv* ev)</span>
<a href="#l72.353"></a><span id="l72.353"> {</span>
<a href="#l72.354"></a><span id="l72.354">   if ( !mStore_Builder )</span>
<a href="#l72.355"></a><span id="l72.355">   {</span>
<a href="#l72.356"></a><span id="l72.356">     morkStream* stream = this-&gt;LazyGetInStream(ev);</span>
<a href="#l72.357"></a><span id="l72.357">     if ( stream )</span>
<a href="#l72.358"></a><span id="l72.358">     {</span>
<a href="#l72.359"></a><span id="l72.359">       nsIMdbHeap* heap = mPort_Heap;</span>
<a href="#l72.360"></a><span id="l72.360" class="difflineminus">-      morkBuilder* builder = new(*heap, ev) </span>
<a href="#l72.361"></a><span id="l72.361" class="difflineplus">+      morkBuilder* builder = new(*heap, ev)</span>
<a href="#l72.362"></a><span id="l72.362">         morkBuilder(ev, morkUsage::kHeap, heap, stream,</span>
<a href="#l72.363"></a><span id="l72.363">           morkBuilder_kDefaultBytesPerParseSegment, heap, this);</span>
<a href="#l72.364"></a><span id="l72.364">       if ( builder )</span>
<a href="#l72.365"></a><span id="l72.365">       {</span>
<a href="#l72.366"></a><span id="l72.366">         mStore_Builder = builder; // transfer strong ref to this slot</span>
<a href="#l72.367"></a><span id="l72.367">       }</span>
<a href="#l72.368"></a><span id="l72.368">     }</span>
<a href="#l72.369"></a><span id="l72.369">   }</span>
<a href="#l72.370"></a><span id="l72.370" class="difflineat">@@ -540,52 +540,52 @@ morkBuilder* morkStore::LazyGetBuilder(m</span>
<a href="#l72.371"></a><span id="l72.371"> </span>
<a href="#l72.372"></a><span id="l72.372"> morkRowSpace*</span>
<a href="#l72.373"></a><span id="l72.373"> morkStore::LazyGetRowSpace(morkEnv* ev, mdb_scope inRowScope)</span>
<a href="#l72.374"></a><span id="l72.374"> {</span>
<a href="#l72.375"></a><span id="l72.375">   morkRowSpace* outSpace = mStore_RowSpaces.GetRowSpace(ev, inRowScope);</span>
<a href="#l72.376"></a><span id="l72.376">   if ( !outSpace &amp;&amp; ev-&gt;Good() ) // try to make new space?</span>
<a href="#l72.377"></a><span id="l72.377">   {</span>
<a href="#l72.378"></a><span id="l72.378">     nsIMdbHeap* heap = mPort_Heap;</span>
<a href="#l72.379"></a><span id="l72.379" class="difflineminus">-    outSpace = new(*heap, ev) </span>
<a href="#l72.380"></a><span id="l72.380" class="difflineplus">+    outSpace = new(*heap, ev)</span>
<a href="#l72.381"></a><span id="l72.381">       morkRowSpace(ev, morkUsage::kHeap, inRowScope, this, heap, heap);</span>
<a href="#l72.382"></a><span id="l72.382" class="difflineminus">-      </span>
<a href="#l72.383"></a><span id="l72.383" class="difflineplus">+</span>
<a href="#l72.384"></a><span id="l72.384">     if ( outSpace ) // successful space creation?</span>
<a href="#l72.385"></a><span id="l72.385">     {</span>
<a href="#l72.386"></a><span id="l72.386">       this-&gt;MaybeDirtyStore();</span>
<a href="#l72.387"></a><span id="l72.387" class="difflineminus">-    </span>
<a href="#l72.388"></a><span id="l72.388" class="difflineplus">+</span>
<a href="#l72.389"></a><span id="l72.389">       // note adding to node map creates its own strong ref...</span>
<a href="#l72.390"></a><span id="l72.390">       if ( mStore_RowSpaces.AddRowSpace(ev, outSpace) )</span>
<a href="#l72.391"></a><span id="l72.391">         outSpace-&gt;CutStrongRef(ev); // ...so we can drop our strong ref</span>
<a href="#l72.392"></a><span id="l72.392">     }</span>
<a href="#l72.393"></a><span id="l72.393">   }</span>
<a href="#l72.394"></a><span id="l72.394">   return outSpace;</span>
<a href="#l72.395"></a><span id="l72.395"> }</span>
<a href="#l72.396"></a><span id="l72.396"> </span>
<a href="#l72.397"></a><span id="l72.397"> morkAtomSpace*</span>
<a href="#l72.398"></a><span id="l72.398"> morkStore::LazyGetAtomSpace(morkEnv* ev, mdb_scope inAtomScope)</span>
<a href="#l72.399"></a><span id="l72.399"> {</span>
<a href="#l72.400"></a><span id="l72.400">   morkAtomSpace* outSpace = mStore_AtomSpaces.GetAtomSpace(ev, inAtomScope);</span>
<a href="#l72.401"></a><span id="l72.401">   if ( !outSpace &amp;&amp; ev-&gt;Good() ) // try to make new space?</span>
<a href="#l72.402"></a><span id="l72.402">   {</span>
<a href="#l72.403"></a><span id="l72.403">     if ( inAtomScope == morkStore_kValueSpaceScope )</span>
<a href="#l72.404"></a><span id="l72.404">       outSpace = this-&gt;LazyGetGroundAtomSpace(ev);</span>
<a href="#l72.405"></a><span id="l72.405" class="difflineminus">-      </span>
<a href="#l72.406"></a><span id="l72.406" class="difflineplus">+</span>
<a href="#l72.407"></a><span id="l72.407">     else if ( inAtomScope == morkStore_kGroundColumnSpace )</span>
<a href="#l72.408"></a><span id="l72.408">       outSpace = this-&gt;LazyGetGroundColumnSpace(ev);</span>
<a href="#l72.409"></a><span id="l72.409">     else</span>
<a href="#l72.410"></a><span id="l72.410">     {</span>
<a href="#l72.411"></a><span id="l72.411">       nsIMdbHeap* heap = mPort_Heap;</span>
<a href="#l72.412"></a><span id="l72.412" class="difflineminus">-      outSpace = new(*heap, ev) </span>
<a href="#l72.413"></a><span id="l72.413" class="difflineplus">+      outSpace = new(*heap, ev)</span>
<a href="#l72.414"></a><span id="l72.414">         morkAtomSpace(ev, morkUsage::kHeap, inAtomScope, this, heap, heap);</span>
<a href="#l72.415"></a><span id="l72.415" class="difflineminus">-        </span>
<a href="#l72.416"></a><span id="l72.416" class="difflineplus">+</span>
<a href="#l72.417"></a><span id="l72.417">       if ( outSpace ) // successful space creation?</span>
<a href="#l72.418"></a><span id="l72.418">       {</span>
<a href="#l72.419"></a><span id="l72.419">         this-&gt;MaybeDirtyStore();</span>
<a href="#l72.420"></a><span id="l72.420" class="difflineminus">-    </span>
<a href="#l72.421"></a><span id="l72.421" class="difflineplus">+</span>
<a href="#l72.422"></a><span id="l72.422">         // note adding to node map creates its own strong ref...</span>
<a href="#l72.423"></a><span id="l72.423">         if ( mStore_AtomSpaces.AddAtomSpace(ev, outSpace) )</span>
<a href="#l72.424"></a><span id="l72.424">           outSpace-&gt;CutStrongRef(ev); // ...so we can drop our strong ref</span>
<a href="#l72.425"></a><span id="l72.425">       }</span>
<a href="#l72.426"></a><span id="l72.426">     }</span>
<a href="#l72.427"></a><span id="l72.427">   }</span>
<a href="#l72.428"></a><span id="l72.428">   return outSpace;</span>
<a href="#l72.429"></a><span id="l72.429"> }</span>
<a href="#l72.430"></a><span id="l72.430" class="difflineat">@@ -612,42 +612,42 @@ morkStore::CannotAutoAssignAtomIdentityE</span>
<a href="#l72.431"></a><span id="l72.431"> mork_bool</span>
<a href="#l72.432"></a><span id="l72.432"> morkStore::OpenStoreFile(morkEnv* ev, mork_bool inFrozen,</span>
<a href="#l72.433"></a><span id="l72.433">     // const char* inFilePath,</span>
<a href="#l72.434"></a><span id="l72.434">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l72.435"></a><span id="l72.435">     const mdbOpenPolicy* inOpenPolicy)</span>
<a href="#l72.436"></a><span id="l72.436"> {</span>
<a href="#l72.437"></a><span id="l72.437">   MORK_USED_2(inOpenPolicy,inFrozen);</span>
<a href="#l72.438"></a><span id="l72.438">   nsIMdbFile_SlotStrongFile(ioFile, ev, &amp;mStore_File);</span>
<a href="#l72.439"></a><span id="l72.439" class="difflineminus">-  </span>
<a href="#l72.440"></a><span id="l72.440" class="difflineplus">+</span>
<a href="#l72.441"></a><span id="l72.441">   // if ( ev-&gt;Good() )</span>
<a href="#l72.442"></a><span id="l72.442">   // {</span>
<a href="#l72.443"></a><span id="l72.443">   //   morkFile* file = morkFile::OpenOldFile(ev, mPort_Heap,</span>
<a href="#l72.444"></a><span id="l72.444">   //     inFilePath, inFrozen);</span>
<a href="#l72.445"></a><span id="l72.445">   //   if ( ioFile )</span>
<a href="#l72.446"></a><span id="l72.446">   //   {</span>
<a href="#l72.447"></a><span id="l72.447">   //     if ( ev-&gt;Good() )</span>
<a href="#l72.448"></a><span id="l72.448">   //       morkFile::SlotStrongFile(file, ev, &amp;mStore_File);</span>
<a href="#l72.449"></a><span id="l72.449">   //     else</span>
<a href="#l72.450"></a><span id="l72.450">   //       file-&gt;CutStrongRef(ev);</span>
<a href="#l72.451"></a><span id="l72.451" class="difflineminus">-  //       </span>
<a href="#l72.452"></a><span id="l72.452" class="difflineplus">+  //</span>
<a href="#l72.453"></a><span id="l72.453">   //   }</span>
<a href="#l72.454"></a><span id="l72.454">   // }</span>
<a href="#l72.455"></a><span id="l72.455">   return ev-&gt;Good();</span>
<a href="#l72.456"></a><span id="l72.456"> }</span>
<a href="#l72.457"></a><span id="l72.457"> </span>
<a href="#l72.458"></a><span id="l72.458"> mork_bool</span>
<a href="#l72.459"></a><span id="l72.459"> morkStore::CreateStoreFile(morkEnv* ev,</span>
<a href="#l72.460"></a><span id="l72.460">     // const char* inFilePath,</span>
<a href="#l72.461"></a><span id="l72.461">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l72.462"></a><span id="l72.462">     const mdbOpenPolicy* inOpenPolicy)</span>
<a href="#l72.463"></a><span id="l72.463"> {</span>
<a href="#l72.464"></a><span id="l72.464">   MORK_USED_1(inOpenPolicy);</span>
<a href="#l72.465"></a><span id="l72.465">   nsIMdbFile_SlotStrongFile(ioFile, ev, &amp;mStore_File);</span>
<a href="#l72.466"></a><span id="l72.466" class="difflineminus">-  </span>
<a href="#l72.467"></a><span id="l72.467" class="difflineplus">+</span>
<a href="#l72.468"></a><span id="l72.468">   return ev-&gt;Good();</span>
<a href="#l72.469"></a><span id="l72.469"> }</span>
<a href="#l72.470"></a><span id="l72.470"> </span>
<a href="#l72.471"></a><span id="l72.471"> morkAtom*</span>
<a href="#l72.472"></a><span id="l72.472"> morkStore::CopyAtom(morkEnv* ev, const morkAtom* inAtom)</span>
<a href="#l72.473"></a><span id="l72.473"> // copy inAtom (from some other store) over to this store</span>
<a href="#l72.474"></a><span id="l72.474"> {</span>
<a href="#l72.475"></a><span id="l72.475">   morkAtom* outAtom = 0;</span>
<a href="#l72.476"></a><span id="l72.476" class="difflineat">@@ -666,17 +666,17 @@ morkStore::YarnToAtom(morkEnv* ev, const</span>
<a href="#l72.477"></a><span id="l72.477">   morkAtom* outAtom = 0;</span>
<a href="#l72.478"></a><span id="l72.478">   if ( ev-&gt;Good() )</span>
<a href="#l72.479"></a><span id="l72.479">   {</span>
<a href="#l72.480"></a><span id="l72.480">     morkAtomSpace* groundSpace = this-&gt;LazyGetGroundAtomSpace(ev);</span>
<a href="#l72.481"></a><span id="l72.481">     if ( groundSpace )</span>
<a href="#l72.482"></a><span id="l72.482">     {</span>
<a href="#l72.483"></a><span id="l72.483">       morkFarBookAtom* keyAtom =</span>
<a href="#l72.484"></a><span id="l72.484">         this-&gt;StageYarnAsFarBookAtom(ev, inYarn, groundSpace);</span>
<a href="#l72.485"></a><span id="l72.485" class="difflineminus">-        </span>
<a href="#l72.486"></a><span id="l72.486" class="difflineplus">+</span>
<a href="#l72.487"></a><span id="l72.487">       if ( keyAtom )</span>
<a href="#l72.488"></a><span id="l72.488">       {</span>
<a href="#l72.489"></a><span id="l72.489">         morkAtomBodyMap* map = &amp;groundSpace-&gt;mAtomSpace_AtomBodies;</span>
<a href="#l72.490"></a><span id="l72.490">         outAtom = map-&gt;GetAtom(ev, keyAtom);</span>
<a href="#l72.491"></a><span id="l72.491">         if ( !outAtom &amp;&amp; createIfMissing)</span>
<a href="#l72.492"></a><span id="l72.492">         {</span>
<a href="#l72.493"></a><span id="l72.493">           this-&gt;MaybeDirtyStore();</span>
<a href="#l72.494"></a><span id="l72.494">           outAtom = groundSpace-&gt;MakeBookAtomCopy(ev, *keyAtom);</span>
<a href="#l72.495"></a><span id="l72.495" class="difflineat">@@ -761,17 +761,17 @@ morkStore::MidToYarn(morkEnv* ev, const </span>
<a href="#l72.496"></a><span id="l72.496">   this-&gt;MidToOid(ev, inMid, &amp;tempOid);</span>
<a href="#l72.497"></a><span id="l72.497">   return this-&gt;OidToYarn(ev, tempOid, outYarn);</span>
<a href="#l72.498"></a><span id="l72.498"> }</span>
<a href="#l72.499"></a><span id="l72.499"> </span>
<a href="#l72.500"></a><span id="l72.500"> mork_bool</span>
<a href="#l72.501"></a><span id="l72.501"> morkStore::OidToYarn(morkEnv* ev, const mdbOid&amp; inOid, mdbYarn* outYarn)</span>
<a href="#l72.502"></a><span id="l72.502"> {</span>
<a href="#l72.503"></a><span id="l72.503">   morkBookAtom* atom = 0;</span>
<a href="#l72.504"></a><span id="l72.504" class="difflineminus">-      </span>
<a href="#l72.505"></a><span id="l72.505" class="difflineplus">+</span>
<a href="#l72.506"></a><span id="l72.506">   morkAtomSpace* atomSpace = mStore_AtomSpaces.GetAtomSpace(ev, inOid.mOid_Scope);</span>
<a href="#l72.507"></a><span id="l72.507">   if ( atomSpace )</span>
<a href="#l72.508"></a><span id="l72.508">   {</span>
<a href="#l72.509"></a><span id="l72.509">     morkAtomAidMap* map = &amp;atomSpace-&gt;mAtomSpace_AtomAids;</span>
<a href="#l72.510"></a><span id="l72.510">     atom = map-&gt;GetAid(ev, (mork_aid) inOid.mOid_Id);</span>
<a href="#l72.511"></a><span id="l72.511">   }</span>
<a href="#l72.512"></a><span id="l72.512">   atom-&gt;GetYarn(outYarn); // note this is safe even when atom==nil</span>
<a href="#l72.513"></a><span id="l72.513"> </span>
<a href="#l72.514"></a><span id="l72.514" class="difflineat">@@ -818,41 +818,41 @@ void</span>
<a href="#l72.515"></a><span id="l72.515"> morkStore::TokenToString(morkEnv* ev, mdb_token inToken, mdbYarn* outTokenName)</span>
<a href="#l72.516"></a><span id="l72.516"> {</span>
<a href="#l72.517"></a><span id="l72.517">   if ( inToken &gt; morkAtomSpace_kMaxSevenBitAid )</span>
<a href="#l72.518"></a><span id="l72.518">   {</span>
<a href="#l72.519"></a><span id="l72.519">     morkBookAtom* atom = 0;</span>
<a href="#l72.520"></a><span id="l72.520">     morkAtomSpace* space = mStore_GroundColumnSpace;</span>
<a href="#l72.521"></a><span id="l72.521">     if ( space )</span>
<a href="#l72.522"></a><span id="l72.522">       atom = space-&gt;mAtomSpace_AtomAids.GetAid(ev, (mork_aid) inToken);</span>
<a href="#l72.523"></a><span id="l72.523" class="difflineminus">-      </span>
<a href="#l72.524"></a><span id="l72.524" class="difflineplus">+</span>
<a href="#l72.525"></a><span id="l72.525">     atom-&gt;GetYarn(outTokenName); // note this is safe even when atom==nil</span>
<a href="#l72.526"></a><span id="l72.526">   }</span>
<a href="#l72.527"></a><span id="l72.527">   else // token is an &quot;immediate&quot; single byte string representation?</span>
<a href="#l72.528"></a><span id="l72.528">     this-&gt;SmallTokenToOneByteYarn(ev, inToken, outTokenName);</span>
<a href="#l72.529"></a><span id="l72.529"> }</span>
<a href="#l72.530"></a><span id="l72.530" class="difflineminus">-  </span>
<a href="#l72.531"></a><span id="l72.531" class="difflineplus">+</span>
<a href="#l72.532"></a><span id="l72.532"> // void</span>
<a href="#l72.533"></a><span id="l72.533"> // morkStore::SyncTokenIdChange(morkEnv* ev, const morkBookAtom* inAtom,</span>
<a href="#l72.534"></a><span id="l72.534"> //   const mdbOid* inOid)</span>
<a href="#l72.535"></a><span id="l72.535"> // {</span>
<a href="#l72.536"></a><span id="l72.536"> // mork_token   mStore_MorkNoneToken;    // token for &quot;mork:none&quot;   // fill=9</span>
<a href="#l72.537"></a><span id="l72.537"> // mork_column  mStore_CharsetToken;     // token for &quot;charset&quot;     // fill=7</span>
<a href="#l72.538"></a><span id="l72.538"> // mork_column  mStore_AtomScopeToken;   // token for &quot;atomScope&quot;   // fill=9</span>
<a href="#l72.539"></a><span id="l72.539"> // mork_column  mStore_RowScopeToken;    // token for &quot;rowScope&quot;    // fill=8</span>
<a href="#l72.540"></a><span id="l72.540"> // mork_column  mStore_TableScopeToken;  // token for &quot;tableScope&quot;  // fill=10</span>
<a href="#l72.541"></a><span id="l72.541"> // mork_column  mStore_ColumnScopeToken; // token for &quot;columnScope&quot; // fill=11</span>
<a href="#l72.542"></a><span id="l72.542"> // mork_kind    mStore_TableKindToken;   // token for &quot;tableKind&quot;   // fill=9</span>
<a href="#l72.543"></a><span id="l72.543"> // ---------------------ruler-for-token-length-above---123456789012</span>
<a href="#l72.544"></a><span id="l72.544" class="difflineminus">-// </span>
<a href="#l72.545"></a><span id="l72.545" class="difflineplus">+//</span>
<a href="#l72.546"></a><span id="l72.546"> //   if ( inOid-&gt;mOid_Scope == morkStore_kColumnSpaceScope &amp;&amp; inAtom-&gt;IsWeeBook() )</span>
<a href="#l72.547"></a><span id="l72.547"> //   {</span>
<a href="#l72.548"></a><span id="l72.548"> //     const mork_u1* body = ((const morkWeeBookAtom*) inAtom)-&gt;mWeeBookAtom_Body;</span>
<a href="#l72.549"></a><span id="l72.549"> //     mork_size size = inAtom-&gt;mAtom_Size;</span>
<a href="#l72.550"></a><span id="l72.550" class="difflineminus">-// </span>
<a href="#l72.551"></a><span id="l72.551" class="difflineplus">+//</span>
<a href="#l72.552"></a><span id="l72.552"> //     if ( size &gt;= 7 &amp;&amp; size &lt;= 11 )</span>
<a href="#l72.553"></a><span id="l72.553"> //     {</span>
<a href="#l72.554"></a><span id="l72.554"> //       if ( size == 9 )</span>
<a href="#l72.555"></a><span id="l72.555"> //       {</span>
<a href="#l72.556"></a><span id="l72.556"> //         if ( *body == 'm' )</span>
<a href="#l72.557"></a><span id="l72.557"> //         {</span>
<a href="#l72.558"></a><span id="l72.558"> //           if ( MORK_MEMCMP(body, &quot;mork:none&quot;, 9) == 0 )</span>
<a href="#l72.559"></a><span id="l72.559"> //             mStore_MorkNoneToken = inAtom-&gt;mBookAtom_Id;</span>
<a href="#l72.560"></a><span id="l72.560" class="difflineat">@@ -914,17 +914,17 @@ morkStore::AddAlias(morkEnv* ev, const m</span>
<a href="#l72.561"></a><span id="l72.561">               ev-&gt;NewError(&quot;duplicate alias ID&quot;);</span>
<a href="#l72.562"></a><span id="l72.562">         }</span>
<a href="#l72.563"></a><span id="l72.563">         else</span>
<a href="#l72.564"></a><span id="l72.564">         {</span>
<a href="#l72.565"></a><span id="l72.565">           this-&gt;MaybeDirtyStore();</span>
<a href="#l72.566"></a><span id="l72.566">           keyAtom-&gt;mBookAtom_Id = oid-&gt;mOid_Id;</span>
<a href="#l72.567"></a><span id="l72.567">           outAtom = atomSpace-&gt;MakeBookAtomCopyWithAid(ev,</span>
<a href="#l72.568"></a><span id="l72.568">             *keyAtom, (mork_aid) oid-&gt;mOid_Id);</span>
<a href="#l72.569"></a><span id="l72.569" class="difflineminus">-            </span>
<a href="#l72.570"></a><span id="l72.570" class="difflineplus">+</span>
<a href="#l72.571"></a><span id="l72.571">           // if ( outAtom &amp;&amp; outAtom-&gt;IsWeeBook() )</span>
<a href="#l72.572"></a><span id="l72.572">           // {</span>
<a href="#l72.573"></a><span id="l72.573">           //   if ( oid-&gt;mOid_Scope == morkStore_kColumnSpaceScope )</span>
<a href="#l72.574"></a><span id="l72.574">           //   {</span>
<a href="#l72.575"></a><span id="l72.575">           //    mork_size size = outAtom-&gt;mAtom_Size;</span>
<a href="#l72.576"></a><span id="l72.576">           //     if ( size &gt;= 7 &amp;&amp; size &lt;= 11 )</span>
<a href="#l72.577"></a><span id="l72.577">           //       this-&gt;SyncTokenIdChange(ev, outAtom, oid);</span>
<a href="#l72.578"></a><span id="l72.578">           //   }</span>
<a href="#l72.579"></a><span id="l72.579" class="difflineat">@@ -932,17 +932,17 @@ morkStore::AddAlias(morkEnv* ev, const m</span>
<a href="#l72.580"></a><span id="l72.580">         }</span>
<a href="#l72.581"></a><span id="l72.581">       }</span>
<a href="#l72.582"></a><span id="l72.582">     }</span>
<a href="#l72.583"></a><span id="l72.583">   }</span>
<a href="#l72.584"></a><span id="l72.584">   return outAtom;</span>
<a href="#l72.585"></a><span id="l72.585"> }</span>
<a href="#l72.586"></a><span id="l72.586"> </span>
<a href="#l72.587"></a><span id="l72.587"> #define morkStore_kMaxCopyTokenSize 512 /* if larger, cannot be copied */</span>
<a href="#l72.588"></a><span id="l72.588" class="difflineminus">-  </span>
<a href="#l72.589"></a><span id="l72.589" class="difflineplus">+</span>
<a href="#l72.590"></a><span id="l72.590"> mork_token</span>
<a href="#l72.591"></a><span id="l72.591"> morkStore::CopyToken(morkEnv* ev, mdb_token inToken, morkStore* inStore)</span>
<a href="#l72.592"></a><span id="l72.592"> // copy inToken from inStore over to this store</span>
<a href="#l72.593"></a><span id="l72.593"> {</span>
<a href="#l72.594"></a><span id="l72.594">   mork_token outToken = 0;</span>
<a href="#l72.595"></a><span id="l72.595">   if ( inStore == this ) // same store?</span>
<a href="#l72.596"></a><span id="l72.596">     outToken = inToken; // just return token unchanged</span>
<a href="#l72.597"></a><span id="l72.597">   else</span>
<a href="#l72.598"></a><span id="l72.598" class="difflineat">@@ -950,17 +950,17 @@ morkStore::CopyToken(morkEnv* ev, mdb_to</span>
<a href="#l72.599"></a><span id="l72.599">     char yarnBuf[ morkStore_kMaxCopyTokenSize ];</span>
<a href="#l72.600"></a><span id="l72.600">     mdbYarn yarn;</span>
<a href="#l72.601"></a><span id="l72.601">     yarn.mYarn_Buf = yarnBuf;</span>
<a href="#l72.602"></a><span id="l72.602">     yarn.mYarn_Fill = 0;</span>
<a href="#l72.603"></a><span id="l72.603">     yarn.mYarn_Size = morkStore_kMaxCopyTokenSize;</span>
<a href="#l72.604"></a><span id="l72.604">     yarn.mYarn_More = 0;</span>
<a href="#l72.605"></a><span id="l72.605">     yarn.mYarn_Form = 0;</span>
<a href="#l72.606"></a><span id="l72.606">     yarn.mYarn_Grow = 0;</span>
<a href="#l72.607"></a><span id="l72.607" class="difflineminus">-    </span>
<a href="#l72.608"></a><span id="l72.608" class="difflineplus">+</span>
<a href="#l72.609"></a><span id="l72.609">     inStore-&gt;TokenToString(ev, inToken, &amp;yarn);</span>
<a href="#l72.610"></a><span id="l72.610">     if ( ev-&gt;Good() )</span>
<a href="#l72.611"></a><span id="l72.611">     {</span>
<a href="#l72.612"></a><span id="l72.612">       morkBuf buf(yarn.mYarn_Buf, yarn.mYarn_Fill);</span>
<a href="#l72.613"></a><span id="l72.613">       outToken = this-&gt;BufToToken(ev, &amp;buf);</span>
<a href="#l72.614"></a><span id="l72.614">     }</span>
<a href="#l72.615"></a><span id="l72.615">   }</span>
<a href="#l72.616"></a><span id="l72.616">   return outToken;</span>
<a href="#l72.617"></a><span id="l72.617" class="difflineat">@@ -1006,17 +1006,17 @@ morkStore::BufToToken(morkEnv* ev, const</span>
<a href="#l72.618"></a><span id="l72.618">             }</span>
<a href="#l72.619"></a><span id="l72.619">           }</span>
<a href="#l72.620"></a><span id="l72.620">         }</span>
<a href="#l72.621"></a><span id="l72.621">       }</span>
<a href="#l72.622"></a><span id="l72.622">     }</span>
<a href="#l72.623"></a><span id="l72.623">     else // only a single byte in inTokenName string:</span>
<a href="#l72.624"></a><span id="l72.624">       outToken = *s;</span>
<a href="#l72.625"></a><span id="l72.625">   }</span>
<a href="#l72.626"></a><span id="l72.626" class="difflineminus">-  </span>
<a href="#l72.627"></a><span id="l72.627" class="difflineplus">+</span>
<a href="#l72.628"></a><span id="l72.628">   return outToken;</span>
<a href="#l72.629"></a><span id="l72.629"> }</span>
<a href="#l72.630"></a><span id="l72.630"> </span>
<a href="#l72.631"></a><span id="l72.631"> mork_token</span>
<a href="#l72.632"></a><span id="l72.632"> morkStore::StringToToken(morkEnv* ev, const char* inTokenName)</span>
<a href="#l72.633"></a><span id="l72.633"> {</span>
<a href="#l72.634"></a><span id="l72.634">   mork_token outToken = 0;</span>
<a href="#l72.635"></a><span id="l72.635">   if ( ev-&gt;Good() )</span>
<a href="#l72.636"></a><span id="l72.636" class="difflineat">@@ -1048,17 +1048,17 @@ morkStore::StringToToken(morkEnv* ev, co</span>
<a href="#l72.637"></a><span id="l72.637">             }</span>
<a href="#l72.638"></a><span id="l72.638">           }</span>
<a href="#l72.639"></a><span id="l72.639">         }</span>
<a href="#l72.640"></a><span id="l72.640">       }</span>
<a href="#l72.641"></a><span id="l72.641">     }</span>
<a href="#l72.642"></a><span id="l72.642">     else // only a single byte in inTokenName string:</span>
<a href="#l72.643"></a><span id="l72.643">       outToken = *s;</span>
<a href="#l72.644"></a><span id="l72.644">   }</span>
<a href="#l72.645"></a><span id="l72.645" class="difflineminus">-  </span>
<a href="#l72.646"></a><span id="l72.646" class="difflineplus">+</span>
<a href="#l72.647"></a><span id="l72.647">   return outToken;</span>
<a href="#l72.648"></a><span id="l72.648"> }</span>
<a href="#l72.649"></a><span id="l72.649"> </span>
<a href="#l72.650"></a><span id="l72.650"> mork_token</span>
<a href="#l72.651"></a><span id="l72.651"> morkStore::QueryToken(morkEnv* ev, const char* inTokenName)</span>
<a href="#l72.652"></a><span id="l72.652"> {</span>
<a href="#l72.653"></a><span id="l72.653">   mork_token outToken = 0;</span>
<a href="#l72.654"></a><span id="l72.654">   if ( ev-&gt;Good() )</span>
<a href="#l72.655"></a><span id="l72.655" class="difflineat">@@ -1083,37 +1083,37 @@ morkStore::QueryToken(morkEnv* ev, const</span>
<a href="#l72.656"></a><span id="l72.656">             bookAtom-&gt;MakeCellUseForever(ev);</span>
<a href="#l72.657"></a><span id="l72.657">           }</span>
<a href="#l72.658"></a><span id="l72.658">         }</span>
<a href="#l72.659"></a><span id="l72.659">       }</span>
<a href="#l72.660"></a><span id="l72.660">     }</span>
<a href="#l72.661"></a><span id="l72.661">     else // only a single byte in inTokenName string:</span>
<a href="#l72.662"></a><span id="l72.662">       outToken = *s;</span>
<a href="#l72.663"></a><span id="l72.663">   }</span>
<a href="#l72.664"></a><span id="l72.664" class="difflineminus">-  </span>
<a href="#l72.665"></a><span id="l72.665" class="difflineplus">+</span>
<a href="#l72.666"></a><span id="l72.666">   return outToken;</span>
<a href="#l72.667"></a><span id="l72.667"> }</span>
<a href="#l72.668"></a><span id="l72.668"> </span>
<a href="#l72.669"></a><span id="l72.669"> mork_bool</span>
<a href="#l72.670"></a><span id="l72.670" class="difflineminus">-morkStore::HasTableKind(morkEnv* ev, mdb_scope inRowScope, </span>
<a href="#l72.671"></a><span id="l72.671" class="difflineplus">+morkStore::HasTableKind(morkEnv* ev, mdb_scope inRowScope,</span>
<a href="#l72.672"></a><span id="l72.672">   mdb_kind inTableKind, mdb_count* outTableCount)</span>
<a href="#l72.673"></a><span id="l72.673"> {</span>
<a href="#l72.674"></a><span id="l72.674">   MORK_USED_2(inRowScope,inTableKind);</span>
<a href="#l72.675"></a><span id="l72.675">   mork_bool outBool = morkBool_kFalse;</span>
<a href="#l72.676"></a><span id="l72.676">   mdb_count tableCount = 0;</span>
<a href="#l72.677"></a><span id="l72.677"> </span>
<a href="#l72.678"></a><span id="l72.678">   ev-&gt;StubMethodOnlyError();</span>
<a href="#l72.679"></a><span id="l72.679" class="difflineminus">-  </span>
<a href="#l72.680"></a><span id="l72.680" class="difflineplus">+</span>
<a href="#l72.681"></a><span id="l72.681">   if ( outTableCount )</span>
<a href="#l72.682"></a><span id="l72.682">     *outTableCount = tableCount;</span>
<a href="#l72.683"></a><span id="l72.683">   return outBool;</span>
<a href="#l72.684"></a><span id="l72.684"> }</span>
<a href="#l72.685"></a><span id="l72.685"> </span>
<a href="#l72.686"></a><span id="l72.686"> morkTable*</span>
<a href="#l72.687"></a><span id="l72.687" class="difflineminus">-morkStore::GetTableKind(morkEnv* ev, mdb_scope inRowScope, </span>
<a href="#l72.688"></a><span id="l72.688" class="difflineplus">+morkStore::GetTableKind(morkEnv* ev, mdb_scope inRowScope,</span>
<a href="#l72.689"></a><span id="l72.689">   mdb_kind inTableKind, mdb_count* outTableCount,</span>
<a href="#l72.690"></a><span id="l72.690">   mdb_bool* outMustBeUnique)</span>
<a href="#l72.691"></a><span id="l72.691"> {</span>
<a href="#l72.692"></a><span id="l72.692">   morkTable* outTable = 0;</span>
<a href="#l72.693"></a><span id="l72.693">   if ( ev-&gt;Good() )</span>
<a href="#l72.694"></a><span id="l72.694">   {</span>
<a href="#l72.695"></a><span id="l72.695">     morkRowSpace* rowSpace = this-&gt;LazyGetRowSpace(ev, inRowScope);</span>
<a href="#l72.696"></a><span id="l72.696">     if ( rowSpace )</span>
<a href="#l72.697"></a><span id="l72.697" class="difflineat">@@ -1171,21 +1171,21 @@ morkStore::GetTable(morkEnv* ev, const m</span>
<a href="#l72.698"></a><span id="l72.698">     morkRowSpace* rowSpace = this-&gt;LazyGetRowSpace(ev, inOid-&gt;mOid_Scope);</span>
<a href="#l72.699"></a><span id="l72.699">     if ( rowSpace )</span>
<a href="#l72.700"></a><span id="l72.700">     {</span>
<a href="#l72.701"></a><span id="l72.701">       outTable = rowSpace-&gt;FindTableByTid(ev, inOid-&gt;mOid_Id);</span>
<a href="#l72.702"></a><span id="l72.702">     }</span>
<a href="#l72.703"></a><span id="l72.703">   }</span>
<a href="#l72.704"></a><span id="l72.704">   return outTable;</span>
<a href="#l72.705"></a><span id="l72.705"> }</span>
<a href="#l72.706"></a><span id="l72.706" class="difflineminus">-  </span>
<a href="#l72.707"></a><span id="l72.707" class="difflineplus">+</span>
<a href="#l72.708"></a><span id="l72.708"> morkTable*</span>
<a href="#l72.709"></a><span id="l72.709"> morkStore::NewTable(morkEnv* ev, mdb_scope inRowScope,</span>
<a href="#l72.710"></a><span id="l72.710">   mdb_kind inTableKind, mdb_bool inMustBeUnique,</span>
<a href="#l72.711"></a><span id="l72.711" class="difflineminus">-  const mdbOid* inOptionalMetaRowOid) // can be nil to avoid specifying </span>
<a href="#l72.712"></a><span id="l72.712" class="difflineplus">+  const mdbOid* inOptionalMetaRowOid) // can be nil to avoid specifying</span>
<a href="#l72.713"></a><span id="l72.713"> {</span>
<a href="#l72.714"></a><span id="l72.714">   morkTable* outTable = 0;</span>
<a href="#l72.715"></a><span id="l72.715">   if ( ev-&gt;Good() )</span>
<a href="#l72.716"></a><span id="l72.716">   {</span>
<a href="#l72.717"></a><span id="l72.717">     morkRowSpace* rowSpace = this-&gt;LazyGetRowSpace(ev, inRowScope);</span>
<a href="#l72.718"></a><span id="l72.718">     if ( rowSpace )</span>
<a href="#l72.719"></a><span id="l72.719">       outTable = rowSpace-&gt;NewTable(ev, inTableKind, inMustBeUnique,</span>
<a href="#l72.720"></a><span id="l72.720">         inOptionalMetaRowOid);</span>
<a href="#l72.721"></a><span id="l72.721" class="difflineat">@@ -1196,17 +1196,17 @@ morkStore::NewTable(morkEnv* ev, mdb_sco</span>
<a href="#l72.722"></a><span id="l72.722"> morkPortTableCursor*</span>
<a href="#l72.723"></a><span id="l72.723"> morkStore::GetPortTableCursor(morkEnv* ev, mdb_scope inRowScope,</span>
<a href="#l72.724"></a><span id="l72.724">   mdb_kind inTableKind)</span>
<a href="#l72.725"></a><span id="l72.725"> {</span>
<a href="#l72.726"></a><span id="l72.726">   morkPortTableCursor* outCursor = 0;</span>
<a href="#l72.727"></a><span id="l72.727">   if ( ev-&gt;Good() )</span>
<a href="#l72.728"></a><span id="l72.728">   {</span>
<a href="#l72.729"></a><span id="l72.729">     nsIMdbHeap* heap = mPort_Heap;</span>
<a href="#l72.730"></a><span id="l72.730" class="difflineminus">-    outCursor = new(*heap, ev) </span>
<a href="#l72.731"></a><span id="l72.731" class="difflineplus">+    outCursor = new(*heap, ev)</span>
<a href="#l72.732"></a><span id="l72.732">       morkPortTableCursor(ev, morkUsage::kHeap, heap, this,</span>
<a href="#l72.733"></a><span id="l72.733">         inRowScope, inTableKind, heap);</span>
<a href="#l72.734"></a><span id="l72.734">   }</span>
<a href="#l72.735"></a><span id="l72.735">   NS_IF_ADDREF(outCursor);</span>
<a href="#l72.736"></a><span id="l72.736">   return outCursor;</span>
<a href="#l72.737"></a><span id="l72.737"> }</span>
<a href="#l72.738"></a><span id="l72.738"> </span>
<a href="#l72.739"></a><span id="l72.739"> morkRow*</span>
<a href="#l72.740"></a><span id="l72.740" class="difflineat">@@ -1250,17 +1250,17 @@ morkStore::OidToRow(morkEnv* ev, const m</span>
<a href="#l72.741"></a><span id="l72.741">         outRow = rowSpace-&gt;NewRowWithOid(ev, inOid);</span>
<a href="#l72.742"></a><span id="l72.742">     }</span>
<a href="#l72.743"></a><span id="l72.743">   }</span>
<a href="#l72.744"></a><span id="l72.744">   return outRow;</span>
<a href="#l72.745"></a><span id="l72.745"> }</span>
<a href="#l72.746"></a><span id="l72.746"> </span>
<a href="#l72.747"></a><span id="l72.747"> morkTable*</span>
<a href="#l72.748"></a><span id="l72.748"> morkStore::OidToTable(morkEnv* ev, const mdbOid* inOid,</span>
<a href="#l72.749"></a><span id="l72.749" class="difflineminus">-  const mdbOid* inOptionalMetaRowOid) // can be nil to avoid specifying </span>
<a href="#l72.750"></a><span id="l72.750" class="difflineplus">+  const mdbOid* inOptionalMetaRowOid) // can be nil to avoid specifying</span>
<a href="#l72.751"></a><span id="l72.751">   // OidToTable() finds old table with oid, or makes new one if not found.</span>
<a href="#l72.752"></a><span id="l72.752"> {</span>
<a href="#l72.753"></a><span id="l72.753">   morkTable* outTable = 0;</span>
<a href="#l72.754"></a><span id="l72.754">   if ( ev-&gt;Good() )</span>
<a href="#l72.755"></a><span id="l72.755">   {</span>
<a href="#l72.756"></a><span id="l72.756">     morkRowSpace* rowSpace = this-&gt;LazyGetRowSpace(ev, inOid-&gt;mOid_Scope);</span>
<a href="#l72.757"></a><span id="l72.757">     if ( rowSpace )</span>
<a href="#l72.758"></a><span id="l72.758">     {</span>
<a href="#l72.759"></a><span id="l72.759" class="difflineat">@@ -1280,17 +1280,17 @@ morkStore::OidToTable(morkEnv* ev, const</span>
<a href="#l72.760"></a><span id="l72.760"> </span>
<a href="#l72.761"></a><span id="l72.761"> // { ----- begin ref counting for well-behaved cyclic graphs -----</span>
<a href="#l72.762"></a><span id="l72.762"> NS_IMETHODIMP</span>
<a href="#l72.763"></a><span id="l72.763"> morkStore::GetWeakRefCount(nsIMdbEnv* mev, // weak refs</span>
<a href="#l72.764"></a><span id="l72.764">   mdb_count* outCount)</span>
<a href="#l72.765"></a><span id="l72.765"> {</span>
<a href="#l72.766"></a><span id="l72.766">   *outCount = WeakRefsOnly();</span>
<a href="#l72.767"></a><span id="l72.767">   return NS_OK;</span>
<a href="#l72.768"></a><span id="l72.768" class="difflineminus">-}  </span>
<a href="#l72.769"></a><span id="l72.769" class="difflineplus">+}</span>
<a href="#l72.770"></a><span id="l72.770"> NS_IMETHODIMP</span>
<a href="#l72.771"></a><span id="l72.771"> morkStore::GetStrongRefCount(nsIMdbEnv* mev, // strong refs</span>
<a href="#l72.772"></a><span id="l72.772">   mdb_count* outCount)</span>
<a href="#l72.773"></a><span id="l72.773"> {</span>
<a href="#l72.774"></a><span id="l72.774">   *outCount = StrongRefsOnly();</span>
<a href="#l72.775"></a><span id="l72.775">   return NS_OK;</span>
<a href="#l72.776"></a><span id="l72.776"> }</span>
<a href="#l72.777"></a><span id="l72.777"> // ### TODO - clean up this cast, if required</span>
<a href="#l72.778"></a><span id="l72.778" class="difflineat">@@ -1411,47 +1411,47 @@ morkStore::GetIsStoreAndDirty(nsIMdbEnv*</span>
<a href="#l72.779"></a><span id="l72.779">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.780"></a><span id="l72.780">   }</span>
<a href="#l72.781"></a><span id="l72.781">   if ( outBool )</span>
<a href="#l72.782"></a><span id="l72.782">     *outBool = isStoreAndDirty;</span>
<a href="#l72.783"></a><span id="l72.783">   return outErr;</span>
<a href="#l72.784"></a><span id="l72.784"> }</span>
<a href="#l72.785"></a><span id="l72.785"> </span>
<a href="#l72.786"></a><span id="l72.786"> NS_IMETHODIMP</span>
<a href="#l72.787"></a><span id="l72.787" class="difflineminus">-morkStore::GetUsagePolicy(nsIMdbEnv* mev, </span>
<a href="#l72.788"></a><span id="l72.788" class="difflineplus">+morkStore::GetUsagePolicy(nsIMdbEnv* mev,</span>
<a href="#l72.789"></a><span id="l72.789">   mdbUsagePolicy* ioUsagePolicy)</span>
<a href="#l72.790"></a><span id="l72.790"> {</span>
<a href="#l72.791"></a><span id="l72.791">   MORK_USED_1(ioUsagePolicy);</span>
<a href="#l72.792"></a><span id="l72.792">   nsresult outErr = NS_OK;</span>
<a href="#l72.793"></a><span id="l72.793">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.794"></a><span id="l72.794">   if ( ev )</span>
<a href="#l72.795"></a><span id="l72.795">   {</span>
<a href="#l72.796"></a><span id="l72.796">     ev-&gt;StubMethodOnlyError();</span>
<a href="#l72.797"></a><span id="l72.797">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.798"></a><span id="l72.798">   }</span>
<a href="#l72.799"></a><span id="l72.799">   return outErr;</span>
<a href="#l72.800"></a><span id="l72.800"> }</span>
<a href="#l72.801"></a><span id="l72.801"> </span>
<a href="#l72.802"></a><span id="l72.802"> NS_IMETHODIMP</span>
<a href="#l72.803"></a><span id="l72.803" class="difflineminus">-morkStore::SetUsagePolicy(nsIMdbEnv* mev, </span>
<a href="#l72.804"></a><span id="l72.804" class="difflineplus">+morkStore::SetUsagePolicy(nsIMdbEnv* mev,</span>
<a href="#l72.805"></a><span id="l72.805">   const mdbUsagePolicy* inUsagePolicy)</span>
<a href="#l72.806"></a><span id="l72.806"> {</span>
<a href="#l72.807"></a><span id="l72.807">   MORK_USED_1(inUsagePolicy);</span>
<a href="#l72.808"></a><span id="l72.808">   nsresult outErr = NS_OK;</span>
<a href="#l72.809"></a><span id="l72.809">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.810"></a><span id="l72.810">   if ( ev )</span>
<a href="#l72.811"></a><span id="l72.811">   {</span>
<a href="#l72.812"></a><span id="l72.812">     // ev-&gt;StubMethodOnlyError(); // okay to do nothing?</span>
<a href="#l72.813"></a><span id="l72.813">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.814"></a><span id="l72.814">   }</span>
<a href="#l72.815"></a><span id="l72.815">   return outErr;</span>
<a href="#l72.816"></a><span id="l72.816"> }</span>
<a href="#l72.817"></a><span id="l72.817"> // } ----- end attribute methods -----</span>
<a href="#l72.818"></a><span id="l72.818"> </span>
<a href="#l72.819"></a><span id="l72.819" class="difflineminus">-// { ----- begin memory policy methods -----  </span>
<a href="#l72.820"></a><span id="l72.820" class="difflineplus">+// { ----- begin memory policy methods -----</span>
<a href="#l72.821"></a><span id="l72.821"> NS_IMETHODIMP</span>
<a href="#l72.822"></a><span id="l72.822"> morkStore::IdleMemoryPurge( // do memory management already scheduled</span>
<a href="#l72.823"></a><span id="l72.823">   nsIMdbEnv* mev, // context</span>
<a href="#l72.824"></a><span id="l72.824">   mdb_size* outEstimatedBytesFreed) // approximate bytes actually freed</span>
<a href="#l72.825"></a><span id="l72.825"> {</span>
<a href="#l72.826"></a><span id="l72.826">   nsresult outErr = NS_OK;</span>
<a href="#l72.827"></a><span id="l72.827">   mdb_size estimatedBytesFreed = 0;</span>
<a href="#l72.828"></a><span id="l72.828">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.829"></a><span id="l72.829" class="difflineat">@@ -1518,17 +1518,17 @@ morkStore::GetPortFilePath(</span>
<a href="#l72.830"></a><span id="l72.830">     outFilePath-&gt;mYarn_Fill = 0;</span>
<a href="#l72.831"></a><span id="l72.831">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.832"></a><span id="l72.832">   if ( ev )</span>
<a href="#l72.833"></a><span id="l72.833">   {</span>
<a href="#l72.834"></a><span id="l72.834">     if ( mStore_File )</span>
<a href="#l72.835"></a><span id="l72.835">       mStore_File-&gt;Path(mev, outFilePath);</span>
<a href="#l72.836"></a><span id="l72.836">     else</span>
<a href="#l72.837"></a><span id="l72.837">       NilStoreFileError(ev);</span>
<a href="#l72.838"></a><span id="l72.838" class="difflineminus">-    </span>
<a href="#l72.839"></a><span id="l72.839" class="difflineplus">+</span>
<a href="#l72.840"></a><span id="l72.840">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.841"></a><span id="l72.841">   }</span>
<a href="#l72.842"></a><span id="l72.842">   return outErr;</span>
<a href="#l72.843"></a><span id="l72.843"> }</span>
<a href="#l72.844"></a><span id="l72.844"> </span>
<a href="#l72.845"></a><span id="l72.845"> NS_IMETHODIMP</span>
<a href="#l72.846"></a><span id="l72.846"> morkStore::GetPortFile(</span>
<a href="#l72.847"></a><span id="l72.847">   nsIMdbEnv* mev, // context</span>
<a href="#l72.848"></a><span id="l72.848" class="difflineat">@@ -1536,29 +1536,29 @@ morkStore::GetPortFile(</span>
<a href="#l72.849"></a><span id="l72.849"> {</span>
<a href="#l72.850"></a><span id="l72.850">   nsresult outErr = NS_OK;</span>
<a href="#l72.851"></a><span id="l72.851">   if ( acqFile )</span>
<a href="#l72.852"></a><span id="l72.852">     *acqFile = 0;</span>
<a href="#l72.853"></a><span id="l72.853"> </span>
<a href="#l72.854"></a><span id="l72.854">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.855"></a><span id="l72.855">   if ( ev )</span>
<a href="#l72.856"></a><span id="l72.856">   {</span>
<a href="#l72.857"></a><span id="l72.857" class="difflineminus">-    </span>
<a href="#l72.858"></a><span id="l72.858" class="difflineplus">+</span>
<a href="#l72.859"></a><span id="l72.859">     if ( mStore_File )</span>
<a href="#l72.860"></a><span id="l72.860">     {</span>
<a href="#l72.861"></a><span id="l72.861">       if ( acqFile )</span>
<a href="#l72.862"></a><span id="l72.862">       {</span>
<a href="#l72.863"></a><span id="l72.863">         mStore_File-&gt;AddRef();</span>
<a href="#l72.864"></a><span id="l72.864">         if ( ev-&gt;Good() )</span>
<a href="#l72.865"></a><span id="l72.865">           *acqFile = mStore_File;</span>
<a href="#l72.866"></a><span id="l72.866">       }</span>
<a href="#l72.867"></a><span id="l72.867">     }</span>
<a href="#l72.868"></a><span id="l72.868">     else</span>
<a href="#l72.869"></a><span id="l72.869">       NilStoreFileError(ev);</span>
<a href="#l72.870"></a><span id="l72.870" class="difflineminus">-      </span>
<a href="#l72.871"></a><span id="l72.871" class="difflineplus">+</span>
<a href="#l72.872"></a><span id="l72.872">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.873"></a><span id="l72.873">   }</span>
<a href="#l72.874"></a><span id="l72.874">   return outErr;</span>
<a href="#l72.875"></a><span id="l72.875"> }</span>
<a href="#l72.876"></a><span id="l72.876"> // } ----- end filepath methods -----</span>
<a href="#l72.877"></a><span id="l72.877"> </span>
<a href="#l72.878"></a><span id="l72.878"> // { ----- begin export methods -----</span>
<a href="#l72.879"></a><span id="l72.879"> NS_IMETHODIMP</span>
<a href="#l72.880"></a><span id="l72.880" class="difflineat">@@ -1614,17 +1614,17 @@ morkStore::ExportToFormat( // export con</span>
<a href="#l72.881"></a><span id="l72.881">   if ( ev )</span>
<a href="#l72.882"></a><span id="l72.882">   {</span>
<a href="#l72.883"></a><span id="l72.883">     if ( ioFile &amp;&amp; inFormatVersion &amp;&amp; acqThumb )</span>
<a href="#l72.884"></a><span id="l72.884">     {</span>
<a href="#l72.885"></a><span id="l72.885">       ev-&gt;StubMethodOnlyError();</span>
<a href="#l72.886"></a><span id="l72.886">     }</span>
<a href="#l72.887"></a><span id="l72.887">     else</span>
<a href="#l72.888"></a><span id="l72.888">       ev-&gt;NilPointerError();</span>
<a href="#l72.889"></a><span id="l72.889" class="difflineminus">-    </span>
<a href="#l72.890"></a><span id="l72.890" class="difflineplus">+</span>
<a href="#l72.891"></a><span id="l72.891">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.892"></a><span id="l72.892">   }</span>
<a href="#l72.893"></a><span id="l72.893">   if ( acqThumb )</span>
<a href="#l72.894"></a><span id="l72.894">     *acqThumb = outThumb;</span>
<a href="#l72.895"></a><span id="l72.895">   return outErr;</span>
<a href="#l72.896"></a><span id="l72.896"> }</span>
<a href="#l72.897"></a><span id="l72.897"> </span>
<a href="#l72.898"></a><span id="l72.898"> // } ----- end export methods -----</span>
<a href="#l72.899"></a><span id="l72.899" class="difflineat">@@ -1663,17 +1663,17 @@ morkStore::StringToToken( // return an i</span>
<a href="#l72.900"></a><span id="l72.900">   {</span>
<a href="#l72.901"></a><span id="l72.901">     token = StringToToken(ev, inTokenName);</span>
<a href="#l72.902"></a><span id="l72.902">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.903"></a><span id="l72.903">   }</span>
<a href="#l72.904"></a><span id="l72.904">   if ( outToken )</span>
<a href="#l72.905"></a><span id="l72.905">     *outToken = token;</span>
<a href="#l72.906"></a><span id="l72.906">   return outErr;</span>
<a href="#l72.907"></a><span id="l72.907"> }</span>
<a href="#l72.908"></a><span id="l72.908" class="difflineminus">-  </span>
<a href="#l72.909"></a><span id="l72.909" class="difflineplus">+</span>
<a href="#l72.910"></a><span id="l72.910"> </span>
<a href="#l72.911"></a><span id="l72.911"> NS_IMETHODIMP</span>
<a href="#l72.912"></a><span id="l72.912"> morkStore::QueryToken( // like StringToToken(), but without adding</span>
<a href="#l72.913"></a><span id="l72.913">   nsIMdbEnv* mev, // context</span>
<a href="#l72.914"></a><span id="l72.914">   const char* inTokenName, // Latin1 string to tokenize if possible</span>
<a href="#l72.915"></a><span id="l72.915">   mdb_token* outToken) // token for inTokenName inside this port</span>
<a href="#l72.916"></a><span id="l72.916">   // QueryToken() will return a string token if one already exists,</span>
<a href="#l72.917"></a><span id="l72.917">   // but unlike StringToToken(), will not assign a new token if not</span>
<a href="#l72.918"></a><span id="l72.918" class="difflineat">@@ -1690,76 +1690,76 @@ morkStore::QueryToken( // like StringToT</span>
<a href="#l72.919"></a><span id="l72.919">   if ( outToken )</span>
<a href="#l72.920"></a><span id="l72.920">     *outToken = token;</span>
<a href="#l72.921"></a><span id="l72.921">   return outErr;</span>
<a href="#l72.922"></a><span id="l72.922"> }</span>
<a href="#l72.923"></a><span id="l72.923"> </span>
<a href="#l72.924"></a><span id="l72.924"> </span>
<a href="#l72.925"></a><span id="l72.925"> // } ----- end token methods -----</span>
<a href="#l72.926"></a><span id="l72.926"> </span>
<a href="#l72.927"></a><span id="l72.927" class="difflineminus">-// { ----- begin row methods -----  </span>
<a href="#l72.928"></a><span id="l72.928" class="difflineplus">+// { ----- begin row methods -----</span>
<a href="#l72.929"></a><span id="l72.929"> NS_IMETHODIMP</span>
<a href="#l72.930"></a><span id="l72.930"> morkStore::HasRow( // contains a row with the specified oid?</span>
<a href="#l72.931"></a><span id="l72.931">   nsIMdbEnv* mev, // context</span>
<a href="#l72.932"></a><span id="l72.932">   const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l72.933"></a><span id="l72.933">   mdb_bool* outHasRow) // whether GetRow() might succeed</span>
<a href="#l72.934"></a><span id="l72.934"> {</span>
<a href="#l72.935"></a><span id="l72.935">   nsresult outErr = NS_OK;</span>
<a href="#l72.936"></a><span id="l72.936">   mdb_bool hasRow = morkBool_kFalse;</span>
<a href="#l72.937"></a><span id="l72.937">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.938"></a><span id="l72.938">   if ( ev )</span>
<a href="#l72.939"></a><span id="l72.939">   {</span>
<a href="#l72.940"></a><span id="l72.940">     morkRow* row = GetRow(ev, inOid);</span>
<a href="#l72.941"></a><span id="l72.941">     if ( row )</span>
<a href="#l72.942"></a><span id="l72.942">       hasRow = morkBool_kTrue;</span>
<a href="#l72.943"></a><span id="l72.943" class="difflineminus">-      </span>
<a href="#l72.944"></a><span id="l72.944" class="difflineplus">+</span>
<a href="#l72.945"></a><span id="l72.945">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.946"></a><span id="l72.946">   }</span>
<a href="#l72.947"></a><span id="l72.947">   if ( outHasRow )</span>
<a href="#l72.948"></a><span id="l72.948">     *outHasRow = hasRow;</span>
<a href="#l72.949"></a><span id="l72.949">   return outErr;</span>
<a href="#l72.950"></a><span id="l72.950"> }</span>
<a href="#l72.951"></a><span id="l72.951" class="difflineminus">-  </span>
<a href="#l72.952"></a><span id="l72.952" class="difflineplus">+</span>
<a href="#l72.953"></a><span id="l72.953"> NS_IMETHODIMP</span>
<a href="#l72.954"></a><span id="l72.954"> morkStore::GetRow( // access one row with specific oid</span>
<a href="#l72.955"></a><span id="l72.955">   nsIMdbEnv* mev, // context</span>
<a href="#l72.956"></a><span id="l72.956">   const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l72.957"></a><span id="l72.957">   nsIMdbRow** acqRow) // acquire specific row (or null)</span>
<a href="#l72.958"></a><span id="l72.958"> {</span>
<a href="#l72.959"></a><span id="l72.959">   nsresult outErr = NS_OK;</span>
<a href="#l72.960"></a><span id="l72.960">   nsIMdbRow* outRow = 0;</span>
<a href="#l72.961"></a><span id="l72.961">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.962"></a><span id="l72.962">   if ( ev )</span>
<a href="#l72.963"></a><span id="l72.963">   {</span>
<a href="#l72.964"></a><span id="l72.964">     morkRow* row = GetRow(ev, inOid);</span>
<a href="#l72.965"></a><span id="l72.965">     if ( row &amp;&amp; ev-&gt;Good() )</span>
<a href="#l72.966"></a><span id="l72.966">       outRow = row-&gt;AcquireRowHandle(ev, this);</span>
<a href="#l72.967"></a><span id="l72.967" class="difflineminus">-      </span>
<a href="#l72.968"></a><span id="l72.968" class="difflineplus">+</span>
<a href="#l72.969"></a><span id="l72.969">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.970"></a><span id="l72.970">   }</span>
<a href="#l72.971"></a><span id="l72.971">   if ( acqRow )</span>
<a href="#l72.972"></a><span id="l72.972">     *acqRow = outRow;</span>
<a href="#l72.973"></a><span id="l72.973">   return outErr;</span>
<a href="#l72.974"></a><span id="l72.974"> }</span>
<a href="#l72.975"></a><span id="l72.975"> </span>
<a href="#l72.976"></a><span id="l72.976"> NS_IMETHODIMP</span>
<a href="#l72.977"></a><span id="l72.977" class="difflineminus">-morkStore::GetRowRefCount( // get number of tables that contain a row </span>
<a href="#l72.978"></a><span id="l72.978" class="difflineplus">+morkStore::GetRowRefCount( // get number of tables that contain a row</span>
<a href="#l72.979"></a><span id="l72.979">   nsIMdbEnv* mev, // context</span>
<a href="#l72.980"></a><span id="l72.980">   const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l72.981"></a><span id="l72.981" class="difflineminus">-  mdb_count* outRefCount) // number of tables containing inRowKey </span>
<a href="#l72.982"></a><span id="l72.982" class="difflineplus">+  mdb_count* outRefCount) // number of tables containing inRowKey</span>
<a href="#l72.983"></a><span id="l72.983"> {</span>
<a href="#l72.984"></a><span id="l72.984">   nsresult outErr = NS_OK;</span>
<a href="#l72.985"></a><span id="l72.985">   mdb_count count = 0;</span>
<a href="#l72.986"></a><span id="l72.986">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.987"></a><span id="l72.987">   if ( ev )</span>
<a href="#l72.988"></a><span id="l72.988">   {</span>
<a href="#l72.989"></a><span id="l72.989">     morkRow* row = GetRow(ev, inOid);</span>
<a href="#l72.990"></a><span id="l72.990">     if ( row &amp;&amp; ev-&gt;Good() )</span>
<a href="#l72.991"></a><span id="l72.991">       count = row-&gt;mRow_GcUses;</span>
<a href="#l72.992"></a><span id="l72.992" class="difflineminus">-      </span>
<a href="#l72.993"></a><span id="l72.993" class="difflineplus">+</span>
<a href="#l72.994"></a><span id="l72.994">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.995"></a><span id="l72.995">   }</span>
<a href="#l72.996"></a><span id="l72.996">   if ( outRefCount )</span>
<a href="#l72.997"></a><span id="l72.997">     *outRefCount = count;</span>
<a href="#l72.998"></a><span id="l72.998">   return outErr;</span>
<a href="#l72.999"></a><span id="l72.999"> }</span>
<a href="#l72.1000"></a><span id="l72.1000"> </span>
<a href="#l72.1001"></a><span id="l72.1001"> NS_IMETHODIMP</span>
<a href="#l72.1002"></a><span id="l72.1002" class="difflineat">@@ -1801,17 +1801,17 @@ morkStore::FindRow(nsIMdbEnv* mev, // se</span>
<a href="#l72.1003"></a><span id="l72.1003">   // of a given key need be remembered.  Implementors are not required to sort</span>
<a href="#l72.1004"></a><span id="l72.1004">   // all rows by the specified column.</span>
<a href="#l72.1005"></a><span id="l72.1005"> {</span>
<a href="#l72.1006"></a><span id="l72.1006">   nsresult outErr = NS_OK;</span>
<a href="#l72.1007"></a><span id="l72.1007">   nsIMdbRow* outRow = 0;</span>
<a href="#l72.1008"></a><span id="l72.1008">   mdbOid rowOid;</span>
<a href="#l72.1009"></a><span id="l72.1009">   rowOid.mOid_Scope = 0;</span>
<a href="#l72.1010"></a><span id="l72.1010">   rowOid.mOid_Id = (mdb_id) -1;</span>
<a href="#l72.1011"></a><span id="l72.1011" class="difflineminus">-  </span>
<a href="#l72.1012"></a><span id="l72.1012" class="difflineplus">+</span>
<a href="#l72.1013"></a><span id="l72.1013">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.1014"></a><span id="l72.1014">   if ( ev )</span>
<a href="#l72.1015"></a><span id="l72.1015">   {</span>
<a href="#l72.1016"></a><span id="l72.1016">     morkRow* row = FindRow(ev, inRowScope, inColumn, inTargetCellValue);</span>
<a href="#l72.1017"></a><span id="l72.1017">     if ( row &amp;&amp; ev-&gt;Good() )</span>
<a href="#l72.1018"></a><span id="l72.1018">     {</span>
<a href="#l72.1019"></a><span id="l72.1019">       rowOid = row-&gt;mRow_Oid;</span>
<a href="#l72.1020"></a><span id="l72.1020">       if ( acqRow )</span>
<a href="#l72.1021"></a><span id="l72.1021" class="difflineat">@@ -1824,39 +1824,39 @@ morkStore::FindRow(nsIMdbEnv* mev, // se</span>
<a href="#l72.1022"></a><span id="l72.1022">   if ( outRowOid )</span>
<a href="#l72.1023"></a><span id="l72.1023">     *outRowOid = rowOid;</span>
<a href="#l72.1024"></a><span id="l72.1024"> </span>
<a href="#l72.1025"></a><span id="l72.1025">   return outErr;</span>
<a href="#l72.1026"></a><span id="l72.1026"> }</span>
<a href="#l72.1027"></a><span id="l72.1027"> </span>
<a href="#l72.1028"></a><span id="l72.1028"> // } ----- end row methods -----</span>
<a href="#l72.1029"></a><span id="l72.1029"> </span>
<a href="#l72.1030"></a><span id="l72.1030" class="difflineminus">-// { ----- begin table methods -----  </span>
<a href="#l72.1031"></a><span id="l72.1031" class="difflineplus">+// { ----- begin table methods -----</span>
<a href="#l72.1032"></a><span id="l72.1032"> NS_IMETHODIMP</span>
<a href="#l72.1033"></a><span id="l72.1033"> morkStore::HasTable( // supports a table with the specified oid?</span>
<a href="#l72.1034"></a><span id="l72.1034">   nsIMdbEnv* mev, // context</span>
<a href="#l72.1035"></a><span id="l72.1035">   const mdbOid* inOid,  // hypothetical table oid</span>
<a href="#l72.1036"></a><span id="l72.1036">   mdb_bool* outHasTable) // whether GetTable() might succeed</span>
<a href="#l72.1037"></a><span id="l72.1037"> {</span>
<a href="#l72.1038"></a><span id="l72.1038">   nsresult outErr = NS_OK;</span>
<a href="#l72.1039"></a><span id="l72.1039">   mork_bool hasTable = morkBool_kFalse;</span>
<a href="#l72.1040"></a><span id="l72.1040">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.1041"></a><span id="l72.1041">   if ( ev )</span>
<a href="#l72.1042"></a><span id="l72.1042">   {</span>
<a href="#l72.1043"></a><span id="l72.1043">     morkTable* table = GetTable(ev, inOid);</span>
<a href="#l72.1044"></a><span id="l72.1044">     if ( table )</span>
<a href="#l72.1045"></a><span id="l72.1045">       hasTable = morkBool_kTrue;</span>
<a href="#l72.1046"></a><span id="l72.1046" class="difflineminus">-    </span>
<a href="#l72.1047"></a><span id="l72.1047" class="difflineplus">+</span>
<a href="#l72.1048"></a><span id="l72.1048">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.1049"></a><span id="l72.1049">   }</span>
<a href="#l72.1050"></a><span id="l72.1050">   if ( outHasTable )</span>
<a href="#l72.1051"></a><span id="l72.1051">     *outHasTable = hasTable;</span>
<a href="#l72.1052"></a><span id="l72.1052">   return outErr;</span>
<a href="#l72.1053"></a><span id="l72.1053"> }</span>
<a href="#l72.1054"></a><span id="l72.1054" class="difflineminus">-  </span>
<a href="#l72.1055"></a><span id="l72.1055" class="difflineplus">+</span>
<a href="#l72.1056"></a><span id="l72.1056"> NS_IMETHODIMP</span>
<a href="#l72.1057"></a><span id="l72.1057"> morkStore::GetTable( // access one table with specific oid</span>
<a href="#l72.1058"></a><span id="l72.1058">   nsIMdbEnv* mev, // context</span>
<a href="#l72.1059"></a><span id="l72.1059">   const mdbOid* inOid,  // hypothetical table oid</span>
<a href="#l72.1060"></a><span id="l72.1060">   nsIMdbTable** acqTable) // acquire specific table (or null)</span>
<a href="#l72.1061"></a><span id="l72.1061"> {</span>
<a href="#l72.1062"></a><span id="l72.1062">   nsresult outErr = NS_OK;</span>
<a href="#l72.1063"></a><span id="l72.1063">   nsIMdbTable* outTable = 0;</span>
<a href="#l72.1064"></a><span id="l72.1064" class="difflineat">@@ -1886,17 +1886,17 @@ morkStore::HasTableKind( // supports a t</span>
<a href="#l72.1065"></a><span id="l72.1065">   if ( ev )</span>
<a href="#l72.1066"></a><span id="l72.1066">   {</span>
<a href="#l72.1067"></a><span id="l72.1067">     *outSupportsTable = HasTableKind(ev, inRowScope,</span>
<a href="#l72.1068"></a><span id="l72.1068">         inTableKind, outTableCount);</span>
<a href="#l72.1069"></a><span id="l72.1069">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.1070"></a><span id="l72.1070">   }</span>
<a href="#l72.1071"></a><span id="l72.1071">   return outErr;</span>
<a href="#l72.1072"></a><span id="l72.1072"> }</span>
<a href="#l72.1073"></a><span id="l72.1073" class="difflineminus">-      </span>
<a href="#l72.1074"></a><span id="l72.1074" class="difflineplus">+</span>
<a href="#l72.1075"></a><span id="l72.1075"> NS_IMETHODIMP</span>
<a href="#l72.1076"></a><span id="l72.1076"> morkStore::GetTableKind( // access one (random) table of specific type</span>
<a href="#l72.1077"></a><span id="l72.1077">   nsIMdbEnv* mev, // context</span>
<a href="#l72.1078"></a><span id="l72.1078">   mdb_scope inRowScope,      // row scope for row ids</span>
<a href="#l72.1079"></a><span id="l72.1079">   mdb_kind inTableKind,      // the type of table to access</span>
<a href="#l72.1080"></a><span id="l72.1080">   mdb_count* outTableCount, // current number of such tables</span>
<a href="#l72.1081"></a><span id="l72.1081">   mdb_bool* outMustBeUnique, // whether port can hold only one of these</span>
<a href="#l72.1082"></a><span id="l72.1082">   nsIMdbTable** acqTable)      // acquire scoped collection of rows</span>
<a href="#l72.1083"></a><span id="l72.1083" class="difflineat">@@ -1911,17 +1911,17 @@ morkStore::GetTableKind( // access one (</span>
<a href="#l72.1084"></a><span id="l72.1084">     if ( table &amp;&amp; ev-&gt;Good() )</span>
<a href="#l72.1085"></a><span id="l72.1085">       outTable = table-&gt;AcquireTableHandle(ev);</span>
<a href="#l72.1086"></a><span id="l72.1086">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.1087"></a><span id="l72.1087">   }</span>
<a href="#l72.1088"></a><span id="l72.1088">   if ( acqTable )</span>
<a href="#l72.1089"></a><span id="l72.1089">     *acqTable = outTable;</span>
<a href="#l72.1090"></a><span id="l72.1090">   return outErr;</span>
<a href="#l72.1091"></a><span id="l72.1091"> }</span>
<a href="#l72.1092"></a><span id="l72.1092" class="difflineminus">-  </span>
<a href="#l72.1093"></a><span id="l72.1093" class="difflineplus">+</span>
<a href="#l72.1094"></a><span id="l72.1094"> NS_IMETHODIMP</span>
<a href="#l72.1095"></a><span id="l72.1095"> morkStore::GetPortTableCursor( // get cursor for all tables of specific type</span>
<a href="#l72.1096"></a><span id="l72.1096">   nsIMdbEnv* mev, // context</span>
<a href="#l72.1097"></a><span id="l72.1097">   mdb_scope inRowScope, // row scope for row ids</span>
<a href="#l72.1098"></a><span id="l72.1098">   mdb_kind inTableKind, // the type of table to access</span>
<a href="#l72.1099"></a><span id="l72.1099">   nsIMdbPortTableCursor** acqCursor) // all such tables in the port</span>
<a href="#l72.1100"></a><span id="l72.1100"> {</span>
<a href="#l72.1101"></a><span id="l72.1101">   nsresult outErr = NS_OK;</span>
<a href="#l72.1102"></a><span id="l72.1102" class="difflineat">@@ -1939,17 +1939,17 @@ morkStore::GetPortTableCursor( // get cu</span>
<a href="#l72.1103"></a><span id="l72.1103">   }</span>
<a href="#l72.1104"></a><span id="l72.1104">   if ( acqCursor )</span>
<a href="#l72.1105"></a><span id="l72.1105">     *acqCursor = outCursor;</span>
<a href="#l72.1106"></a><span id="l72.1106">   return outErr;</span>
<a href="#l72.1107"></a><span id="l72.1107"> }</span>
<a href="#l72.1108"></a><span id="l72.1108"> // } ----- end table methods -----</span>
<a href="#l72.1109"></a><span id="l72.1109"> </span>
<a href="#l72.1110"></a><span id="l72.1110"> // { ----- begin commit methods -----</span>
<a href="#l72.1111"></a><span id="l72.1111" class="difflineminus">-  </span>
<a href="#l72.1112"></a><span id="l72.1112" class="difflineplus">+</span>
<a href="#l72.1113"></a><span id="l72.1113"> NS_IMETHODIMP</span>
<a href="#l72.1114"></a><span id="l72.1114"> morkStore::ShouldCompress( // store wastes at least inPercentWaste?</span>
<a href="#l72.1115"></a><span id="l72.1115">   nsIMdbEnv* mev, // context</span>
<a href="#l72.1116"></a><span id="l72.1116">   mdb_percent inPercentWaste, // 0..100 percent file size waste threshold</span>
<a href="#l72.1117"></a><span id="l72.1117">   mdb_percent* outActualWaste, // 0..100 percent of file actually wasted</span>
<a href="#l72.1118"></a><span id="l72.1118">   mdb_bool* outShould) // true when about inPercentWaste% is wasted</span>
<a href="#l72.1119"></a><span id="l72.1119"> {</span>
<a href="#l72.1120"></a><span id="l72.1120">   mdb_percent actualWaste = 0;</span>
<a href="#l72.1121"></a><span id="l72.1121" class="difflineat">@@ -1975,17 +1975,17 @@ morkStore::ShouldCompress( // store wast</span>
<a href="#l72.1122"></a><span id="l72.1122"> // } ===== end nsIMdbPort methods =====</span>
<a href="#l72.1123"></a><span id="l72.1123"> </span>
<a href="#l72.1124"></a><span id="l72.1124"> NS_IMETHODIMP</span>
<a href="#l72.1125"></a><span id="l72.1125"> morkStore::NewTable( // make one new table of specific type</span>
<a href="#l72.1126"></a><span id="l72.1126">   nsIMdbEnv* mev, // context</span>
<a href="#l72.1127"></a><span id="l72.1127">   mdb_scope inRowScope,    // row scope for row ids</span>
<a href="#l72.1128"></a><span id="l72.1128">   mdb_kind inTableKind,    // the type of table to access</span>
<a href="#l72.1129"></a><span id="l72.1129">   mdb_bool inMustBeUnique, // whether store can hold only one of these</span>
<a href="#l72.1130"></a><span id="l72.1130" class="difflineminus">-  const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l72.1131"></a><span id="l72.1131" class="difflineplus">+  const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l72.1132"></a><span id="l72.1132">   nsIMdbTable** acqTable)     // acquire scoped collection of rows</span>
<a href="#l72.1133"></a><span id="l72.1133"> {</span>
<a href="#l72.1134"></a><span id="l72.1134">   nsresult outErr = NS_OK;</span>
<a href="#l72.1135"></a><span id="l72.1135">   nsIMdbTable* outTable = 0;</span>
<a href="#l72.1136"></a><span id="l72.1136">   morkEnv* ev = this-&gt;CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.1137"></a><span id="l72.1137">   if ( ev )</span>
<a href="#l72.1138"></a><span id="l72.1138">   {</span>
<a href="#l72.1139"></a><span id="l72.1139">     morkTable* table = NewTable(ev, inRowScope,</span>
<a href="#l72.1140"></a><span id="l72.1140" class="difflineat">@@ -2000,17 +2000,17 @@ morkStore::NewTable( // make one new tab</span>
<a href="#l72.1141"></a><span id="l72.1141"> }</span>
<a href="#l72.1142"></a><span id="l72.1142"> </span>
<a href="#l72.1143"></a><span id="l72.1143"> NS_IMETHODIMP</span>
<a href="#l72.1144"></a><span id="l72.1144"> morkStore::NewTableWithOid( // make one new table of specific type</span>
<a href="#l72.1145"></a><span id="l72.1145">   nsIMdbEnv* mev, // context</span>
<a href="#l72.1146"></a><span id="l72.1146">   const mdbOid* inOid,   // caller assigned oid</span>
<a href="#l72.1147"></a><span id="l72.1147">   mdb_kind inTableKind,    // the type of table to access</span>
<a href="#l72.1148"></a><span id="l72.1148">   mdb_bool inMustBeUnique, // whether store can hold only one of these</span>
<a href="#l72.1149"></a><span id="l72.1149" class="difflineminus">-  const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l72.1150"></a><span id="l72.1150" class="difflineplus">+  const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l72.1151"></a><span id="l72.1151">   nsIMdbTable** acqTable)     // acquire scoped collection of rows</span>
<a href="#l72.1152"></a><span id="l72.1152"> {</span>
<a href="#l72.1153"></a><span id="l72.1153">   nsresult outErr = NS_OK;</span>
<a href="#l72.1154"></a><span id="l72.1154">   nsIMdbTable* outTable = 0;</span>
<a href="#l72.1155"></a><span id="l72.1155">   morkEnv* ev = CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.1156"></a><span id="l72.1156">   if ( ev )</span>
<a href="#l72.1157"></a><span id="l72.1157">   {</span>
<a href="#l72.1158"></a><span id="l72.1158">     morkTable* table = OidToTable(ev, inOid,</span>
<a href="#l72.1159"></a><span id="l72.1159" class="difflineat">@@ -2071,17 +2071,17 @@ morkStore::NewRowWithOid(nsIMdbEnv* mev,</span>
<a href="#l72.1160"></a><span id="l72.1160">   nsresult outErr = NS_OK;</span>
<a href="#l72.1161"></a><span id="l72.1161">   nsIMdbRow* outRow = 0;</span>
<a href="#l72.1162"></a><span id="l72.1162">   morkEnv* ev = CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.1163"></a><span id="l72.1163">   if ( ev )</span>
<a href="#l72.1164"></a><span id="l72.1164">   {</span>
<a href="#l72.1165"></a><span id="l72.1165">     morkRow* row = NewRowWithOid(ev, inOid);</span>
<a href="#l72.1166"></a><span id="l72.1166">     if ( row &amp;&amp; ev-&gt;Good() )</span>
<a href="#l72.1167"></a><span id="l72.1167">       outRow = row-&gt;AcquireRowHandle(ev, this);</span>
<a href="#l72.1168"></a><span id="l72.1168" class="difflineminus">-      </span>
<a href="#l72.1169"></a><span id="l72.1169" class="difflineplus">+</span>
<a href="#l72.1170"></a><span id="l72.1170">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.1171"></a><span id="l72.1171">   }</span>
<a href="#l72.1172"></a><span id="l72.1172">   if ( acqRow )</span>
<a href="#l72.1173"></a><span id="l72.1173">     *acqRow = outRow;</span>
<a href="#l72.1174"></a><span id="l72.1174">   return outErr;</span>
<a href="#l72.1175"></a><span id="l72.1175"> }</span>
<a href="#l72.1176"></a><span id="l72.1176"> </span>
<a href="#l72.1177"></a><span id="l72.1177"> NS_IMETHODIMP</span>
<a href="#l72.1178"></a><span id="l72.1178" class="difflineat">@@ -2094,17 +2094,17 @@ morkStore::NewRow(nsIMdbEnv* mev, // new</span>
<a href="#l72.1179"></a><span id="l72.1179">   nsresult outErr = NS_OK;</span>
<a href="#l72.1180"></a><span id="l72.1180">   nsIMdbRow* outRow = 0;</span>
<a href="#l72.1181"></a><span id="l72.1181">   morkEnv* ev = CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.1182"></a><span id="l72.1182">   if ( ev )</span>
<a href="#l72.1183"></a><span id="l72.1183">   {</span>
<a href="#l72.1184"></a><span id="l72.1184">     morkRow* row = NewRow(ev, inRowScope);</span>
<a href="#l72.1185"></a><span id="l72.1185">     if ( row &amp;&amp; ev-&gt;Good() )</span>
<a href="#l72.1186"></a><span id="l72.1186">       outRow = row-&gt;AcquireRowHandle(ev, this);</span>
<a href="#l72.1187"></a><span id="l72.1187" class="difflineminus">-      </span>
<a href="#l72.1188"></a><span id="l72.1188" class="difflineplus">+</span>
<a href="#l72.1189"></a><span id="l72.1189">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.1190"></a><span id="l72.1190">   }</span>
<a href="#l72.1191"></a><span id="l72.1191">   if ( acqRow )</span>
<a href="#l72.1192"></a><span id="l72.1192">     *acqRow = outRow;</span>
<a href="#l72.1193"></a><span id="l72.1193">   return outErr;</span>
<a href="#l72.1194"></a><span id="l72.1194"> }</span>
<a href="#l72.1195"></a><span id="l72.1195"> // } ----- end row methods -----</span>
<a href="#l72.1196"></a><span id="l72.1196"> </span>
<a href="#l72.1197"></a><span id="l72.1197" class="difflineat">@@ -2180,35 +2180,35 @@ morkStore::LargeCommit( // save importan</span>
<a href="#l72.1198"></a><span id="l72.1198"> // locked until commit is finished or canceled through the thumb instance.</span>
<a href="#l72.1199"></a><span id="l72.1199"> // Until the commit is done, the store will report it has readonly status.</span>
<a href="#l72.1200"></a><span id="l72.1200"> {</span>
<a href="#l72.1201"></a><span id="l72.1201">   nsresult outErr = NS_OK;</span>
<a href="#l72.1202"></a><span id="l72.1202">   nsIMdbThumb* outThumb = 0;</span>
<a href="#l72.1203"></a><span id="l72.1203">   morkEnv* ev = CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.1204"></a><span id="l72.1204">   if ( ev )</span>
<a href="#l72.1205"></a><span id="l72.1205">   {</span>
<a href="#l72.1206"></a><span id="l72.1206" class="difflineminus">-    </span>
<a href="#l72.1207"></a><span id="l72.1207" class="difflineplus">+</span>
<a href="#l72.1208"></a><span id="l72.1208">     morkThumb* thumb = 0;</span>
<a href="#l72.1209"></a><span id="l72.1209">     // morkFile* file = store-&gt;mStore_File;</span>
<a href="#l72.1210"></a><span id="l72.1210">     if ( DoPreferLargeOverCompressCommit(ev) )</span>
<a href="#l72.1211"></a><span id="l72.1211">     {</span>
<a href="#l72.1212"></a><span id="l72.1212">       thumb = morkThumb::Make_LargeCommit(ev, mPort_Heap, this);</span>
<a href="#l72.1213"></a><span id="l72.1213">     }</span>
<a href="#l72.1214"></a><span id="l72.1214">     else</span>
<a href="#l72.1215"></a><span id="l72.1215">     {</span>
<a href="#l72.1216"></a><span id="l72.1216">       mork_bool doCollect = morkBool_kFalse;</span>
<a href="#l72.1217"></a><span id="l72.1217">       thumb = morkThumb::Make_CompressCommit(ev, mPort_Heap, this, doCollect);</span>
<a href="#l72.1218"></a><span id="l72.1218">     }</span>
<a href="#l72.1219"></a><span id="l72.1219" class="difflineminus">-    </span>
<a href="#l72.1220"></a><span id="l72.1220" class="difflineplus">+</span>
<a href="#l72.1221"></a><span id="l72.1221">     if ( thumb )</span>
<a href="#l72.1222"></a><span id="l72.1222">     {</span>
<a href="#l72.1223"></a><span id="l72.1223">       outThumb = thumb;</span>
<a href="#l72.1224"></a><span id="l72.1224">       thumb-&gt;AddRef();</span>
<a href="#l72.1225"></a><span id="l72.1225">     }</span>
<a href="#l72.1226"></a><span id="l72.1226" class="difflineminus">-      </span>
<a href="#l72.1227"></a><span id="l72.1227" class="difflineplus">+</span>
<a href="#l72.1228"></a><span id="l72.1228">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.1229"></a><span id="l72.1229">   }</span>
<a href="#l72.1230"></a><span id="l72.1230">   if ( acqThumb )</span>
<a href="#l72.1231"></a><span id="l72.1231">     *acqThumb = outThumb;</span>
<a href="#l72.1232"></a><span id="l72.1232">   return outErr;</span>
<a href="#l72.1233"></a><span id="l72.1233"> }</span>
<a href="#l72.1234"></a><span id="l72.1234"> </span>
<a href="#l72.1235"></a><span id="l72.1235"> NS_IMETHODIMP</span>
<a href="#l72.1236"></a><span id="l72.1236" class="difflineat">@@ -2220,28 +2220,28 @@ morkStore::SessionCommit( // save all ch</span>
<a href="#l72.1237"></a><span id="l72.1237"> // locked until commit is finished or canceled through the thumb instance.</span>
<a href="#l72.1238"></a><span id="l72.1238"> // Until the commit is done, the store will report it has readonly status.</span>
<a href="#l72.1239"></a><span id="l72.1239"> {</span>
<a href="#l72.1240"></a><span id="l72.1240">   nsresult outErr = NS_OK;</span>
<a href="#l72.1241"></a><span id="l72.1241">   nsIMdbThumb* outThumb = 0;</span>
<a href="#l72.1242"></a><span id="l72.1242">   morkEnv* ev = CanUseStore(mev, /*inMutable*/ morkBool_kFalse, &amp;outErr);</span>
<a href="#l72.1243"></a><span id="l72.1243">   if ( ev )</span>
<a href="#l72.1244"></a><span id="l72.1244">   {</span>
<a href="#l72.1245"></a><span id="l72.1245" class="difflineminus">-    </span>
<a href="#l72.1246"></a><span id="l72.1246" class="difflineplus">+</span>
<a href="#l72.1247"></a><span id="l72.1247">     morkThumb* thumb = 0;</span>
<a href="#l72.1248"></a><span id="l72.1248">     if ( DoPreferLargeOverCompressCommit(ev) )</span>
<a href="#l72.1249"></a><span id="l72.1249">     {</span>
<a href="#l72.1250"></a><span id="l72.1250">       thumb = morkThumb::Make_LargeCommit(ev, mPort_Heap, this);</span>
<a href="#l72.1251"></a><span id="l72.1251">     }</span>
<a href="#l72.1252"></a><span id="l72.1252">     else</span>
<a href="#l72.1253"></a><span id="l72.1253">     {</span>
<a href="#l72.1254"></a><span id="l72.1254">       mork_bool doCollect = morkBool_kFalse;</span>
<a href="#l72.1255"></a><span id="l72.1255">       thumb = morkThumb::Make_CompressCommit(ev, mPort_Heap, this, doCollect);</span>
<a href="#l72.1256"></a><span id="l72.1256">     }</span>
<a href="#l72.1257"></a><span id="l72.1257" class="difflineminus">-    </span>
<a href="#l72.1258"></a><span id="l72.1258" class="difflineplus">+</span>
<a href="#l72.1259"></a><span id="l72.1259">     if ( thumb )</span>
<a href="#l72.1260"></a><span id="l72.1260">     {</span>
<a href="#l72.1261"></a><span id="l72.1261">       outThumb = thumb;</span>
<a href="#l72.1262"></a><span id="l72.1262">       thumb-&gt;AddRef();</span>
<a href="#l72.1263"></a><span id="l72.1263">     }</span>
<a href="#l72.1264"></a><span id="l72.1264">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.1265"></a><span id="l72.1265">   }</span>
<a href="#l72.1266"></a><span id="l72.1266">   if ( acqThumb )</span>
<a href="#l72.1267"></a><span id="l72.1267" class="difflineat">@@ -2266,17 +2266,17 @@ morkStore::CompressCommit( // commit and</span>
<a href="#l72.1268"></a><span id="l72.1268">     mork_bool doCollect = morkBool_kFalse;</span>
<a href="#l72.1269"></a><span id="l72.1269">     morkThumb* thumb = morkThumb::Make_CompressCommit(ev, mPort_Heap, this, doCollect);</span>
<a href="#l72.1270"></a><span id="l72.1270">     if ( thumb )</span>
<a href="#l72.1271"></a><span id="l72.1271">     {</span>
<a href="#l72.1272"></a><span id="l72.1272">       outThumb = thumb;</span>
<a href="#l72.1273"></a><span id="l72.1273">       thumb-&gt;AddRef();</span>
<a href="#l72.1274"></a><span id="l72.1274">       mStore_CanWriteIncremental = morkBool_kTrue;</span>
<a href="#l72.1275"></a><span id="l72.1275">     }</span>
<a href="#l72.1276"></a><span id="l72.1276" class="difflineminus">-      </span>
<a href="#l72.1277"></a><span id="l72.1277" class="difflineplus">+</span>
<a href="#l72.1278"></a><span id="l72.1278">     outErr = ev-&gt;AsErr();</span>
<a href="#l72.1279"></a><span id="l72.1279">   }</span>
<a href="#l72.1280"></a><span id="l72.1280">   if ( acqThumb )</span>
<a href="#l72.1281"></a><span id="l72.1281">     *acqThumb = outThumb;</span>
<a href="#l72.1282"></a><span id="l72.1282">   return outErr;</span>
<a href="#l72.1283"></a><span id="l72.1283"> }</span>
<a href="#l72.1284"></a><span id="l72.1284"> </span>
<a href="#l72.1285"></a><span id="l72.1285"> // } ----- end commit methods -----</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l73.1"></a><span id="l73.1" class="difflineminus">--- a/db/mork/src/morkStore.h</span>
<a href="#l73.2"></a><span id="l73.2" class="difflineplus">+++ b/db/mork/src/morkStore.h</span>
<a href="#l73.3"></a><span id="l73.3" class="difflineat">@@ -58,47 +58,47 @@</span>
<a href="#l73.4"></a><span id="l73.4"> #define morkStore_kNoneToken ((mork_token) 'n')</span>
<a href="#l73.5"></a><span id="l73.5"> #define morkStore_kFormColumn ((mork_column) 'f')</span>
<a href="#l73.6"></a><span id="l73.6"> #define morkStore_kAtomScopeColumn ((mork_column) 'a')</span>
<a href="#l73.7"></a><span id="l73.7"> #define morkStore_kRowScopeColumn ((mork_column) 'r')</span>
<a href="#l73.8"></a><span id="l73.8"> #define morkStore_kMetaScope ((mork_scope) 'm')</span>
<a href="#l73.9"></a><span id="l73.9"> #define morkStore_kKindColumn ((mork_column) 'k')</span>
<a href="#l73.10"></a><span id="l73.10"> #define morkStore_kStatusColumn ((mork_column) 's')</span>
<a href="#l73.11"></a><span id="l73.11"> </span>
<a href="#l73.12"></a><span id="l73.12" class="difflineminus">-/*| morkStore: </span>
<a href="#l73.13"></a><span id="l73.13" class="difflineplus">+/*| morkStore:</span>
<a href="#l73.14"></a><span id="l73.14"> |*/</span>
<a href="#l73.15"></a><span id="l73.15"> class morkStore :  public morkObject, public nsIMdbStore {</span>
<a href="#l73.16"></a><span id="l73.16"> </span>
<a href="#l73.17"></a><span id="l73.17"> public: // state is public because the entire Mork system is private</span>
<a href="#l73.18"></a><span id="l73.18"> </span>
<a href="#l73.19"></a><span id="l73.19">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l73.20"></a><span id="l73.20"> </span>
<a href="#l73.21"></a><span id="l73.21">   morkEnv*        mPort_Env;      // non-refcounted env which created port</span>
<a href="#l73.22"></a><span id="l73.22">   morkFactory*    mPort_Factory;  // weak ref to suite factory</span>
<a href="#l73.23"></a><span id="l73.23">   nsIMdbHeap*     mPort_Heap;     // heap in which this port allocs objects</span>
<a href="#l73.24"></a><span id="l73.24" class="difflineminus">-  </span>
<a href="#l73.25"></a><span id="l73.25" class="difflineplus">+</span>
<a href="#l73.26"></a><span id="l73.26"> // { ===== begin morkNode interface =====</span>
<a href="#l73.27"></a><span id="l73.27"> public: // morkNode virtual methods</span>
<a href="#l73.28"></a><span id="l73.28" class="difflineminus">-  </span>
<a href="#l73.29"></a><span id="l73.29" class="difflineplus">+</span>
<a href="#l73.30"></a><span id="l73.30">   void ClosePort(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l73.31"></a><span id="l73.31"> </span>
<a href="#l73.32"></a><span id="l73.32"> public: // dynamic type identification</span>
<a href="#l73.33"></a><span id="l73.33">   mork_bool IsPort() const</span>
<a href="#l73.34"></a><span id="l73.34">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kPort; }</span>
<a href="#l73.35"></a><span id="l73.35"> // } ===== end morkNode methods =====</span>
<a href="#l73.36"></a><span id="l73.36"> </span>
<a href="#l73.37"></a><span id="l73.37"> public: // other port methods</span>
<a href="#l73.38"></a><span id="l73.38"> </span>
<a href="#l73.39"></a><span id="l73.39">   // { ----- begin attribute methods -----</span>
<a href="#l73.40"></a><span id="l73.40"> //  NS_IMETHOD IsFrozenMdbObject(nsIMdbEnv* ev, mdb_bool* outIsReadonly);</span>
<a href="#l73.41"></a><span id="l73.41">   // same as nsIMdbPort::GetIsPortReadonly() when this object is inside a port.</span>
<a href="#l73.42"></a><span id="l73.42">   // } ----- end attribute methods -----</span>
<a href="#l73.43"></a><span id="l73.43"> </span>
<a href="#l73.44"></a><span id="l73.44">   // { ----- begin factory methods -----</span>
<a href="#l73.45"></a><span id="l73.45" class="difflineminus">-//  NS_IMETHOD GetMdbFactory(nsIMdbEnv* ev, nsIMdbFactory** acqFactory); </span>
<a href="#l73.46"></a><span id="l73.46" class="difflineplus">+//  NS_IMETHOD GetMdbFactory(nsIMdbEnv* ev, nsIMdbFactory** acqFactory);</span>
<a href="#l73.47"></a><span id="l73.47">   // } ----- end factory methods -----</span>
<a href="#l73.48"></a><span id="l73.48"> </span>
<a href="#l73.49"></a><span id="l73.49">   // { ----- begin ref counting for well-behaved cyclic graphs -----</span>
<a href="#l73.50"></a><span id="l73.50">   NS_IMETHOD GetWeakRefCount(nsIMdbEnv* ev, // weak refs</span>
<a href="#l73.51"></a><span id="l73.51">     mdb_count* outCount) override;</span>
<a href="#l73.52"></a><span id="l73.52">   NS_IMETHOD GetStrongRefCount(nsIMdbEnv* ev, // strong refs</span>
<a href="#l73.53"></a><span id="l73.53">     mdb_count* outCount) override;</span>
<a href="#l73.54"></a><span id="l73.54"> </span>
<a href="#l73.55"></a><span id="l73.55" class="difflineat">@@ -114,34 +114,34 @@ public: // other port methods</span>
<a href="#l73.56"></a><span id="l73.56">   // The first declaration of CutStrongRef is to suppress -Werror,-Woverloaded-virtual.</span>
<a href="#l73.57"></a><span id="l73.57">   NS_IMETHOD_(mork_uses) CutStrongRef(morkEnv* ev) override;</span>
<a href="#l73.58"></a><span id="l73.58"> #endif</span>
<a href="#l73.59"></a><span id="l73.59">   NS_IMETHOD CutStrongRef(nsIMdbEnv* ev) override;</span>
<a href="#l73.60"></a><span id="l73.60"> </span>
<a href="#l73.61"></a><span id="l73.61">   NS_IMETHOD CloseMdbObject(nsIMdbEnv* ev) override; // called at strong refs zero</span>
<a href="#l73.62"></a><span id="l73.62">   NS_IMETHOD IsOpenMdbObject(nsIMdbEnv* ev, mdb_bool* outOpen) override;</span>
<a href="#l73.63"></a><span id="l73.63">   // } ----- end ref counting -----</span>
<a href="#l73.64"></a><span id="l73.64" class="difflineminus">-  </span>
<a href="#l73.65"></a><span id="l73.65" class="difflineplus">+</span>
<a href="#l73.66"></a><span id="l73.66"> // } ===== end nsIMdbObject methods =====</span>
<a href="#l73.67"></a><span id="l73.67"> </span>
<a href="#l73.68"></a><span id="l73.68"> // { ===== begin nsIMdbPort methods =====</span>
<a href="#l73.69"></a><span id="l73.69"> </span>
<a href="#l73.70"></a><span id="l73.70">   // { ----- begin attribute methods -----</span>
<a href="#l73.71"></a><span id="l73.71">   NS_IMETHOD GetIsPortReadonly(nsIMdbEnv* ev, mdb_bool* outBool) override;</span>
<a href="#l73.72"></a><span id="l73.72">   NS_IMETHOD GetIsStore(nsIMdbEnv* ev, mdb_bool* outBool) override;</span>
<a href="#l73.73"></a><span id="l73.73">   NS_IMETHOD GetIsStoreAndDirty(nsIMdbEnv* ev, mdb_bool* outBool) override;</span>
<a href="#l73.74"></a><span id="l73.74"> </span>
<a href="#l73.75"></a><span id="l73.75">   NS_IMETHOD GetUsagePolicy(nsIMdbEnv* ev,</span>
<a href="#l73.76"></a><span id="l73.76">     mdbUsagePolicy* ioUsagePolicy) override;</span>
<a href="#l73.77"></a><span id="l73.77"> </span>
<a href="#l73.78"></a><span id="l73.78">   NS_IMETHOD SetUsagePolicy(nsIMdbEnv* ev,</span>
<a href="#l73.79"></a><span id="l73.79">     const mdbUsagePolicy* inUsagePolicy) override;</span>
<a href="#l73.80"></a><span id="l73.80">   // } ----- end attribute methods -----</span>
<a href="#l73.81"></a><span id="l73.81"> </span>
<a href="#l73.82"></a><span id="l73.82" class="difflineminus">-  // { ----- begin memory policy methods -----  </span>
<a href="#l73.83"></a><span id="l73.83" class="difflineplus">+  // { ----- begin memory policy methods -----</span>
<a href="#l73.84"></a><span id="l73.84">   NS_IMETHOD IdleMemoryPurge( // do memory management already scheduled</span>
<a href="#l73.85"></a><span id="l73.85">     nsIMdbEnv* ev, // context</span>
<a href="#l73.86"></a><span id="l73.86">     mdb_size* outEstimatedBytesFreed) override; // approximate bytes actually freed</span>
<a href="#l73.87"></a><span id="l73.87"> </span>
<a href="#l73.88"></a><span id="l73.88">   NS_IMETHOD SessionMemoryPurge( // request specific footprint decrease</span>
<a href="#l73.89"></a><span id="l73.89">     nsIMdbEnv* ev, // context</span>
<a href="#l73.90"></a><span id="l73.90">     mdb_size inDesiredBytesFreed, // approximate number of bytes wanted</span>
<a href="#l73.91"></a><span id="l73.91">     mdb_size* outEstimatedBytesFreed) override; // approximate bytes actually freed</span>
<a href="#l73.92"></a><span id="l73.92" class="difflineat">@@ -184,49 +184,49 @@ public: // other port methods</span>
<a href="#l73.93"></a><span id="l73.93"> </span>
<a href="#l73.94"></a><span id="l73.94">   // } ----- end export methods -----</span>
<a href="#l73.95"></a><span id="l73.95"> </span>
<a href="#l73.96"></a><span id="l73.96">   // { ----- begin token methods -----</span>
<a href="#l73.97"></a><span id="l73.97">   NS_IMETHOD TokenToString( // return a string name for an integer token</span>
<a href="#l73.98"></a><span id="l73.98">     nsIMdbEnv* ev, // context</span>
<a href="#l73.99"></a><span id="l73.99">     mdb_token inToken, // token for inTokenName inside this port</span>
<a href="#l73.100"></a><span id="l73.100">     mdbYarn* outTokenName) override; // the type of table to access</span>
<a href="#l73.101"></a><span id="l73.101" class="difflineminus">-  </span>
<a href="#l73.102"></a><span id="l73.102" class="difflineplus">+</span>
<a href="#l73.103"></a><span id="l73.103">   NS_IMETHOD StringToToken( // return an integer token for scope name</span>
<a href="#l73.104"></a><span id="l73.104">     nsIMdbEnv* ev, // context</span>
<a href="#l73.105"></a><span id="l73.105">     const char* inTokenName, // Latin1 string to tokenize if possible</span>
<a href="#l73.106"></a><span id="l73.106">     mdb_token* outToken) override; // token for inTokenName inside this port</span>
<a href="#l73.107"></a><span id="l73.107" class="difflineminus">-    </span>
<a href="#l73.108"></a><span id="l73.108" class="difflineplus">+</span>
<a href="#l73.109"></a><span id="l73.109">   // String token zero is never used and never supported. If the port</span>
<a href="#l73.110"></a><span id="l73.110">   // is a mutable store, then StringToToken() to create a new</span>
<a href="#l73.111"></a><span id="l73.111">   // association of inTokenName with a new integer token if possible.</span>
<a href="#l73.112"></a><span id="l73.112">   // But a readonly port will return zero for an unknown scope name.</span>
<a href="#l73.113"></a><span id="l73.113"> </span>
<a href="#l73.114"></a><span id="l73.114">   NS_IMETHOD QueryToken( // like StringToToken(), but without adding</span>
<a href="#l73.115"></a><span id="l73.115">     nsIMdbEnv* ev, // context</span>
<a href="#l73.116"></a><span id="l73.116">     const char* inTokenName, // Latin1 string to tokenize if possible</span>
<a href="#l73.117"></a><span id="l73.117">     mdb_token* outToken) override; // token for inTokenName inside this port</span>
<a href="#l73.118"></a><span id="l73.118" class="difflineminus">-  </span>
<a href="#l73.119"></a><span id="l73.119" class="difflineplus">+</span>
<a href="#l73.120"></a><span id="l73.120">   // QueryToken() will return a string token if one already exists,</span>
<a href="#l73.121"></a><span id="l73.121">   // but unlike StringToToken(), will not assign a new token if not</span>
<a href="#l73.122"></a><span id="l73.122">   // already in use.</span>
<a href="#l73.123"></a><span id="l73.123"> </span>
<a href="#l73.124"></a><span id="l73.124">   // } ----- end token methods -----</span>
<a href="#l73.125"></a><span id="l73.125"> </span>
<a href="#l73.126"></a><span id="l73.126" class="difflineminus">-  // { ----- begin row methods -----  </span>
<a href="#l73.127"></a><span id="l73.127" class="difflineplus">+  // { ----- begin row methods -----</span>
<a href="#l73.128"></a><span id="l73.128">   NS_IMETHOD HasRow( // contains a row with the specified oid?</span>
<a href="#l73.129"></a><span id="l73.129">     nsIMdbEnv* ev, // context</span>
<a href="#l73.130"></a><span id="l73.130">     const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l73.131"></a><span id="l73.131">     mdb_bool* outHasRow) override; // whether GetRow() might succeed</span>
<a href="#l73.132"></a><span id="l73.132"> </span>
<a href="#l73.133"></a><span id="l73.133" class="difflineminus">-  NS_IMETHOD GetRowRefCount( // get number of tables that contain a row </span>
<a href="#l73.134"></a><span id="l73.134" class="difflineplus">+  NS_IMETHOD GetRowRefCount( // get number of tables that contain a row</span>
<a href="#l73.135"></a><span id="l73.135">     nsIMdbEnv* ev, // context</span>
<a href="#l73.136"></a><span id="l73.136">     const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l73.137"></a><span id="l73.137" class="difflineminus">-    mdb_count* outRefCount) override; // number of tables containing inRowKey </span>
<a href="#l73.138"></a><span id="l73.138" class="difflineminus">-    </span>
<a href="#l73.139"></a><span id="l73.139" class="difflineplus">+    mdb_count* outRefCount) override; // number of tables containing inRowKey</span>
<a href="#l73.140"></a><span id="l73.140" class="difflineplus">+</span>
<a href="#l73.141"></a><span id="l73.141">   NS_IMETHOD GetRow( // access one row with specific oid</span>
<a href="#l73.142"></a><span id="l73.142">     nsIMdbEnv* ev, // context</span>
<a href="#l73.143"></a><span id="l73.143">     const mdbOid* inOid,  // hypothetical row oid</span>
<a href="#l73.144"></a><span id="l73.144">     nsIMdbRow** acqRow) override; // acquire specific row (or null)</span>
<a href="#l73.145"></a><span id="l73.145"> </span>
<a href="#l73.146"></a><span id="l73.146">   NS_IMETHOD FindRow(nsIMdbEnv* ev, // search for row with matching cell</span>
<a href="#l73.147"></a><span id="l73.147">     mdb_scope inRowScope,   // row scope for row ids</span>
<a href="#l73.148"></a><span id="l73.148">     mdb_column inColumn,   // the column to search (and maintain an index)</span>
<a href="#l73.149"></a><span id="l73.149" class="difflineat">@@ -262,42 +262,42 @@ public: // other port methods</span>
<a href="#l73.150"></a><span id="l73.150">   //</span>
<a href="#l73.151"></a><span id="l73.151">   // In other words, the FindRow() implementation is allowed to assume simple</span>
<a href="#l73.152"></a><span id="l73.152">   // hash tables mapping unqiue column keys to associated row values will be</span>
<a href="#l73.153"></a><span id="l73.153">   // sufficient, where any duplication is not recorded because only one copy</span>
<a href="#l73.154"></a><span id="l73.154">   // of a given key need be remembered.  Implementors are not required to sort</span>
<a href="#l73.155"></a><span id="l73.155">   // all rows by the specified column.</span>
<a href="#l73.156"></a><span id="l73.156">   // } ----- end row methods -----</span>
<a href="#l73.157"></a><span id="l73.157"> </span>
<a href="#l73.158"></a><span id="l73.158" class="difflineminus">-  // { ----- begin table methods -----  </span>
<a href="#l73.159"></a><span id="l73.159" class="difflineplus">+  // { ----- begin table methods -----</span>
<a href="#l73.160"></a><span id="l73.160">   NS_IMETHOD HasTable( // supports a table with the specified oid?</span>
<a href="#l73.161"></a><span id="l73.161">     nsIMdbEnv* ev, // context</span>
<a href="#l73.162"></a><span id="l73.162">     const mdbOid* inOid,  // hypothetical table oid</span>
<a href="#l73.163"></a><span id="l73.163">     mdb_bool* outHasTable) override; // whether GetTable() might succeed</span>
<a href="#l73.164"></a><span id="l73.164" class="difflineminus">-    </span>
<a href="#l73.165"></a><span id="l73.165" class="difflineplus">+</span>
<a href="#l73.166"></a><span id="l73.166">   NS_IMETHOD GetTable( // access one table with specific oid</span>
<a href="#l73.167"></a><span id="l73.167">     nsIMdbEnv* ev, // context</span>
<a href="#l73.168"></a><span id="l73.168">     const mdbOid* inOid,  // hypothetical table oid</span>
<a href="#l73.169"></a><span id="l73.169">     nsIMdbTable** acqTable) override; // acquire specific table (or null)</span>
<a href="#l73.170"></a><span id="l73.170" class="difflineminus">-  </span>
<a href="#l73.171"></a><span id="l73.171" class="difflineplus">+</span>
<a href="#l73.172"></a><span id="l73.172">   NS_IMETHOD HasTableKind( // supports a table of the specified type?</span>
<a href="#l73.173"></a><span id="l73.173">     nsIMdbEnv* ev, // context</span>
<a href="#l73.174"></a><span id="l73.174">     mdb_scope inRowScope, // rid scope for row ids</span>
<a href="#l73.175"></a><span id="l73.175">     mdb_kind inTableKind, // the type of table to access</span>
<a href="#l73.176"></a><span id="l73.176">     mdb_count* outTableCount, // current number of such tables</span>
<a href="#l73.177"></a><span id="l73.177">     mdb_bool* outSupportsTable) override; // whether GetTableKind() might succeed</span>
<a href="#l73.178"></a><span id="l73.178" class="difflineminus">-        </span>
<a href="#l73.179"></a><span id="l73.179" class="difflineplus">+</span>
<a href="#l73.180"></a><span id="l73.180">   NS_IMETHOD GetTableKind( // access one (random) table of specific type</span>
<a href="#l73.181"></a><span id="l73.181">     nsIMdbEnv* ev, // context</span>
<a href="#l73.182"></a><span id="l73.182">     mdb_scope inRowScope,      // row scope for row ids</span>
<a href="#l73.183"></a><span id="l73.183">     mdb_kind inTableKind,      // the type of table to access</span>
<a href="#l73.184"></a><span id="l73.184">     mdb_count* outTableCount, // current number of such tables</span>
<a href="#l73.185"></a><span id="l73.185">     mdb_bool* outMustBeUnique, // whether port can hold only one of these</span>
<a href="#l73.186"></a><span id="l73.186">     nsIMdbTable** acqTable) override; // acquire scoped collection of rows</span>
<a href="#l73.187"></a><span id="l73.187" class="difflineminus">-    </span>
<a href="#l73.188"></a><span id="l73.188" class="difflineplus">+</span>
<a href="#l73.189"></a><span id="l73.189">   NS_IMETHOD</span>
<a href="#l73.190"></a><span id="l73.190">   GetPortTableCursor( // get cursor for all tables of specific type</span>
<a href="#l73.191"></a><span id="l73.191">     nsIMdbEnv* ev, // context</span>
<a href="#l73.192"></a><span id="l73.192">     mdb_scope inRowScope, // row scope for row ids</span>
<a href="#l73.193"></a><span id="l73.193">     mdb_kind inTableKind, // the type of table to access</span>
<a href="#l73.194"></a><span id="l73.194">     nsIMdbPortTableCursor** acqCursor) override; // all such tables in the port</span>
<a href="#l73.195"></a><span id="l73.195">   // } ----- end table methods -----</span>
<a href="#l73.196"></a><span id="l73.196"> </span>
<a href="#l73.197"></a><span id="l73.197" class="difflineat">@@ -307,17 +307,17 @@ public: // other port methods</span>
<a href="#l73.198"></a><span id="l73.198">   NS_IMETHOD ShouldCompress( // store wastes at least inPercentWaste?</span>
<a href="#l73.199"></a><span id="l73.199">     nsIMdbEnv* ev, // context</span>
<a href="#l73.200"></a><span id="l73.200">     mdb_percent inPercentWaste, // 0..100 percent file size waste threshold</span>
<a href="#l73.201"></a><span id="l73.201">     mdb_percent* outActualWaste, // 0..100 percent of file actually wasted</span>
<a href="#l73.202"></a><span id="l73.202">     mdb_bool* outShould) override; // true when about inPercentWaste% is wasted</span>
<a href="#l73.203"></a><span id="l73.203">   // ShouldCompress() returns true if the store can determine that the file</span>
<a href="#l73.204"></a><span id="l73.204">   // will shrink by an estimated percentage of inPercentWaste% (or more) if</span>
<a href="#l73.205"></a><span id="l73.205">   // CompressCommit() is called, because that percentage of the file seems</span>
<a href="#l73.206"></a><span id="l73.206" class="difflineminus">-  // to be recoverable free space.  The granularity is only in terms of </span>
<a href="#l73.207"></a><span id="l73.207" class="difflineplus">+  // to be recoverable free space.  The granularity is only in terms of</span>
<a href="#l73.208"></a><span id="l73.208">   // percentage points, and any value over 100 is considered equal to 100.</span>
<a href="#l73.209"></a><span id="l73.209">   //</span>
<a href="#l73.210"></a><span id="l73.210">   // If a store only has an approximate idea how much space might be saved</span>
<a href="#l73.211"></a><span id="l73.211">   // during a compress, then a best guess should be made.  For example, the</span>
<a href="#l73.212"></a><span id="l73.212">   // Mork implementation might keep track of how much file space began with</span>
<a href="#l73.213"></a><span id="l73.213">   // text content before the first updating transaction, and then consider</span>
<a href="#l73.214"></a><span id="l73.214">   // all content following the start of the first transaction as potentially</span>
<a href="#l73.215"></a><span id="l73.215">   // wasted space if it is all updates and not just new content.  (This is</span>
<a href="#l73.216"></a><span id="l73.216" class="difflineat">@@ -356,38 +356,38 @@ public: // other port methods</span>
<a href="#l73.217"></a><span id="l73.217">   // of total file size to pass as in the inPercentWaste parameter.  A zero</span>
<a href="#l73.218"></a><span id="l73.218">   // likely returns always trivially true, and 100 always trivially false.</span>
<a href="#l73.219"></a><span id="l73.219">   // The great majority of callers are expected to use values from 25 to 75,</span>
<a href="#l73.220"></a><span id="l73.220">   // since most plausible thresholds for compressing might fall between the</span>
<a href="#l73.221"></a><span id="l73.221">   // extremes of 133% of ideal size and 400% of ideal size.  (Presumably the</span>
<a href="#l73.222"></a><span id="l73.222">   // larger a file gets, the more important the percentage waste involved, so</span>
<a href="#l73.223"></a><span id="l73.223">   // a sliding scale for compress thresholds might use smaller numbers for</span>
<a href="#l73.224"></a><span id="l73.224">   // much bigger file sizes.)</span>
<a href="#l73.225"></a><span id="l73.225" class="difflineminus">-  </span>
<a href="#l73.226"></a><span id="l73.226" class="difflineplus">+</span>
<a href="#l73.227"></a><span id="l73.227">   // } ----- end commit methods -----</span>
<a href="#l73.228"></a><span id="l73.228"> </span>
<a href="#l73.229"></a><span id="l73.229"> // } ===== end nsIMdbPort methods =====</span>
<a href="#l73.230"></a><span id="l73.230"> </span>
<a href="#l73.231"></a><span id="l73.231"> // { ===== begin nsIMdbStore methods =====</span>
<a href="#l73.232"></a><span id="l73.232"> </span>
<a href="#l73.233"></a><span id="l73.233">   // { ----- begin table methods -----</span>
<a href="#l73.234"></a><span id="l73.234">   NS_IMETHOD NewTable( // make one new table of specific type</span>
<a href="#l73.235"></a><span id="l73.235">     nsIMdbEnv* ev, // context</span>
<a href="#l73.236"></a><span id="l73.236">     mdb_scope inRowScope,    // row scope for row ids</span>
<a href="#l73.237"></a><span id="l73.237">     mdb_kind inTableKind,    // the type of table to access</span>
<a href="#l73.238"></a><span id="l73.238">     mdb_bool inMustBeUnique, // whether store can hold only one of these</span>
<a href="#l73.239"></a><span id="l73.239">     const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l73.240"></a><span id="l73.240">     nsIMdbTable** acqTable) override; // acquire scoped collection of rows</span>
<a href="#l73.241"></a><span id="l73.241" class="difflineminus">-    </span>
<a href="#l73.242"></a><span id="l73.242" class="difflineplus">+</span>
<a href="#l73.243"></a><span id="l73.243">   NS_IMETHOD NewTableWithOid( // make one new table of specific type</span>
<a href="#l73.244"></a><span id="l73.244">     nsIMdbEnv* ev, // context</span>
<a href="#l73.245"></a><span id="l73.245">     const mdbOid* inOid,   // caller assigned oid</span>
<a href="#l73.246"></a><span id="l73.246">     mdb_kind inTableKind,    // the type of table to access</span>
<a href="#l73.247"></a><span id="l73.247">     mdb_bool inMustBeUnique, // whether store can hold only one of these</span>
<a href="#l73.248"></a><span id="l73.248" class="difflineminus">-    const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l73.249"></a><span id="l73.249" class="difflineplus">+    const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l73.250"></a><span id="l73.250">     nsIMdbTable** acqTable) override; // acquire scoped collection of rows</span>
<a href="#l73.251"></a><span id="l73.251">   // } ----- end table methods -----</span>
<a href="#l73.252"></a><span id="l73.252"> </span>
<a href="#l73.253"></a><span id="l73.253">   // { ----- begin row scope methods -----</span>
<a href="#l73.254"></a><span id="l73.254">   NS_IMETHOD RowScopeHasAssignedIds(nsIMdbEnv* ev,</span>
<a href="#l73.255"></a><span id="l73.255">     mdb_scope inRowScope,   // row scope for row ids</span>
<a href="#l73.256"></a><span id="l73.256">     mdb_bool* outCallerAssigned, // nonzero if caller assigned specified</span>
<a href="#l73.257"></a><span id="l73.257">     mdb_bool* outStoreAssigned) override; // nonzero if store db assigned specified</span>
<a href="#l73.258"></a><span id="l73.258" class="difflineat">@@ -466,72 +466,72 @@ public: // other port methods</span>
<a href="#l73.259"></a><span id="l73.259">   NS_IMETHOD</span>
<a href="#l73.260"></a><span id="l73.260">   CompressCommit( // commit and make db physically smaller if possible</span>
<a href="#l73.261"></a><span id="l73.261">     nsIMdbEnv* ev, // context</span>
<a href="#l73.262"></a><span id="l73.262">     nsIMdbThumb** acqThumb) override; // acquire thumb for incremental commit</span>
<a href="#l73.263"></a><span id="l73.263">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l73.264"></a><span id="l73.264">   // then the commit will be finished.  Note the store is effectively write</span>
<a href="#l73.265"></a><span id="l73.265">   // locked until commit is finished or canceled through the thumb instance.</span>
<a href="#l73.266"></a><span id="l73.266">   // Until the commit is done, the store will report it has readonly status.</span>
<a href="#l73.267"></a><span id="l73.267" class="difflineminus">-  </span>
<a href="#l73.268"></a><span id="l73.268" class="difflineplus">+</span>
<a href="#l73.269"></a><span id="l73.269">   // } ----- end commit methods -----</span>
<a href="#l73.270"></a><span id="l73.270"> </span>
<a href="#l73.271"></a><span id="l73.271"> // } ===== end nsIMdbStore methods =====</span>
<a href="#l73.272"></a><span id="l73.272"> </span>
<a href="#l73.273"></a><span id="l73.273"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l73.274"></a><span id="l73.274">   static void SlotWeakPort(morkPort* me,</span>
<a href="#l73.275"></a><span id="l73.275">     morkEnv* ev, morkPort** ioSlot)</span>
<a href="#l73.276"></a><span id="l73.276">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l73.277"></a><span id="l73.277" class="difflineminus">-  </span>
<a href="#l73.278"></a><span id="l73.278" class="difflineplus">+</span>
<a href="#l73.279"></a><span id="l73.279">   static void SlotStrongPort(morkPort* me,</span>
<a href="#l73.280"></a><span id="l73.280">     morkEnv* ev, morkPort** ioSlot)</span>
<a href="#l73.281"></a><span id="l73.281">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l73.282"></a><span id="l73.282"> // public: // slots inherited from morkPort (meant to inform only)</span>
<a href="#l73.283"></a><span id="l73.283">   // nsIMdbHeap*     mNode_Heap;</span>
<a href="#l73.284"></a><span id="l73.284">   // mork_able    mNode_Mutable; // can this node be modified?</span>
<a href="#l73.285"></a><span id="l73.285">   // mork_load    mNode_Load;    // is this node clean or dirty?</span>
<a href="#l73.286"></a><span id="l73.286">   // mork_base    mNode_Base;    // must equal morkBase_kNode</span>
<a href="#l73.287"></a><span id="l73.287">   // mork_derived mNode_Derived; // depends on specific node subclass</span>
<a href="#l73.288"></a><span id="l73.288">   // mork_access  mNode_Access;  // kOpen, kClosing, kShut, or kDead</span>
<a href="#l73.289"></a><span id="l73.289">   // mork_usage   mNode_Usage;   // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l73.290"></a><span id="l73.290">   // mork_uses    mNode_Uses;    // refcount for strong refs</span>
<a href="#l73.291"></a><span id="l73.291">   // mork_refs    mNode_Refs;    // refcount for strong refs + weak refs</span>
<a href="#l73.292"></a><span id="l73.292" class="difflineminus">- </span>
<a href="#l73.293"></a><span id="l73.293" class="difflineplus">+</span>
<a href="#l73.294"></a><span id="l73.294">   // morkEnv*        mPort_Env;      // non-refcounted env which created port</span>
<a href="#l73.295"></a><span id="l73.295">   // morkFactory*    mPort_Factory;  // weak ref to suite factory</span>
<a href="#l73.296"></a><span id="l73.296">   // nsIMdbHeap*     mPort_Heap;     // heap in which this port allocs objects</span>
<a href="#l73.297"></a><span id="l73.297"> </span>
<a href="#l73.298"></a><span id="l73.298"> public: // state is public because the entire Mork system is private</span>
<a href="#l73.299"></a><span id="l73.299"> </span>
<a href="#l73.300"></a><span id="l73.300"> // mStore_OidAtomSpace might be unnecessary; I don't remember why I wanted it.</span>
<a href="#l73.301"></a><span id="l73.301">   morkAtomSpace*   mStore_OidAtomSpace;   // ground atom space for oids</span>
<a href="#l73.302"></a><span id="l73.302">   morkAtomSpace*   mStore_GroundAtomSpace; // ground atom space for scopes</span>
<a href="#l73.303"></a><span id="l73.303">   morkAtomSpace*   mStore_GroundColumnSpace; // ground column space for scopes</span>
<a href="#l73.304"></a><span id="l73.304"> </span>
<a href="#l73.305"></a><span id="l73.305">   nsIMdbFile*      mStore_File; // the file containing Mork text</span>
<a href="#l73.306"></a><span id="l73.306">   morkStream*      mStore_InStream; // stream using file used by the builder</span>
<a href="#l73.307"></a><span id="l73.307" class="difflineminus">-  morkBuilder*     mStore_Builder; // to parse Mork text and build structures </span>
<a href="#l73.308"></a><span id="l73.308" class="difflineplus">+  morkBuilder*     mStore_Builder; // to parse Mork text and build structures</span>
<a href="#l73.309"></a><span id="l73.309"> </span>
<a href="#l73.310"></a><span id="l73.310">   morkStream*      mStore_OutStream; // stream using file used by the writer</span>
<a href="#l73.311"></a><span id="l73.311" class="difflineminus">-  </span>
<a href="#l73.312"></a><span id="l73.312" class="difflineplus">+</span>
<a href="#l73.313"></a><span id="l73.313">   morkRowSpaceMap  mStore_RowSpaces;  // maps mork_scope -&gt; morkSpace</span>
<a href="#l73.314"></a><span id="l73.314">   morkAtomSpaceMap mStore_AtomSpaces; // maps mork_scope -&gt; morkSpace</span>
<a href="#l73.315"></a><span id="l73.315" class="difflineminus">-  </span>
<a href="#l73.316"></a><span id="l73.316" class="difflineplus">+</span>
<a href="#l73.317"></a><span id="l73.317">   morkZone         mStore_Zone;</span>
<a href="#l73.318"></a><span id="l73.318" class="difflineminus">-  </span>
<a href="#l73.319"></a><span id="l73.319" class="difflineplus">+</span>
<a href="#l73.320"></a><span id="l73.320">   morkPool         mStore_Pool;</span>
<a href="#l73.321"></a><span id="l73.321"> </span>
<a href="#l73.322"></a><span id="l73.322">   // we alloc a max size book atom to reuse space for atom map key searches:</span>
<a href="#l73.323"></a><span id="l73.323">   // morkMaxBookAtom  mStore_BookAtom; // staging area for atom map searches</span>
<a href="#l73.324"></a><span id="l73.324" class="difflineminus">-  </span>
<a href="#l73.325"></a><span id="l73.325" class="difflineplus">+</span>
<a href="#l73.326"></a><span id="l73.326">   morkFarBookAtom  mStore_FarBookAtom; // staging area for atom map searches</span>
<a href="#l73.327"></a><span id="l73.327" class="difflineminus">-  </span>
<a href="#l73.328"></a><span id="l73.328" class="difflineplus">+</span>
<a href="#l73.329"></a><span id="l73.329">   // GroupIdentity should be one more than largest seen in a parsed db file:</span>
<a href="#l73.330"></a><span id="l73.330">   mork_gid         mStore_CommitGroupIdentity; // transaction ID number</span>
<a href="#l73.331"></a><span id="l73.331" class="difflineminus">-  </span>
<a href="#l73.332"></a><span id="l73.332" class="difflineplus">+</span>
<a href="#l73.333"></a><span id="l73.333">   // group positions are used to help compute PercentOfStoreWasted():</span>
<a href="#l73.334"></a><span id="l73.334">   mork_pos         mStore_FirstCommitGroupPos; // start of first group</span>
<a href="#l73.335"></a><span id="l73.335">   mork_pos         mStore_SecondCommitGroupPos; // start of second group</span>
<a href="#l73.336"></a><span id="l73.336">   // If the first commit group is very near the start of the file (say less</span>
<a href="#l73.337"></a><span id="l73.337">   // than 512 bytes), then we might assume the file started nearly empty and</span>
<a href="#l73.338"></a><span id="l73.338">   // that most of the first group is not wasted.  In that case, the pos of</span>
<a href="#l73.339"></a><span id="l73.339">   // the second commit group might make a better estimate of the start of</span>
<a href="#l73.340"></a><span id="l73.340">   // transaction space that might represent wasted file space.  That's why</span>
<a href="#l73.341"></a><span id="l73.341" class="difflineat">@@ -541,90 +541,90 @@ public: // state is public because the e</span>
<a href="#l73.342"></a><span id="l73.342">   // yet been given a valid value, since the file will always start with a</span>
<a href="#l73.343"></a><span id="l73.343">   // tag, and a commit group cannot actually start at position zero.</span>
<a href="#l73.344"></a><span id="l73.344">   //</span>
<a href="#l73.345"></a><span id="l73.345">   // Either or both the first or second commit group positions might be</span>
<a href="#l73.346"></a><span id="l73.346">   // supplied by either morkWriter (while committing) or morkBuilder (while</span>
<a href="#l73.347"></a><span id="l73.347">   // parsing), since either reading or writing the file might encounter the</span>
<a href="#l73.348"></a><span id="l73.348">   // first transaction groups which came into existence either in the past</span>
<a href="#l73.349"></a><span id="l73.349">   // or in the very recent present.</span>
<a href="#l73.350"></a><span id="l73.350" class="difflineminus">-  </span>
<a href="#l73.351"></a><span id="l73.351" class="difflineplus">+</span>
<a href="#l73.352"></a><span id="l73.352">   mork_bool        mStore_CanAutoAssignAtomIdentity;</span>
<a href="#l73.353"></a><span id="l73.353">   mork_bool        mStore_CanDirty; // changes imply the store becomes dirty?</span>
<a href="#l73.354"></a><span id="l73.354">   mork_u1          mStore_CanWriteIncremental; // compress not required?</span>
<a href="#l73.355"></a><span id="l73.355">   mork_u1          mStore_Pad; // for u4 alignment</span>
<a href="#l73.356"></a><span id="l73.356" class="difflineminus">-  </span>
<a href="#l73.357"></a><span id="l73.357" class="difflineplus">+</span>
<a href="#l73.358"></a><span id="l73.358">   // mStore_CanDirty should be FALSE when parsing a file while building the</span>
<a href="#l73.359"></a><span id="l73.359">   // content going into the store, because such data structure modifications</span>
<a href="#l73.360"></a><span id="l73.360">   // are actuallly in sync with the file.  So content read from a file must</span>
<a href="#l73.361"></a><span id="l73.361">   // be clean with respect to the file.  After a file is finished parsing,</span>
<a href="#l73.362"></a><span id="l73.362">   // the mStore_CanDirty slot should become TRUE, so that any additional</span>
<a href="#l73.363"></a><span id="l73.363">   // changes at runtime cause structures to be marked dirty with respect to</span>
<a href="#l73.364"></a><span id="l73.364">   // the file which must later be updated with changes during a commit.</span>
<a href="#l73.365"></a><span id="l73.365">   //</span>
<a href="#l73.366"></a><span id="l73.366">   // It might also make sense to set mStore_CanDirty to FALSE while a commit</span>
<a href="#l73.367"></a><span id="l73.367">   // is in progress, lest some internal transformations make more content</span>
<a href="#l73.368"></a><span id="l73.368">   // appear dirty when it should not.  So anyone modifying content during a</span>
<a href="#l73.369"></a><span id="l73.369">   // commit should think about the intended significance regarding dirty.</span>
<a href="#l73.370"></a><span id="l73.370"> </span>
<a href="#l73.371"></a><span id="l73.371"> public: // more specific dirty methods for store:</span>
<a href="#l73.372"></a><span id="l73.372">   void SetStoreDirty() { this-&gt;SetNodeDirty(); }</span>
<a href="#l73.373"></a><span id="l73.373">   void SetStoreClean() { this-&gt;SetNodeClean(); }</span>
<a href="#l73.374"></a><span id="l73.374" class="difflineminus">-  </span>
<a href="#l73.375"></a><span id="l73.375" class="difflineplus">+</span>
<a href="#l73.376"></a><span id="l73.376">   mork_bool IsStoreClean() const { return this-&gt;IsNodeClean(); }</span>
<a href="#l73.377"></a><span id="l73.377">   mork_bool IsStoreDirty() const { return this-&gt;IsNodeDirty(); }</span>
<a href="#l73.378"></a><span id="l73.378" class="difflineminus">- </span>
<a href="#l73.379"></a><span id="l73.379" class="difflineplus">+</span>
<a href="#l73.380"></a><span id="l73.380"> public: // setting dirty based on CanDirty:</span>
<a href="#l73.381"></a><span id="l73.381" class="difflineminus">- </span>
<a href="#l73.382"></a><span id="l73.382" class="difflineplus">+</span>
<a href="#l73.383"></a><span id="l73.383">   void MaybeDirtyStore()</span>
<a href="#l73.384"></a><span id="l73.384">   { if ( mStore_CanDirty ) this-&gt;SetStoreDirty(); }</span>
<a href="#l73.385"></a><span id="l73.385" class="difflineminus">-  </span>
<a href="#l73.386"></a><span id="l73.386" class="difflineplus">+</span>
<a href="#l73.387"></a><span id="l73.387"> public: // space waste analysis</span>
<a href="#l73.388"></a><span id="l73.388"> </span>
<a href="#l73.389"></a><span id="l73.389">   mork_percent PercentOfStoreWasted(morkEnv* ev);</span>
<a href="#l73.390"></a><span id="l73.390" class="difflineminus">- </span>
<a href="#l73.391"></a><span id="l73.391" class="difflineplus">+</span>
<a href="#l73.392"></a><span id="l73.392"> public: // setting store and all subspaces canDirty:</span>
<a href="#l73.393"></a><span id="l73.393" class="difflineminus">- </span>
<a href="#l73.394"></a><span id="l73.394" class="difflineplus">+</span>
<a href="#l73.395"></a><span id="l73.395">   void SetStoreAndAllSpacesCanDirty(morkEnv* ev, mork_bool inCanDirty);</span>
<a href="#l73.396"></a><span id="l73.396"> </span>
<a href="#l73.397"></a><span id="l73.397"> public: // building an atom inside mStore_FarBookAtom from a char* string</span>
<a href="#l73.398"></a><span id="l73.398"> </span>
<a href="#l73.399"></a><span id="l73.399">   morkFarBookAtom* StageAliasAsFarBookAtom(morkEnv* ev,</span>
<a href="#l73.400"></a><span id="l73.400">     const morkMid* inMid, morkAtomSpace* ioSpace, mork_cscode inForm);</span>
<a href="#l73.401"></a><span id="l73.401"> </span>
<a href="#l73.402"></a><span id="l73.402">   morkFarBookAtom* StageYarnAsFarBookAtom(morkEnv* ev,</span>
<a href="#l73.403"></a><span id="l73.403">     const mdbYarn* inYarn, morkAtomSpace* ioSpace);</span>
<a href="#l73.404"></a><span id="l73.404"> </span>
<a href="#l73.405"></a><span id="l73.405">   morkFarBookAtom* StageStringAsFarBookAtom(morkEnv* ev,</span>
<a href="#l73.406"></a><span id="l73.406">     const char* inString, mork_cscode inForm, morkAtomSpace* ioSpace);</span>
<a href="#l73.407"></a><span id="l73.407"> </span>
<a href="#l73.408"></a><span id="l73.408"> public: // determining whether incremental writing is a good use of time:</span>
<a href="#l73.409"></a><span id="l73.409"> </span>
<a href="#l73.410"></a><span id="l73.410">   mork_bool DoPreferLargeOverCompressCommit(morkEnv* ev);</span>
<a href="#l73.411"></a><span id="l73.411" class="difflineminus">-  // true when mStore_CanWriteIncremental &amp;&amp; store has file large enough </span>
<a href="#l73.412"></a><span id="l73.412" class="difflineplus">+  // true when mStore_CanWriteIncremental &amp;&amp; store has file large enough</span>
<a href="#l73.413"></a><span id="l73.413"> </span>
<a href="#l73.414"></a><span id="l73.414"> public: // lazy creation of members and nested row or atom spaces</span>
<a href="#l73.415"></a><span id="l73.415"> </span>
<a href="#l73.416"></a><span id="l73.416">   morkAtomSpace*   LazyGetOidAtomSpace(morkEnv* ev);</span>
<a href="#l73.417"></a><span id="l73.417">   morkAtomSpace*   LazyGetGroundAtomSpace(morkEnv* ev);</span>
<a href="#l73.418"></a><span id="l73.418">   morkAtomSpace*   LazyGetGroundColumnSpace(morkEnv* ev);</span>
<a href="#l73.419"></a><span id="l73.419"> </span>
<a href="#l73.420"></a><span id="l73.420">   morkStream*      LazyGetInStream(morkEnv* ev);</span>
<a href="#l73.421"></a><span id="l73.421" class="difflineminus">-  morkBuilder*     LazyGetBuilder(morkEnv* ev); </span>
<a href="#l73.422"></a><span id="l73.422" class="difflineminus">-  void             ForgetBuilder(morkEnv* ev); </span>
<a href="#l73.423"></a><span id="l73.423" class="difflineplus">+  morkBuilder*     LazyGetBuilder(morkEnv* ev);</span>
<a href="#l73.424"></a><span id="l73.424" class="difflineplus">+  void             ForgetBuilder(morkEnv* ev);</span>
<a href="#l73.425"></a><span id="l73.425"> </span>
<a href="#l73.426"></a><span id="l73.426">   morkStream*      LazyGetOutStream(morkEnv* ev);</span>
<a href="#l73.427"></a><span id="l73.427" class="difflineminus">-  </span>
<a href="#l73.428"></a><span id="l73.428" class="difflineplus">+</span>
<a href="#l73.429"></a><span id="l73.429">   morkRowSpace*    LazyGetRowSpace(morkEnv* ev, mdb_scope inRowScope);</span>
<a href="#l73.430"></a><span id="l73.430">   morkAtomSpace*   LazyGetAtomSpace(morkEnv* ev, mdb_scope inAtomScope);</span>
<a href="#l73.431"></a><span id="l73.431" class="difflineminus">- </span>
<a href="#l73.432"></a><span id="l73.432" class="difflineplus">+</span>
<a href="#l73.433"></a><span id="l73.433"> // { ===== begin morkNode interface =====</span>
<a href="#l73.434"></a><span id="l73.434"> public: // morkNode virtual methods</span>
<a href="#l73.435"></a><span id="l73.435">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseStore() only if open</span>
<a href="#l73.436"></a><span id="l73.436" class="difflineminus">-  </span>
<a href="#l73.437"></a><span id="l73.437" class="difflineplus">+</span>
<a href="#l73.438"></a><span id="l73.438"> public: // morkStore construction &amp; destruction</span>
<a href="#l73.439"></a><span id="l73.439">   morkStore(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l73.440"></a><span id="l73.440">      nsIMdbHeap* ioNodeHeap, // the heap (if any) for this node instance</span>
<a href="#l73.441"></a><span id="l73.441">      morkFactory* inFactory, // the factory for this</span>
<a href="#l73.442"></a><span id="l73.442">      nsIMdbHeap* ioPortHeap  // the heap to hold all content in the port</span>
<a href="#l73.443"></a><span id="l73.443">      );</span>
<a href="#l73.444"></a><span id="l73.444">   void CloseStore(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l73.445"></a><span id="l73.445"> </span>
<a href="#l73.446"></a><span id="l73.446" class="difflineat">@@ -639,19 +639,19 @@ public: // dynamic type identification</span>
<a href="#l73.447"></a><span id="l73.447">    mork_bool IsStore() const</span>
<a href="#l73.448"></a><span id="l73.448">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kStore; }</span>
<a href="#l73.449"></a><span id="l73.449"> // } ===== end morkNode methods =====</span>
<a href="#l73.450"></a><span id="l73.450"> </span>
<a href="#l73.451"></a><span id="l73.451"> public: // typing</span>
<a href="#l73.452"></a><span id="l73.452">   static void NonStoreTypeError(morkEnv* ev);</span>
<a href="#l73.453"></a><span id="l73.453">   static void NilStoreFileError(morkEnv* ev);</span>
<a href="#l73.454"></a><span id="l73.454">   static void CannotAutoAssignAtomIdentityError(morkEnv* ev);</span>
<a href="#l73.455"></a><span id="l73.455" class="difflineminus">-  </span>
<a href="#l73.456"></a><span id="l73.456" class="difflineplus">+</span>
<a href="#l73.457"></a><span id="l73.457"> public: //  store utilties</span>
<a href="#l73.458"></a><span id="l73.458" class="difflineminus">-  </span>
<a href="#l73.459"></a><span id="l73.459" class="difflineplus">+</span>
<a href="#l73.460"></a><span id="l73.460">   morkAtom* YarnToAtom(morkEnv* ev, const mdbYarn* inYarn, bool createIfMissing = true);</span>
<a href="#l73.461"></a><span id="l73.461">   morkAtom* AddAlias(morkEnv* ev, const morkMid&amp; inMid,</span>
<a href="#l73.462"></a><span id="l73.462">     mork_cscode inForm);</span>
<a href="#l73.463"></a><span id="l73.463"> </span>
<a href="#l73.464"></a><span id="l73.464"> public: // other store methods</span>
<a href="#l73.465"></a><span id="l73.465"> </span>
<a href="#l73.466"></a><span id="l73.466">   void RenumberAllCollectableContent(morkEnv* ev);</span>
<a href="#l73.467"></a><span id="l73.467"> </span>
<a href="#l73.468"></a><span id="l73.468" class="difflineat">@@ -664,93 +664,93 @@ public: // other store methods</span>
<a href="#l73.469"></a><span id="l73.469">     // const char* inFilePath,</span>
<a href="#l73.470"></a><span id="l73.470">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l73.471"></a><span id="l73.471">     const mdbOpenPolicy* inOpenPolicy);</span>
<a href="#l73.472"></a><span id="l73.472"> </span>
<a href="#l73.473"></a><span id="l73.473">   mork_bool CreateStoreFile(morkEnv* ev, // return value equals ev-&gt;Good()</span>
<a href="#l73.474"></a><span id="l73.474">     // const char* inFilePath,</span>
<a href="#l73.475"></a><span id="l73.475">     nsIMdbFile* ioFile, // db abstract file interface</span>
<a href="#l73.476"></a><span id="l73.476">     const mdbOpenPolicy* inOpenPolicy);</span>
<a href="#l73.477"></a><span id="l73.477" class="difflineminus">-    </span>
<a href="#l73.478"></a><span id="l73.478" class="difflineplus">+</span>
<a href="#l73.479"></a><span id="l73.479">   morkAtom* CopyAtom(morkEnv* ev, const morkAtom* inAtom);</span>
<a href="#l73.480"></a><span id="l73.480">   // copy inAtom (from some other store) over to this store</span>
<a href="#l73.481"></a><span id="l73.481" class="difflineminus">-    </span>
<a href="#l73.482"></a><span id="l73.482" class="difflineplus">+</span>
<a href="#l73.483"></a><span id="l73.483">   mork_token CopyToken(morkEnv* ev, mdb_token inToken, morkStore* inStore);</span>
<a href="#l73.484"></a><span id="l73.484">   // copy inToken from inStore over to this store</span>
<a href="#l73.485"></a><span id="l73.485" class="difflineminus">-    </span>
<a href="#l73.486"></a><span id="l73.486" class="difflineplus">+</span>
<a href="#l73.487"></a><span id="l73.487">   mork_token BufToToken(morkEnv* ev, const morkBuf* inBuf);</span>
<a href="#l73.488"></a><span id="l73.488">   mork_token StringToToken(morkEnv* ev, const char* inTokenName);</span>
<a href="#l73.489"></a><span id="l73.489">   mork_token QueryToken(morkEnv* ev, const char* inTokenName);</span>
<a href="#l73.490"></a><span id="l73.490">   void TokenToString(morkEnv* ev, mdb_token inToken, mdbYarn* outTokenName);</span>
<a href="#l73.491"></a><span id="l73.491" class="difflineminus">-  </span>
<a href="#l73.492"></a><span id="l73.492" class="difflineplus">+</span>
<a href="#l73.493"></a><span id="l73.493">   mork_bool MidToOid(morkEnv* ev, const morkMid&amp; inMid,</span>
<a href="#l73.494"></a><span id="l73.494">      mdbOid* outOid);</span>
<a href="#l73.495"></a><span id="l73.495">   mork_bool OidToYarn(morkEnv* ev, const mdbOid&amp; inOid, mdbYarn* outYarn);</span>
<a href="#l73.496"></a><span id="l73.496">   mork_bool MidToYarn(morkEnv* ev, const morkMid&amp; inMid,</span>
<a href="#l73.497"></a><span id="l73.497">      mdbYarn* outYarn);</span>
<a href="#l73.498"></a><span id="l73.498"> </span>
<a href="#l73.499"></a><span id="l73.499">   morkBookAtom* MidToAtom(morkEnv* ev, const morkMid&amp; inMid);</span>
<a href="#l73.500"></a><span id="l73.500">   morkRow* MidToRow(morkEnv* ev, const morkMid&amp; inMid);</span>
<a href="#l73.501"></a><span id="l73.501">   morkTable* MidToTable(morkEnv* ev, const morkMid&amp; inMid);</span>
<a href="#l73.502"></a><span id="l73.502" class="difflineminus">-  </span>
<a href="#l73.503"></a><span id="l73.503" class="difflineplus">+</span>
<a href="#l73.504"></a><span id="l73.504">   morkRow* OidToRow(morkEnv* ev, const mdbOid* inOid);</span>
<a href="#l73.505"></a><span id="l73.505">   // OidToRow() finds old row with oid, or makes new one if not found.</span>
<a href="#l73.506"></a><span id="l73.506"> </span>
<a href="#l73.507"></a><span id="l73.507">   morkTable* OidToTable(morkEnv* ev, const mdbOid* inOid,</span>
<a href="#l73.508"></a><span id="l73.508">     const mdbOid* inOptionalMetaRowOid);</span>
<a href="#l73.509"></a><span id="l73.509">   // OidToTable() finds old table with oid, or makes new one if not found.</span>
<a href="#l73.510"></a><span id="l73.510" class="difflineminus">-  </span>
<a href="#l73.511"></a><span id="l73.511" class="difflineplus">+</span>
<a href="#l73.512"></a><span id="l73.512">   static void SmallTokenToOneByteYarn(morkEnv* ev, mdb_token inToken,</span>
<a href="#l73.513"></a><span id="l73.513">     mdbYarn* outYarn);</span>
<a href="#l73.514"></a><span id="l73.514" class="difflineminus">-  </span>
<a href="#l73.515"></a><span id="l73.515" class="difflineminus">-  mork_bool HasTableKind(morkEnv* ev, mdb_scope inRowScope, </span>
<a href="#l73.516"></a><span id="l73.516" class="difflineplus">+</span>
<a href="#l73.517"></a><span id="l73.517" class="difflineplus">+  mork_bool HasTableKind(morkEnv* ev, mdb_scope inRowScope,</span>
<a href="#l73.518"></a><span id="l73.518">     mdb_kind inTableKind, mdb_count* outTableCount);</span>
<a href="#l73.519"></a><span id="l73.519" class="difflineminus">-  </span>
<a href="#l73.520"></a><span id="l73.520" class="difflineminus">-  morkTable* GetTableKind(morkEnv* ev, mdb_scope inRowScope, </span>
<a href="#l73.521"></a><span id="l73.521" class="difflineplus">+</span>
<a href="#l73.522"></a><span id="l73.522" class="difflineplus">+  morkTable* GetTableKind(morkEnv* ev, mdb_scope inRowScope,</span>
<a href="#l73.523"></a><span id="l73.523">     mdb_kind inTableKind, mdb_count* outTableCount,</span>
<a href="#l73.524"></a><span id="l73.524">     mdb_bool* outMustBeUnique);</span>
<a href="#l73.525"></a><span id="l73.525"> </span>
<a href="#l73.526"></a><span id="l73.526">   morkRow* FindRow(morkEnv* ev, mdb_scope inScope, mdb_column inColumn,</span>
<a href="#l73.527"></a><span id="l73.527">     const mdbYarn* inTargetCellValue);</span>
<a href="#l73.528"></a><span id="l73.528" class="difflineminus">-  </span>
<a href="#l73.529"></a><span id="l73.529" class="difflineplus">+</span>
<a href="#l73.530"></a><span id="l73.530">   morkRow* GetRow(morkEnv* ev, const mdbOid* inOid);</span>
<a href="#l73.531"></a><span id="l73.531">   morkTable* GetTable(morkEnv* ev, const mdbOid* inOid);</span>
<a href="#l73.532"></a><span id="l73.532" class="difflineminus">-    </span>
<a href="#l73.533"></a><span id="l73.533" class="difflineplus">+</span>
<a href="#l73.534"></a><span id="l73.534">   morkTable* NewTable(morkEnv* ev, mdb_scope inRowScope,</span>
<a href="#l73.535"></a><span id="l73.535">     mdb_kind inTableKind, mdb_bool inMustBeUnique,</span>
<a href="#l73.536"></a><span id="l73.536">     const mdbOid* inOptionalMetaRowOid);</span>
<a href="#l73.537"></a><span id="l73.537"> </span>
<a href="#l73.538"></a><span id="l73.538">   morkPortTableCursor* GetPortTableCursor(morkEnv* ev, mdb_scope inRowScope,</span>
<a href="#l73.539"></a><span id="l73.539">     mdb_kind inTableKind) ;</span>
<a href="#l73.540"></a><span id="l73.540"> </span>
<a href="#l73.541"></a><span id="l73.541">   morkRow* NewRowWithOid(morkEnv* ev, const mdbOid* inOid);</span>
<a href="#l73.542"></a><span id="l73.542">   morkRow* NewRow(morkEnv* ev, mdb_scope inRowScope);</span>
<a href="#l73.543"></a><span id="l73.543"> </span>
<a href="#l73.544"></a><span id="l73.544">   morkThumb* MakeCompressCommitThumb(morkEnv* ev, mork_bool inDoCollect);</span>
<a href="#l73.545"></a><span id="l73.545"> </span>
<a href="#l73.546"></a><span id="l73.546"> public: // commit related methods</span>
<a href="#l73.547"></a><span id="l73.547"> </span>
<a href="#l73.548"></a><span id="l73.548">   mork_bool MarkAllStoreContentDirty(morkEnv* ev);</span>
<a href="#l73.549"></a><span id="l73.549" class="difflineminus">-  // MarkAllStoreContentDirty() visits every object in the store and marks </span>
<a href="#l73.550"></a><span id="l73.550" class="difflineplus">+  // MarkAllStoreContentDirty() visits every object in the store and marks</span>
<a href="#l73.551"></a><span id="l73.551">   // them dirty, including every table, row, cell, and atom.  The return</span>
<a href="#l73.552"></a><span id="l73.552">   // equals ev-&gt;Good(), to show whether any error happened.  This method is</span>
<a href="#l73.553"></a><span id="l73.553">   // intended for use in the beginning of a &quot;compress commit&quot; which writes</span>
<a href="#l73.554"></a><span id="l73.554">   // all store content, whether dirty or not.  We dirty everything first so</span>
<a href="#l73.555"></a><span id="l73.555">   // that later iterations over content can mark things clean as they are</span>
<a href="#l73.556"></a><span id="l73.556">   // written, and organize the process of serialization so that objects are</span>
<a href="#l73.557"></a><span id="l73.557">   // written only at need (because of being dirty).</span>
<a href="#l73.558"></a><span id="l73.558"> </span>
<a href="#l73.559"></a><span id="l73.559"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l73.560"></a><span id="l73.560">   static void SlotWeakStore(morkStore* me,</span>
<a href="#l73.561"></a><span id="l73.561">     morkEnv* ev, morkStore** ioSlot)</span>
<a href="#l73.562"></a><span id="l73.562">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l73.563"></a><span id="l73.563" class="difflineminus">-  </span>
<a href="#l73.564"></a><span id="l73.564" class="difflineplus">+</span>
<a href="#l73.565"></a><span id="l73.565">   static void SlotStrongStore(morkStore* me,</span>
<a href="#l73.566"></a><span id="l73.566">     morkEnv* ev, morkStore** ioSlot)</span>
<a href="#l73.567"></a><span id="l73.567" class="difflineminus">-  { </span>
<a href="#l73.568"></a><span id="l73.568" class="difflineplus">+  {</span>
<a href="#l73.569"></a><span id="l73.569">     morkStore* store = *ioSlot;</span>
<a href="#l73.570"></a><span id="l73.570">     if ( me != store )</span>
<a href="#l73.571"></a><span id="l73.571">     {</span>
<a href="#l73.572"></a><span id="l73.572">       if ( store )</span>
<a href="#l73.573"></a><span id="l73.573">       {</span>
<a href="#l73.574"></a><span id="l73.574">         // what if this nulls out the ev and causes asserts?</span>
<a href="#l73.575"></a><span id="l73.575">         // can we move this after the CutStrongRef()?</span>
<a href="#l73.576"></a><span id="l73.576">         *ioSlot = 0;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l74.1"></a><span id="l74.1" class="difflineminus">--- a/db/mork/src/morkStream.cpp</span>
<a href="#l74.2"></a><span id="l74.2" class="difflineplus">+++ b/db/mork/src/morkStream.cpp</span>
<a href="#l74.3"></a><span id="l74.3" class="difflineat">@@ -24,17 +24,17 @@</span>
<a href="#l74.4"></a><span id="l74.4"> #endif</span>
<a href="#l74.5"></a><span id="l74.5"> </span>
<a href="#l74.6"></a><span id="l74.6"> #ifndef _MORKSTREAM_</span>
<a href="#l74.7"></a><span id="l74.7"> #include &quot;morkStream.h&quot;</span>
<a href="#l74.8"></a><span id="l74.8"> #endif</span>
<a href="#l74.9"></a><span id="l74.9"> </span>
<a href="#l74.10"></a><span id="l74.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l74.11"></a><span id="l74.11"> </span>
<a href="#l74.12"></a><span id="l74.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l74.13"></a><span id="l74.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l74.14"></a><span id="l74.14"> // { ===== begin morkNode interface =====</span>
<a href="#l74.15"></a><span id="l74.15"> </span>
<a href="#l74.16"></a><span id="l74.16"> /*public virtual*/ void</span>
<a href="#l74.17"></a><span id="l74.17"> morkStream::CloseMorkNode(morkEnv* ev) // CloseStream() only if open</span>
<a href="#l74.18"></a><span id="l74.18"> {</span>
<a href="#l74.19"></a><span id="l74.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l74.20"></a><span id="l74.20">   {</span>
<a href="#l74.21"></a><span id="l74.21">     this-&gt;MarkClosing();</span>
<a href="#l74.22"></a><span id="l74.22" class="difflineat">@@ -68,48 +68,48 @@ morkStream::morkStream(morkEnv* ev, cons</span>
<a href="#l74.23"></a><span id="l74.23"> , mStream_HitEof( morkBool_kFalse )</span>
<a href="#l74.24"></a><span id="l74.24"> {</span>
<a href="#l74.25"></a><span id="l74.25">   if ( ev-&gt;Good() )</span>
<a href="#l74.26"></a><span id="l74.26">   {</span>
<a href="#l74.27"></a><span id="l74.27">     if ( inBufSize &lt; morkStream_kMinBufSize )</span>
<a href="#l74.28"></a><span id="l74.28">       mStream_BufSize = inBufSize = morkStream_kMinBufSize;</span>
<a href="#l74.29"></a><span id="l74.29">     else if ( inBufSize &gt; morkStream_kMaxBufSize )</span>
<a href="#l74.30"></a><span id="l74.30">       mStream_BufSize = inBufSize = morkStream_kMaxBufSize;</span>
<a href="#l74.31"></a><span id="l74.31" class="difflineminus">-    </span>
<a href="#l74.32"></a><span id="l74.32" class="difflineplus">+</span>
<a href="#l74.33"></a><span id="l74.33">     if ( ioContentFile &amp;&amp; ioHeap )</span>
<a href="#l74.34"></a><span id="l74.34">     {</span>
<a href="#l74.35"></a><span id="l74.35">       // if ( ioContentFile-&gt;FileFrozen() ) // forced to be readonly?</span>
<a href="#l74.36"></a><span id="l74.36">       //   inFrozen = morkBool_kTrue; // override the input value</span>
<a href="#l74.37"></a><span id="l74.37" class="difflineminus">-        </span>
<a href="#l74.38"></a><span id="l74.38" class="difflineplus">+</span>
<a href="#l74.39"></a><span id="l74.39">       nsIMdbFile_SlotStrongFile(ioContentFile, ev, &amp;mStream_ContentFile);</span>
<a href="#l74.40"></a><span id="l74.40">       if ( ev-&gt;Good() )</span>
<a href="#l74.41"></a><span id="l74.41">       {</span>
<a href="#l74.42"></a><span id="l74.42">         mork_u1* buf = 0;</span>
<a href="#l74.43"></a><span id="l74.43">         ioHeap-&gt;Alloc(ev-&gt;AsMdbEnv(), inBufSize, (void**) &amp;buf);</span>
<a href="#l74.44"></a><span id="l74.44">         if ( buf )</span>
<a href="#l74.45"></a><span id="l74.45">         {</span>
<a href="#l74.46"></a><span id="l74.46">           mStream_At = mStream_Buf = buf;</span>
<a href="#l74.47"></a><span id="l74.47" class="difflineminus">-          </span>
<a href="#l74.48"></a><span id="l74.48" class="difflineplus">+</span>
<a href="#l74.49"></a><span id="l74.49">           if ( !inFrozen )</span>
<a href="#l74.50"></a><span id="l74.50">           {</span>
<a href="#l74.51"></a><span id="l74.51">             // physical buffer end never moves:</span>
<a href="#l74.52"></a><span id="l74.52">             mStream_WriteEnd = buf + inBufSize;</span>
<a href="#l74.53"></a><span id="l74.53">           }</span>
<a href="#l74.54"></a><span id="l74.54">           else</span>
<a href="#l74.55"></a><span id="l74.55">             mStream_WriteEnd = 0; // no writing is allowed</span>
<a href="#l74.56"></a><span id="l74.56" class="difflineminus">-          </span>
<a href="#l74.57"></a><span id="l74.57" class="difflineplus">+</span>
<a href="#l74.58"></a><span id="l74.58">           if ( inFrozen )</span>
<a href="#l74.59"></a><span id="l74.59">           {</span>
<a href="#l74.60"></a><span id="l74.60">             // logical buffer end starts at Buf with no content:</span>
<a href="#l74.61"></a><span id="l74.61">             mStream_ReadEnd = buf;</span>
<a href="#l74.62"></a><span id="l74.62">             this-&gt;SetFileFrozen(inFrozen);</span>
<a href="#l74.63"></a><span id="l74.63">           }</span>
<a href="#l74.64"></a><span id="l74.64">           else</span>
<a href="#l74.65"></a><span id="l74.65">             mStream_ReadEnd = 0; // no reading is allowed</span>
<a href="#l74.66"></a><span id="l74.66" class="difflineminus">-          </span>
<a href="#l74.67"></a><span id="l74.67" class="difflineplus">+</span>
<a href="#l74.68"></a><span id="l74.68">           this-&gt;SetFileActive(morkBool_kTrue);</span>
<a href="#l74.69"></a><span id="l74.69">           this-&gt;SetFileIoOpen(morkBool_kTrue);</span>
<a href="#l74.70"></a><span id="l74.70">         }</span>
<a href="#l74.71"></a><span id="l74.71">         if ( ev-&gt;Good() )</span>
<a href="#l74.72"></a><span id="l74.72">           mNode_Derived = morkDerived_kStream;</span>
<a href="#l74.73"></a><span id="l74.73">       }</span>
<a href="#l74.74"></a><span id="l74.74">     }</span>
<a href="#l74.75"></a><span id="l74.75">     else ev-&gt;NilPointerError();</span>
<a href="#l74.76"></a><span id="l74.76" class="difflineat">@@ -120,37 +120,37 @@ morkStream::morkStream(morkEnv* ev, cons</span>
<a href="#l74.77"></a><span id="l74.77"> morkStream::CloseStream(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l74.78"></a><span id="l74.78"> {</span>
<a href="#l74.79"></a><span id="l74.79">     if ( this-&gt;IsNode() )</span>
<a href="#l74.80"></a><span id="l74.80">     {</span>
<a href="#l74.81"></a><span id="l74.81">       nsIMdbFile_SlotStrongFile((nsIMdbFile*) 0, ev, &amp;mStream_ContentFile);</span>
<a href="#l74.82"></a><span id="l74.82">       nsIMdbHeap* heap = mFile_SlotHeap;</span>
<a href="#l74.83"></a><span id="l74.83">       mork_u1* buf = mStream_Buf;</span>
<a href="#l74.84"></a><span id="l74.84">       mStream_Buf = 0;</span>
<a href="#l74.85"></a><span id="l74.85" class="difflineminus">-      </span>
<a href="#l74.86"></a><span id="l74.86" class="difflineplus">+</span>
<a href="#l74.87"></a><span id="l74.87">       if ( heap &amp;&amp; buf )</span>
<a href="#l74.88"></a><span id="l74.88">         heap-&gt;Free(ev-&gt;AsMdbEnv(), buf);</span>
<a href="#l74.89"></a><span id="l74.89"> </span>
<a href="#l74.90"></a><span id="l74.90">       this-&gt;CloseFile(ev);</span>
<a href="#l74.91"></a><span id="l74.91">       this-&gt;MarkShut();</span>
<a href="#l74.92"></a><span id="l74.92">     }</span>
<a href="#l74.93"></a><span id="l74.93">     else</span>
<a href="#l74.94"></a><span id="l74.94">       this-&gt;NonNodeError(ev);</span>
<a href="#l74.95"></a><span id="l74.95"> }</span>
<a href="#l74.96"></a><span id="l74.96"> </span>
<a href="#l74.97"></a><span id="l74.97"> // } ===== end morkNode methods =====</span>
<a href="#l74.98"></a><span id="l74.98" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l74.99"></a><span id="l74.99" class="difflineminus">-  </span>
<a href="#l74.100"></a><span id="l74.100" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l74.101"></a><span id="l74.101" class="difflineplus">+</span>
<a href="#l74.102"></a><span id="l74.102"> #define morkStream_kSpacesPerIndent 1 /* one space per indent */</span>
<a href="#l74.103"></a><span id="l74.103"> #define morkStream_kMaxIndentDepth 70 /* max indent of 70 space bytes */</span>
<a href="#l74.104"></a><span id="l74.104"> static const char morkStream_kSpaces[] // next line to ease length perception</span>
<a href="#l74.105"></a><span id="l74.105"> = &quot;                                                                        &quot;;</span>
<a href="#l74.106"></a><span id="l74.106"> // 123456789_123456789_123456789_123456789_123456789_123456789_123456789_</span>
<a href="#l74.107"></a><span id="l74.107"> // morkStream_kSpaces above must contain (at least) 70 spaces (ASCII 0x20)</span>
<a href="#l74.108"></a><span id="l74.108" class="difflineminus">- </span>
<a href="#l74.109"></a><span id="l74.109" class="difflineplus">+</span>
<a href="#l74.110"></a><span id="l74.110"> mork_size</span>
<a href="#l74.111"></a><span id="l74.111"> morkStream::PutIndent(morkEnv* ev, mork_count inDepth)</span>
<a href="#l74.112"></a><span id="l74.112">   // PutIndent() puts a linebreak, and then</span>
<a href="#l74.113"></a><span id="l74.113">   // &quot;indents&quot; by inDepth, and returns the line length after indentation.</span>
<a href="#l74.114"></a><span id="l74.114"> {</span>
<a href="#l74.115"></a><span id="l74.115">   mork_size outLength = 0;</span>
<a href="#l74.116"></a><span id="l74.116">   nsIMdbEnv *mev = ev-&gt;AsMdbEnv();</span>
<a href="#l74.117"></a><span id="l74.117">   if ( ev-&gt;Good() )</span>
<a href="#l74.118"></a><span id="l74.118" class="difflineat">@@ -169,55 +169,55 @@ morkStream::PutIndent(morkEnv* ev, mork_</span>
<a href="#l74.119"></a><span id="l74.119"> </span>
<a href="#l74.120"></a><span id="l74.120"> mork_size</span>
<a href="#l74.121"></a><span id="l74.121"> morkStream::PutByteThenIndent(morkEnv* ev, int inByte, mork_count inDepth)</span>
<a href="#l74.122"></a><span id="l74.122">   // PutByteThenIndent() puts the byte, then a linebreak, and then</span>
<a href="#l74.123"></a><span id="l74.123">   // &quot;indents&quot; by inDepth, and returns the line length after indentation.</span>
<a href="#l74.124"></a><span id="l74.124"> {</span>
<a href="#l74.125"></a><span id="l74.125">   mork_size outLength = 0;</span>
<a href="#l74.126"></a><span id="l74.126">   nsIMdbEnv *mev = ev-&gt;AsMdbEnv();</span>
<a href="#l74.127"></a><span id="l74.127" class="difflineminus">-  </span>
<a href="#l74.128"></a><span id="l74.128" class="difflineplus">+</span>
<a href="#l74.129"></a><span id="l74.129">   if ( inDepth &gt; morkStream_kMaxIndentDepth )</span>
<a href="#l74.130"></a><span id="l74.130">     inDepth = morkStream_kMaxIndentDepth;</span>
<a href="#l74.131"></a><span id="l74.131" class="difflineminus">-  </span>
<a href="#l74.132"></a><span id="l74.132" class="difflineplus">+</span>
<a href="#l74.133"></a><span id="l74.133">   this-&gt;Putc(ev, inByte);</span>
<a href="#l74.134"></a><span id="l74.134">   if ( ev-&gt;Good() )</span>
<a href="#l74.135"></a><span id="l74.135">   {</span>
<a href="#l74.136"></a><span id="l74.136">     this-&gt;PutLineBreak(ev);</span>
<a href="#l74.137"></a><span id="l74.137">     if ( ev-&gt;Good() )</span>
<a href="#l74.138"></a><span id="l74.138">     {</span>
<a href="#l74.139"></a><span id="l74.139">       outLength = inDepth;</span>
<a href="#l74.140"></a><span id="l74.140">       mdb_size bytesWritten;</span>
<a href="#l74.141"></a><span id="l74.141">       if ( inDepth )</span>
<a href="#l74.142"></a><span id="l74.142">         this-&gt;Write(mev, morkStream_kSpaces, inDepth, &amp;bytesWritten);</span>
<a href="#l74.143"></a><span id="l74.143">     }</span>
<a href="#l74.144"></a><span id="l74.144">   }</span>
<a href="#l74.145"></a><span id="l74.145">   return outLength;</span>
<a href="#l74.146"></a><span id="l74.146"> }</span>
<a href="#l74.147"></a><span id="l74.147" class="difflineminus">-  </span>
<a href="#l74.148"></a><span id="l74.148" class="difflineplus">+</span>
<a href="#l74.149"></a><span id="l74.149"> mork_size</span>
<a href="#l74.150"></a><span id="l74.150"> morkStream::PutStringThenIndent(morkEnv* ev,</span>
<a href="#l74.151"></a><span id="l74.151">   const char* inString, mork_count inDepth)</span>
<a href="#l74.152"></a><span id="l74.152"> // PutStringThenIndent() puts the string, then a linebreak, and then</span>
<a href="#l74.153"></a><span id="l74.153"> // &quot;indents&quot; by inDepth, and returns the line length after indentation.</span>
<a href="#l74.154"></a><span id="l74.154"> {</span>
<a href="#l74.155"></a><span id="l74.155">   mork_size outLength = 0;</span>
<a href="#l74.156"></a><span id="l74.156">   mdb_size bytesWritten;</span>
<a href="#l74.157"></a><span id="l74.157">   nsIMdbEnv *mev = ev-&gt;AsMdbEnv();</span>
<a href="#l74.158"></a><span id="l74.158" class="difflineminus">-  </span>
<a href="#l74.159"></a><span id="l74.159" class="difflineplus">+</span>
<a href="#l74.160"></a><span id="l74.160">   if ( inDepth &gt; morkStream_kMaxIndentDepth )</span>
<a href="#l74.161"></a><span id="l74.161">     inDepth = morkStream_kMaxIndentDepth;</span>
<a href="#l74.162"></a><span id="l74.162" class="difflineminus">-  </span>
<a href="#l74.163"></a><span id="l74.163" class="difflineplus">+</span>
<a href="#l74.164"></a><span id="l74.164">   if ( inString )</span>
<a href="#l74.165"></a><span id="l74.165">   {</span>
<a href="#l74.166"></a><span id="l74.166">     mork_size length = strlen(inString);</span>
<a href="#l74.167"></a><span id="l74.167">     if ( length &amp;&amp; ev-&gt;Good() ) // any bytes to write?</span>
<a href="#l74.168"></a><span id="l74.168">       this-&gt;Write(mev, inString, length, &amp;bytesWritten);</span>
<a href="#l74.169"></a><span id="l74.169">   }</span>
<a href="#l74.170"></a><span id="l74.170" class="difflineminus">-  </span>
<a href="#l74.171"></a><span id="l74.171" class="difflineplus">+</span>
<a href="#l74.172"></a><span id="l74.172">   if ( ev-&gt;Good() )</span>
<a href="#l74.173"></a><span id="l74.173">   {</span>
<a href="#l74.174"></a><span id="l74.174">     this-&gt;PutLineBreak(ev);</span>
<a href="#l74.175"></a><span id="l74.175">     if ( ev-&gt;Good() )</span>
<a href="#l74.176"></a><span id="l74.176">     {</span>
<a href="#l74.177"></a><span id="l74.177">       outLength = inDepth;</span>
<a href="#l74.178"></a><span id="l74.178">       if ( inDepth )</span>
<a href="#l74.179"></a><span id="l74.179">         this-&gt;Write(mev, morkStream_kSpaces, inDepth, &amp;bytesWritten);</span>
<a href="#l74.180"></a><span id="l74.180" class="difflineat">@@ -276,35 +276,35 @@ morkStream::PutByteThenNewline(morkEnv* </span>
<a href="#l74.181"></a><span id="l74.181"> </span>
<a href="#l74.182"></a><span id="l74.182"> mork_size</span>
<a href="#l74.183"></a><span id="l74.183"> morkStream::PutLineBreak(morkEnv* ev)</span>
<a href="#l74.184"></a><span id="l74.184"> {</span>
<a href="#l74.185"></a><span id="l74.185"> #if defined(MORK_MAC)</span>
<a href="#l74.186"></a><span id="l74.186"> </span>
<a href="#l74.187"></a><span id="l74.187">   this-&gt;Putc(ev, mork_kCR);</span>
<a href="#l74.188"></a><span id="l74.188">   return 1;</span>
<a href="#l74.189"></a><span id="l74.189" class="difflineminus">-  </span>
<a href="#l74.190"></a><span id="l74.190" class="difflineplus">+</span>
<a href="#l74.191"></a><span id="l74.191"> #else</span>
<a href="#l74.192"></a><span id="l74.192"> #  if defined(MORK_WIN)</span>
<a href="#l74.193"></a><span id="l74.193" class="difflineminus">-  </span>
<a href="#l74.194"></a><span id="l74.194" class="difflineplus">+</span>
<a href="#l74.195"></a><span id="l74.195">   this-&gt;Putc(ev, mork_kCR);</span>
<a href="#l74.196"></a><span id="l74.196">   this-&gt;Putc(ev, mork_kLF);</span>
<a href="#l74.197"></a><span id="l74.197">   return 2;</span>
<a href="#l74.198"></a><span id="l74.198" class="difflineminus">-  </span>
<a href="#l74.199"></a><span id="l74.199" class="difflineplus">+</span>
<a href="#l74.200"></a><span id="l74.200"> #  else</span>
<a href="#l74.201"></a><span id="l74.201"> #    ifdef MORK_UNIX</span>
<a href="#l74.202"></a><span id="l74.202" class="difflineminus">-  </span>
<a href="#l74.203"></a><span id="l74.203" class="difflineplus">+</span>
<a href="#l74.204"></a><span id="l74.204">   this-&gt;Putc(ev, mork_kLF);</span>
<a href="#l74.205"></a><span id="l74.205">   return 1;</span>
<a href="#l74.206"></a><span id="l74.206" class="difflineminus">-  </span>
<a href="#l74.207"></a><span id="l74.207" class="difflineplus">+</span>
<a href="#l74.208"></a><span id="l74.208"> #    endif /* MORK_UNIX */</span>
<a href="#l74.209"></a><span id="l74.209"> #  endif /* MORK_WIN */</span>
<a href="#l74.210"></a><span id="l74.210"> #endif /* MORK_MAC */</span>
<a href="#l74.211"></a><span id="l74.211"> }</span>
<a href="#l74.212"></a><span id="l74.212" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l74.213"></a><span id="l74.213" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l74.214"></a><span id="l74.214"> // public: // virtual morkFile methods</span>
<a href="#l74.215"></a><span id="l74.215"> </span>
<a href="#l74.216"></a><span id="l74.216"> </span>
<a href="#l74.217"></a><span id="l74.217"> NS_IMETHODIMP</span>
<a href="#l74.218"></a><span id="l74.218"> morkStream::Steal(nsIMdbEnv* mev, nsIMdbFile* ioThief)</span>
<a href="#l74.219"></a><span id="l74.219">   // Steal: tell this file to close any associated i/o stream in the file</span>
<a href="#l74.220"></a><span id="l74.220">   // system, because the file ioThief intends to reopen the file in order</span>
<a href="#l74.221"></a><span id="l74.221">   // to provide the MDB implementation with more exotic file access than is</span>
<a href="#l74.222"></a><span id="l74.222" class="difflineat">@@ -354,22 +354,22 @@ morkStream::AcquireBud(nsIMdbEnv* mev, n</span>
<a href="#l74.223"></a><span id="l74.223">   nsIMdbFile* file = mStream_ContentFile;</span>
<a href="#l74.224"></a><span id="l74.224">   morkEnv *ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l74.225"></a><span id="l74.225">   if ( this-&gt;IsOpenAndActiveFile() &amp;&amp; file )</span>
<a href="#l74.226"></a><span id="l74.226">   {</span>
<a href="#l74.227"></a><span id="l74.227">     // figure out how this interacts with buffering and mStream_WriteEnd:</span>
<a href="#l74.228"></a><span id="l74.228">     ev-&gt;StubMethodOnlyError();</span>
<a href="#l74.229"></a><span id="l74.229">   }</span>
<a href="#l74.230"></a><span id="l74.230">   else this-&gt;NewFileDownError(ev);</span>
<a href="#l74.231"></a><span id="l74.231" class="difflineminus">-  </span>
<a href="#l74.232"></a><span id="l74.232" class="difflineplus">+</span>
<a href="#l74.233"></a><span id="l74.233">   *acqBud = outFile;</span>
<a href="#l74.234"></a><span id="l74.234">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l74.235"></a><span id="l74.235"> }</span>
<a href="#l74.236"></a><span id="l74.236"> </span>
<a href="#l74.237"></a><span id="l74.237" class="difflineminus">-mork_pos </span>
<a href="#l74.238"></a><span id="l74.238" class="difflineplus">+mork_pos</span>
<a href="#l74.239"></a><span id="l74.239"> morkStream::Length(morkEnv* ev) const // eof</span>
<a href="#l74.240"></a><span id="l74.240"> {</span>
<a href="#l74.241"></a><span id="l74.241">   mork_pos outPos = 0;</span>
<a href="#l74.242"></a><span id="l74.242"> </span>
<a href="#l74.243"></a><span id="l74.243">   nsIMdbFile* file = mStream_ContentFile;</span>
<a href="#l74.244"></a><span id="l74.244">   if ( this-&gt;IsOpenAndActiveFile() &amp;&amp; file )</span>
<a href="#l74.245"></a><span id="l74.245">   {</span>
<a href="#l74.246"></a><span id="l74.246">     mork_pos contentEof = 0;</span>
<a href="#l74.247"></a><span id="l74.247" class="difflineat">@@ -416,56 +416,56 @@ void morkStream::NewCantWriteSourceError</span>
<a href="#l74.248"></a><span id="l74.248"> { ev-&gt;NewError(&quot;cant write stream source&quot;); }</span>
<a href="#l74.249"></a><span id="l74.249"> </span>
<a href="#l74.250"></a><span id="l74.250"> void morkStream::NewPosBeyondEofError(morkEnv* ev) const</span>
<a href="#l74.251"></a><span id="l74.251"> { ev-&gt;NewError(&quot;stream pos beyond eof&quot;); }</span>
<a href="#l74.252"></a><span id="l74.252"> </span>
<a href="#l74.253"></a><span id="l74.253"> void morkStream::NewBadCursorOrderError(morkEnv* ev) const</span>
<a href="#l74.254"></a><span id="l74.254"> { ev-&gt;NewError(&quot;bad stream cursor order&quot;); }</span>
<a href="#l74.255"></a><span id="l74.255"> </span>
<a href="#l74.256"></a><span id="l74.256" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l74.257"></a><span id="l74.257" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l74.258"></a><span id="l74.258"> morkStream::Tell(nsIMdbEnv* mdbev, mork_pos *aOutPos) const</span>
<a href="#l74.259"></a><span id="l74.259"> {</span>
<a href="#l74.260"></a><span id="l74.260">   nsresult rv = NS_OK;</span>
<a href="#l74.261"></a><span id="l74.261">   morkEnv *ev = morkEnv::FromMdbEnv(mdbev);</span>
<a href="#l74.262"></a><span id="l74.262"> </span>
<a href="#l74.263"></a><span id="l74.263">   NS_ENSURE_ARG_POINTER(aOutPos);</span>
<a href="#l74.264"></a><span id="l74.264" class="difflineminus">-  </span>
<a href="#l74.265"></a><span id="l74.265" class="difflineplus">+</span>
<a href="#l74.266"></a><span id="l74.266">   nsIMdbFile* file = mStream_ContentFile;</span>
<a href="#l74.267"></a><span id="l74.267">   if ( this-&gt;IsOpenAndActiveFile() &amp;&amp; file )</span>
<a href="#l74.268"></a><span id="l74.268">   {</span>
<a href="#l74.269"></a><span id="l74.269">     mork_u1* buf = mStream_Buf;</span>
<a href="#l74.270"></a><span id="l74.270">     mork_u1* at = mStream_At;</span>
<a href="#l74.271"></a><span id="l74.271" class="difflineminus">-    </span>
<a href="#l74.272"></a><span id="l74.272" class="difflineplus">+</span>
<a href="#l74.273"></a><span id="l74.273">     mork_u1* readEnd = mStream_ReadEnd;   // nonzero only if readonly</span>
<a href="#l74.274"></a><span id="l74.274">     mork_u1* writeEnd = mStream_WriteEnd; // nonzero only if writeonly</span>
<a href="#l74.275"></a><span id="l74.275" class="difflineminus">-    </span>
<a href="#l74.276"></a><span id="l74.276" class="difflineplus">+</span>
<a href="#l74.277"></a><span id="l74.277">     if ( writeEnd )</span>
<a href="#l74.278"></a><span id="l74.278">     {</span>
<a href="#l74.279"></a><span id="l74.279" class="difflineminus">-      if ( buf &amp;&amp; at &gt;= buf &amp;&amp; at &lt;= writeEnd ) </span>
<a href="#l74.280"></a><span id="l74.280" class="difflineplus">+      if ( buf &amp;&amp; at &gt;= buf &amp;&amp; at &lt;= writeEnd )</span>
<a href="#l74.281"></a><span id="l74.281">       {</span>
<a href="#l74.282"></a><span id="l74.282">         *aOutPos = mStream_BufPos + (at - buf);</span>
<a href="#l74.283"></a><span id="l74.283">       }</span>
<a href="#l74.284"></a><span id="l74.284">       else this-&gt;NewBadCursorOrderError(ev);</span>
<a href="#l74.285"></a><span id="l74.285">     }</span>
<a href="#l74.286"></a><span id="l74.286">     else if ( readEnd )</span>
<a href="#l74.287"></a><span id="l74.287">     {</span>
<a href="#l74.288"></a><span id="l74.288" class="difflineminus">-      if ( buf &amp;&amp; at &gt;= buf &amp;&amp; at &lt;= readEnd ) </span>
<a href="#l74.289"></a><span id="l74.289" class="difflineplus">+      if ( buf &amp;&amp; at &gt;= buf &amp;&amp; at &lt;= readEnd )</span>
<a href="#l74.290"></a><span id="l74.290">       {</span>
<a href="#l74.291"></a><span id="l74.291">         *aOutPos = mStream_BufPos + (at - buf);</span>
<a href="#l74.292"></a><span id="l74.292">       }</span>
<a href="#l74.293"></a><span id="l74.293">       else this-&gt;NewBadCursorOrderError(ev);</span>
<a href="#l74.294"></a><span id="l74.294">     }</span>
<a href="#l74.295"></a><span id="l74.295">   }</span>
<a href="#l74.296"></a><span id="l74.296">   else this-&gt;NewFileDownError(ev);</span>
<a href="#l74.297"></a><span id="l74.297"> </span>
<a href="#l74.298"></a><span id="l74.298">   return rv;</span>
<a href="#l74.299"></a><span id="l74.299"> }</span>
<a href="#l74.300"></a><span id="l74.300"> </span>
<a href="#l74.301"></a><span id="l74.301" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l74.302"></a><span id="l74.302" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l74.303"></a><span id="l74.303"> morkStream::Read(nsIMdbEnv* mdbev, void* outBuf, mork_size inSize, mork_size *aOutSize)</span>
<a href="#l74.304"></a><span id="l74.304"> {</span>
<a href="#l74.305"></a><span id="l74.305">   NS_ENSURE_ARG_POINTER(aOutSize);</span>
<a href="#l74.306"></a><span id="l74.306">   // First we satisfy the request from buffered bytes, if any.  Then</span>
<a href="#l74.307"></a><span id="l74.307">   // if additional bytes are needed, we satisfy these by direct reads</span>
<a href="#l74.308"></a><span id="l74.308">   // from the content file without any local buffering (but we still need</span>
<a href="#l74.309"></a><span id="l74.309">   // to adjust the buffer position to reflect the current i/o point).</span>
<a href="#l74.310"></a><span id="l74.310"> </span>
<a href="#l74.311"></a><span id="l74.311" class="difflineat">@@ -483,51 +483,51 @@ morkStream::Read(nsIMdbEnv* mdbev, void*</span>
<a href="#l74.312"></a><span id="l74.312">         mork_u1* sink = (mork_u1*) outBuf; // where we plan to write bytes</span>
<a href="#l74.313"></a><span id="l74.313">         if ( sink ) // caller passed good buffer address?</span>
<a href="#l74.314"></a><span id="l74.314">         {</span>
<a href="#l74.315"></a><span id="l74.315">           mork_u1* at = mStream_At;</span>
<a href="#l74.316"></a><span id="l74.316">           mork_u1* buf = mStream_Buf;</span>
<a href="#l74.317"></a><span id="l74.317">           if ( at &gt;= buf &amp;&amp; at &lt;= end ) // expected cursor order?</span>
<a href="#l74.318"></a><span id="l74.318">           {</span>
<a href="#l74.319"></a><span id="l74.319">             mork_num remaining = (mork_num) (end - at); // bytes left in buffer</span>
<a href="#l74.320"></a><span id="l74.320" class="difflineminus">-            </span>
<a href="#l74.321"></a><span id="l74.321" class="difflineplus">+</span>
<a href="#l74.322"></a><span id="l74.322">             mork_num quantum = inSize; // number of bytes to copy</span>
<a href="#l74.323"></a><span id="l74.323">             if ( quantum &gt; remaining ) // more than buffer content?</span>
<a href="#l74.324"></a><span id="l74.324">               quantum = remaining; // restrict to buffered bytes</span>
<a href="#l74.325"></a><span id="l74.325" class="difflineminus">-              </span>
<a href="#l74.326"></a><span id="l74.326" class="difflineplus">+</span>
<a href="#l74.327"></a><span id="l74.327">             if ( quantum ) // any bytes left in the buffer?</span>
<a href="#l74.328"></a><span id="l74.328">             {</span>
<a href="#l74.329"></a><span id="l74.329">               MORK_MEMCPY(sink, at, quantum); // from buffer bytes</span>
<a href="#l74.330"></a><span id="l74.330" class="difflineminus">-              </span>
<a href="#l74.331"></a><span id="l74.331" class="difflineplus">+</span>
<a href="#l74.332"></a><span id="l74.332">               at += quantum; // advance past read bytes</span>
<a href="#l74.333"></a><span id="l74.333">               mStream_At = at;</span>
<a href="#l74.334"></a><span id="l74.334">               *aOutSize += quantum;  // this much copied so far</span>
<a href="#l74.335"></a><span id="l74.335"> </span>
<a href="#l74.336"></a><span id="l74.336">               sink += quantum;   // in case we need to copy more</span>
<a href="#l74.337"></a><span id="l74.337">               inSize -= quantum; // filled this much of request</span>
<a href="#l74.338"></a><span id="l74.338">               mStream_HitEof = morkBool_kFalse;</span>
<a href="#l74.339"></a><span id="l74.339">             }</span>
<a href="#l74.340"></a><span id="l74.340" class="difflineminus">-            </span>
<a href="#l74.341"></a><span id="l74.341" class="difflineplus">+</span>
<a href="#l74.342"></a><span id="l74.342">             if ( inSize ) // we still need to read more content?</span>
<a href="#l74.343"></a><span id="l74.343">             {</span>
<a href="#l74.344"></a><span id="l74.344">               // We need to read more bytes directly from the</span>
<a href="#l74.345"></a><span id="l74.345">               // content file, without local buffering.  We have</span>
<a href="#l74.346"></a><span id="l74.346">               // exhausted the local buffer, so we need to show</span>
<a href="#l74.347"></a><span id="l74.347">               // it is now empty, and adjust the current buf pos.</span>
<a href="#l74.348"></a><span id="l74.348" class="difflineminus">-              </span>
<a href="#l74.349"></a><span id="l74.349" class="difflineplus">+</span>
<a href="#l74.350"></a><span id="l74.350">               mork_num posDelta = (mork_num) (at - buf); // old buf content</span>
<a href="#l74.351"></a><span id="l74.351">               mStream_BufPos += posDelta;   // past now empty buf</span>
<a href="#l74.352"></a><span id="l74.352" class="difflineminus">-              </span>
<a href="#l74.353"></a><span id="l74.353" class="difflineplus">+</span>
<a href="#l74.354"></a><span id="l74.354">               mStream_At = mStream_ReadEnd = buf; // empty buffer</span>
<a href="#l74.355"></a><span id="l74.355" class="difflineminus">-              </span>
<a href="#l74.356"></a><span id="l74.356" class="difflineplus">+</span>
<a href="#l74.357"></a><span id="l74.357">               // file-&gt;Seek(ev, mStream_BufPos); // set file pos</span>
<a href="#l74.358"></a><span id="l74.358">               // if ( ev-&gt;Good() ) // no seek error?</span>
<a href="#l74.359"></a><span id="l74.359">               // {</span>
<a href="#l74.360"></a><span id="l74.360">               // }</span>
<a href="#l74.361"></a><span id="l74.361" class="difflineminus">-              </span>
<a href="#l74.362"></a><span id="l74.362" class="difflineplus">+</span>
<a href="#l74.363"></a><span id="l74.363">               mork_num actual = 0;</span>
<a href="#l74.364"></a><span id="l74.364">               nsIMdbEnv* menv = ev-&gt;AsMdbEnv();</span>
<a href="#l74.365"></a><span id="l74.365">               file-&gt;Get(menv, sink, inSize, mStream_BufPos, &amp;actual);</span>
<a href="#l74.366"></a><span id="l74.366">               if ( ev-&gt;Good() ) // no read error?</span>
<a href="#l74.367"></a><span id="l74.367">               {</span>
<a href="#l74.368"></a><span id="l74.368">                 if ( actual )</span>
<a href="#l74.369"></a><span id="l74.369">                 {</span>
<a href="#l74.370"></a><span id="l74.370">                   *aOutSize += actual;</span>
<a href="#l74.371"></a><span id="l74.371" class="difflineat">@@ -542,38 +542,38 @@ morkStream::Read(nsIMdbEnv* mdbev, void*</span>
<a href="#l74.372"></a><span id="l74.372">           else this-&gt;NewBadCursorOrderError(ev);</span>
<a href="#l74.373"></a><span id="l74.373">         }</span>
<a href="#l74.374"></a><span id="l74.374">         else this-&gt;NewNullStreamBufferError(ev);</span>
<a href="#l74.375"></a><span id="l74.375">       }</span>
<a href="#l74.376"></a><span id="l74.376">     }</span>
<a href="#l74.377"></a><span id="l74.377">     else this-&gt;NewCantReadSinkError(ev);</span>
<a href="#l74.378"></a><span id="l74.378">   }</span>
<a href="#l74.379"></a><span id="l74.379">   else this-&gt;NewFileDownError(ev);</span>
<a href="#l74.380"></a><span id="l74.380" class="difflineminus">-  </span>
<a href="#l74.381"></a><span id="l74.381" class="difflineplus">+</span>
<a href="#l74.382"></a><span id="l74.382">   if ( ev-&gt;Bad() )</span>
<a href="#l74.383"></a><span id="l74.383">     *aOutSize = 0;</span>
<a href="#l74.384"></a><span id="l74.384"> </span>
<a href="#l74.385"></a><span id="l74.385">   return rv;</span>
<a href="#l74.386"></a><span id="l74.386"> }</span>
<a href="#l74.387"></a><span id="l74.387"> </span>
<a href="#l74.388"></a><span id="l74.388" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l74.389"></a><span id="l74.389" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l74.390"></a><span id="l74.390"> morkStream::Seek(nsIMdbEnv * mdbev, mork_pos inPos, mork_pos *aOutPos)</span>
<a href="#l74.391"></a><span id="l74.391"> {</span>
<a href="#l74.392"></a><span id="l74.392">   NS_ENSURE_ARG_POINTER(aOutPos);</span>
<a href="#l74.393"></a><span id="l74.393">   morkEnv *ev = morkEnv::FromMdbEnv(mdbev);</span>
<a href="#l74.394"></a><span id="l74.394">   *aOutPos = 0;</span>
<a href="#l74.395"></a><span id="l74.395">   nsresult rv = NS_OK;</span>
<a href="#l74.396"></a><span id="l74.396">   nsIMdbFile* file = mStream_ContentFile;</span>
<a href="#l74.397"></a><span id="l74.397">   if ( this-&gt;IsOpenOrClosingNode() &amp;&amp; this-&gt;FileActive() &amp;&amp; file )</span>
<a href="#l74.398"></a><span id="l74.398">   {</span>
<a href="#l74.399"></a><span id="l74.399">     mork_u1* at = mStream_At;             // current position in buffer</span>
<a href="#l74.400"></a><span id="l74.400" class="difflineminus">-    mork_u1* buf = mStream_Buf;           // beginning of buffer </span>
<a href="#l74.401"></a><span id="l74.401" class="difflineplus">+    mork_u1* buf = mStream_Buf;           // beginning of buffer</span>
<a href="#l74.402"></a><span id="l74.402">     mork_u1* readEnd = mStream_ReadEnd;   // nonzero only if readonly</span>
<a href="#l74.403"></a><span id="l74.403">     mork_u1* writeEnd = mStream_WriteEnd; // nonzero only if writeonly</span>
<a href="#l74.404"></a><span id="l74.404" class="difflineminus">-    </span>
<a href="#l74.405"></a><span id="l74.405" class="difflineplus">+</span>
<a href="#l74.406"></a><span id="l74.406">     if ( writeEnd ) // file is mutable/writeonly?</span>
<a href="#l74.407"></a><span id="l74.407">     {</span>
<a href="#l74.408"></a><span id="l74.408">       if ( mStream_Dirty ) // need to commit buffer changes?</span>
<a href="#l74.409"></a><span id="l74.409">         this-&gt;Flush(mdbev);</span>
<a href="#l74.410"></a><span id="l74.410"> </span>
<a href="#l74.411"></a><span id="l74.411">       if ( ev-&gt;Good() ) // no errors during flush or earlier?</span>
<a href="#l74.412"></a><span id="l74.412">       {</span>
<a href="#l74.413"></a><span id="l74.413">         if ( at == buf ) // expected post flush cursor value?</span>
<a href="#l74.414"></a><span id="l74.414" class="difflineat">@@ -614,24 +614,24 @@ morkStream::Seek(nsIMdbEnv * mdbev, mork</span>
<a href="#l74.415"></a><span id="l74.415">             if ( inPos == eof ) // notice eof reached?</span>
<a href="#l74.416"></a><span id="l74.416">               mStream_HitEof = morkBool_kTrue;</span>
<a href="#l74.417"></a><span id="l74.417">           }</span>
<a href="#l74.418"></a><span id="l74.418">           else this-&gt;NewPosBeyondEofError(ev);</span>
<a href="#l74.419"></a><span id="l74.419">         }</span>
<a href="#l74.420"></a><span id="l74.420">       }</span>
<a href="#l74.421"></a><span id="l74.421">       else this-&gt;NewBadCursorOrderError(ev);</span>
<a href="#l74.422"></a><span id="l74.422">     }</span>
<a href="#l74.423"></a><span id="l74.423" class="difflineminus">-      </span>
<a href="#l74.424"></a><span id="l74.424" class="difflineplus">+</span>
<a href="#l74.425"></a><span id="l74.425">   }</span>
<a href="#l74.426"></a><span id="l74.426">   else this-&gt;NewFileDownError(ev);</span>
<a href="#l74.427"></a><span id="l74.427"> </span>
<a href="#l74.428"></a><span id="l74.428">   return rv;</span>
<a href="#l74.429"></a><span id="l74.429"> }</span>
<a href="#l74.430"></a><span id="l74.430"> </span>
<a href="#l74.431"></a><span id="l74.431" class="difflineminus">-NS_IMETHODIMP </span>
<a href="#l74.432"></a><span id="l74.432" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l74.433"></a><span id="l74.433"> morkStream::Write(nsIMdbEnv* menv, const void* inBuf, mork_size inSize, mork_size  *aOutSize)</span>
<a href="#l74.434"></a><span id="l74.434"> {</span>
<a href="#l74.435"></a><span id="l74.435">   mork_num outActual = 0;</span>
<a href="#l74.436"></a><span id="l74.436">   morkEnv *ev = morkEnv::FromMdbEnv(menv);</span>
<a href="#l74.437"></a><span id="l74.437"> </span>
<a href="#l74.438"></a><span id="l74.438">   nsIMdbFile* file = mStream_ContentFile;</span>
<a href="#l74.439"></a><span id="l74.439">   if ( this-&gt;IsOpenActiveAndMutableFile() &amp;&amp; file )</span>
<a href="#l74.440"></a><span id="l74.440">   {</span>
<a href="#l74.441"></a><span id="l74.441" class="difflineat">@@ -643,58 +643,58 @@ morkStream::Write(nsIMdbEnv* menv, const</span>
<a href="#l74.442"></a><span id="l74.442">         const mork_u1* source = (const mork_u1*) inBuf; // from where</span>
<a href="#l74.443"></a><span id="l74.443">         if ( source ) // caller passed good buffer address?</span>
<a href="#l74.444"></a><span id="l74.444">         {</span>
<a href="#l74.445"></a><span id="l74.445">           mork_u1* at = mStream_At;</span>
<a href="#l74.446"></a><span id="l74.446">           mork_u1* buf = mStream_Buf;</span>
<a href="#l74.447"></a><span id="l74.447">           if ( at &gt;= buf &amp;&amp; at &lt;= end ) // expected cursor order?</span>
<a href="#l74.448"></a><span id="l74.448">           {</span>
<a href="#l74.449"></a><span id="l74.449">             mork_num space = (mork_num) (end - at); // space left in buffer</span>
<a href="#l74.450"></a><span id="l74.450" class="difflineminus">-            </span>
<a href="#l74.451"></a><span id="l74.451" class="difflineplus">+</span>
<a href="#l74.452"></a><span id="l74.452">             mork_num quantum = inSize; // number of bytes to write</span>
<a href="#l74.453"></a><span id="l74.453">             if ( quantum &gt; space ) // more than buffer size?</span>
<a href="#l74.454"></a><span id="l74.454">               quantum = space; // restrict to avail space</span>
<a href="#l74.455"></a><span id="l74.455" class="difflineminus">-              </span>
<a href="#l74.456"></a><span id="l74.456" class="difflineplus">+</span>
<a href="#l74.457"></a><span id="l74.457">             if ( quantum ) // any space left in the buffer?</span>
<a href="#l74.458"></a><span id="l74.458">             {</span>
<a href="#l74.459"></a><span id="l74.459">               mStream_Dirty = morkBool_kTrue; // to ensure later flush</span>
<a href="#l74.460"></a><span id="l74.460">               MORK_MEMCPY(at, source, quantum); // into buffer</span>
<a href="#l74.461"></a><span id="l74.461" class="difflineminus">-              </span>
<a href="#l74.462"></a><span id="l74.462" class="difflineplus">+</span>
<a href="#l74.463"></a><span id="l74.463">               mStream_At += quantum; // advance past written bytes</span>
<a href="#l74.464"></a><span id="l74.464">               outActual += quantum;  // this much written so far</span>
<a href="#l74.465"></a><span id="l74.465"> </span>
<a href="#l74.466"></a><span id="l74.466">               source += quantum; // in case we need to write more</span>
<a href="#l74.467"></a><span id="l74.467">               inSize -= quantum; // filled this much of request</span>
<a href="#l74.468"></a><span id="l74.468">             }</span>
<a href="#l74.469"></a><span id="l74.469" class="difflineminus">-            </span>
<a href="#l74.470"></a><span id="l74.470" class="difflineplus">+</span>
<a href="#l74.471"></a><span id="l74.471">             if ( inSize ) // we still need to write more content?</span>
<a href="#l74.472"></a><span id="l74.472">             {</span>
<a href="#l74.473"></a><span id="l74.473">               // We need to write more bytes directly to the</span>
<a href="#l74.474"></a><span id="l74.474">               // content file, without local buffering.  We have</span>
<a href="#l74.475"></a><span id="l74.475">               // exhausted the local buffer, so we need to flush</span>
<a href="#l74.476"></a><span id="l74.476">               // it and empty it, and adjust the current buf pos.</span>
<a href="#l74.477"></a><span id="l74.477">               // After flushing, if the rest of the write fits</span>
<a href="#l74.478"></a><span id="l74.478">               // inside the buffer, we will put bytes into the</span>
<a href="#l74.479"></a><span id="l74.479">               // buffer rather than write them to content file.</span>
<a href="#l74.480"></a><span id="l74.480" class="difflineminus">-              </span>
<a href="#l74.481"></a><span id="l74.481" class="difflineplus">+</span>
<a href="#l74.482"></a><span id="l74.482">               if ( mStream_Dirty )</span>
<a href="#l74.483"></a><span id="l74.483">                 this-&gt;Flush(menv); // will update mStream_BufPos</span>
<a href="#l74.484"></a><span id="l74.484"> </span>
<a href="#l74.485"></a><span id="l74.485">               at = mStream_At;</span>
<a href="#l74.486"></a><span id="l74.486">               if ( at &lt; buf || at &gt; end ) // bad cursor?</span>
<a href="#l74.487"></a><span id="l74.487">                 this-&gt;NewBadCursorOrderError(ev);</span>
<a href="#l74.488"></a><span id="l74.488" class="difflineminus">-                </span>
<a href="#l74.489"></a><span id="l74.489" class="difflineplus">+</span>
<a href="#l74.490"></a><span id="l74.490">               if ( ev-&gt;Good() ) // no errors?</span>
<a href="#l74.491"></a><span id="l74.491">               {</span>
<a href="#l74.492"></a><span id="l74.492">                 space = (mork_num) (end - at); // space left in buffer</span>
<a href="#l74.493"></a><span id="l74.493">                 if ( space &gt; inSize ) // write to buffer?</span>
<a href="#l74.494"></a><span id="l74.494">                 {</span>
<a href="#l74.495"></a><span id="l74.495">                   mStream_Dirty = morkBool_kTrue; // ensure flush</span>
<a href="#l74.496"></a><span id="l74.496">                   MORK_MEMCPY(at, source, inSize); // copy</span>
<a href="#l74.497"></a><span id="l74.497" class="difflineminus">-                  </span>
<a href="#l74.498"></a><span id="l74.498" class="difflineplus">+</span>
<a href="#l74.499"></a><span id="l74.499">                   mStream_At += inSize; // past written bytes</span>
<a href="#l74.500"></a><span id="l74.500">                   outActual += inSize;  // this much written</span>
<a href="#l74.501"></a><span id="l74.501">                 }</span>
<a href="#l74.502"></a><span id="l74.502">                 else // directly to content file instead</span>
<a href="#l74.503"></a><span id="l74.503">                 {</span>
<a href="#l74.504"></a><span id="l74.504">                   // file-&gt;Seek(ev, mStream_BufPos); // set pos</span>
<a href="#l74.505"></a><span id="l74.505">                   // if ( ev-&gt;Good() ) // no seek error?</span>
<a href="#l74.506"></a><span id="l74.506">                   // {</span>
<a href="#l74.507"></a><span id="l74.507" class="difflineat">@@ -714,88 +714,88 @@ morkStream::Write(nsIMdbEnv* menv, const</span>
<a href="#l74.508"></a><span id="l74.508">           else this-&gt;NewBadCursorOrderError(ev);</span>
<a href="#l74.509"></a><span id="l74.509">         }</span>
<a href="#l74.510"></a><span id="l74.510">         else this-&gt;NewNullStreamBufferError(ev);</span>
<a href="#l74.511"></a><span id="l74.511">       }</span>
<a href="#l74.512"></a><span id="l74.512">     }</span>
<a href="#l74.513"></a><span id="l74.513">     else this-&gt;NewCantWriteSourceError(ev);</span>
<a href="#l74.514"></a><span id="l74.514">   }</span>
<a href="#l74.515"></a><span id="l74.515">   else this-&gt;NewFileDownError(ev);</span>
<a href="#l74.516"></a><span id="l74.516" class="difflineminus">-  </span>
<a href="#l74.517"></a><span id="l74.517" class="difflineplus">+</span>
<a href="#l74.518"></a><span id="l74.518">   if ( ev-&gt;Bad() )</span>
<a href="#l74.519"></a><span id="l74.519">     outActual = 0;</span>
<a href="#l74.520"></a><span id="l74.520"> </span>
<a href="#l74.521"></a><span id="l74.521">   *aOutSize = outActual;</span>
<a href="#l74.522"></a><span id="l74.522">   return ev-&gt;AsErr();</span>
<a href="#l74.523"></a><span id="l74.523"> }</span>
<a href="#l74.524"></a><span id="l74.524"> </span>
<a href="#l74.525"></a><span id="l74.525" class="difflineminus">-NS_IMETHODIMP     </span>
<a href="#l74.526"></a><span id="l74.526" class="difflineplus">+NS_IMETHODIMP</span>
<a href="#l74.527"></a><span id="l74.527"> morkStream::Flush(nsIMdbEnv* ev)</span>
<a href="#l74.528"></a><span id="l74.528"> {</span>
<a href="#l74.529"></a><span id="l74.529">   morkEnv *mev = morkEnv::FromMdbEnv(ev);</span>
<a href="#l74.530"></a><span id="l74.530">   nsresult rv = NS_ERROR_FAILURE;</span>
<a href="#l74.531"></a><span id="l74.531">   nsIMdbFile* file = mStream_ContentFile;</span>
<a href="#l74.532"></a><span id="l74.532">   if ( this-&gt;IsOpenOrClosingNode() &amp;&amp; this-&gt;FileActive() &amp;&amp; file )</span>
<a href="#l74.533"></a><span id="l74.533">   {</span>
<a href="#l74.534"></a><span id="l74.534">     if ( mStream_Dirty )</span>
<a href="#l74.535"></a><span id="l74.535">       this-&gt;spill_buf(mev);</span>
<a href="#l74.536"></a><span id="l74.536"> </span>
<a href="#l74.537"></a><span id="l74.537">     rv = file-&gt;Flush(ev);</span>
<a href="#l74.538"></a><span id="l74.538">   }</span>
<a href="#l74.539"></a><span id="l74.539">   else this-&gt;NewFileDownError(mev);</span>
<a href="#l74.540"></a><span id="l74.540">   return rv;</span>
<a href="#l74.541"></a><span id="l74.541"> }</span>
<a href="#l74.542"></a><span id="l74.542"> </span>
<a href="#l74.543"></a><span id="l74.543" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l74.544"></a><span id="l74.544" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l74.545"></a><span id="l74.545"> // protected: // protected non-poly morkStream methods (for char io)</span>
<a href="#l74.546"></a><span id="l74.546"> </span>
<a href="#l74.547"></a><span id="l74.547"> int</span>
<a href="#l74.548"></a><span id="l74.548"> morkStream::fill_getc(morkEnv* ev)</span>
<a href="#l74.549"></a><span id="l74.549"> {</span>
<a href="#l74.550"></a><span id="l74.550">   int c = EOF;</span>
<a href="#l74.551"></a><span id="l74.551" class="difflineminus">-  </span>
<a href="#l74.552"></a><span id="l74.552" class="difflineplus">+</span>
<a href="#l74.553"></a><span id="l74.553">   nsIMdbFile* file = mStream_ContentFile;</span>
<a href="#l74.554"></a><span id="l74.554">   if ( this-&gt;IsOpenAndActiveFile() &amp;&amp; file )</span>
<a href="#l74.555"></a><span id="l74.555">   {</span>
<a href="#l74.556"></a><span id="l74.556">     mork_u1* buf = mStream_Buf;</span>
<a href="#l74.557"></a><span id="l74.557">     mork_u1* end = mStream_ReadEnd; // beyond buf after earlier read</span>
<a href="#l74.558"></a><span id="l74.558">     if ( end &gt; buf ) // any earlier read bytes buffered?</span>
<a href="#l74.559"></a><span id="l74.559">     {</span>
<a href="#l74.560"></a><span id="l74.560">       mStream_BufPos += ( end - buf ); // advance past old read</span>
<a href="#l74.561"></a><span id="l74.561">     }</span>
<a href="#l74.562"></a><span id="l74.562" class="difflineminus">-      </span>
<a href="#l74.563"></a><span id="l74.563" class="difflineplus">+</span>
<a href="#l74.564"></a><span id="l74.564">     if ( ev-&gt;Good() ) // no errors yet?</span>
<a href="#l74.565"></a><span id="l74.565">     {</span>
<a href="#l74.566"></a><span id="l74.566">       // file-&gt;Seek(ev, mStream_BufPos); // set file pos</span>
<a href="#l74.567"></a><span id="l74.567">       // if ( ev-&gt;Good() ) // no seek error?</span>
<a href="#l74.568"></a><span id="l74.568">       // {</span>
<a href="#l74.569"></a><span id="l74.569">       // }</span>
<a href="#l74.570"></a><span id="l74.570"> </span>
<a href="#l74.571"></a><span id="l74.571">       nsIMdbEnv* menv = ev-&gt;AsMdbEnv();</span>
<a href="#l74.572"></a><span id="l74.572">       mork_num actual = 0;</span>
<a href="#l74.573"></a><span id="l74.573">       file-&gt;Get(menv, buf, mStream_BufSize, mStream_BufPos, &amp;actual);</span>
<a href="#l74.574"></a><span id="l74.574">       if ( ev-&gt;Good() ) // no read errors?</span>
<a href="#l74.575"></a><span id="l74.575">       {</span>
<a href="#l74.576"></a><span id="l74.576">         if ( actual &gt; mStream_BufSize ) // more than asked for??</span>
<a href="#l74.577"></a><span id="l74.577">           actual = mStream_BufSize;</span>
<a href="#l74.578"></a><span id="l74.578" class="difflineminus">-        </span>
<a href="#l74.579"></a><span id="l74.579" class="difflineplus">+</span>
<a href="#l74.580"></a><span id="l74.580">         mStream_At = buf;</span>
<a href="#l74.581"></a><span id="l74.581">         mStream_ReadEnd = buf + actual;</span>
<a href="#l74.582"></a><span id="l74.582">         if ( actual ) // any bytes actually read?</span>
<a href="#l74.583"></a><span id="l74.583">         {</span>
<a href="#l74.584"></a><span id="l74.584">           c = *mStream_At++; // return first byte from buffer</span>
<a href="#l74.585"></a><span id="l74.585">           mStream_HitEof = morkBool_kFalse;</span>
<a href="#l74.586"></a><span id="l74.586">         }</span>
<a href="#l74.587"></a><span id="l74.587">         else</span>
<a href="#l74.588"></a><span id="l74.588">           mStream_HitEof = morkBool_kTrue;</span>
<a href="#l74.589"></a><span id="l74.589">       }</span>
<a href="#l74.590"></a><span id="l74.590">     }</span>
<a href="#l74.591"></a><span id="l74.591">   }</span>
<a href="#l74.592"></a><span id="l74.592">   else this-&gt;NewFileDownError(ev);</span>
<a href="#l74.593"></a><span id="l74.593" class="difflineminus">-  </span>
<a href="#l74.594"></a><span id="l74.594" class="difflineplus">+</span>
<a href="#l74.595"></a><span id="l74.595">   return c;</span>
<a href="#l74.596"></a><span id="l74.596"> }</span>
<a href="#l74.597"></a><span id="l74.597"> </span>
<a href="#l74.598"></a><span id="l74.598"> void</span>
<a href="#l74.599"></a><span id="l74.599"> morkStream::spill_putc(morkEnv* ev, int c)</span>
<a href="#l74.600"></a><span id="l74.600"> {</span>
<a href="#l74.601"></a><span id="l74.601">   this-&gt;spill_buf(ev);</span>
<a href="#l74.602"></a><span id="l74.602">   if ( ev-&gt;Good() &amp;&amp; mStream_At &lt; mStream_WriteEnd )</span>
<a href="#l74.603"></a><span id="l74.603" class="difflineat">@@ -826,17 +826,17 @@ morkStream::spill_buf(morkEnv* ev) // sp</span>
<a href="#l74.604"></a><span id="l74.604">           if ( ev-&gt;Good() )</span>
<a href="#l74.605"></a><span id="l74.605">           {</span>
<a href="#l74.606"></a><span id="l74.606">             // file-&gt;Seek(ev, mStream_BufPos);</span>
<a href="#l74.607"></a><span id="l74.607">             // if ( ev-&gt;Good() )</span>
<a href="#l74.608"></a><span id="l74.608">             // {</span>
<a href="#l74.609"></a><span id="l74.609">             // }</span>
<a href="#l74.610"></a><span id="l74.610">             nsIMdbEnv* menv = ev-&gt;AsMdbEnv();</span>
<a href="#l74.611"></a><span id="l74.611">             mork_num actual = 0;</span>
<a href="#l74.612"></a><span id="l74.612" class="difflineminus">-            </span>
<a href="#l74.613"></a><span id="l74.613" class="difflineplus">+</span>
<a href="#l74.614"></a><span id="l74.614">             file-&gt;Put(menv, buf, count, mStream_BufPos, &amp;actual);</span>
<a href="#l74.615"></a><span id="l74.615">             if ( ev-&gt;Good() )</span>
<a href="#l74.616"></a><span id="l74.616">             {</span>
<a href="#l74.617"></a><span id="l74.617">               mStream_BufPos += actual; // past bytes written</span>
<a href="#l74.618"></a><span id="l74.618">               mStream_At = buf; // reset buffer cursor</span>
<a href="#l74.619"></a><span id="l74.619">               mStream_Dirty = morkBool_kFalse;</span>
<a href="#l74.620"></a><span id="l74.620">             }</span>
<a href="#l74.621"></a><span id="l74.621">           }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l75.1"></a><span id="l75.1" class="difflineminus">--- a/db/mork/src/morkStream.h</span>
<a href="#l75.2"></a><span id="l75.2" class="difflineplus">+++ b/db/mork/src/morkStream.h</span>
<a href="#l75.3"></a><span id="l75.3" class="difflineat">@@ -82,44 +82,44 @@</span>
<a href="#l75.4"></a><span id="l75.4"> **| else branch of the statement calls a function that raises an appropriate</span>
<a href="#l75.5"></a><span id="l75.5"> **| error to complain about either reading a sink or writing a source.</span>
<a href="#l75.6"></a><span id="l75.6"> **|</span>
<a href="#l75.7"></a><span id="l75.7"> **|| morkStream is a direct clone of ab_Stream from Communicator 4.5's</span>
<a href="#l75.8"></a><span id="l75.8"> **| address book code, which in turn was based on the stream class in the</span>
<a href="#l75.9"></a><span id="l75.9"> **| public domain Mithril programming language.</span>
<a href="#l75.10"></a><span id="l75.10"> |*/</span>
<a href="#l75.11"></a><span id="l75.11"> </span>
<a href="#l75.12"></a><span id="l75.12" class="difflineminus">-#define morkStream_kPrintBufSize /*i*/ 512 /* buffer size used by printf() */ </span>
<a href="#l75.13"></a><span id="l75.13" class="difflineplus">+#define morkStream_kPrintBufSize /*i*/ 512 /* buffer size used by printf() */</span>
<a href="#l75.14"></a><span id="l75.14"> </span>
<a href="#l75.15"></a><span id="l75.15" class="difflineminus">-#define morkStream_kMinBufSize /*i*/ 512 /* buffer no fewer bytes */ </span>
<a href="#l75.16"></a><span id="l75.16" class="difflineminus">-#define morkStream_kMaxBufSize /*i*/ (32 * 1024) /* buffer no more bytes */ </span>
<a href="#l75.17"></a><span id="l75.17" class="difflineplus">+#define morkStream_kMinBufSize /*i*/ 512 /* buffer no fewer bytes */</span>
<a href="#l75.18"></a><span id="l75.18" class="difflineplus">+#define morkStream_kMaxBufSize /*i*/ (32 * 1024) /* buffer no more bytes */</span>
<a href="#l75.19"></a><span id="l75.19"> </span>
<a href="#l75.20"></a><span id="l75.20"> #define morkDerived_kStream     /*i*/ 0x7A74 /* ascii 'zt' */</span>
<a href="#l75.21"></a><span id="l75.21"> </span>
<a href="#l75.22"></a><span id="l75.22"> class morkStream /*d*/ : public morkFile { /* from Mithril's AgStream class */</span>
<a href="#l75.23"></a><span id="l75.23"> </span>
<a href="#l75.24"></a><span id="l75.24" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l75.25"></a><span id="l75.25" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l75.26"></a><span id="l75.26"> protected: // protected morkStream members</span>
<a href="#l75.27"></a><span id="l75.27">   mork_u1*    mStream_At;       // pointer into mStream_Buf</span>
<a href="#l75.28"></a><span id="l75.28">   mork_u1*    mStream_ReadEnd;  // null or one byte past last readable byte</span>
<a href="#l75.29"></a><span id="l75.29">   mork_u1*    mStream_WriteEnd; // null or mStream_Buf + mStream_BufSize</span>
<a href="#l75.30"></a><span id="l75.30"> </span>
<a href="#l75.31"></a><span id="l75.31">   nsIMdbFile* mStream_ContentFile;  // where content is read and written</span>
<a href="#l75.32"></a><span id="l75.32"> </span>
<a href="#l75.33"></a><span id="l75.33">   mork_u1*    mStream_Buf;      // dynamically allocated memory to buffer io</span>
<a href="#l75.34"></a><span id="l75.34">   mork_size   mStream_BufSize;  // requested buf size (fixed by min and max)</span>
<a href="#l75.35"></a><span id="l75.35">   mork_pos    mStream_BufPos;   // logical position of byte at mStream_Buf</span>
<a href="#l75.36"></a><span id="l75.36">   mork_bool   mStream_Dirty;    // does the buffer need to be flushed?</span>
<a href="#l75.37"></a><span id="l75.37">   mork_bool   mStream_HitEof;   // has eof been reached? (only frozen streams)</span>
<a href="#l75.38"></a><span id="l75.38" class="difflineminus">-  </span>
<a href="#l75.39"></a><span id="l75.39" class="difflineplus">+</span>
<a href="#l75.40"></a><span id="l75.40"> // { ===== begin morkNode interface =====</span>
<a href="#l75.41"></a><span id="l75.41"> public: // morkNode virtual methods</span>
<a href="#l75.42"></a><span id="l75.42">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseStream() only if open</span>
<a href="#l75.43"></a><span id="l75.43">   virtual ~morkStream(); // assert that CloseStream() executed earlier</span>
<a href="#l75.44"></a><span id="l75.44" class="difflineminus">-  </span>
<a href="#l75.45"></a><span id="l75.45" class="difflineplus">+</span>
<a href="#l75.46"></a><span id="l75.46"> public: // morkStream construction &amp; destruction</span>
<a href="#l75.47"></a><span id="l75.47">   morkStream(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l75.48"></a><span id="l75.48">       nsIMdbFile* ioContentFile, mork_size inBufSize, mork_bool inFrozen);</span>
<a href="#l75.49"></a><span id="l75.49">   void CloseStream(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l75.50"></a><span id="l75.50"> </span>
<a href="#l75.51"></a><span id="l75.51"> private: // copying is not allowed</span>
<a href="#l75.52"></a><span id="l75.52">   morkStream(const morkStream&amp; other);</span>
<a href="#l75.53"></a><span id="l75.53">   morkStream&amp; operator=(const morkStream&amp; other);</span>
<a href="#l75.54"></a><span id="l75.54" class="difflineat">@@ -127,17 +127,17 @@ private: // copying is not allowed</span>
<a href="#l75.55"></a><span id="l75.55"> public: // dynamic type identification</span>
<a href="#l75.56"></a><span id="l75.56">   mork_bool IsStream() const</span>
<a href="#l75.57"></a><span id="l75.57">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kStream; }</span>
<a href="#l75.58"></a><span id="l75.58"> // } ===== end morkNode methods =====</span>
<a href="#l75.59"></a><span id="l75.59"> </span>
<a href="#l75.60"></a><span id="l75.60"> public: // typing</span>
<a href="#l75.61"></a><span id="l75.61">   void NonStreamTypeError(morkEnv* ev);</span>
<a href="#l75.62"></a><span id="l75.62"> </span>
<a href="#l75.63"></a><span id="l75.63" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l75.64"></a><span id="l75.64" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l75.65"></a><span id="l75.65"> public: // virtual morkFile methods</span>
<a href="#l75.66"></a><span id="l75.66"> </span>
<a href="#l75.67"></a><span id="l75.67">   NS_IMETHOD Steal(nsIMdbEnv* ev, nsIMdbFile* ioThief) override;</span>
<a href="#l75.68"></a><span id="l75.68">   // Steal: tell this file to close any associated i/o stream in the file</span>
<a href="#l75.69"></a><span id="l75.69">   // system, because the file ioThief intends to reopen the file in order</span>
<a href="#l75.70"></a><span id="l75.70">   // to provide the MDB implementation with more exotic file access than is</span>
<a href="#l75.71"></a><span id="l75.71">   // offered by the nsIMdbFile alone.  Presumably the thief knows enough</span>
<a href="#l75.72"></a><span id="l75.72">   // from Path() in order to know which file to reopen.  If Steal() is</span>
<a href="#l75.73"></a><span id="l75.73" class="difflineat">@@ -168,83 +168,83 @@ public: // virtual morkFile methods</span>
<a href="#l75.74"></a><span id="l75.74">   // Note that AcquireBud() is an illegal operation on readonly files.</span>
<a href="#l75.75"></a><span id="l75.75"> </span>
<a href="#l75.76"></a><span id="l75.76">   virtual mork_pos Length(morkEnv* ev) const override; // eof</span>
<a href="#l75.77"></a><span id="l75.77">   NS_IMETHOD  Tell(nsIMdbEnv* ev, mork_pos *aOutPos  ) const override;</span>
<a href="#l75.78"></a><span id="l75.78">   NS_IMETHOD  Read(nsIMdbEnv* ev, void* outBuf, mork_size inSize, mork_size *aOutCount) override;</span>
<a href="#l75.79"></a><span id="l75.79">   NS_IMETHOD  Seek(nsIMdbEnv* ev, mork_pos inPos, mork_pos *aOutPos) override;</span>
<a href="#l75.80"></a><span id="l75.80">   NS_IMETHOD  Write(nsIMdbEnv* ev, const void* inBuf, mork_size inSize, mork_size *aOutCount) override;</span>
<a href="#l75.81"></a><span id="l75.81">   NS_IMETHOD  Flush(nsIMdbEnv* ev) override;</span>
<a href="#l75.82"></a><span id="l75.82" class="difflineminus">-    </span>
<a href="#l75.83"></a><span id="l75.83" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l75.84"></a><span id="l75.84" class="difflineplus">+</span>
<a href="#l75.85"></a><span id="l75.85" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l75.86"></a><span id="l75.86"> protected: // protected non-poly morkStream methods (for char io)</span>
<a href="#l75.87"></a><span id="l75.87"> </span>
<a href="#l75.88"></a><span id="l75.88">   int     fill_getc(morkEnv* ev);</span>
<a href="#l75.89"></a><span id="l75.89">   void    spill_putc(morkEnv* ev, int c);</span>
<a href="#l75.90"></a><span id="l75.90">   void    spill_buf(morkEnv* ev); // spill/flush from buffer to file</span>
<a href="#l75.91"></a><span id="l75.91" class="difflineminus">-      </span>
<a href="#l75.92"></a><span id="l75.92" class="difflineminus">-// ````` ````` ````` `````   ````` ````` ````` `````  </span>
<a href="#l75.93"></a><span id="l75.93" class="difflineplus">+</span>
<a href="#l75.94"></a><span id="l75.94" class="difflineplus">+// ````` ````` ````` `````   ````` ````` ````` `````</span>
<a href="#l75.95"></a><span id="l75.95"> public: // public non-poly morkStream methods</span>
<a href="#l75.96"></a><span id="l75.96" class="difflineminus">-    </span>
<a href="#l75.97"></a><span id="l75.97" class="difflineplus">+</span>
<a href="#l75.98"></a><span id="l75.98">   void NewBadCursorSlotsError(morkEnv* ev) const;</span>
<a href="#l75.99"></a><span id="l75.99">   void NewBadCursorOrderError(morkEnv* ev) const;</span>
<a href="#l75.100"></a><span id="l75.100">   void NewNullStreamBufferError(morkEnv* ev) const;</span>
<a href="#l75.101"></a><span id="l75.101">   void NewCantReadSinkError(morkEnv* ev) const;</span>
<a href="#l75.102"></a><span id="l75.102">   void NewCantWriteSourceError(morkEnv* ev) const;</span>
<a href="#l75.103"></a><span id="l75.103">   void NewPosBeyondEofError(morkEnv* ev) const;</span>
<a href="#l75.104"></a><span id="l75.104" class="difflineminus">-      </span>
<a href="#l75.105"></a><span id="l75.105" class="difflineplus">+</span>
<a href="#l75.106"></a><span id="l75.106">   nsIMdbFile* GetStreamContentFile() const { return mStream_ContentFile; }</span>
<a href="#l75.107"></a><span id="l75.107">   mork_size   GetStreamBufferSize() const { return mStream_BufSize; }</span>
<a href="#l75.108"></a><span id="l75.108" class="difflineminus">-  </span>
<a href="#l75.109"></a><span id="l75.109" class="difflineplus">+</span>
<a href="#l75.110"></a><span id="l75.110">   mork_size  PutIndent(morkEnv* ev, mork_count inDepth);</span>
<a href="#l75.111"></a><span id="l75.111">   // PutIndent() puts a linebreak, and then</span>
<a href="#l75.112"></a><span id="l75.112">   // &quot;indents&quot; by inDepth, and returns the line length after indentation.</span>
<a href="#l75.113"></a><span id="l75.113" class="difflineminus">-  </span>
<a href="#l75.114"></a><span id="l75.114" class="difflineplus">+</span>
<a href="#l75.115"></a><span id="l75.115">   mork_size  PutByteThenIndent(morkEnv* ev, int inByte, mork_count inDepth);</span>
<a href="#l75.116"></a><span id="l75.116">   // PutByteThenIndent() puts the byte, then a linebreak, and then</span>
<a href="#l75.117"></a><span id="l75.117">   // &quot;indents&quot; by inDepth, and returns the line length after indentation.</span>
<a href="#l75.118"></a><span id="l75.118" class="difflineminus">-  </span>
<a href="#l75.119"></a><span id="l75.119" class="difflineplus">+</span>
<a href="#l75.120"></a><span id="l75.120">   mork_size  PutStringThenIndent(morkEnv* ev,</span>
<a href="#l75.121"></a><span id="l75.121">     const char* inString, mork_count inDepth);</span>
<a href="#l75.122"></a><span id="l75.122">   // PutStringThenIndent() puts the string, then a linebreak, and then</span>
<a href="#l75.123"></a><span id="l75.123">   // &quot;indents&quot; by inDepth, and returns the line length after indentation.</span>
<a href="#l75.124"></a><span id="l75.124" class="difflineminus">-  </span>
<a href="#l75.125"></a><span id="l75.125" class="difflineplus">+</span>
<a href="#l75.126"></a><span id="l75.126">   mork_size  PutString(morkEnv* ev, const char* inString);</span>
<a href="#l75.127"></a><span id="l75.127">   // PutString() returns the length of the string written.</span>
<a href="#l75.128"></a><span id="l75.128" class="difflineminus">-  </span>
<a href="#l75.129"></a><span id="l75.129" class="difflineplus">+</span>
<a href="#l75.130"></a><span id="l75.130">   mork_size  PutStringThenNewline(morkEnv* ev, const char* inString);</span>
<a href="#l75.131"></a><span id="l75.131">   // PutStringThenNewline() returns total number of bytes written.</span>
<a href="#l75.132"></a><span id="l75.132"> </span>
<a href="#l75.133"></a><span id="l75.133">   mork_size  PutByteThenNewline(morkEnv* ev, int inByte);</span>
<a href="#l75.134"></a><span id="l75.134">   // PutByteThenNewline() returns total number of bytes written.</span>
<a href="#l75.135"></a><span id="l75.135"> </span>
<a href="#l75.136"></a><span id="l75.136" class="difflineminus">-  // ````` ````` stdio type methods ````` ````` </span>
<a href="#l75.137"></a><span id="l75.137" class="difflineplus">+  // ````` ````` stdio type methods ````` `````</span>
<a href="#l75.138"></a><span id="l75.138">   void    Ungetc(int c) /*i*/</span>
<a href="#l75.139"></a><span id="l75.139">   { if ( mStream_At &gt; mStream_Buf &amp;&amp; c &gt; 0 ) *--mStream_At = (mork_u1) c; }</span>
<a href="#l75.140"></a><span id="l75.140" class="difflineminus">-  </span>
<a href="#l75.141"></a><span id="l75.141" class="difflineplus">+</span>
<a href="#l75.142"></a><span id="l75.142">   // Note Getc() returns EOF consistently after any fill_getc() error occurs.</span>
<a href="#l75.143"></a><span id="l75.143">   int     Getc(morkEnv* ev) /*i*/</span>
<a href="#l75.144"></a><span id="l75.144">   { return ( mStream_At &lt; mStream_ReadEnd )? *mStream_At++ : fill_getc(ev); }</span>
<a href="#l75.145"></a><span id="l75.145" class="difflineminus">-  </span>
<a href="#l75.146"></a><span id="l75.146" class="difflineplus">+</span>
<a href="#l75.147"></a><span id="l75.147">   void    Putc(morkEnv* ev, int c) /*i*/</span>
<a href="#l75.148"></a><span id="l75.148" class="difflineminus">-  { </span>
<a href="#l75.149"></a><span id="l75.149" class="difflineplus">+  {</span>
<a href="#l75.150"></a><span id="l75.150">     mStream_Dirty = morkBool_kTrue;</span>
<a href="#l75.151"></a><span id="l75.151">     if ( mStream_At &lt; mStream_WriteEnd )</span>
<a href="#l75.152"></a><span id="l75.152">       *mStream_At++ = (mork_u1) c;</span>
<a href="#l75.153"></a><span id="l75.153">     else</span>
<a href="#l75.154"></a><span id="l75.154">       spill_putc(ev, c);</span>
<a href="#l75.155"></a><span id="l75.155">   }</span>
<a href="#l75.156"></a><span id="l75.156"> </span>
<a href="#l75.157"></a><span id="l75.157">   mork_size PutLineBreak(morkEnv* ev);</span>
<a href="#l75.158"></a><span id="l75.158" class="difflineminus">-  </span>
<a href="#l75.159"></a><span id="l75.159" class="difflineplus">+</span>
<a href="#l75.160"></a><span id="l75.160"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l75.161"></a><span id="l75.161">   static void SlotWeakStream(morkStream* me,</span>
<a href="#l75.162"></a><span id="l75.162">     morkEnv* ev, morkStream** ioSlot)</span>
<a href="#l75.163"></a><span id="l75.163">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l75.164"></a><span id="l75.164" class="difflineminus">-  </span>
<a href="#l75.165"></a><span id="l75.165" class="difflineplus">+</span>
<a href="#l75.166"></a><span id="l75.166">   static void SlotStrongStream(morkStream* me,</span>
<a href="#l75.167"></a><span id="l75.167">     morkEnv* ev, morkStream** ioSlot)</span>
<a href="#l75.168"></a><span id="l75.168">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l75.169"></a><span id="l75.169"> };</span>
<a href="#l75.170"></a><span id="l75.170"> </span>
<a href="#l75.171"></a><span id="l75.171"> </span>
<a href="#l75.172"></a><span id="l75.172"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l75.173"></a><span id="l75.173"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l76.1"></a><span id="l76.1" class="difflineminus">--- a/db/mork/src/morkTable.cpp</span>
<a href="#l76.2"></a><span id="l76.2" class="difflineplus">+++ b/db/mork/src/morkTable.cpp</span>
<a href="#l76.3"></a><span id="l76.3" class="difflineat">@@ -48,17 +48,17 @@</span>
<a href="#l76.4"></a><span id="l76.4"> #endif</span>
<a href="#l76.5"></a><span id="l76.5"> </span>
<a href="#l76.6"></a><span id="l76.6"> #ifndef _MORKROWOBJECT_</span>
<a href="#l76.7"></a><span id="l76.7"> #include &quot;morkRowObject.h&quot;</span>
<a href="#l76.8"></a><span id="l76.8"> #endif</span>
<a href="#l76.9"></a><span id="l76.9"> </span>
<a href="#l76.10"></a><span id="l76.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l76.11"></a><span id="l76.11"> </span>
<a href="#l76.12"></a><span id="l76.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l76.13"></a><span id="l76.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l76.14"></a><span id="l76.14"> // { ===== begin morkNode interface =====</span>
<a href="#l76.15"></a><span id="l76.15"> </span>
<a href="#l76.16"></a><span id="l76.16"> /*public virtual*/ void</span>
<a href="#l76.17"></a><span id="l76.17"> morkTable::CloseMorkNode(morkEnv* ev) /*i*/ // CloseTable() only if open</span>
<a href="#l76.18"></a><span id="l76.18"> {</span>
<a href="#l76.19"></a><span id="l76.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l76.20"></a><span id="l76.20">   {</span>
<a href="#l76.21"></a><span id="l76.21">     morkObject::CloseMorkNode(ev); // give base class a chance.</span>
<a href="#l76.22"></a><span id="l76.22" class="difflineat">@@ -74,45 +74,45 @@ morkTable::~morkTable() /*i*/ // assert </span>
<a href="#l76.23"></a><span id="l76.23">   CloseMorkNode(mMorkEnv);</span>
<a href="#l76.24"></a><span id="l76.24">   MORK_ASSERT(this-&gt;IsShutNode());</span>
<a href="#l76.25"></a><span id="l76.25">   MORK_ASSERT(mTable_Store==0);</span>
<a href="#l76.26"></a><span id="l76.26">   MORK_ASSERT(mTable_RowSpace==0);</span>
<a href="#l76.27"></a><span id="l76.27"> }</span>
<a href="#l76.28"></a><span id="l76.28"> </span>
<a href="#l76.29"></a><span id="l76.29"> /*public non-poly*/</span>
<a href="#l76.30"></a><span id="l76.30"> morkTable::morkTable(morkEnv* ev, /*i*/</span>
<a href="#l76.31"></a><span id="l76.31" class="difflineminus">-  const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap, </span>
<a href="#l76.32"></a><span id="l76.32" class="difflineplus">+  const morkUsage&amp; inUsage, nsIMdbHeap* ioHeap,</span>
<a href="#l76.33"></a><span id="l76.33">   morkStore* ioStore, nsIMdbHeap* ioSlotHeap, morkRowSpace* ioRowSpace,</span>
<a href="#l76.34"></a><span id="l76.34" class="difflineminus">-  const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l76.35"></a><span id="l76.35" class="difflineplus">+  const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l76.36"></a><span id="l76.36">   mork_tid inTid, mork_kind inKind, mork_bool inMustBeUnique)</span>
<a href="#l76.37"></a><span id="l76.37"> : morkObject(ev, inUsage, ioHeap, (mork_color) inTid, (morkHandle*) 0)</span>
<a href="#l76.38"></a><span id="l76.38"> , mTable_Store( 0 )</span>
<a href="#l76.39"></a><span id="l76.39"> , mTable_RowSpace( 0 )</span>
<a href="#l76.40"></a><span id="l76.40"> , mTable_MetaRow( 0 )</span>
<a href="#l76.41"></a><span id="l76.41"> </span>
<a href="#l76.42"></a><span id="l76.42"> , mTable_RowMap( 0 )</span>
<a href="#l76.43"></a><span id="l76.43"> // , mTable_RowMap(ev, morkUsage::kMember, (nsIMdbHeap*) 0, ioSlotHeap,</span>
<a href="#l76.44"></a><span id="l76.44"> //   morkTable_kStartRowMapSlotCount)</span>
<a href="#l76.45"></a><span id="l76.45"> , mTable_RowArray(ev, morkUsage::kMember, (nsIMdbHeap*) 0,</span>
<a href="#l76.46"></a><span id="l76.46">   morkTable_kStartRowArraySize, ioSlotHeap)</span>
<a href="#l76.47"></a><span id="l76.47" class="difflineminus">-  </span>
<a href="#l76.48"></a><span id="l76.48" class="difflineplus">+</span>
<a href="#l76.49"></a><span id="l76.49"> , mTable_ChangeList()</span>
<a href="#l76.50"></a><span id="l76.50"> , mTable_ChangesCount( 0 )</span>
<a href="#l76.51"></a><span id="l76.51"> , mTable_ChangesMax( 3 ) // any very small number greater than zero</span>
<a href="#l76.52"></a><span id="l76.52"> </span>
<a href="#l76.53"></a><span id="l76.53"> , mTable_Kind( inKind )</span>
<a href="#l76.54"></a><span id="l76.54"> </span>
<a href="#l76.55"></a><span id="l76.55"> , mTable_Flags( 0 )</span>
<a href="#l76.56"></a><span id="l76.56"> , mTable_Priority( morkPriority_kLo ) // NOT high priority</span>
<a href="#l76.57"></a><span id="l76.57"> , mTable_GcUses( 0 )</span>
<a href="#l76.58"></a><span id="l76.58"> , mTable_Pad( 0 )</span>
<a href="#l76.59"></a><span id="l76.59"> {</span>
<a href="#l76.60"></a><span id="l76.60">   this-&gt;mLink_Next = 0;</span>
<a href="#l76.61"></a><span id="l76.61">   this-&gt;mLink_Prev = 0;</span>
<a href="#l76.62"></a><span id="l76.62" class="difflineminus">-  </span>
<a href="#l76.63"></a><span id="l76.63" class="difflineplus">+</span>
<a href="#l76.64"></a><span id="l76.64">   if ( ev-&gt;Good() )</span>
<a href="#l76.65"></a><span id="l76.65">   {</span>
<a href="#l76.66"></a><span id="l76.66">     if ( ioStore &amp;&amp; ioSlotHeap &amp;&amp; ioRowSpace )</span>
<a href="#l76.67"></a><span id="l76.67">     {</span>
<a href="#l76.68"></a><span id="l76.68">       if ( inKind )</span>
<a href="#l76.69"></a><span id="l76.69">       {</span>
<a href="#l76.70"></a><span id="l76.70">         if ( inMustBeUnique )</span>
<a href="#l76.71"></a><span id="l76.71">           this-&gt;SetTableUnique();</span>
<a href="#l76.72"></a><span id="l76.72" class="difflineat">@@ -124,17 +124,17 @@ morkTable::morkTable(morkEnv* ev, /*i*/</span>
<a href="#l76.73"></a><span id="l76.73">         {</span>
<a href="#l76.74"></a><span id="l76.74">           mTable_MetaRowOid.mOid_Scope = 0;</span>
<a href="#l76.75"></a><span id="l76.75">           mTable_MetaRowOid.mOid_Id = morkRow_kMinusOneRid;</span>
<a href="#l76.76"></a><span id="l76.76">         }</span>
<a href="#l76.77"></a><span id="l76.77">         if ( ev-&gt;Good() )</span>
<a href="#l76.78"></a><span id="l76.78">         {</span>
<a href="#l76.79"></a><span id="l76.79">           if ( this-&gt;MaybeDirtySpaceStoreAndTable() )</span>
<a href="#l76.80"></a><span id="l76.80">             this-&gt;SetTableRewrite(); // everything is dirty</span>
<a href="#l76.81"></a><span id="l76.81" class="difflineminus">-            </span>
<a href="#l76.82"></a><span id="l76.82" class="difflineplus">+</span>
<a href="#l76.83"></a><span id="l76.83">           mNode_Derived = morkDerived_kTable;</span>
<a href="#l76.84"></a><span id="l76.84">         }</span>
<a href="#l76.85"></a><span id="l76.85">         this-&gt;MaybeDirtySpaceStoreAndTable(); // new table might dirty store</span>
<a href="#l76.86"></a><span id="l76.86">       }</span>
<a href="#l76.87"></a><span id="l76.87">       else</span>
<a href="#l76.88"></a><span id="l76.88">         ioRowSpace-&gt;ZeroKindError(ev);</span>
<a href="#l76.89"></a><span id="l76.89">     }</span>
<a href="#l76.90"></a><span id="l76.90">     else</span>
<a href="#l76.91"></a><span id="l76.91" class="difflineat">@@ -157,17 +157,17 @@ morkTable::CloseTable(morkEnv* ev) /*i*/</span>
<a href="#l76.92"></a><span id="l76.92">       this-&gt;MarkShut();</span>
<a href="#l76.93"></a><span id="l76.93">     }</span>
<a href="#l76.94"></a><span id="l76.94">     else</span>
<a href="#l76.95"></a><span id="l76.95">       this-&gt;NonNodeError(ev);</span>
<a href="#l76.96"></a><span id="l76.96"> }</span>
<a href="#l76.97"></a><span id="l76.97"> </span>
<a href="#l76.98"></a><span id="l76.98"> </span>
<a href="#l76.99"></a><span id="l76.99"> // } ===== end morkNode methods =====</span>
<a href="#l76.100"></a><span id="l76.100" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l76.101"></a><span id="l76.101" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l76.102"></a><span id="l76.102"> </span>
<a href="#l76.103"></a><span id="l76.103"> // { ===== begin nsIMdbCollection methods =====</span>
<a href="#l76.104"></a><span id="l76.104"> </span>
<a href="#l76.105"></a><span id="l76.105"> // { ----- begin attribute methods -----</span>
<a href="#l76.106"></a><span id="l76.106"> NS_IMETHODIMP</span>
<a href="#l76.107"></a><span id="l76.107"> morkTable::GetSeed(nsIMdbEnv* mev,</span>
<a href="#l76.108"></a><span id="l76.108">   mdb_seed* outSeed)    // member change count</span>
<a href="#l76.109"></a><span id="l76.109"> {</span>
<a href="#l76.110"></a><span id="l76.110" class="difflineat">@@ -175,32 +175,32 @@ morkTable::GetSeed(nsIMdbEnv* mev,</span>
<a href="#l76.111"></a><span id="l76.111">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.112"></a><span id="l76.112">   if ( ev )</span>
<a href="#l76.113"></a><span id="l76.113">   {</span>
<a href="#l76.114"></a><span id="l76.114">     *outSeed = mTable_RowArray.mArray_Seed;</span>
<a href="#l76.115"></a><span id="l76.115">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.116"></a><span id="l76.116">   }</span>
<a href="#l76.117"></a><span id="l76.117">   return outErr;</span>
<a href="#l76.118"></a><span id="l76.118"> }</span>
<a href="#l76.119"></a><span id="l76.119" class="difflineminus">-  </span>
<a href="#l76.120"></a><span id="l76.120" class="difflineplus">+</span>
<a href="#l76.121"></a><span id="l76.121"> NS_IMETHODIMP</span>
<a href="#l76.122"></a><span id="l76.122"> morkTable::GetCount(nsIMdbEnv* mev,</span>
<a href="#l76.123"></a><span id="l76.123">   mdb_count* outCount) // member count</span>
<a href="#l76.124"></a><span id="l76.124"> {</span>
<a href="#l76.125"></a><span id="l76.125">   NS_ENSURE_ARG_POINTER(outCount);</span>
<a href="#l76.126"></a><span id="l76.126">   *outCount = mTable_RowArray.mArray_Fill;</span>
<a href="#l76.127"></a><span id="l76.127">   return NS_OK;</span>
<a href="#l76.128"></a><span id="l76.128"> }</span>
<a href="#l76.129"></a><span id="l76.129"> </span>
<a href="#l76.130"></a><span id="l76.130"> NS_IMETHODIMP</span>
<a href="#l76.131"></a><span id="l76.131"> morkTable::GetPort(nsIMdbEnv* mev,</span>
<a href="#l76.132"></a><span id="l76.132">   nsIMdbPort** acqPort) // collection container</span>
<a href="#l76.133"></a><span id="l76.133"> {</span>
<a href="#l76.134"></a><span id="l76.134">   (void) morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.135"></a><span id="l76.135" class="difflineminus">-  NS_ENSURE_ARG_POINTER(acqPort);    </span>
<a href="#l76.136"></a><span id="l76.136" class="difflineplus">+  NS_ENSURE_ARG_POINTER(acqPort);</span>
<a href="#l76.137"></a><span id="l76.137">   *acqPort = mTable_Store;</span>
<a href="#l76.138"></a><span id="l76.138">   return NS_OK;</span>
<a href="#l76.139"></a><span id="l76.139"> }</span>
<a href="#l76.140"></a><span id="l76.140"> // } ----- end attribute methods -----</span>
<a href="#l76.141"></a><span id="l76.141"> </span>
<a href="#l76.142"></a><span id="l76.142"> // { ----- begin cursor methods -----</span>
<a href="#l76.143"></a><span id="l76.143"> NS_IMETHODIMP</span>
<a href="#l76.144"></a><span id="l76.144"> morkTable::GetCursor( // make a cursor starting iter at inMemberPos</span>
<a href="#l76.145"></a><span id="l76.145" class="difflineat">@@ -222,29 +222,29 @@ morkTable::GetOid(nsIMdbEnv* mev,</span>
<a href="#l76.146"></a><span id="l76.146">   GetTableOid(ev, outOid);</span>
<a href="#l76.147"></a><span id="l76.147">   return NS_OK;</span>
<a href="#l76.148"></a><span id="l76.148"> }</span>
<a href="#l76.149"></a><span id="l76.149"> </span>
<a href="#l76.150"></a><span id="l76.150"> NS_IMETHODIMP</span>
<a href="#l76.151"></a><span id="l76.151"> morkTable::BecomeContent(nsIMdbEnv* mev,</span>
<a href="#l76.152"></a><span id="l76.152">   const mdbOid* inOid) // exchange content</span>
<a href="#l76.153"></a><span id="l76.153"> {</span>
<a href="#l76.154"></a><span id="l76.154" class="difflineminus">-  NS_ASSERTION(false, &quot;not implemented&quot;); </span>
<a href="#l76.155"></a><span id="l76.155" class="difflineplus">+  NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l76.156"></a><span id="l76.156">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l76.157"></a><span id="l76.157">   // remember table-&gt;MaybeDirtySpaceStoreAndTable();</span>
<a href="#l76.158"></a><span id="l76.158"> }</span>
<a href="#l76.159"></a><span id="l76.159"> </span>
<a href="#l76.160"></a><span id="l76.160"> // } ----- end ID methods -----</span>
<a href="#l76.161"></a><span id="l76.161"> </span>
<a href="#l76.162"></a><span id="l76.162"> // { ----- begin activity dropping methods -----</span>
<a href="#l76.163"></a><span id="l76.163"> NS_IMETHODIMP</span>
<a href="#l76.164"></a><span id="l76.164"> morkTable::DropActivity( // tell collection usage no longer expected</span>
<a href="#l76.165"></a><span id="l76.165">   nsIMdbEnv* mev)</span>
<a href="#l76.166"></a><span id="l76.166"> {</span>
<a href="#l76.167"></a><span id="l76.167" class="difflineminus">-  NS_ASSERTION(false, &quot;not implemented&quot;); </span>
<a href="#l76.168"></a><span id="l76.168" class="difflineplus">+  NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l76.169"></a><span id="l76.169">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l76.170"></a><span id="l76.170"> }</span>
<a href="#l76.171"></a><span id="l76.171"> </span>
<a href="#l76.172"></a><span id="l76.172"> // } ----- end activity dropping methods -----</span>
<a href="#l76.173"></a><span id="l76.173"> </span>
<a href="#l76.174"></a><span id="l76.174"> // } ===== end nsIMdbCollection methods =====</span>
<a href="#l76.175"></a><span id="l76.175"> </span>
<a href="#l76.176"></a><span id="l76.176"> // { ===== begin nsIMdbTable methods =====</span>
<a href="#l76.177"></a><span id="l76.177" class="difflineat">@@ -255,17 +255,17 @@ NS_IMETHODIMP</span>
<a href="#l76.178"></a><span id="l76.178"> morkTable::SetTablePriority(nsIMdbEnv* mev, mdb_priority inPrio)</span>
<a href="#l76.179"></a><span id="l76.179"> {</span>
<a href="#l76.180"></a><span id="l76.180">   nsresult outErr = NS_OK;</span>
<a href="#l76.181"></a><span id="l76.181">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.182"></a><span id="l76.182">   if ( ev )</span>
<a href="#l76.183"></a><span id="l76.183">   {</span>
<a href="#l76.184"></a><span id="l76.184">     if ( inPrio &gt; morkPriority_kMax )</span>
<a href="#l76.185"></a><span id="l76.185">       inPrio = morkPriority_kMax;</span>
<a href="#l76.186"></a><span id="l76.186" class="difflineminus">-      </span>
<a href="#l76.187"></a><span id="l76.187" class="difflineplus">+</span>
<a href="#l76.188"></a><span id="l76.188">     mTable_Priority = inPrio;</span>
<a href="#l76.189"></a><span id="l76.189">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.190"></a><span id="l76.190">   }</span>
<a href="#l76.191"></a><span id="l76.191">   return outErr;</span>
<a href="#l76.192"></a><span id="l76.192"> }</span>
<a href="#l76.193"></a><span id="l76.193"> </span>
<a href="#l76.194"></a><span id="l76.194"> NS_IMETHODIMP</span>
<a href="#l76.195"></a><span id="l76.195"> morkTable::GetTablePriority(nsIMdbEnv* mev, mdb_priority* outPrio)</span>
<a href="#l76.196"></a><span id="l76.196" class="difflineat">@@ -303,17 +303,17 @@ morkTable::SetTableBeVerbose(nsIMdbEnv* </span>
<a href="#l76.197"></a><span id="l76.197">   nsresult outErr = NS_OK;</span>
<a href="#l76.198"></a><span id="l76.198">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.199"></a><span id="l76.199">   if ( ev )</span>
<a href="#l76.200"></a><span id="l76.200">   {</span>
<a href="#l76.201"></a><span id="l76.201">     if ( inBeVerbose )</span>
<a href="#l76.202"></a><span id="l76.202">       SetTableVerbose();</span>
<a href="#l76.203"></a><span id="l76.203">     else</span>
<a href="#l76.204"></a><span id="l76.204">       ClearTableVerbose();</span>
<a href="#l76.205"></a><span id="l76.205" class="difflineminus">-   </span>
<a href="#l76.206"></a><span id="l76.206" class="difflineplus">+</span>
<a href="#l76.207"></a><span id="l76.207">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.208"></a><span id="l76.208">   }</span>
<a href="#l76.209"></a><span id="l76.209">   return outErr;</span>
<a href="#l76.210"></a><span id="l76.210"> }</span>
<a href="#l76.211"></a><span id="l76.211"> </span>
<a href="#l76.212"></a><span id="l76.212"> NS_IMETHODIMP</span>
<a href="#l76.213"></a><span id="l76.213"> morkTable::GetTableIsUnique(nsIMdbEnv* mev, mdb_bool* outIsUnique)</span>
<a href="#l76.214"></a><span id="l76.214"> {</span>
<a href="#l76.215"></a><span id="l76.215" class="difflineat">@@ -347,17 +347,17 @@ morkTable::GetRowScope(nsIMdbEnv* mev, m</span>
<a href="#l76.216"></a><span id="l76.216">   }</span>
<a href="#l76.217"></a><span id="l76.217">   if ( outRowScope )</span>
<a href="#l76.218"></a><span id="l76.218">     *outRowScope = rowScope;</span>
<a href="#l76.219"></a><span id="l76.219">   return outErr;</span>
<a href="#l76.220"></a><span id="l76.220"> }</span>
<a href="#l76.221"></a><span id="l76.221"> </span>
<a href="#l76.222"></a><span id="l76.222"> NS_IMETHODIMP</span>
<a href="#l76.223"></a><span id="l76.223"> morkTable::GetMetaRow( nsIMdbEnv* mev,</span>
<a href="#l76.224"></a><span id="l76.224" class="difflineminus">-  const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l76.225"></a><span id="l76.225" class="difflineplus">+  const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l76.226"></a><span id="l76.226">   mdbOid* outOid, // output meta row oid, can be nil to suppress output</span>
<a href="#l76.227"></a><span id="l76.227">   nsIMdbRow** acqRow) // acquire table's unique singleton meta row</span>
<a href="#l76.228"></a><span id="l76.228">   // The purpose of a meta row is to support the persistent recording of</span>
<a href="#l76.229"></a><span id="l76.229">   // meta info about a table as cells put into the distinguished meta row.</span>
<a href="#l76.230"></a><span id="l76.230">   // Each table has exactly one meta row, which is not considered a member</span>
<a href="#l76.231"></a><span id="l76.231">   // of the collection of rows inside the table.  The only way to tell</span>
<a href="#l76.232"></a><span id="l76.232">   // whether a row is a meta row is by the fact that it is returned by this</span>
<a href="#l76.233"></a><span id="l76.233">   // GetMetaRow() method from some table. Otherwise nothing distinguishes</span>
<a href="#l76.234"></a><span id="l76.234" class="difflineat">@@ -383,24 +383,24 @@ morkTable::GetMetaRow( nsIMdbEnv* mev,</span>
<a href="#l76.235"></a><span id="l76.235">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.236"></a><span id="l76.236">   if ( ev )</span>
<a href="#l76.237"></a><span id="l76.237">   {</span>
<a href="#l76.238"></a><span id="l76.238">     morkRow* row = GetMetaRow(ev, inOptionalMetaRowOid);</span>
<a href="#l76.239"></a><span id="l76.239">     if ( row &amp;&amp; ev-&gt;Good() )</span>
<a href="#l76.240"></a><span id="l76.240">     {</span>
<a href="#l76.241"></a><span id="l76.241">       if ( outOid )</span>
<a href="#l76.242"></a><span id="l76.242">         *outOid = row-&gt;mRow_Oid;</span>
<a href="#l76.243"></a><span id="l76.243" class="difflineminus">-        </span>
<a href="#l76.244"></a><span id="l76.244" class="difflineplus">+</span>
<a href="#l76.245"></a><span id="l76.245">       outRow = row-&gt;AcquireRowHandle(ev, mTable_Store);</span>
<a href="#l76.246"></a><span id="l76.246">     }</span>
<a href="#l76.247"></a><span id="l76.247">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.248"></a><span id="l76.248">   }</span>
<a href="#l76.249"></a><span id="l76.249">   if ( acqRow )</span>
<a href="#l76.250"></a><span id="l76.250">     *acqRow = outRow;</span>
<a href="#l76.251"></a><span id="l76.251" class="difflineminus">-    </span>
<a href="#l76.252"></a><span id="l76.252" class="difflineplus">+</span>
<a href="#l76.253"></a><span id="l76.253">   if ( ev-&gt;Bad() &amp;&amp; outOid )</span>
<a href="#l76.254"></a><span id="l76.254">   {</span>
<a href="#l76.255"></a><span id="l76.255">     outOid-&gt;mOid_Scope = 0;</span>
<a href="#l76.256"></a><span id="l76.256">     outOid-&gt;mOid_Id = morkRow_kMinusOneRid;</span>
<a href="#l76.257"></a><span id="l76.257">   }</span>
<a href="#l76.258"></a><span id="l76.258">   return outErr;</span>
<a href="#l76.259"></a><span id="l76.259"> }</span>
<a href="#l76.260"></a><span id="l76.260"> </span>
<a href="#l76.261"></a><span id="l76.261" class="difflineat">@@ -423,17 +423,17 @@ morkTable::GetTableRowCursor( // make a </span>
<a href="#l76.262"></a><span id="l76.262">     {</span>
<a href="#l76.263"></a><span id="l76.263">       if ( ev-&gt;Good() )</span>
<a href="#l76.264"></a><span id="l76.264">       {</span>
<a href="#l76.265"></a><span id="l76.265">         // cursor-&gt;mCursor_Seed = (mork_seed) inRowPos;</span>
<a href="#l76.266"></a><span id="l76.266">         outCursor = cursor;</span>
<a href="#l76.267"></a><span id="l76.267">         outCursor-&gt;AddRef();</span>
<a href="#l76.268"></a><span id="l76.268">       }</span>
<a href="#l76.269"></a><span id="l76.269">     }</span>
<a href="#l76.270"></a><span id="l76.270" class="difflineminus">-      </span>
<a href="#l76.271"></a><span id="l76.271" class="difflineplus">+</span>
<a href="#l76.272"></a><span id="l76.272">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.273"></a><span id="l76.273">   }</span>
<a href="#l76.274"></a><span id="l76.274">   if ( acqCursor )</span>
<a href="#l76.275"></a><span id="l76.275">     *acqCursor = outCursor;</span>
<a href="#l76.276"></a><span id="l76.276">   return outErr;</span>
<a href="#l76.277"></a><span id="l76.277"> }</span>
<a href="#l76.278"></a><span id="l76.278"> // } ----- end row position methods -----</span>
<a href="#l76.279"></a><span id="l76.279"> </span>
<a href="#l76.280"></a><span id="l76.280" class="difflineat">@@ -443,24 +443,24 @@ morkTable::PosToOid( // get row member f</span>
<a href="#l76.281"></a><span id="l76.281">   nsIMdbEnv* mev, // context</span>
<a href="#l76.282"></a><span id="l76.282">   mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l76.283"></a><span id="l76.283">   mdbOid* outOid) // row oid at the specified position</span>
<a href="#l76.284"></a><span id="l76.284"> {</span>
<a href="#l76.285"></a><span id="l76.285">   nsresult outErr = NS_OK;</span>
<a href="#l76.286"></a><span id="l76.286">   mdbOid roid;</span>
<a href="#l76.287"></a><span id="l76.287">   roid.mOid_Scope = 0;</span>
<a href="#l76.288"></a><span id="l76.288">   roid.mOid_Id = (mork_id) -1;</span>
<a href="#l76.289"></a><span id="l76.289" class="difflineminus">-  </span>
<a href="#l76.290"></a><span id="l76.290" class="difflineplus">+</span>
<a href="#l76.291"></a><span id="l76.291">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.292"></a><span id="l76.292">   if ( ev )</span>
<a href="#l76.293"></a><span id="l76.293">   {</span>
<a href="#l76.294"></a><span id="l76.294">     morkRow* row = SafeRowAt(ev, inRowPos);</span>
<a href="#l76.295"></a><span id="l76.295">     if ( row )</span>
<a href="#l76.296"></a><span id="l76.296">       roid = row-&gt;mRow_Oid;</span>
<a href="#l76.297"></a><span id="l76.297" class="difflineminus">-    </span>
<a href="#l76.298"></a><span id="l76.298" class="difflineplus">+</span>
<a href="#l76.299"></a><span id="l76.299">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.300"></a><span id="l76.300">   }</span>
<a href="#l76.301"></a><span id="l76.301">   if ( outOid )</span>
<a href="#l76.302"></a><span id="l76.302">     *outOid = roid;</span>
<a href="#l76.303"></a><span id="l76.303">   return outErr;</span>
<a href="#l76.304"></a><span id="l76.304"> }</span>
<a href="#l76.305"></a><span id="l76.305"> </span>
<a href="#l76.306"></a><span id="l76.306"> NS_IMETHODIMP</span>
<a href="#l76.307"></a><span id="l76.307" class="difflineat">@@ -490,17 +490,17 @@ morkTable::PosToRow( // get row member f</span>
<a href="#l76.308"></a><span id="l76.308">   nsresult outErr = NS_OK;</span>
<a href="#l76.309"></a><span id="l76.309">   nsIMdbRow* outRow = 0;</span>
<a href="#l76.310"></a><span id="l76.310">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.311"></a><span id="l76.311">   if ( ev )</span>
<a href="#l76.312"></a><span id="l76.312">   {</span>
<a href="#l76.313"></a><span id="l76.313">     morkRow* row = SafeRowAt(ev, inRowPos);</span>
<a href="#l76.314"></a><span id="l76.314">     if ( row &amp;&amp; mTable_Store )</span>
<a href="#l76.315"></a><span id="l76.315">       outRow = row-&gt;AcquireRowHandle(ev, mTable_Store);</span>
<a href="#l76.316"></a><span id="l76.316" class="difflineminus">-      </span>
<a href="#l76.317"></a><span id="l76.317" class="difflineplus">+</span>
<a href="#l76.318"></a><span id="l76.318">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.319"></a><span id="l76.319">   }</span>
<a href="#l76.320"></a><span id="l76.320">   if ( acqRow )</span>
<a href="#l76.321"></a><span id="l76.321">     *acqRow = outRow;</span>
<a href="#l76.322"></a><span id="l76.322">   return outErr;</span>
<a href="#l76.323"></a><span id="l76.323"> }</span>
<a href="#l76.324"></a><span id="l76.324"> </span>
<a href="#l76.325"></a><span id="l76.325"> NS_IMETHODIMP</span>
<a href="#l76.326"></a><span id="l76.326" class="difflineat">@@ -517,23 +517,23 @@ morkTable::RowToPos( // test for the tab</span>
<a href="#l76.327"></a><span id="l76.327">     morkRowObject* row = (morkRowObject*) ioRow;</span>
<a href="#l76.328"></a><span id="l76.328">     pos = ArrayHasOid(ev, &amp;row-&gt;mRowObject_Row-&gt;mRow_Oid);</span>
<a href="#l76.329"></a><span id="l76.329">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.330"></a><span id="l76.330">   }</span>
<a href="#l76.331"></a><span id="l76.331">   if ( outPos )</span>
<a href="#l76.332"></a><span id="l76.332">     *outPos = pos;</span>
<a href="#l76.333"></a><span id="l76.333">   return outErr;</span>
<a href="#l76.334"></a><span id="l76.334"> }</span>
<a href="#l76.335"></a><span id="l76.335" class="difflineminus">-  </span>
<a href="#l76.336"></a><span id="l76.336" class="difflineplus">+</span>
<a href="#l76.337"></a><span id="l76.337"> // Note that HasRow() performs the inverse oid-&gt;pos mapping</span>
<a href="#l76.338"></a><span id="l76.338"> // } ----- end row position methods -----</span>
<a href="#l76.339"></a><span id="l76.339"> </span>
<a href="#l76.340"></a><span id="l76.340"> // { ----- begin oid set methods -----</span>
<a href="#l76.341"></a><span id="l76.341"> NS_IMETHODIMP</span>
<a href="#l76.342"></a><span id="l76.342" class="difflineminus">-morkTable::AddOid( // make sure the row with inOid is a table member </span>
<a href="#l76.343"></a><span id="l76.343" class="difflineplus">+morkTable::AddOid( // make sure the row with inOid is a table member</span>
<a href="#l76.344"></a><span id="l76.344">   nsIMdbEnv* mev, // context</span>
<a href="#l76.345"></a><span id="l76.345">   const mdbOid* inOid) // row to ensure membership in table</span>
<a href="#l76.346"></a><span id="l76.346"> {</span>
<a href="#l76.347"></a><span id="l76.347">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l76.348"></a><span id="l76.348">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l76.349"></a><span id="l76.349"> }</span>
<a href="#l76.350"></a><span id="l76.350"> </span>
<a href="#l76.351"></a><span id="l76.351"> NS_IMETHODIMP</span>
<a href="#l76.352"></a><span id="l76.352" class="difflineat">@@ -549,33 +549,33 @@ morkTable::HasOid( // test for the table</span>
<a href="#l76.353"></a><span id="l76.353">     if ( outHasOid )</span>
<a href="#l76.354"></a><span id="l76.354">       *outHasOid = MapHasOid(ev, inOid);</span>
<a href="#l76.355"></a><span id="l76.355">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.356"></a><span id="l76.356">   }</span>
<a href="#l76.357"></a><span id="l76.357">   return outErr;</span>
<a href="#l76.358"></a><span id="l76.358"> }</span>
<a href="#l76.359"></a><span id="l76.359"> </span>
<a href="#l76.360"></a><span id="l76.360"> NS_IMETHODIMP</span>
<a href="#l76.361"></a><span id="l76.361" class="difflineminus">-morkTable::CutOid( // make sure the row with inOid is not a member </span>
<a href="#l76.362"></a><span id="l76.362" class="difflineplus">+morkTable::CutOid( // make sure the row with inOid is not a member</span>
<a href="#l76.363"></a><span id="l76.363">   nsIMdbEnv* mev, // context</span>
<a href="#l76.364"></a><span id="l76.364">   const mdbOid* inOid) // row to remove from table</span>
<a href="#l76.365"></a><span id="l76.365"> {</span>
<a href="#l76.366"></a><span id="l76.366">   nsresult outErr = NS_OK;</span>
<a href="#l76.367"></a><span id="l76.367">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.368"></a><span id="l76.368">   if ( ev )</span>
<a href="#l76.369"></a><span id="l76.369">   {</span>
<a href="#l76.370"></a><span id="l76.370">     if ( inOid &amp;&amp; mTable_Store )</span>
<a href="#l76.371"></a><span id="l76.371">     {</span>
<a href="#l76.372"></a><span id="l76.372">       morkRow* row = mTable_Store-&gt;GetRow(ev, inOid);</span>
<a href="#l76.373"></a><span id="l76.373">       if ( row )</span>
<a href="#l76.374"></a><span id="l76.374">         CutRow(ev, row);</span>
<a href="#l76.375"></a><span id="l76.375">     }</span>
<a href="#l76.376"></a><span id="l76.376">     else</span>
<a href="#l76.377"></a><span id="l76.377">       ev-&gt;NilPointerError();</span>
<a href="#l76.378"></a><span id="l76.378" class="difflineminus">-      </span>
<a href="#l76.379"></a><span id="l76.379" class="difflineplus">+</span>
<a href="#l76.380"></a><span id="l76.380">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.381"></a><span id="l76.381">   }</span>
<a href="#l76.382"></a><span id="l76.382">   return outErr;</span>
<a href="#l76.383"></a><span id="l76.383"> }</span>
<a href="#l76.384"></a><span id="l76.384"> // } ----- end oid set methods -----</span>
<a href="#l76.385"></a><span id="l76.385"> </span>
<a href="#l76.386"></a><span id="l76.386"> // { ----- begin row set methods -----</span>
<a href="#l76.387"></a><span id="l76.387"> NS_IMETHODIMP</span>
<a href="#l76.388"></a><span id="l76.388" class="difflineat">@@ -591,32 +591,32 @@ morkTable::NewRow( // create a new row i</span>
<a href="#l76.389"></a><span id="l76.389">   {</span>
<a href="#l76.390"></a><span id="l76.390">     if ( ioOid &amp;&amp; mTable_Store )</span>
<a href="#l76.391"></a><span id="l76.391">     {</span>
<a href="#l76.392"></a><span id="l76.392">       morkRow* row = 0;</span>
<a href="#l76.393"></a><span id="l76.393">       if ( ioOid-&gt;mOid_Id == morkRow_kMinusOneRid )</span>
<a href="#l76.394"></a><span id="l76.394">         row = mTable_Store-&gt;NewRow(ev, ioOid-&gt;mOid_Scope);</span>
<a href="#l76.395"></a><span id="l76.395">       else</span>
<a href="#l76.396"></a><span id="l76.396">         row = mTable_Store-&gt;NewRowWithOid(ev, ioOid);</span>
<a href="#l76.397"></a><span id="l76.397" class="difflineminus">-        </span>
<a href="#l76.398"></a><span id="l76.398" class="difflineplus">+</span>
<a href="#l76.399"></a><span id="l76.399">       if ( row &amp;&amp; AddRow(ev, row) )</span>
<a href="#l76.400"></a><span id="l76.400">         outRow = row-&gt;AcquireRowHandle(ev, mTable_Store);</span>
<a href="#l76.401"></a><span id="l76.401">     }</span>
<a href="#l76.402"></a><span id="l76.402">     else</span>
<a href="#l76.403"></a><span id="l76.403">       ev-&gt;NilPointerError();</span>
<a href="#l76.404"></a><span id="l76.404" class="difflineminus">-      </span>
<a href="#l76.405"></a><span id="l76.405" class="difflineplus">+</span>
<a href="#l76.406"></a><span id="l76.406">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.407"></a><span id="l76.407">   }</span>
<a href="#l76.408"></a><span id="l76.408">   if ( acqRow )</span>
<a href="#l76.409"></a><span id="l76.409">     *acqRow = outRow;</span>
<a href="#l76.410"></a><span id="l76.410">   return outErr;</span>
<a href="#l76.411"></a><span id="l76.411"> }</span>
<a href="#l76.412"></a><span id="l76.412"> </span>
<a href="#l76.413"></a><span id="l76.413"> NS_IMETHODIMP</span>
<a href="#l76.414"></a><span id="l76.414" class="difflineminus">-morkTable::AddRow( // make sure the row with inOid is a table member </span>
<a href="#l76.415"></a><span id="l76.415" class="difflineplus">+morkTable::AddRow( // make sure the row with inOid is a table member</span>
<a href="#l76.416"></a><span id="l76.416">   nsIMdbEnv* mev, // context</span>
<a href="#l76.417"></a><span id="l76.417">   nsIMdbRow* ioRow) // row to ensure membership in table</span>
<a href="#l76.418"></a><span id="l76.418"> {</span>
<a href="#l76.419"></a><span id="l76.419">   nsresult outErr = NS_OK;</span>
<a href="#l76.420"></a><span id="l76.420">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.421"></a><span id="l76.421">   if ( ev )</span>
<a href="#l76.422"></a><span id="l76.422">   {</span>
<a href="#l76.423"></a><span id="l76.423">     morkRowObject *rowObj = (morkRowObject *) ioRow;</span>
<a href="#l76.424"></a><span id="l76.424" class="difflineat">@@ -643,34 +643,34 @@ morkTable::HasRow( // test for the table</span>
<a href="#l76.425"></a><span id="l76.425">       *outBool = MapHasOid(ev, &amp;row-&gt;mRow_Oid);</span>
<a href="#l76.426"></a><span id="l76.426">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.427"></a><span id="l76.427">   }</span>
<a href="#l76.428"></a><span id="l76.428">   return outErr;</span>
<a href="#l76.429"></a><span id="l76.429"> }</span>
<a href="#l76.430"></a><span id="l76.430"> </span>
<a href="#l76.431"></a><span id="l76.431"> </span>
<a href="#l76.432"></a><span id="l76.432"> NS_IMETHODIMP</span>
<a href="#l76.433"></a><span id="l76.433" class="difflineminus">-morkTable::CutRow( // make sure the row with inOid is not a member </span>
<a href="#l76.434"></a><span id="l76.434" class="difflineplus">+morkTable::CutRow( // make sure the row with inOid is not a member</span>
<a href="#l76.435"></a><span id="l76.435">   nsIMdbEnv* mev, // context</span>
<a href="#l76.436"></a><span id="l76.436">   nsIMdbRow* ioRow) // row to remove from table</span>
<a href="#l76.437"></a><span id="l76.437"> {</span>
<a href="#l76.438"></a><span id="l76.438">   nsresult outErr = NS_OK;</span>
<a href="#l76.439"></a><span id="l76.439">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.440"></a><span id="l76.440">   if ( ev )</span>
<a href="#l76.441"></a><span id="l76.441">   {</span>
<a href="#l76.442"></a><span id="l76.442">     morkRowObject *rowObj = (morkRowObject *) ioRow;</span>
<a href="#l76.443"></a><span id="l76.443">     morkRow* row = rowObj-&gt;mRowObject_Row;</span>
<a href="#l76.444"></a><span id="l76.444">     CutRow(ev, row);</span>
<a href="#l76.445"></a><span id="l76.445">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.446"></a><span id="l76.446">   }</span>
<a href="#l76.447"></a><span id="l76.447">   return outErr;</span>
<a href="#l76.448"></a><span id="l76.448"> }</span>
<a href="#l76.449"></a><span id="l76.449"> </span>
<a href="#l76.450"></a><span id="l76.450"> NS_IMETHODIMP</span>
<a href="#l76.451"></a><span id="l76.451" class="difflineminus">-morkTable::CutAllRows( // remove all rows from the table </span>
<a href="#l76.452"></a><span id="l76.452" class="difflineplus">+morkTable::CutAllRows( // remove all rows from the table</span>
<a href="#l76.453"></a><span id="l76.453">   nsIMdbEnv* mev) // context</span>
<a href="#l76.454"></a><span id="l76.454"> {</span>
<a href="#l76.455"></a><span id="l76.455">   nsresult outErr = NS_OK;</span>
<a href="#l76.456"></a><span id="l76.456">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l76.457"></a><span id="l76.457">   if ( ev )</span>
<a href="#l76.458"></a><span id="l76.458">   {</span>
<a href="#l76.459"></a><span id="l76.459">     CutAllRows(ev);</span>
<a href="#l76.460"></a><span id="l76.460">     outErr = ev-&gt;AsErr();</span>
<a href="#l76.461"></a><span id="l76.461" class="difflineat">@@ -684,17 +684,17 @@ NS_IMETHODIMP</span>
<a href="#l76.462"></a><span id="l76.462"> morkTable::FindRowMatches( // search variable number of sorted cols</span>
<a href="#l76.463"></a><span id="l76.463">   nsIMdbEnv* mev, // context</span>
<a href="#l76.464"></a><span id="l76.464">   const mdbYarn* inPrefix, // content to find as prefix in row's column cell</span>
<a href="#l76.465"></a><span id="l76.465">   nsIMdbTableRowCursor** acqCursor) // set of matching rows</span>
<a href="#l76.466"></a><span id="l76.466"> {</span>
<a href="#l76.467"></a><span id="l76.467">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l76.468"></a><span id="l76.468">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l76.469"></a><span id="l76.469"> }</span>
<a href="#l76.470"></a><span id="l76.470" class="difflineminus">-  </span>
<a href="#l76.471"></a><span id="l76.471" class="difflineplus">+</span>
<a href="#l76.472"></a><span id="l76.472"> NS_IMETHODIMP</span>
<a href="#l76.473"></a><span id="l76.473"> morkTable::GetSearchColumns( // query columns used by FindRowMatches()</span>
<a href="#l76.474"></a><span id="l76.474">   nsIMdbEnv* mev, // context</span>
<a href="#l76.475"></a><span id="l76.475">   mdb_count* outCount, // context</span>
<a href="#l76.476"></a><span id="l76.476">   mdbColumnSet* outColSet) // caller supplied space to put columns</span>
<a href="#l76.477"></a><span id="l76.477">   // GetSearchColumns() returns the columns actually searched when the</span>
<a href="#l76.478"></a><span id="l76.478">   // FindRowMatches() method is called.  No more than mColumnSet_Count</span>
<a href="#l76.479"></a><span id="l76.479">   // slots of mColumnSet_Columns will be written, since mColumnSet_Count</span>
<a href="#l76.480"></a><span id="l76.480" class="difflineat">@@ -710,47 +710,47 @@ morkTable::GetSearchColumns( // query co</span>
<a href="#l76.481"></a><span id="l76.481"> {</span>
<a href="#l76.482"></a><span id="l76.482">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l76.483"></a><span id="l76.483">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l76.484"></a><span id="l76.484"> }</span>
<a href="#l76.485"></a><span id="l76.485"> // } ----- end searching methods -----</span>
<a href="#l76.486"></a><span id="l76.486"> </span>
<a href="#l76.487"></a><span id="l76.487"> // { ----- begin hinting methods -----</span>
<a href="#l76.488"></a><span id="l76.488"> NS_IMETHODIMP</span>
<a href="#l76.489"></a><span id="l76.489" class="difflineminus">-morkTable::SearchColumnsHint( // advise re future expected search cols  </span>
<a href="#l76.490"></a><span id="l76.490" class="difflineplus">+morkTable::SearchColumnsHint( // advise re future expected search cols</span>
<a href="#l76.491"></a><span id="l76.491">   nsIMdbEnv* mev, // context</span>
<a href="#l76.492"></a><span id="l76.492">   const mdbColumnSet* inColumnSet) // columns likely to be searched</span>
<a href="#l76.493"></a><span id="l76.493"> {</span>
<a href="#l76.494"></a><span id="l76.494">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l76.495"></a><span id="l76.495">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l76.496"></a><span id="l76.496"> }</span>
<a href="#l76.497"></a><span id="l76.497" class="difflineminus">-  </span>
<a href="#l76.498"></a><span id="l76.498" class="difflineplus">+</span>
<a href="#l76.499"></a><span id="l76.499"> NS_IMETHODIMP</span>
<a href="#l76.500"></a><span id="l76.500" class="difflineminus">-morkTable::SortColumnsHint( // advise re future expected sort columns  </span>
<a href="#l76.501"></a><span id="l76.501" class="difflineplus">+morkTable::SortColumnsHint( // advise re future expected sort columns</span>
<a href="#l76.502"></a><span id="l76.502">   nsIMdbEnv* mev, // context</span>
<a href="#l76.503"></a><span id="l76.503">   const mdbColumnSet* inColumnSet) // columns for likely sort requests</span>
<a href="#l76.504"></a><span id="l76.504"> {</span>
<a href="#l76.505"></a><span id="l76.505">   NS_ASSERTION(false, &quot;not implemented&quot;);</span>
<a href="#l76.506"></a><span id="l76.506">   return NS_ERROR_NOT_IMPLEMENTED;</span>
<a href="#l76.507"></a><span id="l76.507"> }</span>
<a href="#l76.508"></a><span id="l76.508"> </span>
<a href="#l76.509"></a><span id="l76.509"> NS_IMETHODIMP</span>
<a href="#l76.510"></a><span id="l76.510" class="difflineminus">-morkTable::StartBatchChangeHint( // advise before many adds and cuts  </span>
<a href="#l76.511"></a><span id="l76.511" class="difflineplus">+morkTable::StartBatchChangeHint( // advise before many adds and cuts</span>
<a href="#l76.512"></a><span id="l76.512">   nsIMdbEnv* mev, // context</span>
<a href="#l76.513"></a><span id="l76.513">   const void* inLabel) // intend unique address to match end call</span>
<a href="#l76.514"></a><span id="l76.514">   // If batch starts nest by virtue of nesting calls in the stack, then</span>
<a href="#l76.515"></a><span id="l76.515">   // the address of a local variable makes a good batch start label that</span>
<a href="#l76.516"></a><span id="l76.516">   // can be used at batch end time, and such addresses remain unique.</span>
<a href="#l76.517"></a><span id="l76.517"> {</span>
<a href="#l76.518"></a><span id="l76.518">   // we don't do anything here.</span>
<a href="#l76.519"></a><span id="l76.519">   return NS_OK;</span>
<a href="#l76.520"></a><span id="l76.520"> }</span>
<a href="#l76.521"></a><span id="l76.521"> </span>
<a href="#l76.522"></a><span id="l76.522"> NS_IMETHODIMP</span>
<a href="#l76.523"></a><span id="l76.523" class="difflineminus">-morkTable::EndBatchChangeHint( // advise before many adds and cuts  </span>
<a href="#l76.524"></a><span id="l76.524" class="difflineplus">+morkTable::EndBatchChangeHint( // advise before many adds and cuts</span>
<a href="#l76.525"></a><span id="l76.525">   nsIMdbEnv* mev, // context</span>
<a href="#l76.526"></a><span id="l76.526">   const void* inLabel) // label matching start label</span>
<a href="#l76.527"></a><span id="l76.527">   // Suppose a table is maintaining one or many sort orders for a table,</span>
<a href="#l76.528"></a><span id="l76.528">   // so that every row added to the table must be inserted in each sort,</span>
<a href="#l76.529"></a><span id="l76.529">   // and every row cut must be removed from each sort.  If a db client</span>
<a href="#l76.530"></a><span id="l76.530">   // intends to make many such changes before needing any information</span>
<a href="#l76.531"></a><span id="l76.531">   // about the order or positions of rows inside a table, then a client</span>
<a href="#l76.532"></a><span id="l76.532">   // might tell the table to start batch changes in order to disable</span>
<a href="#l76.533"></a><span id="l76.533" class="difflineat">@@ -970,48 +970,48 @@ mork_refs</span>
<a href="#l76.534"></a><span id="l76.534"> morkTable::CutStrongRef(morkEnv *ev)</span>
<a href="#l76.535"></a><span id="l76.535"> {</span>
<a href="#l76.536"></a><span id="l76.536">   return (mork_refs) Release();</span>
<a href="#l76.537"></a><span id="l76.537"> }</span>
<a href="#l76.538"></a><span id="l76.538"> </span>
<a href="#l76.539"></a><span id="l76.539"> mork_u2</span>
<a href="#l76.540"></a><span id="l76.540"> morkTable::AddTableGcUse(morkEnv* ev)</span>
<a href="#l76.541"></a><span id="l76.541"> {</span>
<a href="#l76.542"></a><span id="l76.542" class="difflineminus">-  MORK_USED_1(ev); </span>
<a href="#l76.543"></a><span id="l76.543" class="difflineplus">+  MORK_USED_1(ev);</span>
<a href="#l76.544"></a><span id="l76.544">   if ( mTable_GcUses &lt; morkTable_kMaxTableGcUses ) // not already maxed out?</span>
<a href="#l76.545"></a><span id="l76.545">     ++mTable_GcUses;</span>
<a href="#l76.546"></a><span id="l76.546" class="difflineminus">-    </span>
<a href="#l76.547"></a><span id="l76.547" class="difflineplus">+</span>
<a href="#l76.548"></a><span id="l76.548">   return mTable_GcUses;</span>
<a href="#l76.549"></a><span id="l76.549"> }</span>
<a href="#l76.550"></a><span id="l76.550"> </span>
<a href="#l76.551"></a><span id="l76.551"> mork_u2</span>
<a href="#l76.552"></a><span id="l76.552"> morkTable::CutTableGcUse(morkEnv* ev)</span>
<a href="#l76.553"></a><span id="l76.553"> {</span>
<a href="#l76.554"></a><span id="l76.554">   if ( mTable_GcUses ) // any outstanding uses to cut?</span>
<a href="#l76.555"></a><span id="l76.555">   {</span>
<a href="#l76.556"></a><span id="l76.556">     if ( mTable_GcUses &lt; morkTable_kMaxTableGcUses ) // not frozen at max?</span>
<a href="#l76.557"></a><span id="l76.557">       --mTable_GcUses;</span>
<a href="#l76.558"></a><span id="l76.558">   }</span>
<a href="#l76.559"></a><span id="l76.559">   else</span>
<a href="#l76.560"></a><span id="l76.560">     this-&gt;TableGcUsesUnderflowWarning(ev);</span>
<a href="#l76.561"></a><span id="l76.561" class="difflineminus">-    </span>
<a href="#l76.562"></a><span id="l76.562" class="difflineplus">+</span>
<a href="#l76.563"></a><span id="l76.563">   return mTable_GcUses;</span>
<a href="#l76.564"></a><span id="l76.564"> }</span>
<a href="#l76.565"></a><span id="l76.565"> </span>
<a href="#l76.566"></a><span id="l76.566"> // table dirty handling more complex thatn morkNode::SetNodeDirty() etc.</span>
<a href="#l76.567"></a><span id="l76.567"> </span>
<a href="#l76.568"></a><span id="l76.568"> void morkTable::SetTableClean(morkEnv* ev)</span>
<a href="#l76.569"></a><span id="l76.569"> {</span>
<a href="#l76.570"></a><span id="l76.570">   if ( mTable_ChangeList.HasListMembers() )</span>
<a href="#l76.571"></a><span id="l76.571">   {</span>
<a href="#l76.572"></a><span id="l76.572">     nsIMdbHeap* heap = mTable_Store-&gt;mPort_Heap;</span>
<a href="#l76.573"></a><span id="l76.573">     mTable_ChangeList.CutAndZapAllListMembers(ev, heap); // forget changes</span>
<a href="#l76.574"></a><span id="l76.574">   }</span>
<a href="#l76.575"></a><span id="l76.575">   mTable_ChangesCount = 0;</span>
<a href="#l76.576"></a><span id="l76.576" class="difflineminus">-  </span>
<a href="#l76.577"></a><span id="l76.577" class="difflineplus">+</span>
<a href="#l76.578"></a><span id="l76.578">   mTable_Flags = 0;</span>
<a href="#l76.579"></a><span id="l76.579">   this-&gt;SetNodeClean();</span>
<a href="#l76.580"></a><span id="l76.580"> }</span>
<a href="#l76.581"></a><span id="l76.581"> </span>
<a href="#l76.582"></a><span id="l76.582"> // notifications regarding table changes:</span>
<a href="#l76.583"></a><span id="l76.583"> </span>
<a href="#l76.584"></a><span id="l76.584"> void morkTable::NoteTableMoveRow(morkEnv* ev, morkRow* ioRow, mork_pos inPos)</span>
<a href="#l76.585"></a><span id="l76.585"> {</span>
<a href="#l76.586"></a><span id="l76.586" class="difflineat">@@ -1130,48 +1130,48 @@ mork_bool morkTable::MaybeDirtySpaceStor</span>
<a href="#l76.587"></a><span id="l76.587">   if ( rowSpace )</span>
<a href="#l76.588"></a><span id="l76.588">   {</span>
<a href="#l76.589"></a><span id="l76.589">     morkStore* store = rowSpace-&gt;mSpace_Store;</span>
<a href="#l76.590"></a><span id="l76.590">     if ( store &amp;&amp; store-&gt;mStore_CanDirty )</span>
<a href="#l76.591"></a><span id="l76.591">     {</span>
<a href="#l76.592"></a><span id="l76.592">       store-&gt;SetStoreDirty();</span>
<a href="#l76.593"></a><span id="l76.593">       rowSpace-&gt;mSpace_CanDirty = morkBool_kTrue;</span>
<a href="#l76.594"></a><span id="l76.594">     }</span>
<a href="#l76.595"></a><span id="l76.595" class="difflineminus">-    </span>
<a href="#l76.596"></a><span id="l76.596" class="difflineplus">+</span>
<a href="#l76.597"></a><span id="l76.597">     if ( rowSpace-&gt;mSpace_CanDirty ) // first time being dirtied?</span>
<a href="#l76.598"></a><span id="l76.598">     {</span>
<a href="#l76.599"></a><span id="l76.599">       if ( this-&gt;IsTableClean() )</span>
<a href="#l76.600"></a><span id="l76.600">       {</span>
<a href="#l76.601"></a><span id="l76.601">         mork_count rowCount = this-&gt;GetRowCount();</span>
<a href="#l76.602"></a><span id="l76.602">         mork_count oneThird = rowCount / 4; // one third of rows</span>
<a href="#l76.603"></a><span id="l76.603">         if ( oneThird &gt; 0x07FFF ) // more than half max u2?</span>
<a href="#l76.604"></a><span id="l76.604">           oneThird = 0x07FFF;</span>
<a href="#l76.605"></a><span id="l76.605" class="difflineminus">-          </span>
<a href="#l76.606"></a><span id="l76.606" class="difflineplus">+</span>
<a href="#l76.607"></a><span id="l76.607">         mTable_ChangesMax = (mork_u2) oneThird;</span>
<a href="#l76.608"></a><span id="l76.608">       }</span>
<a href="#l76.609"></a><span id="l76.609">       this-&gt;SetTableDirty();</span>
<a href="#l76.610"></a><span id="l76.610">       rowSpace-&gt;SetRowSpaceDirty();</span>
<a href="#l76.611"></a><span id="l76.611" class="difflineminus">-      </span>
<a href="#l76.612"></a><span id="l76.612" class="difflineplus">+</span>
<a href="#l76.613"></a><span id="l76.613">       return morkBool_kTrue;</span>
<a href="#l76.614"></a><span id="l76.614">     }</span>
<a href="#l76.615"></a><span id="l76.615">   }</span>
<a href="#l76.616"></a><span id="l76.616">   return morkBool_kFalse;</span>
<a href="#l76.617"></a><span id="l76.617"> }</span>
<a href="#l76.618"></a><span id="l76.618"> </span>
<a href="#l76.619"></a><span id="l76.619"> morkRow*</span>
<a href="#l76.620"></a><span id="l76.620"> morkTable::GetMetaRow(morkEnv* ev, const mdbOid* inOptionalMetaRowOid)</span>
<a href="#l76.621"></a><span id="l76.621"> {</span>
<a href="#l76.622"></a><span id="l76.622">   morkRow* outRow = mTable_MetaRow;</span>
<a href="#l76.623"></a><span id="l76.623">   if ( !outRow )</span>
<a href="#l76.624"></a><span id="l76.624">   {</span>
<a href="#l76.625"></a><span id="l76.625">     morkStore* store = mTable_Store;</span>
<a href="#l76.626"></a><span id="l76.626">     mdbOid* oid = &amp;mTable_MetaRowOid;</span>
<a href="#l76.627"></a><span id="l76.627">     if ( inOptionalMetaRowOid &amp;&amp; !oid-&gt;mOid_Scope )</span>
<a href="#l76.628"></a><span id="l76.628">       *oid = *inOptionalMetaRowOid;</span>
<a href="#l76.629"></a><span id="l76.629" class="difflineminus">-      </span>
<a href="#l76.630"></a><span id="l76.630" class="difflineplus">+</span>
<a href="#l76.631"></a><span id="l76.631">     if ( oid-&gt;mOid_Scope ) // oid already recorded in table?</span>
<a href="#l76.632"></a><span id="l76.632">       outRow = store-&gt;OidToRow(ev, oid);</span>
<a href="#l76.633"></a><span id="l76.633">     else</span>
<a href="#l76.634"></a><span id="l76.634">     {</span>
<a href="#l76.635"></a><span id="l76.635">       outRow = store-&gt;NewRow(ev, morkStore_kMetaScope);</span>
<a href="#l76.636"></a><span id="l76.636">       if ( outRow ) // need to record new oid in table?</span>
<a href="#l76.637"></a><span id="l76.637">         *oid = outRow-&gt;mRow_Oid;</span>
<a href="#l76.638"></a><span id="l76.638">     }</span>
<a href="#l76.639"></a><span id="l76.639" class="difflineat">@@ -1180,17 +1180,17 @@ morkTable::GetMetaRow(morkEnv* ev, const</span>
<a href="#l76.640"></a><span id="l76.640">     {</span>
<a href="#l76.641"></a><span id="l76.641">       outRow-&gt;AddRowGcUse(ev);</span>
<a href="#l76.642"></a><span id="l76.642"> </span>
<a href="#l76.643"></a><span id="l76.643">       this-&gt;SetTableNewMeta();</span>
<a href="#l76.644"></a><span id="l76.644">       if ( this-&gt;IsTableClean() ) // catch dirty status of meta row?</span>
<a href="#l76.645"></a><span id="l76.645">         this-&gt;MaybeDirtySpaceStoreAndTable();</span>
<a href="#l76.646"></a><span id="l76.646">     }</span>
<a href="#l76.647"></a><span id="l76.647">   }</span>
<a href="#l76.648"></a><span id="l76.648" class="difflineminus">-  </span>
<a href="#l76.649"></a><span id="l76.649" class="difflineplus">+</span>
<a href="#l76.650"></a><span id="l76.650">   return outRow;</span>
<a href="#l76.651"></a><span id="l76.651"> }</span>
<a href="#l76.652"></a><span id="l76.652"> </span>
<a href="#l76.653"></a><span id="l76.653"> void</span>
<a href="#l76.654"></a><span id="l76.654"> morkTable::GetTableOid(morkEnv* ev, mdbOid* outOid)</span>
<a href="#l76.655"></a><span id="l76.655"> {</span>
<a href="#l76.656"></a><span id="l76.656">   morkRowSpace* space = mTable_RowSpace;</span>
<a href="#l76.657"></a><span id="l76.657">   if ( space )</span>
<a href="#l76.658"></a><span id="l76.658" class="difflineat">@@ -1207,17 +1207,17 @@ morkTable::AcquireTableHandle(morkEnv* e</span>
<a href="#l76.659"></a><span id="l76.659"> {</span>
<a href="#l76.660"></a><span id="l76.660">   AddRef();</span>
<a href="#l76.661"></a><span id="l76.661">   return this;</span>
<a href="#l76.662"></a><span id="l76.662"> }</span>
<a href="#l76.663"></a><span id="l76.663"> </span>
<a href="#l76.664"></a><span id="l76.664"> mork_pos</span>
<a href="#l76.665"></a><span id="l76.665"> morkTable::ArrayHasOid(morkEnv* ev, const mdbOid* inOid)</span>
<a href="#l76.666"></a><span id="l76.666"> {</span>
<a href="#l76.667"></a><span id="l76.667" class="difflineminus">-  MORK_USED_1(ev); </span>
<a href="#l76.668"></a><span id="l76.668" class="difflineplus">+  MORK_USED_1(ev);</span>
<a href="#l76.669"></a><span id="l76.669">   mork_count count = mTable_RowArray.mArray_Fill;</span>
<a href="#l76.670"></a><span id="l76.670">   mork_pos pos = -1;</span>
<a href="#l76.671"></a><span id="l76.671">   while ( ++pos &lt; (mork_pos)count )</span>
<a href="#l76.672"></a><span id="l76.672">   {</span>
<a href="#l76.673"></a><span id="l76.673">     morkRow* row = (morkRow*) mTable_RowArray.At(pos);</span>
<a href="#l76.674"></a><span id="l76.674">     MORK_ASSERT(row);</span>
<a href="#l76.675"></a><span id="l76.675">     if ( row &amp;&amp; row-&gt;EqualOid(inOid) )</span>
<a href="#l76.676"></a><span id="l76.676">     {</span>
<a href="#l76.677"></a><span id="l76.677" class="difflineat">@@ -1284,62 +1284,62 @@ morkRow* morkTable::find_member_row(mork</span>
<a href="#l76.678"></a><span id="l76.678">   return (morkRow*) 0;</span>
<a href="#l76.679"></a><span id="l76.679"> }</span>
<a href="#l76.680"></a><span id="l76.680"> </span>
<a href="#l76.681"></a><span id="l76.681"> mork_pos</span>
<a href="#l76.682"></a><span id="l76.682"> morkTable::MoveRow(morkEnv* ev, morkRow* ioRow, // change row position</span>
<a href="#l76.683"></a><span id="l76.683">   mork_pos inHintFromPos, // suggested hint regarding start position</span>
<a href="#l76.684"></a><span id="l76.684">   mork_pos inToPos) // desired new position for row ioRow</span>
<a href="#l76.685"></a><span id="l76.685">   // MoveRow() returns the actual position of ioRow afterwards; this</span>
<a href="#l76.686"></a><span id="l76.686" class="difflineminus">-  // position is -1 if and only if ioRow was not found as a member.     </span>
<a href="#l76.687"></a><span id="l76.687" class="difflineplus">+  // position is -1 if and only if ioRow was not found as a member.</span>
<a href="#l76.688"></a><span id="l76.688"> {</span>
<a href="#l76.689"></a><span id="l76.689">   mork_pos outPos = -1; // means ioRow was not a table member</span>
<a href="#l76.690"></a><span id="l76.690">   mork_bool canDirty = ( this-&gt;IsTableClean() )?</span>
<a href="#l76.691"></a><span id="l76.691">     this-&gt;MaybeDirtySpaceStoreAndTable() : morkBool_kTrue;</span>
<a href="#l76.692"></a><span id="l76.692" class="difflineminus">-  </span>
<a href="#l76.693"></a><span id="l76.693" class="difflineplus">+</span>
<a href="#l76.694"></a><span id="l76.694">   morkRow** rows = (morkRow**) mTable_RowArray.mArray_Slots;</span>
<a href="#l76.695"></a><span id="l76.695">   mork_count count = mTable_RowArray.mArray_Fill;</span>
<a href="#l76.696"></a><span id="l76.696">   if ( count &amp;&amp; rows &amp;&amp; ev-&gt;Good() ) // any members at all? no errors?</span>
<a href="#l76.697"></a><span id="l76.697">   {</span>
<a href="#l76.698"></a><span id="l76.698">     mork_pos lastPos = count - 1; // index of last row slot</span>
<a href="#l76.699"></a><span id="l76.699" class="difflineminus">-      </span>
<a href="#l76.700"></a><span id="l76.700" class="difflineplus">+</span>
<a href="#l76.701"></a><span id="l76.701">     if ( inToPos &gt; lastPos ) // beyond last used array slot?</span>
<a href="#l76.702"></a><span id="l76.702">       inToPos = lastPos; // put row into last available slot</span>
<a href="#l76.703"></a><span id="l76.703">     else if ( inToPos &lt; 0 ) // before first usable slot?</span>
<a href="#l76.704"></a><span id="l76.704">       inToPos = 0; // put row in very first slow</span>
<a href="#l76.705"></a><span id="l76.705" class="difflineminus">-      </span>
<a href="#l76.706"></a><span id="l76.706" class="difflineplus">+</span>
<a href="#l76.707"></a><span id="l76.707">     if ( inHintFromPos &gt; lastPos ) // beyond last used array slot?</span>
<a href="#l76.708"></a><span id="l76.708">       inHintFromPos = lastPos; // seek row in last available slot</span>
<a href="#l76.709"></a><span id="l76.709">     else if ( inHintFromPos &lt; 0 ) // before first usable slot?</span>
<a href="#l76.710"></a><span id="l76.710">       inHintFromPos = 0; // seek row in very first slow</span>
<a href="#l76.711"></a><span id="l76.711"> </span>
<a href="#l76.712"></a><span id="l76.712">     morkRow** fromSlot = 0; // becomes nonzero of ioRow is ever found</span>
<a href="#l76.713"></a><span id="l76.713">     morkRow** rowsEnd = rows + count; // one past last used array slot</span>
<a href="#l76.714"></a><span id="l76.714" class="difflineminus">-    </span>
<a href="#l76.715"></a><span id="l76.715" class="difflineplus">+</span>
<a href="#l76.716"></a><span id="l76.716">     if ( inHintFromPos &lt;= 0 ) // start of table? just scan for row?</span>
<a href="#l76.717"></a><span id="l76.717">     {</span>
<a href="#l76.718"></a><span id="l76.718">       morkRow** cursor = rows - 1; // before first array slot</span>
<a href="#l76.719"></a><span id="l76.719">       while ( ++cursor &lt; rowsEnd )</span>
<a href="#l76.720"></a><span id="l76.720">       {</span>
<a href="#l76.721"></a><span id="l76.721">         if ( *cursor == ioRow )</span>
<a href="#l76.722"></a><span id="l76.722">         {</span>
<a href="#l76.723"></a><span id="l76.723">           fromSlot = cursor;</span>
<a href="#l76.724"></a><span id="l76.724">           break; // end while loop</span>
<a href="#l76.725"></a><span id="l76.725">         }</span>
<a href="#l76.726"></a><span id="l76.726">       }</span>
<a href="#l76.727"></a><span id="l76.727">     }</span>
<a href="#l76.728"></a><span id="l76.728">     else // search near the start position and work outwards</span>
<a href="#l76.729"></a><span id="l76.729">     {</span>
<a href="#l76.730"></a><span id="l76.730">       morkRow** lo = rows + inHintFromPos; // lowest search point</span>
<a href="#l76.731"></a><span id="l76.731">       morkRow** hi = lo; // highest search point starts at lowest point</span>
<a href="#l76.732"></a><span id="l76.732" class="difflineminus">-      </span>
<a href="#l76.733"></a><span id="l76.733" class="difflineplus">+</span>
<a href="#l76.734"></a><span id="l76.734">       // Seek ioRow in spiral widening search below and above inHintFromPos.</span>
<a href="#l76.735"></a><span id="l76.735">       // This is faster when inHintFromPos is at all accurate, but is slower</span>
<a href="#l76.736"></a><span id="l76.736">       // than a straightforward scan when inHintFromPos is nearly random.</span>
<a href="#l76.737"></a><span id="l76.737" class="difflineminus">-      </span>
<a href="#l76.738"></a><span id="l76.738" class="difflineplus">+</span>
<a href="#l76.739"></a><span id="l76.739">       while ( lo &gt;= rows || hi &lt; rowsEnd ) // keep searching?</span>
<a href="#l76.740"></a><span id="l76.740">       {</span>
<a href="#l76.741"></a><span id="l76.741">         if ( lo &gt;= rows ) // low direction search still feasible?</span>
<a href="#l76.742"></a><span id="l76.742">         {</span>
<a href="#l76.743"></a><span id="l76.743">           if ( *lo == ioRow ) // actually found the row?</span>
<a href="#l76.744"></a><span id="l76.744">           {</span>
<a href="#l76.745"></a><span id="l76.745">             fromSlot = lo;</span>
<a href="#l76.746"></a><span id="l76.746">             break; // end while loop</span>
<a href="#l76.747"></a><span id="l76.747" class="difflineat">@@ -1352,26 +1352,26 @@ morkTable::MoveRow(morkEnv* ev, morkRow*</span>
<a href="#l76.748"></a><span id="l76.748">           {</span>
<a href="#l76.749"></a><span id="l76.749">             fromSlot = hi;</span>
<a href="#l76.750"></a><span id="l76.750">             break; // end while loop</span>
<a href="#l76.751"></a><span id="l76.751">           }</span>
<a href="#l76.752"></a><span id="l76.752">           ++hi; // advance further higher</span>
<a href="#l76.753"></a><span id="l76.753">         }</span>
<a href="#l76.754"></a><span id="l76.754">       }</span>
<a href="#l76.755"></a><span id="l76.755">     }</span>
<a href="#l76.756"></a><span id="l76.756" class="difflineminus">-    </span>
<a href="#l76.757"></a><span id="l76.757" class="difflineplus">+</span>
<a href="#l76.758"></a><span id="l76.758">     if ( fromSlot ) // ioRow was found as a table member?</span>
<a href="#l76.759"></a><span id="l76.759">     {</span>
<a href="#l76.760"></a><span id="l76.760">       outPos = fromSlot - rows; // actual position where row was found</span>
<a href="#l76.761"></a><span id="l76.761">       if ( outPos != inToPos ) // actually need to move this row?</span>
<a href="#l76.762"></a><span id="l76.762">       {</span>
<a href="#l76.763"></a><span id="l76.763">         morkRow** toSlot = rows + inToPos; // slot where row must go</span>
<a href="#l76.764"></a><span id="l76.764" class="difflineminus">-        </span>
<a href="#l76.765"></a><span id="l76.765" class="difflineplus">+</span>
<a href="#l76.766"></a><span id="l76.766">         ++mTable_RowArray.mArray_Seed; // we modify the array now:</span>
<a href="#l76.767"></a><span id="l76.767" class="difflineminus">-        </span>
<a href="#l76.768"></a><span id="l76.768" class="difflineplus">+</span>
<a href="#l76.769"></a><span id="l76.769">         if ( fromSlot &lt; toSlot ) // row is moving upwards?</span>
<a href="#l76.770"></a><span id="l76.770">         {</span>
<a href="#l76.771"></a><span id="l76.771">           morkRow** up = fromSlot; // leading pointer going upward</span>
<a href="#l76.772"></a><span id="l76.772">           while ( ++up &lt;= toSlot ) // have not gone above destination?</span>
<a href="#l76.773"></a><span id="l76.773">           {</span>
<a href="#l76.774"></a><span id="l76.774">             *fromSlot = *up; // shift down one</span>
<a href="#l76.775"></a><span id="l76.775">             fromSlot = up; // shift trailing pointer up</span>
<a href="#l76.776"></a><span id="l76.776">           }</span>
<a href="#l76.777"></a><span id="l76.777" class="difflineat">@@ -1399,17 +1399,17 @@ morkTable::MoveRow(morkEnv* ev, morkRow*</span>
<a href="#l76.778"></a><span id="l76.778"> mork_bool</span>
<a href="#l76.779"></a><span id="l76.779"> morkTable::AddRow(morkEnv* ev, morkRow* ioRow)</span>
<a href="#l76.780"></a><span id="l76.780"> {</span>
<a href="#l76.781"></a><span id="l76.781">   morkRow* row = this-&gt;find_member_row(ev, ioRow);</span>
<a href="#l76.782"></a><span id="l76.782">   if ( !row &amp;&amp; ev-&gt;Good() )</span>
<a href="#l76.783"></a><span id="l76.783">   {</span>
<a href="#l76.784"></a><span id="l76.784">     mork_bool canDirty = ( this-&gt;IsTableClean() )?</span>
<a href="#l76.785"></a><span id="l76.785">       this-&gt;MaybeDirtySpaceStoreAndTable() : morkBool_kTrue;</span>
<a href="#l76.786"></a><span id="l76.786" class="difflineminus">-      </span>
<a href="#l76.787"></a><span id="l76.787" class="difflineplus">+</span>
<a href="#l76.788"></a><span id="l76.788">     mork_pos pos = mTable_RowArray.AppendSlot(ev, ioRow);</span>
<a href="#l76.789"></a><span id="l76.789">     if ( ev-&gt;Good() &amp;&amp; pos &gt;= 0 )</span>
<a href="#l76.790"></a><span id="l76.790">     {</span>
<a href="#l76.791"></a><span id="l76.791">       ioRow-&gt;AddRowGcUse(ev);</span>
<a href="#l76.792"></a><span id="l76.792">       if ( mTable_RowMap )</span>
<a href="#l76.793"></a><span id="l76.793">       {</span>
<a href="#l76.794"></a><span id="l76.794">         if ( mTable_RowMap-&gt;AddRow(ev, ioRow) )</span>
<a href="#l76.795"></a><span id="l76.795">         {</span>
<a href="#l76.796"></a><span id="l76.796" class="difflineat">@@ -1431,17 +1431,17 @@ morkTable::AddRow(morkEnv* ev, morkRow* </span>
<a href="#l76.797"></a><span id="l76.797"> mork_bool</span>
<a href="#l76.798"></a><span id="l76.798"> morkTable::CutRow(morkEnv* ev, morkRow* ioRow)</span>
<a href="#l76.799"></a><span id="l76.799"> {</span>
<a href="#l76.800"></a><span id="l76.800">   morkRow* row = this-&gt;find_member_row(ev, ioRow);</span>
<a href="#l76.801"></a><span id="l76.801">   if ( row )</span>
<a href="#l76.802"></a><span id="l76.802">   {</span>
<a href="#l76.803"></a><span id="l76.803">     mork_bool canDirty = ( this-&gt;IsTableClean() )?</span>
<a href="#l76.804"></a><span id="l76.804">       this-&gt;MaybeDirtySpaceStoreAndTable() : morkBool_kTrue;</span>
<a href="#l76.805"></a><span id="l76.805" class="difflineminus">-      </span>
<a href="#l76.806"></a><span id="l76.806" class="difflineplus">+</span>
<a href="#l76.807"></a><span id="l76.807">     mork_count count = mTable_RowArray.mArray_Fill;</span>
<a href="#l76.808"></a><span id="l76.808">     morkRow** rowSlots = (morkRow**) mTable_RowArray.mArray_Slots;</span>
<a href="#l76.809"></a><span id="l76.809">     if ( rowSlots ) // array has vector as expected?</span>
<a href="#l76.810"></a><span id="l76.810">     {</span>
<a href="#l76.811"></a><span id="l76.811">       mork_pos pos = -1;</span>
<a href="#l76.812"></a><span id="l76.812">       morkRow** end = rowSlots + count;</span>
<a href="#l76.813"></a><span id="l76.813">       morkRow** slot = rowSlots - 1; // prepare for preincrement:</span>
<a href="#l76.814"></a><span id="l76.814">       while ( ++slot &lt; end ) // another slot to check?</span>
<a href="#l76.815"></a><span id="l76.815" class="difflineat">@@ -1454,17 +1454,17 @@ morkTable::CutRow(morkEnv* ev, morkRow* </span>
<a href="#l76.816"></a><span id="l76.816">       }</span>
<a href="#l76.817"></a><span id="l76.817">       if ( pos &gt;= 0 ) // need to cut if from the array?</span>
<a href="#l76.818"></a><span id="l76.818">         mTable_RowArray.CutSlot(ev, pos);</span>
<a href="#l76.819"></a><span id="l76.819">       else</span>
<a href="#l76.820"></a><span id="l76.820">         ev-&gt;NewWarning(&quot;row not found in array&quot;);</span>
<a href="#l76.821"></a><span id="l76.821">     }</span>
<a href="#l76.822"></a><span id="l76.822">     else</span>
<a href="#l76.823"></a><span id="l76.823">       mTable_RowArray.NilSlotsAddressError(ev);</span>
<a href="#l76.824"></a><span id="l76.824" class="difflineminus">-      </span>
<a href="#l76.825"></a><span id="l76.825" class="difflineplus">+</span>
<a href="#l76.826"></a><span id="l76.826">     if ( mTable_RowMap )</span>
<a href="#l76.827"></a><span id="l76.827">       mTable_RowMap-&gt;CutRow(ev, ioRow);</span>
<a href="#l76.828"></a><span id="l76.828"> </span>
<a href="#l76.829"></a><span id="l76.829">     if ( canDirty )</span>
<a href="#l76.830"></a><span id="l76.830">       this-&gt;NoteTableCutRow(ev, ioRow);</span>
<a href="#l76.831"></a><span id="l76.831"> </span>
<a href="#l76.832"></a><span id="l76.832">     if ( ioRow-&gt;CutRowGcUse(ev) == 0 )</span>
<a href="#l76.833"></a><span id="l76.833">       ioRow-&gt;OnZeroRowGcUse(ev);</span>
<a href="#l76.834"></a><span id="l76.834" class="difflineat">@@ -1476,33 +1476,33 @@ morkTable::CutRow(morkEnv* ev, morkRow* </span>
<a href="#l76.835"></a><span id="l76.835"> mork_bool</span>
<a href="#l76.836"></a><span id="l76.836"> morkTable::CutAllRows(morkEnv* ev)</span>
<a href="#l76.837"></a><span id="l76.837"> {</span>
<a href="#l76.838"></a><span id="l76.838">   if ( this-&gt;MaybeDirtySpaceStoreAndTable() )</span>
<a href="#l76.839"></a><span id="l76.839">   {</span>
<a href="#l76.840"></a><span id="l76.840">     this-&gt;SetTableRewrite(); // everything is dirty</span>
<a href="#l76.841"></a><span id="l76.841">     this-&gt;NoteTableSetAll(ev);</span>
<a href="#l76.842"></a><span id="l76.842">   }</span>
<a href="#l76.843"></a><span id="l76.843" class="difflineminus">-    </span>
<a href="#l76.844"></a><span id="l76.844" class="difflineplus">+</span>
<a href="#l76.845"></a><span id="l76.845">   if ( ev-&gt;Good() )</span>
<a href="#l76.846"></a><span id="l76.846">   {</span>
<a href="#l76.847"></a><span id="l76.847">     mTable_RowArray.CutAllSlots(ev);</span>
<a href="#l76.848"></a><span id="l76.848">     if ( mTable_RowMap )</span>
<a href="#l76.849"></a><span id="l76.849">     {</span>
<a href="#l76.850"></a><span id="l76.850">       morkRowMapIter i(ev, mTable_RowMap);</span>
<a href="#l76.851"></a><span id="l76.851">       mork_change* c = 0;</span>
<a href="#l76.852"></a><span id="l76.852">       morkRow* r = 0;</span>
<a href="#l76.853"></a><span id="l76.853" class="difflineminus">-      </span>
<a href="#l76.854"></a><span id="l76.854" class="difflineplus">+</span>
<a href="#l76.855"></a><span id="l76.855">       for ( c = i.FirstRow(ev, &amp;r); c;  c = i.NextRow(ev, &amp;r) )</span>
<a href="#l76.856"></a><span id="l76.856">       {</span>
<a href="#l76.857"></a><span id="l76.857">         if ( r )</span>
<a href="#l76.858"></a><span id="l76.858">         {</span>
<a href="#l76.859"></a><span id="l76.859">           if ( r-&gt;CutRowGcUse(ev) == 0 )</span>
<a href="#l76.860"></a><span id="l76.860">             r-&gt;OnZeroRowGcUse(ev);</span>
<a href="#l76.861"></a><span id="l76.861" class="difflineminus">-            </span>
<a href="#l76.862"></a><span id="l76.862" class="difflineplus">+</span>
<a href="#l76.863"></a><span id="l76.863">           i.CutHereRow(ev, (morkRow**) 0);</span>
<a href="#l76.864"></a><span id="l76.864">         }</span>
<a href="#l76.865"></a><span id="l76.865">         else</span>
<a href="#l76.866"></a><span id="l76.866">           ev-&gt;NewWarning(&quot;nil row in table map&quot;);</span>
<a href="#l76.867"></a><span id="l76.867">       }</span>
<a href="#l76.868"></a><span id="l76.868">     }</span>
<a href="#l76.869"></a><span id="l76.869">   }</span>
<a href="#l76.870"></a><span id="l76.870">   return ev-&gt;Good();</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l77.1"></a><span id="l77.1" class="difflineminus">--- a/db/mork/src/morkTable.h</span>
<a href="#l77.2"></a><span id="l77.2" class="difflineplus">+++ b/db/mork/src/morkTable.h</span>
<a href="#l77.3"></a><span id="l77.3" class="difflineat">@@ -69,31 +69,31 @@ class nsIMdbTable;</span>
<a href="#l77.4"></a><span id="l77.4"> #define morkTable_kMaxTableGcUses 0x0FF /* max for 8-bit unsigned int */</span>
<a href="#l77.5"></a><span id="l77.5"> </span>
<a href="#l77.6"></a><span id="l77.6"> #define morkTable_kUniqueBit   ((mork_u1) (1 &lt;&lt; 0))</span>
<a href="#l77.7"></a><span id="l77.7"> #define morkTable_kVerboseBit  ((mork_u1) (1 &lt;&lt; 1))</span>
<a href="#l77.8"></a><span id="l77.8"> #define morkTable_kNotedBit    ((mork_u1) (1 &lt;&lt; 2)) /* space has change notes */</span>
<a href="#l77.9"></a><span id="l77.9"> #define morkTable_kRewriteBit  ((mork_u1) (1 &lt;&lt; 3)) /* must rewrite all rows */</span>
<a href="#l77.10"></a><span id="l77.10"> #define morkTable_kNewMetaBit  ((mork_u1) (1 &lt;&lt; 4)) /* new table meta row */</span>
<a href="#l77.11"></a><span id="l77.11"> </span>
<a href="#l77.12"></a><span id="l77.12" class="difflineminus">-class morkTable : public morkObject, public morkLink, public nsIMdbTable { </span>
<a href="#l77.13"></a><span id="l77.13" class="difflineplus">+class morkTable : public morkObject, public morkLink, public nsIMdbTable {</span>
<a href="#l77.14"></a><span id="l77.14"> </span>
<a href="#l77.15"></a><span id="l77.15">   // NOTE the morkLink base is for morkRowSpace::mRowSpace_TablesByPriority</span>
<a href="#l77.16"></a><span id="l77.16"> </span>
<a href="#l77.17"></a><span id="l77.17"> // public: // slots inherited from morkObject (meant to inform only)</span>
<a href="#l77.18"></a><span id="l77.18">   // nsIMdbHeap*    mNode_Heap;</span>
<a href="#l77.19"></a><span id="l77.19"> </span>
<a href="#l77.20"></a><span id="l77.20">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l77.21"></a><span id="l77.21">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l77.22"></a><span id="l77.22" class="difflineminus">-  </span>
<a href="#l77.23"></a><span id="l77.23" class="difflineplus">+</span>
<a href="#l77.24"></a><span id="l77.24">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l77.25"></a><span id="l77.25">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l77.26"></a><span id="l77.26">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l77.27"></a><span id="l77.27">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l77.28"></a><span id="l77.28" class="difflineminus">-  </span>
<a href="#l77.29"></a><span id="l77.29" class="difflineplus">+</span>
<a href="#l77.30"></a><span id="l77.30">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l77.31"></a><span id="l77.31">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l77.32"></a><span id="l77.32"> </span>
<a href="#l77.33"></a><span id="l77.33">   // mork_color   mBead_Color;   // ID for this bead</span>
<a href="#l77.34"></a><span id="l77.34">   // morkHandle*  mObject_Handle;  // weak ref to handle for this object</span>
<a href="#l77.35"></a><span id="l77.35"> </span>
<a href="#l77.36"></a><span id="l77.36"> public: // bead color setter &amp; getter replace obsolete member mTable_Id:</span>
<a href="#l77.37"></a><span id="l77.37"> </span>
<a href="#l77.38"></a><span id="l77.38" class="difflineat">@@ -143,28 +143,28 @@ public: // state is public because the e</span>
<a href="#l77.39"></a><span id="l77.39">   // { ----- begin activity dropping methods -----</span>
<a href="#l77.40"></a><span id="l77.40">   NS_IMETHOD DropActivity( // tell collection usage no longer expected</span>
<a href="#l77.41"></a><span id="l77.41">     nsIMdbEnv* ev) override;</span>
<a href="#l77.42"></a><span id="l77.42">   // } ----- end activity dropping methods -----</span>
<a href="#l77.43"></a><span id="l77.43"> </span>
<a href="#l77.44"></a><span id="l77.44"> // } ===== end nsIMdbCollection methods =====</span>
<a href="#l77.45"></a><span id="l77.45">   NS_IMETHOD SetTablePriority(nsIMdbEnv* ev, mdb_priority inPrio) override;</span>
<a href="#l77.46"></a><span id="l77.46">   NS_IMETHOD GetTablePriority(nsIMdbEnv* ev, mdb_priority* outPrio) override;</span>
<a href="#l77.47"></a><span id="l77.47" class="difflineminus">-  </span>
<a href="#l77.48"></a><span id="l77.48" class="difflineplus">+</span>
<a href="#l77.49"></a><span id="l77.49">   NS_IMETHOD GetTableBeVerbose(nsIMdbEnv* ev, mdb_bool* outBeVerbose) override;</span>
<a href="#l77.50"></a><span id="l77.50">   NS_IMETHOD SetTableBeVerbose(nsIMdbEnv* ev, mdb_bool inBeVerbose) override;</span>
<a href="#l77.51"></a><span id="l77.51" class="difflineminus">-  </span>
<a href="#l77.52"></a><span id="l77.52" class="difflineplus">+</span>
<a href="#l77.53"></a><span id="l77.53">   NS_IMETHOD GetTableIsUnique(nsIMdbEnv* ev, mdb_bool* outIsUnique) override;</span>
<a href="#l77.54"></a><span id="l77.54" class="difflineminus">-  </span>
<a href="#l77.55"></a><span id="l77.55" class="difflineplus">+</span>
<a href="#l77.56"></a><span id="l77.56">   NS_IMETHOD GetTableKind(nsIMdbEnv* ev, mdb_kind* outTableKind) override;</span>
<a href="#l77.57"></a><span id="l77.57">   NS_IMETHOD GetRowScope(nsIMdbEnv* ev, mdb_scope* outRowScope) override;</span>
<a href="#l77.58"></a><span id="l77.58" class="difflineminus">-  </span>
<a href="#l77.59"></a><span id="l77.59" class="difflineplus">+</span>
<a href="#l77.60"></a><span id="l77.60">   NS_IMETHOD GetMetaRow(</span>
<a href="#l77.61"></a><span id="l77.61">     nsIMdbEnv* ev, // context</span>
<a href="#l77.62"></a><span id="l77.62" class="difflineminus">-    const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l77.63"></a><span id="l77.63" class="difflineplus">+    const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l77.64"></a><span id="l77.64">     mdbOid* outOid, // output meta row oid, can be nil to suppress output</span>
<a href="#l77.65"></a><span id="l77.65">     nsIMdbRow** acqRow) override; // acquire table's unique singleton meta row</span>
<a href="#l77.66"></a><span id="l77.66">     // The purpose of a meta row is to support the persistent recording of</span>
<a href="#l77.67"></a><span id="l77.67">     // meta info about a table as cells put into the distinguished meta row.</span>
<a href="#l77.68"></a><span id="l77.68">     // Each table has exactly one meta row, which is not considered a member</span>
<a href="#l77.69"></a><span id="l77.69">     // of the collection of rows inside the table.  The only way to tell</span>
<a href="#l77.70"></a><span id="l77.70">     // whether a row is a meta row is by the fact that it is returned by this</span>
<a href="#l77.71"></a><span id="l77.71">     // GetMetaRow() method from some table. Otherwise nothing distinguishes</span>
<a href="#l77.72"></a><span id="l77.72" class="difflineat">@@ -199,83 +199,83 @@ public: // state is public because the e</span>
<a href="#l77.73"></a><span id="l77.73">     nsIMdbEnv* ev, // context</span>
<a href="#l77.74"></a><span id="l77.74">     mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l77.75"></a><span id="l77.75">     mdbOid* outOid) override; // row oid at the specified position</span>
<a href="#l77.76"></a><span id="l77.76"> </span>
<a href="#l77.77"></a><span id="l77.77">   NS_IMETHOD OidToPos( // test for the table position of a row member</span>
<a href="#l77.78"></a><span id="l77.78">     nsIMdbEnv* ev, // context</span>
<a href="#l77.79"></a><span id="l77.79">     const mdbOid* inOid, // row to find in table</span>
<a href="#l77.80"></a><span id="l77.80">     mdb_pos* outPos) override; // zero-based ordinal position of row in table</span>
<a href="#l77.81"></a><span id="l77.81" class="difflineminus">-    </span>
<a href="#l77.82"></a><span id="l77.82" class="difflineplus">+</span>
<a href="#l77.83"></a><span id="l77.83">   NS_IMETHOD PosToRow( // test for the table position of a row member</span>
<a href="#l77.84"></a><span id="l77.84">     nsIMdbEnv* ev, // context</span>
<a href="#l77.85"></a><span id="l77.85">     mdb_pos inRowPos, // zero-based ordinal position of row in table</span>
<a href="#l77.86"></a><span id="l77.86">     nsIMdbRow** acqRow) override; // acquire row at table position inRowPos</span>
<a href="#l77.87"></a><span id="l77.87" class="difflineminus">-    </span>
<a href="#l77.88"></a><span id="l77.88" class="difflineplus">+</span>
<a href="#l77.89"></a><span id="l77.89">   NS_IMETHOD RowToPos( // test for the table position of a row member</span>
<a href="#l77.90"></a><span id="l77.90">     nsIMdbEnv* ev, // context</span>
<a href="#l77.91"></a><span id="l77.91">     nsIMdbRow* ioRow, // row to find in table</span>
<a href="#l77.92"></a><span id="l77.92">     mdb_pos* outPos) override; // zero-based ordinal position of row in table</span>
<a href="#l77.93"></a><span id="l77.93">   // } ----- end row position methods -----</span>
<a href="#l77.94"></a><span id="l77.94"> </span>
<a href="#l77.95"></a><span id="l77.95">   // { ----- begin oid set methods -----</span>
<a href="#l77.96"></a><span id="l77.96" class="difflineminus">-  NS_IMETHOD AddOid( // make sure the row with inOid is a table member </span>
<a href="#l77.97"></a><span id="l77.97" class="difflineplus">+  NS_IMETHOD AddOid( // make sure the row with inOid is a table member</span>
<a href="#l77.98"></a><span id="l77.98">     nsIMdbEnv* ev, // context</span>
<a href="#l77.99"></a><span id="l77.99">     const mdbOid* inOid) override; // row to ensure membership in table</span>
<a href="#l77.100"></a><span id="l77.100"> </span>
<a href="#l77.101"></a><span id="l77.101">   NS_IMETHOD HasOid( // test for the table position of a row member</span>
<a href="#l77.102"></a><span id="l77.102">     nsIMdbEnv* ev, // context</span>
<a href="#l77.103"></a><span id="l77.103">     const mdbOid* inOid, // row to find in table</span>
<a href="#l77.104"></a><span id="l77.104">     mdb_bool* outHasOid) override; // whether inOid is a member row</span>
<a href="#l77.105"></a><span id="l77.105"> </span>
<a href="#l77.106"></a><span id="l77.106" class="difflineminus">-  NS_IMETHOD CutOid( // make sure the row with inOid is not a member </span>
<a href="#l77.107"></a><span id="l77.107" class="difflineplus">+  NS_IMETHOD CutOid( // make sure the row with inOid is not a member</span>
<a href="#l77.108"></a><span id="l77.108">     nsIMdbEnv* ev, // context</span>
<a href="#l77.109"></a><span id="l77.109">     const mdbOid* inOid) override; // row to remove from table</span>
<a href="#l77.110"></a><span id="l77.110">   // } ----- end oid set methods -----</span>
<a href="#l77.111"></a><span id="l77.111"> </span>
<a href="#l77.112"></a><span id="l77.112">   // { ----- begin row set methods -----</span>
<a href="#l77.113"></a><span id="l77.113">   NS_IMETHOD NewRow( // create a new row instance in table</span>
<a href="#l77.114"></a><span id="l77.114">     nsIMdbEnv* ev, // context</span>
<a href="#l77.115"></a><span id="l77.115">     mdbOid* ioOid, // please use minus one (unbound) rowId for db-assigned IDs</span>
<a href="#l77.116"></a><span id="l77.116">     nsIMdbRow** acqRow) override; // create new row</span>
<a href="#l77.117"></a><span id="l77.117"> </span>
<a href="#l77.118"></a><span id="l77.118" class="difflineminus">-  NS_IMETHOD AddRow( // make sure the row with inOid is a table member </span>
<a href="#l77.119"></a><span id="l77.119" class="difflineplus">+  NS_IMETHOD AddRow( // make sure the row with inOid is a table member</span>
<a href="#l77.120"></a><span id="l77.120">     nsIMdbEnv* ev, // context</span>
<a href="#l77.121"></a><span id="l77.121">     nsIMdbRow* ioRow) override; // row to ensure membership in table</span>
<a href="#l77.122"></a><span id="l77.122"> </span>
<a href="#l77.123"></a><span id="l77.123">   NS_IMETHOD HasRow( // test for the table position of a row member</span>
<a href="#l77.124"></a><span id="l77.124">     nsIMdbEnv* ev, // context</span>
<a href="#l77.125"></a><span id="l77.125">     nsIMdbRow* ioRow, // row to find in table</span>
<a href="#l77.126"></a><span id="l77.126">     mdb_bool* outHasRow) override; // whether row is a table member</span>
<a href="#l77.127"></a><span id="l77.127"> </span>
<a href="#l77.128"></a><span id="l77.128" class="difflineminus">-  NS_IMETHOD CutRow( // make sure the row with inOid is not a member </span>
<a href="#l77.129"></a><span id="l77.129" class="difflineplus">+  NS_IMETHOD CutRow( // make sure the row with inOid is not a member</span>
<a href="#l77.130"></a><span id="l77.130">     nsIMdbEnv* ev, // context</span>
<a href="#l77.131"></a><span id="l77.131">     nsIMdbRow* ioRow) override; // row to remove from table</span>
<a href="#l77.132"></a><span id="l77.132"> </span>
<a href="#l77.133"></a><span id="l77.133">   NS_IMETHOD CutAllRows( // remove all rows from the table</span>
<a href="#l77.134"></a><span id="l77.134">     nsIMdbEnv* ev) override; // context</span>
<a href="#l77.135"></a><span id="l77.135">   // } ----- end row set methods -----</span>
<a href="#l77.136"></a><span id="l77.136"> </span>
<a href="#l77.137"></a><span id="l77.137">   // { ----- begin hinting methods -----</span>
<a href="#l77.138"></a><span id="l77.138" class="difflineminus">-  NS_IMETHOD SearchColumnsHint( // advise re future expected search cols  </span>
<a href="#l77.139"></a><span id="l77.139" class="difflineplus">+  NS_IMETHOD SearchColumnsHint( // advise re future expected search cols</span>
<a href="#l77.140"></a><span id="l77.140">     nsIMdbEnv* ev, // context</span>
<a href="#l77.141"></a><span id="l77.141">     const mdbColumnSet* inColumnSet) override; // columns likely to be searched</span>
<a href="#l77.142"></a><span id="l77.142" class="difflineminus">-    </span>
<a href="#l77.143"></a><span id="l77.143" class="difflineminus">-  NS_IMETHOD SortColumnsHint( // advise re future expected sort columns  </span>
<a href="#l77.144"></a><span id="l77.144" class="difflineplus">+</span>
<a href="#l77.145"></a><span id="l77.145" class="difflineplus">+  NS_IMETHOD SortColumnsHint( // advise re future expected sort columns</span>
<a href="#l77.146"></a><span id="l77.146">     nsIMdbEnv* ev, // context</span>
<a href="#l77.147"></a><span id="l77.147">     const mdbColumnSet* inColumnSet) override; // columns for likely sort requests</span>
<a href="#l77.148"></a><span id="l77.148" class="difflineminus">-    </span>
<a href="#l77.149"></a><span id="l77.149" class="difflineminus">-  NS_IMETHOD StartBatchChangeHint( // advise before many adds and cuts  </span>
<a href="#l77.150"></a><span id="l77.150" class="difflineplus">+</span>
<a href="#l77.151"></a><span id="l77.151" class="difflineplus">+  NS_IMETHOD StartBatchChangeHint( // advise before many adds and cuts</span>
<a href="#l77.152"></a><span id="l77.152">     nsIMdbEnv* ev, // context</span>
<a href="#l77.153"></a><span id="l77.153">     const void* inLabel) override; // intend unique address to match end call</span>
<a href="#l77.154"></a><span id="l77.154">     // If batch starts nest by virtue of nesting calls in the stack, then</span>
<a href="#l77.155"></a><span id="l77.155">     // the address of a local variable makes a good batch start label that</span>
<a href="#l77.156"></a><span id="l77.156">     // can be used at batch end time, and such addresses remain unique.</span>
<a href="#l77.157"></a><span id="l77.157" class="difflineminus">-    </span>
<a href="#l77.158"></a><span id="l77.158" class="difflineminus">-  NS_IMETHOD EndBatchChangeHint( // advise before many adds and cuts  </span>
<a href="#l77.159"></a><span id="l77.159" class="difflineplus">+</span>
<a href="#l77.160"></a><span id="l77.160" class="difflineplus">+  NS_IMETHOD EndBatchChangeHint( // advise before many adds and cuts</span>
<a href="#l77.161"></a><span id="l77.161">     nsIMdbEnv* ev, // context</span>
<a href="#l77.162"></a><span id="l77.162">     const void* inLabel) override; // label matching start label</span>
<a href="#l77.163"></a><span id="l77.163">     // Suppose a table is maintaining one or many sort orders for a table,</span>
<a href="#l77.164"></a><span id="l77.164">     // so that every row added to the table must be inserted in each sort,</span>
<a href="#l77.165"></a><span id="l77.165">     // and every row cut must be removed from each sort.  If a db client</span>
<a href="#l77.166"></a><span id="l77.166">     // intends to make many such changes before needing any information</span>
<a href="#l77.167"></a><span id="l77.167">     // about the order or positions of rows inside a table, then a client</span>
<a href="#l77.168"></a><span id="l77.168">     // might tell the table to start batch changes in order to disable</span>
<a href="#l77.169"></a><span id="l77.169" class="difflineat">@@ -312,22 +312,22 @@ public: // state is public because the e</span>
<a href="#l77.170"></a><span id="l77.170">   // sorting: note all rows are assumed sorted by row ID as a secondary</span>
<a href="#l77.171"></a><span id="l77.171">   // sort following the primary column sort, when table rows are sorted.</span>
<a href="#l77.172"></a><span id="l77.172"> </span>
<a href="#l77.173"></a><span id="l77.173">   NS_IMETHOD</span>
<a href="#l77.174"></a><span id="l77.174">   CanSortColumn( // query which column is currently used for sorting</span>
<a href="#l77.175"></a><span id="l77.175">     nsIMdbEnv* ev, // context</span>
<a href="#l77.176"></a><span id="l77.176">     mdb_column inColumn, // column to query sorting potential</span>
<a href="#l77.177"></a><span id="l77.177">     mdb_bool* outCanSort) override; // whether the column can be sorted</span>
<a href="#l77.178"></a><span id="l77.178" class="difflineminus">-    </span>
<a href="#l77.179"></a><span id="l77.179" class="difflineplus">+</span>
<a href="#l77.180"></a><span id="l77.180">   NS_IMETHOD GetSorting( // view same table in particular sorting</span>
<a href="#l77.181"></a><span id="l77.181">     nsIMdbEnv* ev, // context</span>
<a href="#l77.182"></a><span id="l77.182">     mdb_column inColumn, // requested new column for sorting table</span>
<a href="#l77.183"></a><span id="l77.183">     nsIMdbSorting** acqSorting) override; // acquire sorting for column</span>
<a href="#l77.184"></a><span id="l77.184" class="difflineminus">-    </span>
<a href="#l77.185"></a><span id="l77.185" class="difflineplus">+</span>
<a href="#l77.186"></a><span id="l77.186">   NS_IMETHOD SetSearchSorting( // use this sorting in FindRowMatches()</span>
<a href="#l77.187"></a><span id="l77.187">     nsIMdbEnv* ev, // context</span>
<a href="#l77.188"></a><span id="l77.188">     mdb_column inColumn, // often same as nsIMdbSorting::GetSortColumn()</span>
<a href="#l77.189"></a><span id="l77.189">     nsIMdbSorting* ioSorting) override; // requested sorting for some column</span>
<a href="#l77.190"></a><span id="l77.190">     // SetSearchSorting() attempts to inform the table that ioSorting</span>
<a href="#l77.191"></a><span id="l77.191">     // should be used during calls to FindRowMatches() for searching</span>
<a href="#l77.192"></a><span id="l77.192">     // the column which is actually sorted by ioSorting.  This method</span>
<a href="#l77.193"></a><span id="l77.193">     // is most useful in conjunction with nsIMdbSorting::SetCompare(),</span>
<a href="#l77.194"></a><span id="l77.194" class="difflineat">@@ -348,141 +348,141 @@ public: // state is public because the e</span>
<a href="#l77.195"></a><span id="l77.195">     // implementations are instructed to give precedence to the column</span>
<a href="#l77.196"></a><span id="l77.196">     // specified by ioSorting (so this means callers might just pass</span>
<a href="#l77.197"></a><span id="l77.197">     // zero for inColumn when ioSorting is also provided, since then</span>
<a href="#l77.198"></a><span id="l77.198">     // inColumn is both redundant and ignored).</span>
<a href="#l77.199"></a><span id="l77.199">   // } ----- end sorting methods -----</span>
<a href="#l77.200"></a><span id="l77.200"> </span>
<a href="#l77.201"></a><span id="l77.201">   // { ----- begin moving methods -----</span>
<a href="#l77.202"></a><span id="l77.202">   // moving a row does nothing unless a table is currently unsorted</span>
<a href="#l77.203"></a><span id="l77.203" class="difflineminus">-  </span>
<a href="#l77.204"></a><span id="l77.204" class="difflineplus">+</span>
<a href="#l77.205"></a><span id="l77.205">   NS_IMETHOD MoveOid( // change position of row in unsorted table</span>
<a href="#l77.206"></a><span id="l77.206">     nsIMdbEnv* ev, // context</span>
<a href="#l77.207"></a><span id="l77.207">     const mdbOid* inOid,  // row oid to find in table</span>
<a href="#l77.208"></a><span id="l77.208">     mdb_pos inHintFromPos, // suggested hint regarding start position</span>
<a href="#l77.209"></a><span id="l77.209">     mdb_pos inToPos,       // desired new position for row inRowId</span>
<a href="#l77.210"></a><span id="l77.210">     mdb_pos* outActualPos) override; // actual new position of row in table</span>
<a href="#l77.211"></a><span id="l77.211"> </span>
<a href="#l77.212"></a><span id="l77.212">   NS_IMETHOD MoveRow( // change position of row in unsorted table</span>
<a href="#l77.213"></a><span id="l77.213">     nsIMdbEnv* ev, // context</span>
<a href="#l77.214"></a><span id="l77.214">     nsIMdbRow* ioRow,  // row oid to find in table</span>
<a href="#l77.215"></a><span id="l77.215">     mdb_pos inHintFromPos, // suggested hint regarding start position</span>
<a href="#l77.216"></a><span id="l77.216">     mdb_pos inToPos,       // desired new position for row inRowId</span>
<a href="#l77.217"></a><span id="l77.217">     mdb_pos* outActualPos) override; // actual new position of row in table</span>
<a href="#l77.218"></a><span id="l77.218">   // } ----- end moving methods -----</span>
<a href="#l77.219"></a><span id="l77.219" class="difflineminus">-  </span>
<a href="#l77.220"></a><span id="l77.220" class="difflineplus">+</span>
<a href="#l77.221"></a><span id="l77.221">   // { ----- begin index methods -----</span>
<a href="#l77.222"></a><span id="l77.222">   NS_IMETHOD AddIndex( // create a sorting index for column if possible</span>
<a href="#l77.223"></a><span id="l77.223">     nsIMdbEnv* ev, // context</span>
<a href="#l77.224"></a><span id="l77.224">     mdb_column inColumn, // the column to sort by index</span>
<a href="#l77.225"></a><span id="l77.225">     nsIMdbThumb** acqThumb) override; // acquire thumb for incremental index building</span>
<a href="#l77.226"></a><span id="l77.226">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l77.227"></a><span id="l77.227">   // then the index addition will be finished.</span>
<a href="#l77.228"></a><span id="l77.228" class="difflineminus">-  </span>
<a href="#l77.229"></a><span id="l77.229" class="difflineplus">+</span>
<a href="#l77.230"></a><span id="l77.230">   NS_IMETHOD CutIndex( // stop supporting a specific column index</span>
<a href="#l77.231"></a><span id="l77.231">     nsIMdbEnv* ev, // context</span>
<a href="#l77.232"></a><span id="l77.232">     mdb_column inColumn, // the column with index to be removed</span>
<a href="#l77.233"></a><span id="l77.233">     nsIMdbThumb** acqThumb) override; // acquire thumb for incremental index destroy</span>
<a href="#l77.234"></a><span id="l77.234">   // Call nsIMdbThumb::DoMore() until done, or until the thumb is broken, and</span>
<a href="#l77.235"></a><span id="l77.235">   // then the index removal will be finished.</span>
<a href="#l77.236"></a><span id="l77.236" class="difflineminus">-  </span>
<a href="#l77.237"></a><span id="l77.237" class="difflineplus">+</span>
<a href="#l77.238"></a><span id="l77.238">   NS_IMETHOD HasIndex( // query for current presence of a column index</span>
<a href="#l77.239"></a><span id="l77.239">     nsIMdbEnv* ev, // context</span>
<a href="#l77.240"></a><span id="l77.240">     mdb_column inColumn, // the column to investigate</span>
<a href="#l77.241"></a><span id="l77.241">     mdb_bool* outHasIndex) override; // whether column has index for this column</span>
<a href="#l77.242"></a><span id="l77.242"> </span>
<a href="#l77.243"></a><span id="l77.243" class="difflineminus">-  </span>
<a href="#l77.244"></a><span id="l77.244" class="difflineplus">+</span>
<a href="#l77.245"></a><span id="l77.245">   NS_IMETHOD EnableIndexOnSort( // create an index for col on first sort</span>
<a href="#l77.246"></a><span id="l77.246">     nsIMdbEnv* ev, // context</span>
<a href="#l77.247"></a><span id="l77.247">     mdb_column inColumn) override; // the column to index if ever sorted</span>
<a href="#l77.248"></a><span id="l77.248" class="difflineminus">-  </span>
<a href="#l77.249"></a><span id="l77.249" class="difflineplus">+</span>
<a href="#l77.250"></a><span id="l77.250">   NS_IMETHOD QueryIndexOnSort( // check whether index on sort is enabled</span>
<a href="#l77.251"></a><span id="l77.251">     nsIMdbEnv* ev, // context</span>
<a href="#l77.252"></a><span id="l77.252">     mdb_column inColumn, // the column to investigate</span>
<a href="#l77.253"></a><span id="l77.253">     mdb_bool* outIndexOnSort) override; // whether column has index-on-sort enabled</span>
<a href="#l77.254"></a><span id="l77.254" class="difflineminus">-  </span>
<a href="#l77.255"></a><span id="l77.255" class="difflineplus">+</span>
<a href="#l77.256"></a><span id="l77.256">   NS_IMETHOD DisableIndexOnSort( // prevent future index creation on sort</span>
<a href="#l77.257"></a><span id="l77.257">     nsIMdbEnv* ev, // context</span>
<a href="#l77.258"></a><span id="l77.258">     mdb_column inColumn) override; // the column to index if ever sorted</span>
<a href="#l77.259"></a><span id="l77.259">   // } ----- end index methods -----</span>
<a href="#l77.260"></a><span id="l77.260"> </span>
<a href="#l77.261"></a><span id="l77.261">   morkStore*      mTable_Store;   // non-refcnted ptr to port</span>
<a href="#l77.262"></a><span id="l77.262"> </span>
<a href="#l77.263"></a><span id="l77.263" class="difflineminus">-  // mTable_RowSpace-&gt;SpaceScope() is row scope </span>
<a href="#l77.264"></a><span id="l77.264" class="difflineplus">+  // mTable_RowSpace-&gt;SpaceScope() is row scope</span>
<a href="#l77.265"></a><span id="l77.265">   morkRowSpace*   mTable_RowSpace; // non-refcnted ptr to containing space</span>
<a href="#l77.266"></a><span id="l77.266"> </span>
<a href="#l77.267"></a><span id="l77.267">   morkRow*        mTable_MetaRow; // table's actual meta row</span>
<a href="#l77.268"></a><span id="l77.268">   mdbOid          mTable_MetaRowOid; // oid for meta row</span>
<a href="#l77.269"></a><span id="l77.269" class="difflineminus">-  </span>
<a href="#l77.270"></a><span id="l77.270" class="difflineplus">+</span>
<a href="#l77.271"></a><span id="l77.271">   morkRowMap*     mTable_RowMap;     // (strong ref) hash table of all members</span>
<a href="#l77.272"></a><span id="l77.272">   morkArray       mTable_RowArray;   // array of morkRow pointers</span>
<a href="#l77.273"></a><span id="l77.273" class="difflineminus">-  </span>
<a href="#l77.274"></a><span id="l77.274" class="difflineplus">+</span>
<a href="#l77.275"></a><span id="l77.275">   morkList        mTable_ChangeList;      // list of table changes</span>
<a href="#l77.276"></a><span id="l77.276" class="difflineminus">-  mork_u2         mTable_ChangesCount; // length of changes list </span>
<a href="#l77.277"></a><span id="l77.277" class="difflineminus">-  mork_u2         mTable_ChangesMax;   // max list length before rewrite </span>
<a href="#l77.278"></a><span id="l77.278" class="difflineminus">-  </span>
<a href="#l77.279"></a><span id="l77.279" class="difflineplus">+  mork_u2         mTable_ChangesCount; // length of changes list</span>
<a href="#l77.280"></a><span id="l77.280" class="difflineplus">+  mork_u2         mTable_ChangesMax;   // max list length before rewrite</span>
<a href="#l77.281"></a><span id="l77.281" class="difflineplus">+</span>
<a href="#l77.282"></a><span id="l77.282">   // mork_tid        mTable_Id;</span>
<a href="#l77.283"></a><span id="l77.283">   mork_kind       mTable_Kind;</span>
<a href="#l77.284"></a><span id="l77.284" class="difflineminus">-  </span>
<a href="#l77.285"></a><span id="l77.285" class="difflineplus">+</span>
<a href="#l77.286"></a><span id="l77.286">   mork_u1         mTable_Flags;         // bit flags</span>
<a href="#l77.287"></a><span id="l77.287">   mork_priority   mTable_Priority;      // 0..9, any other value equals 9</span>
<a href="#l77.288"></a><span id="l77.288">   mork_u1         mTable_GcUses;        // persistent references from cells</span>
<a href="#l77.289"></a><span id="l77.289">   mork_u1         mTable_Pad;      // for u4 alignment</span>
<a href="#l77.290"></a><span id="l77.290"> </span>
<a href="#l77.291"></a><span id="l77.291"> public: // flags bit twiddling</span>
<a href="#l77.292"></a><span id="l77.292" class="difflineminus">-  </span>
<a href="#l77.293"></a><span id="l77.293" class="difflineplus">+</span>
<a href="#l77.294"></a><span id="l77.294">   void SetTableUnique() { mTable_Flags |= morkTable_kUniqueBit; }</span>
<a href="#l77.295"></a><span id="l77.295">   void SetTableVerbose() { mTable_Flags |= morkTable_kVerboseBit; }</span>
<a href="#l77.296"></a><span id="l77.296">   void SetTableNoted() { mTable_Flags |= morkTable_kNotedBit; }</span>
<a href="#l77.297"></a><span id="l77.297">   void SetTableRewrite() { mTable_Flags |= morkTable_kRewriteBit; }</span>
<a href="#l77.298"></a><span id="l77.298">   void SetTableNewMeta() { mTable_Flags |= morkTable_kNewMetaBit; }</span>
<a href="#l77.299"></a><span id="l77.299"> </span>
<a href="#l77.300"></a><span id="l77.300">   void ClearTableUnique() { mTable_Flags &amp;= (mork_u1) ~morkTable_kUniqueBit; }</span>
<a href="#l77.301"></a><span id="l77.301">   void ClearTableVerbose() { mTable_Flags &amp;= (mork_u1) ~morkTable_kVerboseBit; }</span>
<a href="#l77.302"></a><span id="l77.302">   void ClearTableNoted() { mTable_Flags &amp;= (mork_u1) ~morkTable_kNotedBit; }</span>
<a href="#l77.303"></a><span id="l77.303">   void ClearTableRewrite() { mTable_Flags &amp;= (mork_u1) ~morkTable_kRewriteBit; }</span>
<a href="#l77.304"></a><span id="l77.304">   void ClearTableNewMeta() { mTable_Flags &amp;= (mork_u1) ~morkTable_kNewMetaBit; }</span>
<a href="#l77.305"></a><span id="l77.305"> </span>
<a href="#l77.306"></a><span id="l77.306">   mork_bool IsTableUnique() const</span>
<a href="#l77.307"></a><span id="l77.307">   { return ( mTable_Flags &amp; morkTable_kUniqueBit ) != 0; }</span>
<a href="#l77.308"></a><span id="l77.308" class="difflineminus">-  </span>
<a href="#l77.309"></a><span id="l77.309" class="difflineplus">+</span>
<a href="#l77.310"></a><span id="l77.310">   mork_bool IsTableVerbose() const</span>
<a href="#l77.311"></a><span id="l77.311">   { return ( mTable_Flags &amp; morkTable_kVerboseBit ) != 0; }</span>
<a href="#l77.312"></a><span id="l77.312" class="difflineminus">-  </span>
<a href="#l77.313"></a><span id="l77.313" class="difflineplus">+</span>
<a href="#l77.314"></a><span id="l77.314">   mork_bool IsTableNoted() const</span>
<a href="#l77.315"></a><span id="l77.315">   { return ( mTable_Flags &amp; morkTable_kNotedBit ) != 0; }</span>
<a href="#l77.316"></a><span id="l77.316" class="difflineminus">-  </span>
<a href="#l77.317"></a><span id="l77.317" class="difflineplus">+</span>
<a href="#l77.318"></a><span id="l77.318">   mork_bool IsTableRewrite() const</span>
<a href="#l77.319"></a><span id="l77.319">   { return ( mTable_Flags &amp; morkTable_kRewriteBit ) != 0; }</span>
<a href="#l77.320"></a><span id="l77.320" class="difflineminus">-  </span>
<a href="#l77.321"></a><span id="l77.321" class="difflineplus">+</span>
<a href="#l77.322"></a><span id="l77.322">   mork_bool IsTableNewMeta() const</span>
<a href="#l77.323"></a><span id="l77.323">   { return ( mTable_Flags &amp; morkTable_kNewMetaBit ) != 0; }</span>
<a href="#l77.324"></a><span id="l77.324"> </span>
<a href="#l77.325"></a><span id="l77.325"> public: // table dirty handling more complex than morkNode::SetNodeDirty() etc.</span>
<a href="#l77.326"></a><span id="l77.326"> </span>
<a href="#l77.327"></a><span id="l77.327">   void SetTableDirty() { this-&gt;SetNodeDirty(); }</span>
<a href="#l77.328"></a><span id="l77.328">   void SetTableClean(morkEnv* ev);</span>
<a href="#l77.329"></a><span id="l77.329" class="difflineminus">-   </span>
<a href="#l77.330"></a><span id="l77.330" class="difflineplus">+</span>
<a href="#l77.331"></a><span id="l77.331">   mork_bool IsTableClean() const { return this-&gt;IsNodeClean(); }</span>
<a href="#l77.332"></a><span id="l77.332">   mork_bool IsTableDirty() const { return this-&gt;IsNodeDirty(); }</span>
<a href="#l77.333"></a><span id="l77.333"> </span>
<a href="#l77.334"></a><span id="l77.334"> public: // morkNode memory management operators</span>
<a href="#l77.335"></a><span id="l77.335">   void* operator new(size_t inSize, nsIMdbHeap&amp; ioHeap, morkEnv* ev) CPP_THROW_NEW</span>
<a href="#l77.336"></a><span id="l77.336">   { return morkNode::MakeNew(inSize, ioHeap, ev); }</span>
<a href="#l77.337"></a><span id="l77.337" class="difflineminus">-  </span>
<a href="#l77.338"></a><span id="l77.338" class="difflineminus">- </span>
<a href="#l77.339"></a><span id="l77.339" class="difflineplus">+</span>
<a href="#l77.340"></a><span id="l77.340" class="difflineplus">+</span>
<a href="#l77.341"></a><span id="l77.341"> // { ===== begin morkNode interface =====</span>
<a href="#l77.342"></a><span id="l77.342"> public: // morkNode virtual methods</span>
<a href="#l77.343"></a><span id="l77.343">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseTable() if open</span>
<a href="#l77.344"></a><span id="l77.344" class="difflineminus">-  </span>
<a href="#l77.345"></a><span id="l77.345" class="difflineplus">+</span>
<a href="#l77.346"></a><span id="l77.346"> public: // morkTable construction &amp; destruction</span>
<a href="#l77.347"></a><span id="l77.347">   morkTable(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l77.348"></a><span id="l77.348">     nsIMdbHeap* ioNodeHeap, morkStore* ioStore,</span>
<a href="#l77.349"></a><span id="l77.349">     nsIMdbHeap* ioSlotHeap, morkRowSpace* ioRowSpace,</span>
<a href="#l77.350"></a><span id="l77.350" class="difflineminus">-    const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying </span>
<a href="#l77.351"></a><span id="l77.351" class="difflineplus">+    const mdbOid* inOptionalMetaRowOid, // can be nil to avoid specifying</span>
<a href="#l77.352"></a><span id="l77.352">     mork_tid inTableId,</span>
<a href="#l77.353"></a><span id="l77.353">     mork_kind inKind, mork_bool inMustBeUnique);</span>
<a href="#l77.354"></a><span id="l77.354">   void CloseTable(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l77.355"></a><span id="l77.355"> </span>
<a href="#l77.356"></a><span id="l77.356"> private: // copying is not allowed</span>
<a href="#l77.357"></a><span id="l77.357">   morkTable(const morkTable&amp; other);</span>
<a href="#l77.358"></a><span id="l77.358">   morkTable&amp; operator=(const morkTable&amp; other);</span>
<a href="#l77.359"></a><span id="l77.359">   virtual ~morkTable(); // assert that close executed earlier</span>
<a href="#l77.360"></a><span id="l77.360" class="difflineat">@@ -505,127 +505,127 @@ public: // noting table changes</span>
<a href="#l77.361"></a><span id="l77.361">   mork_bool HasChangeOverflow() const</span>
<a href="#l77.362"></a><span id="l77.362">   { return mTable_ChangesCount &gt;= mTable_ChangesMax; }</span>
<a href="#l77.363"></a><span id="l77.363"> </span>
<a href="#l77.364"></a><span id="l77.364">   void NoteTableSetAll(morkEnv* ev);</span>
<a href="#l77.365"></a><span id="l77.365">   void NoteTableMoveRow(morkEnv* ev, morkRow* ioRow, mork_pos inPos);</span>
<a href="#l77.366"></a><span id="l77.366"> </span>
<a href="#l77.367"></a><span id="l77.367">   void note_row_change(morkEnv* ev, mork_change inChange, morkRow* ioRow);</span>
<a href="#l77.368"></a><span id="l77.368">   void note_row_move(morkEnv* ev, morkRow* ioRow, mork_pos inNewPos);</span>
<a href="#l77.369"></a><span id="l77.369" class="difflineminus">-  </span>
<a href="#l77.370"></a><span id="l77.370" class="difflineplus">+</span>
<a href="#l77.371"></a><span id="l77.371">   void NoteTableAddRow(morkEnv* ev, morkRow* ioRow)</span>
<a href="#l77.372"></a><span id="l77.372">   { this-&gt;note_row_change(ev, morkChange_kAdd, ioRow); }</span>
<a href="#l77.373"></a><span id="l77.373" class="difflineminus">-  </span>
<a href="#l77.374"></a><span id="l77.374" class="difflineplus">+</span>
<a href="#l77.375"></a><span id="l77.375">   void NoteTableCutRow(morkEnv* ev, morkRow* ioRow)</span>
<a href="#l77.376"></a><span id="l77.376">   { this-&gt;note_row_change(ev, morkChange_kCut, ioRow); }</span>
<a href="#l77.377"></a><span id="l77.377" class="difflineminus">-  </span>
<a href="#l77.378"></a><span id="l77.378" class="difflineplus">+</span>
<a href="#l77.379"></a><span id="l77.379"> protected: // internal row map methods</span>
<a href="#l77.380"></a><span id="l77.380"> </span>
<a href="#l77.381"></a><span id="l77.381">   morkRow* find_member_row(morkEnv* ev, morkRow* ioRow);</span>
<a href="#l77.382"></a><span id="l77.382">   void build_row_map(morkEnv* ev);</span>
<a href="#l77.383"></a><span id="l77.383"> </span>
<a href="#l77.384"></a><span id="l77.384"> public: // other table methods</span>
<a href="#l77.385"></a><span id="l77.385" class="difflineminus">-  </span>
<a href="#l77.386"></a><span id="l77.386" class="difflineplus">+</span>
<a href="#l77.387"></a><span id="l77.387">   mork_bool MaybeDirtySpaceStoreAndTable();</span>
<a href="#l77.388"></a><span id="l77.388"> </span>
<a href="#l77.389"></a><span id="l77.389">   morkRow* GetMetaRow(morkEnv* ev, const mdbOid* inOptionalMetaRowOid);</span>
<a href="#l77.390"></a><span id="l77.390" class="difflineminus">-  </span>
<a href="#l77.391"></a><span id="l77.391" class="difflineplus">+</span>
<a href="#l77.392"></a><span id="l77.392">   mork_u2 AddTableGcUse(morkEnv* ev);</span>
<a href="#l77.393"></a><span id="l77.393">   mork_u2 CutTableGcUse(morkEnv* ev);</span>
<a href="#l77.394"></a><span id="l77.394"> </span>
<a href="#l77.395"></a><span id="l77.395">   // void DirtyAllTableContent(morkEnv* ev);</span>
<a href="#l77.396"></a><span id="l77.396"> </span>
<a href="#l77.397"></a><span id="l77.397">   mork_seed TableSeed() const { return mTable_RowArray.mArray_Seed; }</span>
<a href="#l77.398"></a><span id="l77.398" class="difflineminus">-  </span>
<a href="#l77.399"></a><span id="l77.399" class="difflineplus">+</span>
<a href="#l77.400"></a><span id="l77.400">   morkRow* SafeRowAt(morkEnv* ev, mork_pos inPos)</span>
<a href="#l77.401"></a><span id="l77.401">   { return (morkRow*) mTable_RowArray.SafeAt(ev, inPos); }</span>
<a href="#l77.402"></a><span id="l77.402"> </span>
<a href="#l77.403"></a><span id="l77.403">   nsIMdbTable* AcquireTableHandle(morkEnv* ev); // mObject_Handle</span>
<a href="#l77.404"></a><span id="l77.404" class="difflineminus">-  </span>
<a href="#l77.405"></a><span id="l77.405" class="difflineplus">+</span>
<a href="#l77.406"></a><span id="l77.406">   mork_count GetRowCount() const { return mTable_RowArray.mArray_Fill; }</span>
<a href="#l77.407"></a><span id="l77.407"> </span>
<a href="#l77.408"></a><span id="l77.408">   mork_bool IsTableUsed() const</span>
<a href="#l77.409"></a><span id="l77.409">   { return (mTable_GcUses != 0 || this-&gt;GetRowCount() != 0); }</span>
<a href="#l77.410"></a><span id="l77.410"> </span>
<a href="#l77.411"></a><span id="l77.411">   void GetTableOid(morkEnv* ev, mdbOid* outOid);</span>
<a href="#l77.412"></a><span id="l77.412">   mork_pos  ArrayHasOid(morkEnv* ev, const mdbOid* inOid);</span>
<a href="#l77.413"></a><span id="l77.413">   mork_bool MapHasOid(morkEnv* ev, const mdbOid* inOid);</span>
<a href="#l77.414"></a><span id="l77.414">   mork_bool AddRow(morkEnv* ev, morkRow* ioRow); // returns ev-&gt;Good()</span>
<a href="#l77.415"></a><span id="l77.415">   mork_bool CutRow(morkEnv* ev, morkRow* ioRow); // returns ev-&gt;Good()</span>
<a href="#l77.416"></a><span id="l77.416">   mork_bool CutAllRows(morkEnv* ev); // returns ev-&gt;Good()</span>
<a href="#l77.417"></a><span id="l77.417" class="difflineminus">-  </span>
<a href="#l77.418"></a><span id="l77.418" class="difflineplus">+</span>
<a href="#l77.419"></a><span id="l77.419">   mork_pos MoveRow(morkEnv* ev, morkRow* ioRow, // change row position</span>
<a href="#l77.420"></a><span id="l77.420">     mork_pos inHintFromPos, // suggested hint regarding start position</span>
<a href="#l77.421"></a><span id="l77.421">     mork_pos inToPos); // desired new position for row ioRow</span>
<a href="#l77.422"></a><span id="l77.422">     // MoveRow() returns the actual position of ioRow afterwards; this</span>
<a href="#l77.423"></a><span id="l77.423" class="difflineminus">-    // position is -1 if and only if ioRow was not found as a member.     </span>
<a href="#l77.424"></a><span id="l77.424" class="difflineplus">+    // position is -1 if and only if ioRow was not found as a member.</span>
<a href="#l77.425"></a><span id="l77.425"> </span>
<a href="#l77.426"></a><span id="l77.426"> </span>
<a href="#l77.427"></a><span id="l77.427">   morkTableRowCursor* NewTableRowCursor(morkEnv* ev, mork_pos inRowPos);</span>
<a href="#l77.428"></a><span id="l77.428"> </span>
<a href="#l77.429"></a><span id="l77.429"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l77.430"></a><span id="l77.430">   static void SlotWeakTable(morkTable* me,</span>
<a href="#l77.431"></a><span id="l77.431">     morkEnv* ev, morkTable** ioSlot)</span>
<a href="#l77.432"></a><span id="l77.432">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l77.433"></a><span id="l77.433" class="difflineminus">-  </span>
<a href="#l77.434"></a><span id="l77.434" class="difflineplus">+</span>
<a href="#l77.435"></a><span id="l77.435">   static void SlotStrongTable(morkTable* me,</span>
<a href="#l77.436"></a><span id="l77.436">     morkEnv* ev, morkTable** ioSlot)</span>
<a href="#l77.437"></a><span id="l77.437">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l77.438"></a><span id="l77.438"> };</span>
<a href="#l77.439"></a><span id="l77.439"> </span>
<a href="#l77.440"></a><span id="l77.440"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l77.441"></a><span id="l77.441"> </span>
<a href="#l77.442"></a><span id="l77.442"> // use negative values for kCut and kAdd, to keep non-neg move pos distinct:</span>
<a href="#l77.443"></a><span id="l77.443"> #define morkTableChange_kCut ((mork_pos) -1) /* shows row was cut */</span>
<a href="#l77.444"></a><span id="l77.444"> #define morkTableChange_kAdd ((mork_pos) -2) /* shows row was added */</span>
<a href="#l77.445"></a><span id="l77.445"> #define morkTableChange_kNone ((mork_pos) -3) /* unknown change */</span>
<a href="#l77.446"></a><span id="l77.446"> </span>
<a href="#l77.447"></a><span id="l77.447" class="difflineminus">-class morkTableChange : public morkNext { </span>
<a href="#l77.448"></a><span id="l77.448" class="difflineplus">+class morkTableChange : public morkNext {</span>
<a href="#l77.449"></a><span id="l77.449"> public: // state is public because the entire Mork system is private</span>
<a href="#l77.450"></a><span id="l77.450"> </span>
<a href="#l77.451"></a><span id="l77.451">   morkRow*  mTableChange_Row; // the row in the change</span>
<a href="#l77.452"></a><span id="l77.452" class="difflineminus">-  </span>
<a href="#l77.453"></a><span id="l77.453" class="difflineplus">+</span>
<a href="#l77.454"></a><span id="l77.454">   mork_pos  mTableChange_Pos; // kAdd, kCut, or non-neg for row move</span>
<a href="#l77.455"></a><span id="l77.455"> </span>
<a href="#l77.456"></a><span id="l77.456"> public:</span>
<a href="#l77.457"></a><span id="l77.457">   morkTableChange(morkEnv* ev, mork_change inChange, morkRow* ioRow);</span>
<a href="#l77.458"></a><span id="l77.458">   // use this constructor for inChange == morkChange_kAdd or morkChange_kCut</span>
<a href="#l77.459"></a><span id="l77.459" class="difflineminus">-  </span>
<a href="#l77.460"></a><span id="l77.460" class="difflineplus">+</span>
<a href="#l77.461"></a><span id="l77.461">   morkTableChange(morkEnv* ev, morkRow* ioRow, mork_pos inPos);</span>
<a href="#l77.462"></a><span id="l77.462">   // use this constructor when the row is moved</span>
<a href="#l77.463"></a><span id="l77.463"> </span>
<a href="#l77.464"></a><span id="l77.464"> public:</span>
<a href="#l77.465"></a><span id="l77.465">   void UnknownChangeError(morkEnv* ev) const; // morkChange_kAdd or morkChange_kCut</span>
<a href="#l77.466"></a><span id="l77.466">   void NegativeMovePosError(morkEnv* ev) const; // move must be non-neg position</span>
<a href="#l77.467"></a><span id="l77.467" class="difflineminus">-  </span>
<a href="#l77.468"></a><span id="l77.468" class="difflineplus">+</span>
<a href="#l77.469"></a><span id="l77.469"> public:</span>
<a href="#l77.470"></a><span id="l77.470" class="difflineminus">-  </span>
<a href="#l77.471"></a><span id="l77.471" class="difflineplus">+</span>
<a href="#l77.472"></a><span id="l77.472">   mork_bool IsAddRowTableChange() const</span>
<a href="#l77.473"></a><span id="l77.473">   { return ( mTableChange_Pos == morkTableChange_kAdd ); }</span>
<a href="#l77.474"></a><span id="l77.474" class="difflineminus">-  </span>
<a href="#l77.475"></a><span id="l77.475" class="difflineplus">+</span>
<a href="#l77.476"></a><span id="l77.476">   mork_bool IsCutRowTableChange() const</span>
<a href="#l77.477"></a><span id="l77.477">   { return ( mTableChange_Pos == morkTableChange_kCut ); }</span>
<a href="#l77.478"></a><span id="l77.478" class="difflineminus">-  </span>
<a href="#l77.479"></a><span id="l77.479" class="difflineplus">+</span>
<a href="#l77.480"></a><span id="l77.480">   mork_bool IsMoveRowTableChange() const</span>
<a href="#l77.481"></a><span id="l77.481">   { return ( mTableChange_Pos &gt;= 0 ); }</span>
<a href="#l77.482"></a><span id="l77.482"> </span>
<a href="#l77.483"></a><span id="l77.483"> public:</span>
<a href="#l77.484"></a><span id="l77.484" class="difflineminus">-  </span>
<a href="#l77.485"></a><span id="l77.485" class="difflineplus">+</span>
<a href="#l77.486"></a><span id="l77.486">   mork_pos GetMovePos() const { return mTableChange_Pos; }</span>
<a href="#l77.487"></a><span id="l77.487">   // GetMovePos() assumes that IsMoveRowTableChange() is true.</span>
<a href="#l77.488"></a><span id="l77.488"> };</span>
<a href="#l77.489"></a><span id="l77.489"> </span>
<a href="#l77.490"></a><span id="l77.490"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l77.491"></a><span id="l77.491"> </span>
<a href="#l77.492"></a><span id="l77.492"> #define morkDerived_kTableMap  /*i*/ 0x744D /* ascii 'tM' */</span>
<a href="#l77.493"></a><span id="l77.493"> </span>
<a href="#l77.494"></a><span id="l77.494"> /*| morkTableMap: maps mork_token -&gt; morkTable</span>
<a href="#l77.495"></a><span id="l77.495"> |*/</span>
<a href="#l77.496"></a><span id="l77.496"> #ifdef MORK_BEAD_OVER_NODE_MAPS</span>
<a href="#l77.497"></a><span id="l77.497" class="difflineminus">-class morkTableMap : public morkBeadMap { </span>
<a href="#l77.498"></a><span id="l77.498" class="difflineplus">+class morkTableMap : public morkBeadMap {</span>
<a href="#l77.499"></a><span id="l77.499"> #else /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l77.500"></a><span id="l77.500"> class morkTableMap : public morkNodeMap { // for mapping tokens to tables</span>
<a href="#l77.501"></a><span id="l77.501"> #endif /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l77.502"></a><span id="l77.502"> </span>
<a href="#l77.503"></a><span id="l77.503"> public:</span>
<a href="#l77.504"></a><span id="l77.504"> </span>
<a href="#l77.505"></a><span id="l77.505">   virtual ~morkTableMap();</span>
<a href="#l77.506"></a><span id="l77.506">   morkTableMap(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l77.507"></a><span id="l77.507" class="difflineat">@@ -635,35 +635,35 @@ public: // other map methods</span>
<a href="#l77.508"></a><span id="l77.508"> </span>
<a href="#l77.509"></a><span id="l77.509"> #ifdef MORK_BEAD_OVER_NODE_MAPS</span>
<a href="#l77.510"></a><span id="l77.510">   mork_bool  AddTable(morkEnv* ev, morkTable* ioTable)</span>
<a href="#l77.511"></a><span id="l77.511">   { return this-&gt;AddBead(ev, ioTable); }</span>
<a href="#l77.512"></a><span id="l77.512">   // the AddTable() boolean return equals ev-&gt;Good().</span>
<a href="#l77.513"></a><span id="l77.513"> </span>
<a href="#l77.514"></a><span id="l77.514">   mork_bool  CutTable(morkEnv* ev, mork_tid inTid)</span>
<a href="#l77.515"></a><span id="l77.515">   { return this-&gt;CutBead(ev, inTid); }</span>
<a href="#l77.516"></a><span id="l77.516" class="difflineminus">-  // The CutTable() boolean return indicates whether removal happened. </span>
<a href="#l77.517"></a><span id="l77.517" class="difflineminus">-  </span>
<a href="#l77.518"></a><span id="l77.518" class="difflineplus">+  // The CutTable() boolean return indicates whether removal happened.</span>
<a href="#l77.519"></a><span id="l77.519" class="difflineplus">+</span>
<a href="#l77.520"></a><span id="l77.520">   morkTable*  GetTable(morkEnv* ev, mork_tid inTid)</span>
<a href="#l77.521"></a><span id="l77.521">   { return (morkTable*) this-&gt;GetBead(ev, inTid); }</span>
<a href="#l77.522"></a><span id="l77.522">   // Note the returned table does NOT have an increase in refcount for this.</span>
<a href="#l77.523"></a><span id="l77.523"> </span>
<a href="#l77.524"></a><span id="l77.524">   mork_num CutAllTables(morkEnv* ev)</span>
<a href="#l77.525"></a><span id="l77.525">   { return this-&gt;CutAllBeads(ev); }</span>
<a href="#l77.526"></a><span id="l77.526">   // CutAllTables() releases all the referenced table values.</span>
<a href="#l77.527"></a><span id="l77.527" class="difflineminus">-  </span>
<a href="#l77.528"></a><span id="l77.528" class="difflineplus">+</span>
<a href="#l77.529"></a><span id="l77.529"> #else /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l77.530"></a><span id="l77.530">   mork_bool  AddTable(morkEnv* ev, morkTable* ioTable)</span>
<a href="#l77.531"></a><span id="l77.531">   { return this-&gt;AddNode(ev, ioTable-&gt;TableId(), ioTable); }</span>
<a href="#l77.532"></a><span id="l77.532">   // the AddTable() boolean return equals ev-&gt;Good().</span>
<a href="#l77.533"></a><span id="l77.533"> </span>
<a href="#l77.534"></a><span id="l77.534">   mork_bool  CutTable(morkEnv* ev, mork_tid inTid)</span>
<a href="#l77.535"></a><span id="l77.535">   { return this-&gt;CutNode(ev, inTid); }</span>
<a href="#l77.536"></a><span id="l77.536" class="difflineminus">-  // The CutTable() boolean return indicates whether removal happened. </span>
<a href="#l77.537"></a><span id="l77.537" class="difflineminus">-  </span>
<a href="#l77.538"></a><span id="l77.538" class="difflineplus">+  // The CutTable() boolean return indicates whether removal happened.</span>
<a href="#l77.539"></a><span id="l77.539" class="difflineplus">+</span>
<a href="#l77.540"></a><span id="l77.540">   morkTable*  GetTable(morkEnv* ev, mork_tid inTid)</span>
<a href="#l77.541"></a><span id="l77.541">   { return (morkTable*) this-&gt;GetNode(ev, inTid); }</span>
<a href="#l77.542"></a><span id="l77.542">   // Note the returned table does NOT have an increase in refcount for this.</span>
<a href="#l77.543"></a><span id="l77.543"> </span>
<a href="#l77.544"></a><span id="l77.544">   mork_num CutAllTables(morkEnv* ev)</span>
<a href="#l77.545"></a><span id="l77.545">   { return this-&gt;CutAllNodes(ev); }</span>
<a href="#l77.546"></a><span id="l77.546">   // CutAllTables() releases all the referenced table values.</span>
<a href="#l77.547"></a><span id="l77.547"> #endif /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l77.548"></a><span id="l77.548" class="difflineat">@@ -676,51 +676,51 @@ class morkTableMapIter: public morkBeadM</span>
<a href="#l77.549"></a><span id="l77.549"> class morkTableMapIter: public morkMapIter{ // typesafe wrapper class</span>
<a href="#l77.550"></a><span id="l77.550"> #endif /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l77.551"></a><span id="l77.551"> </span>
<a href="#l77.552"></a><span id="l77.552"> public:</span>
<a href="#l77.553"></a><span id="l77.553"> </span>
<a href="#l77.554"></a><span id="l77.554"> #ifdef MORK_BEAD_OVER_NODE_MAPS</span>
<a href="#l77.555"></a><span id="l77.555">   morkTableMapIter(morkEnv* ev, morkTableMap* ioMap)</span>
<a href="#l77.556"></a><span id="l77.556">   : morkBeadMapIter(ev, ioMap) { }</span>
<a href="#l77.557"></a><span id="l77.557" class="difflineminus">- </span>
<a href="#l77.558"></a><span id="l77.558" class="difflineplus">+</span>
<a href="#l77.559"></a><span id="l77.559">   morkTableMapIter( ) : morkBeadMapIter()  { }</span>
<a href="#l77.560"></a><span id="l77.560">   void InitTableMapIter(morkEnv* ev, morkTableMap* ioMap)</span>
<a href="#l77.561"></a><span id="l77.561">   { this-&gt;InitBeadMapIter(ev, ioMap); }</span>
<a href="#l77.562"></a><span id="l77.562" class="difflineminus">-   </span>
<a href="#l77.563"></a><span id="l77.563" class="difflineplus">+</span>
<a href="#l77.564"></a><span id="l77.564">   morkTable* FirstTable(morkEnv* ev)</span>
<a href="#l77.565"></a><span id="l77.565">   { return (morkTable*) this-&gt;FirstBead(ev); }</span>
<a href="#l77.566"></a><span id="l77.566" class="difflineminus">-  </span>
<a href="#l77.567"></a><span id="l77.567" class="difflineplus">+</span>
<a href="#l77.568"></a><span id="l77.568">   morkTable* NextTable(morkEnv* ev)</span>
<a href="#l77.569"></a><span id="l77.569">   { return (morkTable*) this-&gt;NextBead(ev); }</span>
<a href="#l77.570"></a><span id="l77.570" class="difflineminus">-  </span>
<a href="#l77.571"></a><span id="l77.571" class="difflineplus">+</span>
<a href="#l77.572"></a><span id="l77.572">   morkTable* HereTable(morkEnv* ev)</span>
<a href="#l77.573"></a><span id="l77.573">   { return (morkTable*) this-&gt;HereBead(ev); }</span>
<a href="#l77.574"></a><span id="l77.574" class="difflineminus">-  </span>
<a href="#l77.575"></a><span id="l77.575" class="difflineplus">+</span>
<a href="#l77.576"></a><span id="l77.576"> </span>
<a href="#l77.577"></a><span id="l77.577"> #else /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l77.578"></a><span id="l77.578">   morkTableMapIter(morkEnv* ev, morkTableMap* ioMap)</span>
<a href="#l77.579"></a><span id="l77.579">   : morkMapIter(ev, ioMap) { }</span>
<a href="#l77.580"></a><span id="l77.580" class="difflineminus">- </span>
<a href="#l77.581"></a><span id="l77.581" class="difflineplus">+</span>
<a href="#l77.582"></a><span id="l77.582">   morkTableMapIter( ) : morkMapIter()  { }</span>
<a href="#l77.583"></a><span id="l77.583">   void InitTableMapIter(morkEnv* ev, morkTableMap* ioMap)</span>
<a href="#l77.584"></a><span id="l77.584">   { this-&gt;InitMapIter(ev, ioMap); }</span>
<a href="#l77.585"></a><span id="l77.585" class="difflineminus">-   </span>
<a href="#l77.586"></a><span id="l77.586" class="difflineplus">+</span>
<a href="#l77.587"></a><span id="l77.587">   mork_change*</span>
<a href="#l77.588"></a><span id="l77.588">   FirstTable(morkEnv* ev, mork_tid* outTid, morkTable** outTable)</span>
<a href="#l77.589"></a><span id="l77.589">   { return this-&gt;First(ev, outTid, outTable); }</span>
<a href="#l77.590"></a><span id="l77.590" class="difflineminus">-  </span>
<a href="#l77.591"></a><span id="l77.591" class="difflineplus">+</span>
<a href="#l77.592"></a><span id="l77.592">   mork_change*</span>
<a href="#l77.593"></a><span id="l77.593">   NextTable(morkEnv* ev, mork_tid* outTid, morkTable** outTable)</span>
<a href="#l77.594"></a><span id="l77.594">   { return this-&gt;Next(ev, outTid, outTable); }</span>
<a href="#l77.595"></a><span id="l77.595" class="difflineminus">-  </span>
<a href="#l77.596"></a><span id="l77.596" class="difflineplus">+</span>
<a href="#l77.597"></a><span id="l77.597">   mork_change*</span>
<a href="#l77.598"></a><span id="l77.598">   HereTable(morkEnv* ev, mork_tid* outTid, morkTable** outTable)</span>
<a href="#l77.599"></a><span id="l77.599">   { return this-&gt;Here(ev, outTid, outTable); }</span>
<a href="#l77.600"></a><span id="l77.600" class="difflineminus">-  </span>
<a href="#l77.601"></a><span id="l77.601" class="difflineplus">+</span>
<a href="#l77.602"></a><span id="l77.602">   // cutting while iterating hash map might dirty the parent table:</span>
<a href="#l77.603"></a><span id="l77.603">   mork_change*</span>
<a href="#l77.604"></a><span id="l77.604">   CutHereTable(morkEnv* ev, mork_tid* outTid, morkTable** outTable)</span>
<a href="#l77.605"></a><span id="l77.605">   { return this-&gt;CutHere(ev, outTid, outTable); }</span>
<a href="#l77.606"></a><span id="l77.606"> #endif /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l77.607"></a><span id="l77.607"> };</span>
<a href="#l77.608"></a><span id="l77.608"> </span>
<a href="#l77.609"></a><span id="l77.609"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l78.1"></a><span id="l78.1" class="difflineminus">--- a/db/mork/src/morkTableRowCursor.cpp</span>
<a href="#l78.2"></a><span id="l78.2" class="difflineplus">+++ b/db/mork/src/morkTableRowCursor.cpp</span>
<a href="#l78.3"></a><span id="l78.3" class="difflineat">@@ -36,17 +36,17 @@</span>
<a href="#l78.4"></a><span id="l78.4"> #endif</span>
<a href="#l78.5"></a><span id="l78.5"> </span>
<a href="#l78.6"></a><span id="l78.6"> #ifndef _MORKROW_</span>
<a href="#l78.7"></a><span id="l78.7"> #include &quot;morkRow.h&quot;</span>
<a href="#l78.8"></a><span id="l78.8"> #endif</span>
<a href="#l78.9"></a><span id="l78.9"> </span>
<a href="#l78.10"></a><span id="l78.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l78.11"></a><span id="l78.11"> </span>
<a href="#l78.12"></a><span id="l78.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l78.13"></a><span id="l78.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l78.14"></a><span id="l78.14"> // { ===== begin morkNode interface =====</span>
<a href="#l78.15"></a><span id="l78.15"> </span>
<a href="#l78.16"></a><span id="l78.16"> /*public virtual*/ void</span>
<a href="#l78.17"></a><span id="l78.17"> morkTableRowCursor::CloseMorkNode(morkEnv* ev) // CloseTableRowCursor() only if open</span>
<a href="#l78.18"></a><span id="l78.18"> {</span>
<a href="#l78.19"></a><span id="l78.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l78.20"></a><span id="l78.20">   {</span>
<a href="#l78.21"></a><span id="l78.21">     this-&gt;MarkClosing();</span>
<a href="#l78.22"></a><span id="l78.22" class="difflineat">@@ -81,32 +81,32 @@ morkTableRowCursor::morkTableRowCursor(m</span>
<a href="#l78.23"></a><span id="l78.23">     }</span>
<a href="#l78.24"></a><span id="l78.24">     else</span>
<a href="#l78.25"></a><span id="l78.25">       ev-&gt;NilPointerError();</span>
<a href="#l78.26"></a><span id="l78.26">   }</span>
<a href="#l78.27"></a><span id="l78.27"> }</span>
<a href="#l78.28"></a><span id="l78.28"> </span>
<a href="#l78.29"></a><span id="l78.29"> NS_IMPL_ISUPPORTS_INHERITED(morkTableRowCursor, morkCursor, nsIMdbTableRowCursor)</span>
<a href="#l78.30"></a><span id="l78.30"> /*public non-poly*/ void</span>
<a href="#l78.31"></a><span id="l78.31" class="difflineminus">-morkTableRowCursor::CloseTableRowCursor(morkEnv* ev) </span>
<a href="#l78.32"></a><span id="l78.32" class="difflineplus">+morkTableRowCursor::CloseTableRowCursor(morkEnv* ev)</span>
<a href="#l78.33"></a><span id="l78.33"> {</span>
<a href="#l78.34"></a><span id="l78.34">     if ( this-&gt;IsNode() )</span>
<a href="#l78.35"></a><span id="l78.35">     {</span>
<a href="#l78.36"></a><span id="l78.36">       mCursor_Pos = -1;</span>
<a href="#l78.37"></a><span id="l78.37">       mCursor_Seed = 0;</span>
<a href="#l78.38"></a><span id="l78.38">       morkTable::SlotWeakTable((morkTable*) 0, ev, &amp;mTableRowCursor_Table);</span>
<a href="#l78.39"></a><span id="l78.39">       this-&gt;CloseCursor(ev);</span>
<a href="#l78.40"></a><span id="l78.40">       this-&gt;MarkShut();</span>
<a href="#l78.41"></a><span id="l78.41">     }</span>
<a href="#l78.42"></a><span id="l78.42">     else</span>
<a href="#l78.43"></a><span id="l78.43">       this-&gt;NonNodeError(ev);</span>
<a href="#l78.44"></a><span id="l78.44"> }</span>
<a href="#l78.45"></a><span id="l78.45"> </span>
<a href="#l78.46"></a><span id="l78.46"> // } ===== end morkNode methods =====</span>
<a href="#l78.47"></a><span id="l78.47" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l78.48"></a><span id="l78.48" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l78.49"></a><span id="l78.49"> // { ----- begin attribute methods -----</span>
<a href="#l78.50"></a><span id="l78.50"> /*virtual*/ nsresult</span>
<a href="#l78.51"></a><span id="l78.51"> morkTableRowCursor::GetCount(nsIMdbEnv* mev, mdb_count* outCount)</span>
<a href="#l78.52"></a><span id="l78.52"> {</span>
<a href="#l78.53"></a><span id="l78.53">   nsresult outErr = NS_OK;</span>
<a href="#l78.54"></a><span id="l78.54">   mdb_count count = 0;</span>
<a href="#l78.55"></a><span id="l78.55">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l78.56"></a><span id="l78.56">   if ( ev )</span>
<a href="#l78.57"></a><span id="l78.57" class="difflineat">@@ -166,17 +166,17 @@ morkTableRowCursor::GetTable(nsIMdbEnv* </span>
<a href="#l78.58"></a><span id="l78.58"> {</span>
<a href="#l78.59"></a><span id="l78.59">   nsresult outErr = NS_OK;</span>
<a href="#l78.60"></a><span id="l78.60">   nsIMdbTable* outTable = 0;</span>
<a href="#l78.61"></a><span id="l78.61">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l78.62"></a><span id="l78.62">   if ( ev )</span>
<a href="#l78.63"></a><span id="l78.63">   {</span>
<a href="#l78.64"></a><span id="l78.64">     if ( mTableRowCursor_Table )</span>
<a href="#l78.65"></a><span id="l78.65">       outTable = mTableRowCursor_Table-&gt;AcquireTableHandle(ev);</span>
<a href="#l78.66"></a><span id="l78.66" class="difflineminus">-    </span>
<a href="#l78.67"></a><span id="l78.67" class="difflineplus">+</span>
<a href="#l78.68"></a><span id="l78.68">     outErr = ev-&gt;AsErr();</span>
<a href="#l78.69"></a><span id="l78.69">   }</span>
<a href="#l78.70"></a><span id="l78.70">   if ( acqTable )</span>
<a href="#l78.71"></a><span id="l78.71">     *acqTable = outTable;</span>
<a href="#l78.72"></a><span id="l78.72">   return outErr;</span>
<a href="#l78.73"></a><span id="l78.73"> }</span>
<a href="#l78.74"></a><span id="l78.74"> // } ----- end attribute methods -----</span>
<a href="#l78.75"></a><span id="l78.75"> </span>
<a href="#l78.76"></a><span id="l78.76" class="difflineat">@@ -237,17 +237,17 @@ morkTableRowCursor::NextRow( // get row </span>
<a href="#l78.77"></a><span id="l78.77">   nsIMdbRow** acqRow, // acquire next row in table</span>
<a href="#l78.78"></a><span id="l78.78">   mdb_pos* outRowPos)</span>
<a href="#l78.79"></a><span id="l78.79"> {</span>
<a href="#l78.80"></a><span id="l78.80">   nsresult outErr = NS_OK;</span>
<a href="#l78.81"></a><span id="l78.81">   nsIMdbRow* outRow = 0;</span>
<a href="#l78.82"></a><span id="l78.82">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l78.83"></a><span id="l78.83">   if ( ev )</span>
<a href="#l78.84"></a><span id="l78.84">   {</span>
<a href="#l78.85"></a><span id="l78.85" class="difflineminus">-      </span>
<a href="#l78.86"></a><span id="l78.86" class="difflineplus">+</span>
<a href="#l78.87"></a><span id="l78.87">     mdbOid oid; // place to put oid we intend to ignore</span>
<a href="#l78.88"></a><span id="l78.88">     morkRow* row = NextRow(ev, &amp;oid, outRowPos);</span>
<a href="#l78.89"></a><span id="l78.89">     if ( row )</span>
<a href="#l78.90"></a><span id="l78.90">     {</span>
<a href="#l78.91"></a><span id="l78.91">       morkStore* store = row-&gt;GetRowSpaceStore(ev);</span>
<a href="#l78.92"></a><span id="l78.92">       if ( store )</span>
<a href="#l78.93"></a><span id="l78.93">         outRow = row-&gt;AcquireRowHandle(ev, store);</span>
<a href="#l78.94"></a><span id="l78.94">     }</span>
<a href="#l78.95"></a><span id="l78.95" class="difflineat">@@ -264,17 +264,17 @@ morkTableRowCursor::PrevRow( // get row </span>
<a href="#l78.96"></a><span id="l78.96">   nsIMdbRow** acqRow, // acquire previous row in table</span>
<a href="#l78.97"></a><span id="l78.97">   mdb_pos* outRowPos)</span>
<a href="#l78.98"></a><span id="l78.98"> {</span>
<a href="#l78.99"></a><span id="l78.99">   nsresult outErr = NS_OK;</span>
<a href="#l78.100"></a><span id="l78.100">   nsIMdbRow* outRow = 0;</span>
<a href="#l78.101"></a><span id="l78.101">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l78.102"></a><span id="l78.102">   if ( ev )</span>
<a href="#l78.103"></a><span id="l78.103">   {</span>
<a href="#l78.104"></a><span id="l78.104" class="difflineminus">-      </span>
<a href="#l78.105"></a><span id="l78.105" class="difflineplus">+</span>
<a href="#l78.106"></a><span id="l78.106">     mdbOid oid; // place to put oid we intend to ignore</span>
<a href="#l78.107"></a><span id="l78.107">     morkRow* row = PrevRow(ev, &amp;oid, outRowPos);</span>
<a href="#l78.108"></a><span id="l78.108">     if ( row )</span>
<a href="#l78.109"></a><span id="l78.109">     {</span>
<a href="#l78.110"></a><span id="l78.110">       morkStore* store = row-&gt;GetRowSpaceStore(ev);</span>
<a href="#l78.111"></a><span id="l78.111">       if ( store )</span>
<a href="#l78.112"></a><span id="l78.112">         outRow = row-&gt;AcquireRowHandle(ev, store);</span>
<a href="#l78.113"></a><span id="l78.113">     }</span>
<a href="#l78.114"></a><span id="l78.114" class="difflineat">@@ -290,28 +290,28 @@ morkTableRowCursor::PrevRow( // get row </span>
<a href="#l78.115"></a><span id="l78.115"> </span>
<a href="#l78.116"></a><span id="l78.116"> // { ----- begin duplicate row removal methods -----</span>
<a href="#l78.117"></a><span id="l78.117"> NS_IMETHODIMP</span>
<a href="#l78.118"></a><span id="l78.118"> morkTableRowCursor::CanHaveDupRowMembers(nsIMdbEnv* mev, // cursor might hold dups?</span>
<a href="#l78.119"></a><span id="l78.119">   mdb_bool* outCanHaveDups)</span>
<a href="#l78.120"></a><span id="l78.120"> {</span>
<a href="#l78.121"></a><span id="l78.121">   nsresult outErr = NS_OK;</span>
<a href="#l78.122"></a><span id="l78.122">   mdb_bool canHaveDups = mdbBool_kFalse;</span>
<a href="#l78.123"></a><span id="l78.123" class="difflineminus">-  </span>
<a href="#l78.124"></a><span id="l78.124" class="difflineplus">+</span>
<a href="#l78.125"></a><span id="l78.125">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l78.126"></a><span id="l78.126">   if ( ev )</span>
<a href="#l78.127"></a><span id="l78.127">   {</span>
<a href="#l78.128"></a><span id="l78.128">     canHaveDups = CanHaveDupRowMembers(ev);</span>
<a href="#l78.129"></a><span id="l78.129">     outErr = ev-&gt;AsErr();</span>
<a href="#l78.130"></a><span id="l78.130">   }</span>
<a href="#l78.131"></a><span id="l78.131">   if ( outCanHaveDups )</span>
<a href="#l78.132"></a><span id="l78.132">     *outCanHaveDups = canHaveDups;</span>
<a href="#l78.133"></a><span id="l78.133">   return outErr;</span>
<a href="#l78.134"></a><span id="l78.134"> }</span>
<a href="#l78.135"></a><span id="l78.135" class="difflineminus">-  </span>
<a href="#l78.136"></a><span id="l78.136" class="difflineplus">+</span>
<a href="#l78.137"></a><span id="l78.137"> NS_IMETHODIMP</span>
<a href="#l78.138"></a><span id="l78.138"> morkTableRowCursor::MakeUniqueCursor( // clone cursor, removing duplicate rows</span>
<a href="#l78.139"></a><span id="l78.139">   nsIMdbEnv* mev, // context</span>
<a href="#l78.140"></a><span id="l78.140">   nsIMdbTableRowCursor** acqCursor)    // acquire clone with no dups</span>
<a href="#l78.141"></a><span id="l78.141">   // Note that MakeUniqueCursor() is never necessary for a cursor which was</span>
<a href="#l78.142"></a><span id="l78.142">   // created by table method nsIMdbTable::GetTableRowCursor(), because a table</span>
<a href="#l78.143"></a><span id="l78.143">   // never contains the same row as a member more than once.  However, a cursor</span>
<a href="#l78.144"></a><span id="l78.144">   // created by table method nsIMdbTable::FindRowMatches() might contain the</span>
<a href="#l78.145"></a><span id="l78.145" class="difflineat">@@ -330,23 +330,23 @@ morkTableRowCursor::MakeUniqueCursor( //</span>
<a href="#l78.146"></a><span id="l78.146">   // position ranges, without using an explicit row set representation.</span>
<a href="#l78.147"></a><span id="l78.147">   // Callers are encouraged to use nsIMdbCursor::GetCount() to determine</span>
<a href="#l78.148"></a><span id="l78.148">   // whether the row collection is very large (tens of thousands), and to</span>
<a href="#l78.149"></a><span id="l78.149">   // delay calling MakeUniqueCursor() when possible, until a user interface</span>
<a href="#l78.150"></a><span id="l78.150">   // element actually demands the creation of an explicit set representation.</span>
<a href="#l78.151"></a><span id="l78.151"> {</span>
<a href="#l78.152"></a><span id="l78.152">   nsresult outErr = NS_OK;</span>
<a href="#l78.153"></a><span id="l78.153">   nsIMdbTableRowCursor* outCursor = 0;</span>
<a href="#l78.154"></a><span id="l78.154" class="difflineminus">-  </span>
<a href="#l78.155"></a><span id="l78.155" class="difflineplus">+</span>
<a href="#l78.156"></a><span id="l78.156">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l78.157"></a><span id="l78.157">   if ( ev )</span>
<a href="#l78.158"></a><span id="l78.158">   {</span>
<a href="#l78.159"></a><span id="l78.159">     AddRef();</span>
<a href="#l78.160"></a><span id="l78.160">     outCursor = this;</span>
<a href="#l78.161"></a><span id="l78.161" class="difflineminus">-      </span>
<a href="#l78.162"></a><span id="l78.162" class="difflineplus">+</span>
<a href="#l78.163"></a><span id="l78.163">     outErr = ev-&gt;AsErr();</span>
<a href="#l78.164"></a><span id="l78.164">   }</span>
<a href="#l78.165"></a><span id="l78.165">   if ( acqCursor )</span>
<a href="#l78.166"></a><span id="l78.166">     *acqCursor = outCursor;</span>
<a href="#l78.167"></a><span id="l78.167">   return outErr;</span>
<a href="#l78.168"></a><span id="l78.168"> }</span>
<a href="#l78.169"></a><span id="l78.169"> // } ----- end duplicate row removal methods -----</span>
<a href="#l78.170"></a><span id="l78.170"> </span>
<a href="#l78.171"></a><span id="l78.171" class="difflineat">@@ -392,25 +392,25 @@ morkTableRowCursor::GetMemberCount(morkE</span>
<a href="#l78.172"></a><span id="l78.172">     return 0;</span>
<a href="#l78.173"></a><span id="l78.173"> }</span>
<a href="#l78.174"></a><span id="l78.174"> </span>
<a href="#l78.175"></a><span id="l78.175"> morkRow*</span>
<a href="#l78.176"></a><span id="l78.176"> morkTableRowCursor::PrevRow(morkEnv* ev, mdbOid* outOid, mdb_pos* outPos)</span>
<a href="#l78.177"></a><span id="l78.177"> {</span>
<a href="#l78.178"></a><span id="l78.178">   morkRow* outRow = 0;</span>
<a href="#l78.179"></a><span id="l78.179">   mork_pos pos = -1;</span>
<a href="#l78.180"></a><span id="l78.180" class="difflineminus">-  </span>
<a href="#l78.181"></a><span id="l78.181" class="difflineplus">+</span>
<a href="#l78.182"></a><span id="l78.182">   morkTable* table = mTableRowCursor_Table;</span>
<a href="#l78.183"></a><span id="l78.183">   if ( table )</span>
<a href="#l78.184"></a><span id="l78.184">   {</span>
<a href="#l78.185"></a><span id="l78.185">     if ( table-&gt;IsOpenNode() )</span>
<a href="#l78.186"></a><span id="l78.186">     {</span>
<a href="#l78.187"></a><span id="l78.187">       morkArray* array = &amp;table-&gt;mTable_RowArray;</span>
<a href="#l78.188"></a><span id="l78.188">       pos = mCursor_Pos - 1;</span>
<a href="#l78.189"></a><span id="l78.189" class="difflineminus">-        </span>
<a href="#l78.190"></a><span id="l78.190" class="difflineplus">+</span>
<a href="#l78.191"></a><span id="l78.191">       if ( pos &gt;= 0 &amp;&amp; pos &lt; (mork_pos)(array-&gt;mArray_Fill) )</span>
<a href="#l78.192"></a><span id="l78.192">       {</span>
<a href="#l78.193"></a><span id="l78.193">         mCursor_Pos = pos; // update for next time</span>
<a href="#l78.194"></a><span id="l78.194">         morkRow* row = (morkRow*) array-&gt;At(pos);</span>
<a href="#l78.195"></a><span id="l78.195">         if ( row )</span>
<a href="#l78.196"></a><span id="l78.196">         {</span>
<a href="#l78.197"></a><span id="l78.197">           if ( row-&gt;IsRow() )</span>
<a href="#l78.198"></a><span id="l78.198">           {</span>
<a href="#l78.199"></a><span id="l78.199" class="difflineat">@@ -439,29 +439,29 @@ morkTableRowCursor::PrevRow(morkEnv* ev,</span>
<a href="#l78.200"></a><span id="l78.200">   return outRow;</span>
<a href="#l78.201"></a><span id="l78.201"> }</span>
<a href="#l78.202"></a><span id="l78.202"> </span>
<a href="#l78.203"></a><span id="l78.203"> morkRow*</span>
<a href="#l78.204"></a><span id="l78.204"> morkTableRowCursor::NextRow(morkEnv* ev, mdbOid* outOid, mdb_pos* outPos)</span>
<a href="#l78.205"></a><span id="l78.205"> {</span>
<a href="#l78.206"></a><span id="l78.206">   morkRow* outRow = 0;</span>
<a href="#l78.207"></a><span id="l78.207">   mork_pos pos = -1;</span>
<a href="#l78.208"></a><span id="l78.208" class="difflineminus">-  </span>
<a href="#l78.209"></a><span id="l78.209" class="difflineplus">+</span>
<a href="#l78.210"></a><span id="l78.210">   morkTable* table = mTableRowCursor_Table;</span>
<a href="#l78.211"></a><span id="l78.211">   if ( table )</span>
<a href="#l78.212"></a><span id="l78.212">   {</span>
<a href="#l78.213"></a><span id="l78.213">     if ( table-&gt;IsOpenNode() )</span>
<a href="#l78.214"></a><span id="l78.214">     {</span>
<a href="#l78.215"></a><span id="l78.215">       morkArray* array = &amp;table-&gt;mTable_RowArray;</span>
<a href="#l78.216"></a><span id="l78.216">       pos = mCursor_Pos;</span>
<a href="#l78.217"></a><span id="l78.217">       if ( pos &lt; 0 )</span>
<a href="#l78.218"></a><span id="l78.218">         pos = 0;</span>
<a href="#l78.219"></a><span id="l78.219">       else</span>
<a href="#l78.220"></a><span id="l78.220">         ++pos;</span>
<a href="#l78.221"></a><span id="l78.221" class="difflineminus">-        </span>
<a href="#l78.222"></a><span id="l78.222" class="difflineplus">+</span>
<a href="#l78.223"></a><span id="l78.223">       if ( pos &lt; (mork_pos)(array-&gt;mArray_Fill) )</span>
<a href="#l78.224"></a><span id="l78.224">       {</span>
<a href="#l78.225"></a><span id="l78.225">         mCursor_Pos = pos; // update for next time</span>
<a href="#l78.226"></a><span id="l78.226">         morkRow* row = (morkRow*) array-&gt;At(pos);</span>
<a href="#l78.227"></a><span id="l78.227">         if ( row )</span>
<a href="#l78.228"></a><span id="l78.228">         {</span>
<a href="#l78.229"></a><span id="l78.229">           if ( row-&gt;IsRow() )</span>
<a href="#l78.230"></a><span id="l78.230">           {</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l79.1"></a><span id="l79.1" class="difflineminus">--- a/db/mork/src/morkTableRowCursor.h</span>
<a href="#l79.2"></a><span id="l79.2" class="difflineplus">+++ b/db/mork/src/morkTableRowCursor.h</span>
<a href="#l79.3"></a><span id="l79.3" class="difflineat">@@ -40,54 +40,54 @@ class morkTableRowCursor : public morkCu</span>
<a href="#l79.4"></a><span id="l79.4"> </span>
<a href="#l79.5"></a><span id="l79.5">   // mork_seed  mCursor_Seed;</span>
<a href="#l79.6"></a><span id="l79.6">   // mork_pos   mCursor_Pos;</span>
<a href="#l79.7"></a><span id="l79.7">   // mork_bool  mCursor_DoFailOnSeedOutOfSync;</span>
<a href="#l79.8"></a><span id="l79.8">   // mork_u1    mCursor_Pad[ 3 ]; // explicitly pad to u4 alignment</span>
<a href="#l79.9"></a><span id="l79.9"> </span>
<a href="#l79.10"></a><span id="l79.10"> public: // state is public because the entire Mork system is private</span>
<a href="#l79.11"></a><span id="l79.11">   morkTable*  mTableRowCursor_Table; // weak ref to table</span>
<a href="#l79.12"></a><span id="l79.12" class="difflineminus">-    </span>
<a href="#l79.13"></a><span id="l79.13" class="difflineplus">+</span>
<a href="#l79.14"></a><span id="l79.14"> // { ===== begin morkNode interface =====</span>
<a href="#l79.15"></a><span id="l79.15"> public: // morkNode virtual methods</span>
<a href="#l79.16"></a><span id="l79.16">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseTableRowCursor()</span>
<a href="#l79.17"></a><span id="l79.17"> </span>
<a href="#l79.18"></a><span id="l79.18"> protected:</span>
<a href="#l79.19"></a><span id="l79.19">   virtual ~morkTableRowCursor(); // assert that close executed earlier</span>
<a href="#l79.20"></a><span id="l79.20" class="difflineminus">-  </span>
<a href="#l79.21"></a><span id="l79.21" class="difflineplus">+</span>
<a href="#l79.22"></a><span id="l79.22"> public: // morkTableRowCursor construction &amp; destruction</span>
<a href="#l79.23"></a><span id="l79.23">   morkTableRowCursor(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l79.24"></a><span id="l79.24">     nsIMdbHeap* ioHeap, morkTable* ioTable, mork_pos inRowPos);</span>
<a href="#l79.25"></a><span id="l79.25">   void CloseTableRowCursor(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l79.26"></a><span id="l79.26"> </span>
<a href="#l79.27"></a><span id="l79.27"> private: // copying is not allowed</span>
<a href="#l79.28"></a><span id="l79.28">   morkTableRowCursor(const morkTableRowCursor&amp; other);</span>
<a href="#l79.29"></a><span id="l79.29">   morkTableRowCursor&amp; operator=(const morkTableRowCursor&amp; other);</span>
<a href="#l79.30"></a><span id="l79.30"> </span>
<a href="#l79.31"></a><span id="l79.31"> public:</span>
<a href="#l79.32"></a><span id="l79.32">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l79.33"></a><span id="l79.33"> </span>
<a href="#l79.34"></a><span id="l79.34">   // { ----- begin attribute methods -----</span>
<a href="#l79.35"></a><span id="l79.35">   NS_IMETHOD GetCount(nsIMdbEnv* ev, mdb_count* outCount) override; // readonly</span>
<a href="#l79.36"></a><span id="l79.36">   NS_IMETHOD GetSeed(nsIMdbEnv* ev, mdb_seed* outSeed) override;    // readonly</span>
<a href="#l79.37"></a><span id="l79.37" class="difflineminus">-  </span>
<a href="#l79.38"></a><span id="l79.38" class="difflineplus">+</span>
<a href="#l79.39"></a><span id="l79.39">   NS_IMETHOD SetPos(nsIMdbEnv* ev, mdb_pos inPos) override;   // mutable</span>
<a href="#l79.40"></a><span id="l79.40">   NS_IMETHOD GetPos(nsIMdbEnv* ev, mdb_pos* outPos) override;</span>
<a href="#l79.41"></a><span id="l79.41" class="difflineminus">-  </span>
<a href="#l79.42"></a><span id="l79.42" class="difflineplus">+</span>
<a href="#l79.43"></a><span id="l79.43">   NS_IMETHOD SetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool inFail) override;</span>
<a href="#l79.44"></a><span id="l79.44">   NS_IMETHOD GetDoFailOnSeedOutOfSync(nsIMdbEnv* ev, mdb_bool* outFail) override;</span>
<a href="#l79.45"></a><span id="l79.45"> </span>
<a href="#l79.46"></a><span id="l79.46">   // } ----- end attribute methods -----</span>
<a href="#l79.47"></a><span id="l79.47">     NS_IMETHOD GetTable(nsIMdbEnv* ev, nsIMdbTable** acqTable) override;</span>
<a href="#l79.48"></a><span id="l79.48">   // } ----- end attribute methods -----</span>
<a href="#l79.49"></a><span id="l79.49"> </span>
<a href="#l79.50"></a><span id="l79.50">   // { ----- begin duplicate row removal methods -----</span>
<a href="#l79.51"></a><span id="l79.51">   NS_IMETHOD CanHaveDupRowMembers(nsIMdbEnv* ev, // cursor might hold dups?</span>
<a href="#l79.52"></a><span id="l79.52">     mdb_bool* outCanHaveDups) override;</span>
<a href="#l79.53"></a><span id="l79.53" class="difflineminus">-    </span>
<a href="#l79.54"></a><span id="l79.54" class="difflineplus">+</span>
<a href="#l79.55"></a><span id="l79.55">   NS_IMETHOD MakeUniqueCursor( // clone cursor, removing duplicate rows</span>
<a href="#l79.56"></a><span id="l79.56">     nsIMdbEnv* ev, // context</span>
<a href="#l79.57"></a><span id="l79.57">     nsIMdbTableRowCursor** acqCursor) override;    // acquire clone with no dups</span>
<a href="#l79.58"></a><span id="l79.58">   // } ----- end duplicate row removal methods -----</span>
<a href="#l79.59"></a><span id="l79.59"> </span>
<a href="#l79.60"></a><span id="l79.60">   // { ----- begin oid iteration methods -----</span>
<a href="#l79.61"></a><span id="l79.61">   NS_IMETHOD NextRowOid( // get row id of next row in the table</span>
<a href="#l79.62"></a><span id="l79.62">     nsIMdbEnv* ev, // context</span>
<a href="#l79.63"></a><span id="l79.63" class="difflineat">@@ -130,17 +130,17 @@ public: // other table row cursor method</span>
<a href="#l79.64"></a><span id="l79.64"> </span>
<a href="#l79.65"></a><span id="l79.65">   virtual morkRow* NextRow(morkEnv* ev, mdbOid* outOid, mdb_pos* outPos);</span>
<a href="#l79.66"></a><span id="l79.66">   virtual morkRow* PrevRow(morkEnv* ev, mdbOid* outOid, mdb_pos* outPos);</span>
<a href="#l79.67"></a><span id="l79.67"> </span>
<a href="#l79.68"></a><span id="l79.68"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l79.69"></a><span id="l79.69">   static void SlotWeakTableRowCursor(morkTableRowCursor* me,</span>
<a href="#l79.70"></a><span id="l79.70">     morkEnv* ev, morkTableRowCursor** ioSlot)</span>
<a href="#l79.71"></a><span id="l79.71">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l79.72"></a><span id="l79.72" class="difflineminus">-  </span>
<a href="#l79.73"></a><span id="l79.73" class="difflineplus">+</span>
<a href="#l79.74"></a><span id="l79.74">   static void SlotStrongTableRowCursor(morkTableRowCursor* me,</span>
<a href="#l79.75"></a><span id="l79.75">     morkEnv* ev, morkTableRowCursor** ioSlot)</span>
<a href="#l79.76"></a><span id="l79.76">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l79.77"></a><span id="l79.77"> };</span>
<a href="#l79.78"></a><span id="l79.78"> </span>
<a href="#l79.79"></a><span id="l79.79"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l79.80"></a><span id="l79.80"> </span>
<a href="#l79.81"></a><span id="l79.81"> #endif /* _MORKTABLEROWCURSOR_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l80.1"></a><span id="l80.1" class="difflineminus">--- a/db/mork/src/morkThumb.cpp</span>
<a href="#l80.2"></a><span id="l80.2" class="difflineplus">+++ b/db/mork/src/morkThumb.cpp</span>
<a href="#l80.3"></a><span id="l80.3" class="difflineat">@@ -40,17 +40,17 @@</span>
<a href="#l80.4"></a><span id="l80.4"> #endif</span>
<a href="#l80.5"></a><span id="l80.5"> </span>
<a href="#l80.6"></a><span id="l80.6"> #ifndef _MORKBUILDER_</span>
<a href="#l80.7"></a><span id="l80.7"> #include &quot;morkBuilder.h&quot;</span>
<a href="#l80.8"></a><span id="l80.8"> #endif</span>
<a href="#l80.9"></a><span id="l80.9"> </span>
<a href="#l80.10"></a><span id="l80.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l80.11"></a><span id="l80.11"> </span>
<a href="#l80.12"></a><span id="l80.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l80.13"></a><span id="l80.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l80.14"></a><span id="l80.14"> // { ===== begin morkNode interface =====</span>
<a href="#l80.15"></a><span id="l80.15"> </span>
<a href="#l80.16"></a><span id="l80.16"> /*public virtual*/ void</span>
<a href="#l80.17"></a><span id="l80.17"> morkThumb::CloseMorkNode(morkEnv* ev) // CloseThumb() only if open</span>
<a href="#l80.18"></a><span id="l80.18"> {</span>
<a href="#l80.19"></a><span id="l80.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l80.20"></a><span id="l80.20">   {</span>
<a href="#l80.21"></a><span id="l80.21">     this-&gt;MarkClosing();</span>
<a href="#l80.22"></a><span id="l80.22" class="difflineat">@@ -107,29 +107,29 @@ NS_IMPL_ISUPPORTS_INHERITED(morkThumb, m</span>
<a href="#l80.23"></a><span id="l80.23"> morkThumb::CloseThumb(morkEnv* ev) // called by CloseMorkNode();</span>
<a href="#l80.24"></a><span id="l80.24"> {</span>
<a href="#l80.25"></a><span id="l80.25">     if ( this-&gt;IsNode() )</span>
<a href="#l80.26"></a><span id="l80.26">     {</span>
<a href="#l80.27"></a><span id="l80.27">       mThumb_Magic = 0;</span>
<a href="#l80.28"></a><span id="l80.28">       if ( mThumb_Builder &amp;&amp; mThumb_Store )</span>
<a href="#l80.29"></a><span id="l80.29">         mThumb_Store-&gt;ForgetBuilder(ev);</span>
<a href="#l80.30"></a><span id="l80.30">       morkBuilder::SlotStrongBuilder((morkBuilder*) 0, ev, &amp;mThumb_Builder);</span>
<a href="#l80.31"></a><span id="l80.31" class="difflineminus">-      </span>
<a href="#l80.32"></a><span id="l80.32" class="difflineplus">+</span>
<a href="#l80.33"></a><span id="l80.33">       morkWriter::SlotStrongWriter((morkWriter*) 0, ev, &amp;mThumb_Writer);</span>
<a href="#l80.34"></a><span id="l80.34">       nsIMdbFile_SlotStrongFile((nsIMdbFile*) 0, ev, &amp;mThumb_File);</span>
<a href="#l80.35"></a><span id="l80.35">       morkStore::SlotStrongStore((morkStore*) 0, ev, &amp;mThumb_Store);</span>
<a href="#l80.36"></a><span id="l80.36">       morkStore::SlotStrongPort((morkPort*) 0, ev, &amp;mThumb_SourcePort);</span>
<a href="#l80.37"></a><span id="l80.37">       this-&gt;MarkShut();</span>
<a href="#l80.38"></a><span id="l80.38">     }</span>
<a href="#l80.39"></a><span id="l80.39">     else</span>
<a href="#l80.40"></a><span id="l80.40">       this-&gt;NonNodeError(ev);</span>
<a href="#l80.41"></a><span id="l80.41"> }</span>
<a href="#l80.42"></a><span id="l80.42"> </span>
<a href="#l80.43"></a><span id="l80.43"> // } ===== end morkNode methods =====</span>
<a href="#l80.44"></a><span id="l80.44" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l80.45"></a><span id="l80.45" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l80.46"></a><span id="l80.46"> </span>
<a href="#l80.47"></a><span id="l80.47"> // { ===== begin nsIMdbThumb methods =====</span>
<a href="#l80.48"></a><span id="l80.48"> NS_IMETHODIMP</span>
<a href="#l80.49"></a><span id="l80.49"> morkThumb::GetProgress(nsIMdbEnv* mev, mdb_count* outTotal,</span>
<a href="#l80.50"></a><span id="l80.50">   mdb_count* outCurrent, mdb_bool* outDone, mdb_bool* outBroken)</span>
<a href="#l80.51"></a><span id="l80.51"> {</span>
<a href="#l80.52"></a><span id="l80.52">   nsresult outErr = NS_OK;</span>
<a href="#l80.53"></a><span id="l80.53">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l80.54"></a><span id="l80.54" class="difflineat">@@ -202,33 +202,33 @@ morkThumb::CancelAndBreakThumb(nsIMdbEnv</span>
<a href="#l80.55"></a><span id="l80.55"> }</span>
<a href="#l80.56"></a><span id="l80.56"> </span>
<a href="#l80.57"></a><span id="l80.57"> /*static*/ void morkThumb::NilThumbSourcePortError(morkEnv* ev)</span>
<a href="#l80.58"></a><span id="l80.58"> {</span>
<a href="#l80.59"></a><span id="l80.59">   ev-&gt;NewError(&quot;nil mThumb_SourcePort&quot;);</span>
<a href="#l80.60"></a><span id="l80.60"> }</span>
<a href="#l80.61"></a><span id="l80.61"> </span>
<a href="#l80.62"></a><span id="l80.62"> /*static*/ morkThumb*</span>
<a href="#l80.63"></a><span id="l80.63" class="difflineminus">-morkThumb::Make_OpenFileStore(morkEnv* ev, nsIMdbHeap* ioHeap, </span>
<a href="#l80.64"></a><span id="l80.64" class="difflineplus">+morkThumb::Make_OpenFileStore(morkEnv* ev, nsIMdbHeap* ioHeap,</span>
<a href="#l80.65"></a><span id="l80.65">   morkStore* ioStore)</span>
<a href="#l80.66"></a><span id="l80.66"> {</span>
<a href="#l80.67"></a><span id="l80.67">   morkThumb* outThumb = 0;</span>
<a href="#l80.68"></a><span id="l80.68">   if ( ioHeap &amp;&amp; ioStore )</span>
<a href="#l80.69"></a><span id="l80.69">   {</span>
<a href="#l80.70"></a><span id="l80.70">     nsIMdbFile* file = ioStore-&gt;mStore_File;</span>
<a href="#l80.71"></a><span id="l80.71">     if ( file )</span>
<a href="#l80.72"></a><span id="l80.72">     {</span>
<a href="#l80.73"></a><span id="l80.73">       mork_pos fileEof = 0;</span>
<a href="#l80.74"></a><span id="l80.74">       file-&gt;Eof(ev-&gt;AsMdbEnv(), &amp;fileEof);</span>
<a href="#l80.75"></a><span id="l80.75">       if ( ev-&gt;Good() )</span>
<a href="#l80.76"></a><span id="l80.76">       {</span>
<a href="#l80.77"></a><span id="l80.77">         outThumb = new(*ioHeap, ev)</span>
<a href="#l80.78"></a><span id="l80.78">           morkThumb(ev, morkUsage::kHeap, ioHeap, ioHeap,</span>
<a href="#l80.79"></a><span id="l80.79">             morkThumb_kMagic_OpenFileStore);</span>
<a href="#l80.80"></a><span id="l80.80" class="difflineminus">-            </span>
<a href="#l80.81"></a><span id="l80.81" class="difflineplus">+</span>
<a href="#l80.82"></a><span id="l80.82">         if ( outThumb )</span>
<a href="#l80.83"></a><span id="l80.83">         {</span>
<a href="#l80.84"></a><span id="l80.84">           morkBuilder* builder = ioStore-&gt;LazyGetBuilder(ev);</span>
<a href="#l80.85"></a><span id="l80.85">           if ( builder )</span>
<a href="#l80.86"></a><span id="l80.86">           {</span>
<a href="#l80.87"></a><span id="l80.87">             outThumb-&gt;mThumb_Total = (mork_count) fileEof;</span>
<a href="#l80.88"></a><span id="l80.88">             morkStore::SlotStrongStore(ioStore, ev, &amp;outThumb-&gt;mThumb_Store);</span>
<a href="#l80.89"></a><span id="l80.89">             morkBuilder::SlotStrongBuilder(builder, ev,</span>
<a href="#l80.90"></a><span id="l80.90" class="difflineat">@@ -237,100 +237,100 @@ morkThumb::Make_OpenFileStore(morkEnv* e</span>
<a href="#l80.91"></a><span id="l80.91">         }</span>
<a href="#l80.92"></a><span id="l80.92">       }</span>
<a href="#l80.93"></a><span id="l80.93">     }</span>
<a href="#l80.94"></a><span id="l80.94">     else</span>
<a href="#l80.95"></a><span id="l80.95">       ioStore-&gt;NilStoreFileError(ev);</span>
<a href="#l80.96"></a><span id="l80.96">   }</span>
<a href="#l80.97"></a><span id="l80.97">   else</span>
<a href="#l80.98"></a><span id="l80.98">     ev-&gt;NilPointerError();</span>
<a href="#l80.99"></a><span id="l80.99" class="difflineminus">-    </span>
<a href="#l80.100"></a><span id="l80.100" class="difflineplus">+</span>
<a href="#l80.101"></a><span id="l80.101">   return outThumb;</span>
<a href="#l80.102"></a><span id="l80.102"> }</span>
<a href="#l80.103"></a><span id="l80.103"> </span>
<a href="#l80.104"></a><span id="l80.104"> </span>
<a href="#l80.105"></a><span id="l80.105"> /*static*/ morkThumb*</span>
<a href="#l80.106"></a><span id="l80.106" class="difflineminus">-morkThumb::Make_LargeCommit(morkEnv* ev, </span>
<a href="#l80.107"></a><span id="l80.107" class="difflineplus">+morkThumb::Make_LargeCommit(morkEnv* ev,</span>
<a href="#l80.108"></a><span id="l80.108">   nsIMdbHeap* ioHeap, morkStore* ioStore)</span>
<a href="#l80.109"></a><span id="l80.109"> {</span>
<a href="#l80.110"></a><span id="l80.110">   morkThumb* outThumb = 0;</span>
<a href="#l80.111"></a><span id="l80.111">   if ( ioHeap &amp;&amp; ioStore )</span>
<a href="#l80.112"></a><span id="l80.112">   {</span>
<a href="#l80.113"></a><span id="l80.113">     nsIMdbFile* file = ioStore-&gt;mStore_File;</span>
<a href="#l80.114"></a><span id="l80.114">     if ( file )</span>
<a href="#l80.115"></a><span id="l80.115">     {</span>
<a href="#l80.116"></a><span id="l80.116">       outThumb = new(*ioHeap, ev)</span>
<a href="#l80.117"></a><span id="l80.117">         morkThumb(ev, morkUsage::kHeap, ioHeap, ioHeap,</span>
<a href="#l80.118"></a><span id="l80.118">           morkThumb_kMagic_LargeCommit);</span>
<a href="#l80.119"></a><span id="l80.119" class="difflineminus">-          </span>
<a href="#l80.120"></a><span id="l80.120" class="difflineplus">+</span>
<a href="#l80.121"></a><span id="l80.121">       if ( outThumb )</span>
<a href="#l80.122"></a><span id="l80.122">       {</span>
<a href="#l80.123"></a><span id="l80.123">         morkWriter* writer = new(*ioHeap, ev)</span>
<a href="#l80.124"></a><span id="l80.124">           morkWriter(ev, morkUsage::kHeap, ioHeap, ioStore, file, ioHeap);</span>
<a href="#l80.125"></a><span id="l80.125">         if ( writer )</span>
<a href="#l80.126"></a><span id="l80.126">         {</span>
<a href="#l80.127"></a><span id="l80.127">           writer-&gt;mWriter_CommitGroupIdentity =</span>
<a href="#l80.128"></a><span id="l80.128">             ++ioStore-&gt;mStore_CommitGroupIdentity;</span>
<a href="#l80.129"></a><span id="l80.129">           writer-&gt;mWriter_NeedDirtyAll = morkBool_kFalse;</span>
<a href="#l80.130"></a><span id="l80.130">           outThumb-&gt;mThumb_DoCollect = morkBool_kFalse;</span>
<a href="#l80.131"></a><span id="l80.131">           morkStore::SlotStrongStore(ioStore, ev, &amp;outThumb-&gt;mThumb_Store);</span>
<a href="#l80.132"></a><span id="l80.132" class="difflineminus">-          </span>
<a href="#l80.133"></a><span id="l80.133" class="difflineplus">+</span>
<a href="#l80.134"></a><span id="l80.134">           nsIMdbFile_SlotStrongFile(file, ev, &amp;outThumb-&gt;mThumb_File);</span>
<a href="#l80.135"></a><span id="l80.135" class="difflineminus">-          </span>
<a href="#l80.136"></a><span id="l80.136" class="difflineplus">+</span>
<a href="#l80.137"></a><span id="l80.137">           outThumb-&gt;mThumb_Writer = writer; // pass writer ownership to thumb</span>
<a href="#l80.138"></a><span id="l80.138">         }</span>
<a href="#l80.139"></a><span id="l80.139">       }</span>
<a href="#l80.140"></a><span id="l80.140">     }</span>
<a href="#l80.141"></a><span id="l80.141">     else</span>
<a href="#l80.142"></a><span id="l80.142">       ioStore-&gt;NilStoreFileError(ev);</span>
<a href="#l80.143"></a><span id="l80.143">   }</span>
<a href="#l80.144"></a><span id="l80.144">   else</span>
<a href="#l80.145"></a><span id="l80.145">     ev-&gt;NilPointerError();</span>
<a href="#l80.146"></a><span id="l80.146" class="difflineminus">-    </span>
<a href="#l80.147"></a><span id="l80.147" class="difflineplus">+</span>
<a href="#l80.148"></a><span id="l80.148">   return outThumb;</span>
<a href="#l80.149"></a><span id="l80.149"> }</span>
<a href="#l80.150"></a><span id="l80.150"> </span>
<a href="#l80.151"></a><span id="l80.151"> /*static*/ morkThumb*</span>
<a href="#l80.152"></a><span id="l80.152" class="difflineminus">-morkThumb::Make_CompressCommit(morkEnv* ev, </span>
<a href="#l80.153"></a><span id="l80.153" class="difflineplus">+morkThumb::Make_CompressCommit(morkEnv* ev,</span>
<a href="#l80.154"></a><span id="l80.154">   nsIMdbHeap* ioHeap, morkStore* ioStore, mork_bool inDoCollect)</span>
<a href="#l80.155"></a><span id="l80.155"> {</span>
<a href="#l80.156"></a><span id="l80.156">   morkThumb* outThumb = 0;</span>
<a href="#l80.157"></a><span id="l80.157">   if ( ioHeap &amp;&amp; ioStore )</span>
<a href="#l80.158"></a><span id="l80.158">   {</span>
<a href="#l80.159"></a><span id="l80.159">     nsIMdbFile* file = ioStore-&gt;mStore_File;</span>
<a href="#l80.160"></a><span id="l80.160">     if ( file )</span>
<a href="#l80.161"></a><span id="l80.161">     {</span>
<a href="#l80.162"></a><span id="l80.162">       outThumb = new(*ioHeap, ev)</span>
<a href="#l80.163"></a><span id="l80.163">         morkThumb(ev, morkUsage::kHeap, ioHeap, ioHeap,</span>
<a href="#l80.164"></a><span id="l80.164">           morkThumb_kMagic_CompressCommit);</span>
<a href="#l80.165"></a><span id="l80.165" class="difflineminus">-          </span>
<a href="#l80.166"></a><span id="l80.166" class="difflineplus">+</span>
<a href="#l80.167"></a><span id="l80.167">       if ( outThumb )</span>
<a href="#l80.168"></a><span id="l80.168">       {</span>
<a href="#l80.169"></a><span id="l80.169">         morkWriter* writer = new(*ioHeap, ev)</span>
<a href="#l80.170"></a><span id="l80.170">           morkWriter(ev, morkUsage::kHeap, ioHeap, ioStore, file, ioHeap);</span>
<a href="#l80.171"></a><span id="l80.171">         if ( writer )</span>
<a href="#l80.172"></a><span id="l80.172">         {</span>
<a href="#l80.173"></a><span id="l80.173">           writer-&gt;mWriter_NeedDirtyAll = morkBool_kTrue;</span>
<a href="#l80.174"></a><span id="l80.174">           outThumb-&gt;mThumb_DoCollect = inDoCollect;</span>
<a href="#l80.175"></a><span id="l80.175">           morkStore::SlotStrongStore(ioStore, ev, &amp;outThumb-&gt;mThumb_Store);</span>
<a href="#l80.176"></a><span id="l80.176">           nsIMdbFile_SlotStrongFile(file, ev, &amp;outThumb-&gt;mThumb_File);</span>
<a href="#l80.177"></a><span id="l80.177">           outThumb-&gt;mThumb_Writer = writer; // pass writer ownership to thumb</span>
<a href="#l80.178"></a><span id="l80.178" class="difflineminus">-          </span>
<a href="#l80.179"></a><span id="l80.179" class="difflineplus">+</span>
<a href="#l80.180"></a><span id="l80.180">           // cope with fact that parsed transaction groups are going away:</span>
<a href="#l80.181"></a><span id="l80.181">           ioStore-&gt;mStore_FirstCommitGroupPos = 0;</span>
<a href="#l80.182"></a><span id="l80.182">           ioStore-&gt;mStore_SecondCommitGroupPos = 0;</span>
<a href="#l80.183"></a><span id="l80.183">         }</span>
<a href="#l80.184"></a><span id="l80.184">       }</span>
<a href="#l80.185"></a><span id="l80.185">     }</span>
<a href="#l80.186"></a><span id="l80.186">     else</span>
<a href="#l80.187"></a><span id="l80.187">       ioStore-&gt;NilStoreFileError(ev);</span>
<a href="#l80.188"></a><span id="l80.188">   }</span>
<a href="#l80.189"></a><span id="l80.189">   else</span>
<a href="#l80.190"></a><span id="l80.190">     ev-&gt;NilPointerError();</span>
<a href="#l80.191"></a><span id="l80.191" class="difflineminus">-    </span>
<a href="#l80.192"></a><span id="l80.192" class="difflineplus">+</span>
<a href="#l80.193"></a><span id="l80.193">   return outThumb;</span>
<a href="#l80.194"></a><span id="l80.194"> }</span>
<a href="#l80.195"></a><span id="l80.195"> </span>
<a href="#l80.196"></a><span id="l80.196"> // { ===== begin non-poly methods imitating nsIMdbThumb =====</span>
<a href="#l80.197"></a><span id="l80.197"> void morkThumb::GetProgress(morkEnv* ev, mdb_count* outTotal,</span>
<a href="#l80.198"></a><span id="l80.198">   mdb_count* outCurrent, mdb_bool* outDone, mdb_bool* outBroken)</span>
<a href="#l80.199"></a><span id="l80.199"> {</span>
<a href="#l80.200"></a><span id="l80.200">   MORK_USED_1(ev);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l81.1"></a><span id="l81.1" class="difflineminus">--- a/db/mork/src/morkThumb.h</span>
<a href="#l81.2"></a><span id="l81.2" class="difflineplus">+++ b/db/mork/src/morkThumb.h</span>
<a href="#l81.3"></a><span id="l81.3" class="difflineat">@@ -32,31 +32,31 @@</span>
<a href="#l81.4"></a><span id="l81.4"> #define morkThumb_kMagic_NewSortColumn              9 /* table metho) */</span>
<a href="#l81.5"></a><span id="l81.5"> #define morkThumb_kMagic_NewSortColumnWithCompare  10 /* table method */</span>
<a href="#l81.6"></a><span id="l81.6"> #define morkThumb_kMagic_CloneSortColumn           11 /* table method */</span>
<a href="#l81.7"></a><span id="l81.7"> #define morkThumb_kMagic_AddIndex                  12 /* table method */</span>
<a href="#l81.8"></a><span id="l81.8"> #define morkThumb_kMagic_CutIndex                  13 /* table method */</span>
<a href="#l81.9"></a><span id="l81.9"> </span>
<a href="#l81.10"></a><span id="l81.10"> #define morkDerived_kThumb     /*i*/ 0x5468 /* ascii 'Th' */</span>
<a href="#l81.11"></a><span id="l81.11"> </span>
<a href="#l81.12"></a><span id="l81.12" class="difflineminus">-/*| morkThumb: </span>
<a href="#l81.13"></a><span id="l81.13" class="difflineplus">+/*| morkThumb:</span>
<a href="#l81.14"></a><span id="l81.14"> |*/</span>
<a href="#l81.15"></a><span id="l81.15"> class morkThumb : public morkObject, public nsIMdbThumb {</span>
<a href="#l81.16"></a><span id="l81.16"> </span>
<a href="#l81.17"></a><span id="l81.17"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l81.18"></a><span id="l81.18">   // nsIMdbHeap*    mNode_Heap;</span>
<a href="#l81.19"></a><span id="l81.19"> </span>
<a href="#l81.20"></a><span id="l81.20">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l81.21"></a><span id="l81.21">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l81.22"></a><span id="l81.22" class="difflineminus">-  </span>
<a href="#l81.23"></a><span id="l81.23" class="difflineplus">+</span>
<a href="#l81.24"></a><span id="l81.24">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l81.25"></a><span id="l81.25">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l81.26"></a><span id="l81.26">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l81.27"></a><span id="l81.27">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l81.28"></a><span id="l81.28" class="difflineminus">-  </span>
<a href="#l81.29"></a><span id="l81.29" class="difflineplus">+</span>
<a href="#l81.30"></a><span id="l81.30">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l81.31"></a><span id="l81.31">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l81.32"></a><span id="l81.32"> </span>
<a href="#l81.33"></a><span id="l81.33">   // mork_color   mBead_Color;   // ID for this bead</span>
<a href="#l81.34"></a><span id="l81.34">   // morkHandle*  mObject_Handle;  // weak ref to handle for this object</span>
<a href="#l81.35"></a><span id="l81.35"> </span>
<a href="#l81.36"></a><span id="l81.36"> public: // state is public because the entire Mork system is private</span>
<a href="#l81.37"></a><span id="l81.37">   NS_DECL_ISUPPORTS_INHERITED</span>
<a href="#l81.38"></a><span id="l81.38" class="difflineat">@@ -67,34 +67,34 @@ public: // state is public because the e</span>
<a href="#l81.39"></a><span id="l81.39"> </span>
<a href="#l81.40"></a><span id="l81.40">   NS_IMETHOD DoMore(nsIMdbEnv* ev, mdb_count* outTotal,</span>
<a href="#l81.41"></a><span id="l81.41">     mdb_count* outCurrent, mdb_bool* outDone, mdb_bool* outBroken) override;</span>
<a href="#l81.42"></a><span id="l81.42"> </span>
<a href="#l81.43"></a><span id="l81.43">   NS_IMETHOD CancelAndBreakThumb(nsIMdbEnv* ev) override;</span>
<a href="#l81.44"></a><span id="l81.44"> // } ===== end nsIMdbThumb methods =====</span>
<a href="#l81.45"></a><span id="l81.45"> </span>
<a href="#l81.46"></a><span id="l81.46">   // might as well include all the return values here:</span>
<a href="#l81.47"></a><span id="l81.47" class="difflineminus">-  </span>
<a href="#l81.48"></a><span id="l81.48" class="difflineplus">+</span>
<a href="#l81.49"></a><span id="l81.49">   mork_magic   mThumb_Magic;   // magic sig different in each thumb type</span>
<a href="#l81.50"></a><span id="l81.50">   mork_count   mThumb_Total;</span>
<a href="#l81.51"></a><span id="l81.51">   mork_count   mThumb_Current;</span>
<a href="#l81.52"></a><span id="l81.52"> </span>
<a href="#l81.53"></a><span id="l81.53">   mork_bool    mThumb_Done;</span>
<a href="#l81.54"></a><span id="l81.54">   mork_bool    mThumb_Broken;</span>
<a href="#l81.55"></a><span id="l81.55">   mork_u2      mThumb_Seed;  // optional seed for u4 alignment padding</span>
<a href="#l81.56"></a><span id="l81.56" class="difflineminus">-  </span>
<a href="#l81.57"></a><span id="l81.57" class="difflineplus">+</span>
<a href="#l81.58"></a><span id="l81.58">   morkStore*   mThumb_Store; // weak ref to created store</span>
<a href="#l81.59"></a><span id="l81.59">   nsIMdbFile*  mThumb_File;  // strong ref to file (store, import, export)</span>
<a href="#l81.60"></a><span id="l81.60">   morkWriter*  mThumb_Writer;  // strong ref to writer (for commit)</span>
<a href="#l81.61"></a><span id="l81.61">   morkBuilder* mThumb_Builder;  // strong ref to builder (for store open)</span>
<a href="#l81.62"></a><span id="l81.62">   morkPort*    mThumb_SourcePort;  // strong ref to port for import</span>
<a href="#l81.63"></a><span id="l81.63" class="difflineminus">-  </span>
<a href="#l81.64"></a><span id="l81.64" class="difflineplus">+</span>
<a href="#l81.65"></a><span id="l81.65">   mork_bool    mThumb_DoCollect; // influence whether a collect happens</span>
<a href="#l81.66"></a><span id="l81.66">   mork_bool    mThumb_Pad[ 3 ]; // padding for u4 alignment</span>
<a href="#l81.67"></a><span id="l81.67" class="difflineminus">-  </span>
<a href="#l81.68"></a><span id="l81.68" class="difflineplus">+</span>
<a href="#l81.69"></a><span id="l81.69"> // { ===== begin morkNode interface =====</span>
<a href="#l81.70"></a><span id="l81.70"> public: // morkNode virtual methods</span>
<a href="#l81.71"></a><span id="l81.71">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseThumb() only if open</span>
<a href="#l81.72"></a><span id="l81.72"> </span>
<a href="#l81.73"></a><span id="l81.73"> public: // morkThumb construction &amp; destruction</span>
<a href="#l81.74"></a><span id="l81.74">   morkThumb(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l81.75"></a><span id="l81.75">     nsIMdbHeap* ioHeap, nsIMdbHeap* ioSlotHeap, mork_magic inMagic);</span>
<a href="#l81.76"></a><span id="l81.76">   void CloseThumb(morkEnv* ev); // called by CloseMorkNode();</span>
<a href="#l81.77"></a><span id="l81.77" class="difflineat">@@ -138,42 +138,42 @@ public: // 'do more' methods</span>
<a href="#l81.78"></a><span id="l81.78"> </span>
<a href="#l81.79"></a><span id="l81.79"> public: // other thumb methods</span>
<a href="#l81.80"></a><span id="l81.80"> </span>
<a href="#l81.81"></a><span id="l81.81">   morkStore* ThumbToOpenStore(morkEnv* ev);</span>
<a href="#l81.82"></a><span id="l81.82">   // for orkinFactory::ThumbToOpenStore() after OpenFileStore()</span>
<a href="#l81.83"></a><span id="l81.83"> </span>
<a href="#l81.84"></a><span id="l81.84"> public: // assorted thumb constructors</span>
<a href="#l81.85"></a><span id="l81.85"> </span>
<a href="#l81.86"></a><span id="l81.86" class="difflineminus">-  static morkThumb* Make_OpenFileStore(morkEnv* ev, </span>
<a href="#l81.87"></a><span id="l81.87" class="difflineplus">+  static morkThumb* Make_OpenFileStore(morkEnv* ev,</span>
<a href="#l81.88"></a><span id="l81.88">     nsIMdbHeap* ioHeap, morkStore* ioStore);</span>
<a href="#l81.89"></a><span id="l81.89"> </span>
<a href="#l81.90"></a><span id="l81.90" class="difflineminus">-  static morkThumb* Make_CompressCommit(morkEnv* ev, </span>
<a href="#l81.91"></a><span id="l81.91" class="difflineplus">+  static morkThumb* Make_CompressCommit(morkEnv* ev,</span>
<a href="#l81.92"></a><span id="l81.92">     nsIMdbHeap* ioHeap, morkStore* ioStore, mork_bool inDoCollect);</span>
<a href="#l81.93"></a><span id="l81.93"> </span>
<a href="#l81.94"></a><span id="l81.94" class="difflineminus">-  static morkThumb* Make_LargeCommit(morkEnv* ev, </span>
<a href="#l81.95"></a><span id="l81.95" class="difflineplus">+  static morkThumb* Make_LargeCommit(morkEnv* ev,</span>
<a href="#l81.96"></a><span id="l81.96">     nsIMdbHeap* ioHeap, morkStore* ioStore);</span>
<a href="#l81.97"></a><span id="l81.97"> </span>
<a href="#l81.98"></a><span id="l81.98"> // { ===== begin non-poly methods imitating nsIMdbThumb =====</span>
<a href="#l81.99"></a><span id="l81.99">   void GetProgress(morkEnv* ev, mdb_count* outTotal,</span>
<a href="#l81.100"></a><span id="l81.100">     mdb_count* outCurrent, mdb_bool* outDone, mdb_bool* outBroken);</span>
<a href="#l81.101"></a><span id="l81.101" class="difflineminus">-  </span>
<a href="#l81.102"></a><span id="l81.102" class="difflineplus">+</span>
<a href="#l81.103"></a><span id="l81.103">   void DoMore(morkEnv* ev, mdb_count* outTotal,</span>
<a href="#l81.104"></a><span id="l81.104">     mdb_count* outCurrent, mdb_bool* outDone, mdb_bool* outBroken);</span>
<a href="#l81.105"></a><span id="l81.105" class="difflineminus">-  </span>
<a href="#l81.106"></a><span id="l81.106" class="difflineplus">+</span>
<a href="#l81.107"></a><span id="l81.107">   void CancelAndBreakThumb(morkEnv* ev);</span>
<a href="#l81.108"></a><span id="l81.108"> // } ===== end non-poly methods imitating nsIMdbThumb =====</span>
<a href="#l81.109"></a><span id="l81.109"> </span>
<a href="#l81.110"></a><span id="l81.110"> </span>
<a href="#l81.111"></a><span id="l81.111"> </span>
<a href="#l81.112"></a><span id="l81.112"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l81.113"></a><span id="l81.113">   static void SlotWeakThumb(morkThumb* me,</span>
<a href="#l81.114"></a><span id="l81.114">     morkEnv* ev, morkThumb** ioSlot)</span>
<a href="#l81.115"></a><span id="l81.115">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l81.116"></a><span id="l81.116" class="difflineminus">-  </span>
<a href="#l81.117"></a><span id="l81.117" class="difflineplus">+</span>
<a href="#l81.118"></a><span id="l81.118">   static void SlotStrongThumb(morkThumb* me,</span>
<a href="#l81.119"></a><span id="l81.119">     morkEnv* ev, morkThumb** ioSlot)</span>
<a href="#l81.120"></a><span id="l81.120">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l81.121"></a><span id="l81.121"> };</span>
<a href="#l81.122"></a><span id="l81.122"> </span>
<a href="#l81.123"></a><span id="l81.123"> </span>
<a href="#l81.124"></a><span id="l81.124"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l81.125"></a><span id="l81.125"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l82.1"></a><span id="l82.1" class="difflineminus">--- a/db/mork/src/morkUniqRowCursor.h</span>
<a href="#l82.2"></a><span id="l82.2" class="difflineplus">+++ b/db/mork/src/morkUniqRowCursor.h</span>
<a href="#l82.3"></a><span id="l82.3" class="difflineat">@@ -70,25 +70,25 @@ public: // typing</span>
<a href="#l82.4"></a><span id="l82.4">   static void NonUniqRowCursorTypeError(morkEnv* ev);</span>
<a href="#l82.5"></a><span id="l82.5"> </span>
<a href="#l82.6"></a><span id="l82.6"> public: // other search row cursor methods</span>
<a href="#l82.7"></a><span id="l82.7"> </span>
<a href="#l82.8"></a><span id="l82.8">   virtual mork_bool CanHaveDupRowMembers(morkEnv* ev);</span>
<a href="#l82.9"></a><span id="l82.9">   virtual mork_count GetMemberCount(morkEnv* ev);</span>
<a href="#l82.10"></a><span id="l82.10"> </span>
<a href="#l82.11"></a><span id="l82.11">   virtual orkinTableRowCursor* AcquireUniqueRowCursorHandle(morkEnv* ev);</span>
<a href="#l82.12"></a><span id="l82.12" class="difflineminus">-  </span>
<a href="#l82.13"></a><span id="l82.13" class="difflineplus">+</span>
<a href="#l82.14"></a><span id="l82.14">   // virtual mdb_pos NextRowOid(morkEnv* ev, mdbOid* outOid);</span>
<a href="#l82.15"></a><span id="l82.15">   virtual morkRow* NextRow(morkEnv* ev, mdbOid* outOid, mdb_pos* outPos);</span>
<a href="#l82.16"></a><span id="l82.16"> </span>
<a href="#l82.17"></a><span id="l82.17"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l82.18"></a><span id="l82.18">   static void SlotWeakUniqRowCursor(morkUniqRowCursor* me,</span>
<a href="#l82.19"></a><span id="l82.19">     morkEnv* ev, morkUniqRowCursor** ioSlot)</span>
<a href="#l82.20"></a><span id="l82.20">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l82.21"></a><span id="l82.21" class="difflineminus">-  </span>
<a href="#l82.22"></a><span id="l82.22" class="difflineplus">+</span>
<a href="#l82.23"></a><span id="l82.23">   static void SlotStrongUniqRowCursor(morkUniqRowCursor* me,</span>
<a href="#l82.24"></a><span id="l82.24">     morkEnv* ev, morkUniqRowCursor** ioSlot)</span>
<a href="#l82.25"></a><span id="l82.25">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l82.26"></a><span id="l82.26"> };</span>
<a href="#l82.27"></a><span id="l82.27"> </span>
<a href="#l82.28"></a><span id="l82.28"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l82.29"></a><span id="l82.29"> </span>
<a href="#l82.30"></a><span id="l82.30"> #endif /* _MORKUNIQROWCURSOR_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l83.1"></a><span id="l83.1" class="difflineminus">--- a/db/mork/src/morkWriter.cpp</span>
<a href="#l83.2"></a><span id="l83.2" class="difflineplus">+++ b/db/mork/src/morkWriter.cpp</span>
<a href="#l83.3"></a><span id="l83.3" class="difflineat">@@ -72,17 +72,17 @@</span>
<a href="#l83.4"></a><span id="l83.4"> #endif</span>
<a href="#l83.5"></a><span id="l83.5"> </span>
<a href="#l83.6"></a><span id="l83.6"> #ifndef _MORKCH_</span>
<a href="#l83.7"></a><span id="l83.7"> #include &quot;morkCh.h&quot;</span>
<a href="#l83.8"></a><span id="l83.8"> #endif</span>
<a href="#l83.9"></a><span id="l83.9"> </span>
<a href="#l83.10"></a><span id="l83.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l83.11"></a><span id="l83.11"> </span>
<a href="#l83.12"></a><span id="l83.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l83.13"></a><span id="l83.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l83.14"></a><span id="l83.14"> // { ===== begin morkNode interface =====</span>
<a href="#l83.15"></a><span id="l83.15"> </span>
<a href="#l83.16"></a><span id="l83.16"> /*public virtual*/ void</span>
<a href="#l83.17"></a><span id="l83.17"> morkWriter::CloseMorkNode(morkEnv* ev) // CloseTable() only if open</span>
<a href="#l83.18"></a><span id="l83.18"> {</span>
<a href="#l83.19"></a><span id="l83.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l83.20"></a><span id="l83.20">   {</span>
<a href="#l83.21"></a><span id="l83.21">     this-&gt;MarkClosing();</span>
<a href="#l83.22"></a><span id="l83.22" class="difflineat">@@ -113,26 +113,26 @@ morkWriter::morkWriter(morkEnv* ev, cons</span>
<a href="#l83.23"></a><span id="l83.23"> , mWriter_GroupBufFill( 0 )</span>
<a href="#l83.24"></a><span id="l83.24"> </span>
<a href="#l83.25"></a><span id="l83.25"> , mWriter_TotalCount( morkWriter_kCountNumberOfPhases )</span>
<a href="#l83.26"></a><span id="l83.26"> , mWriter_DoneCount( 0 )</span>
<a href="#l83.27"></a><span id="l83.27"> </span>
<a href="#l83.28"></a><span id="l83.28"> , mWriter_LineSize( 0 )</span>
<a href="#l83.29"></a><span id="l83.29"> , mWriter_MaxIndent( morkWriter_kMaxIndent )</span>
<a href="#l83.30"></a><span id="l83.30"> , mWriter_MaxLine( morkWriter_kMaxLine )</span>
<a href="#l83.31"></a><span id="l83.31" class="difflineminus">-  </span>
<a href="#l83.32"></a><span id="l83.32" class="difflineplus">+</span>
<a href="#l83.33"></a><span id="l83.33"> , mWriter_TableForm( 0 )</span>
<a href="#l83.34"></a><span id="l83.34"> , mWriter_TableAtomScope( 'v' )</span>
<a href="#l83.35"></a><span id="l83.35"> , mWriter_TableRowScope( 0 )</span>
<a href="#l83.36"></a><span id="l83.36"> , mWriter_TableKind( 0 )</span>
<a href="#l83.37"></a><span id="l83.37" class="difflineminus">-  </span>
<a href="#l83.38"></a><span id="l83.38" class="difflineplus">+</span>
<a href="#l83.39"></a><span id="l83.39"> , mWriter_RowForm( 0 )</span>
<a href="#l83.40"></a><span id="l83.40"> , mWriter_RowAtomScope( 0 )</span>
<a href="#l83.41"></a><span id="l83.41"> , mWriter_RowScope( 0 )</span>
<a href="#l83.42"></a><span id="l83.42" class="difflineminus">-  </span>
<a href="#l83.43"></a><span id="l83.43" class="difflineplus">+</span>
<a href="#l83.44"></a><span id="l83.44"> , mWriter_DictForm( 0 )</span>
<a href="#l83.45"></a><span id="l83.45"> , mWriter_DictAtomScope( 'v' )</span>
<a href="#l83.46"></a><span id="l83.46"> </span>
<a href="#l83.47"></a><span id="l83.47"> , mWriter_NeedDirtyAll( morkBool_kFalse )</span>
<a href="#l83.48"></a><span id="l83.48"> , mWriter_Incremental( morkBool_kTrue ) // opposite of mWriter_NeedDirtyAll</span>
<a href="#l83.49"></a><span id="l83.49"> , mWriter_DidStartDict( morkBool_kFalse )</span>
<a href="#l83.50"></a><span id="l83.50"> , mWriter_DidEndDict( morkBool_kTrue )</span>
<a href="#l83.51"></a><span id="l83.51"> </span>
<a href="#l83.52"></a><span id="l83.52" class="difflineat">@@ -143,44 +143,44 @@ morkWriter::morkWriter(morkEnv* ev, cons</span>
<a href="#l83.53"></a><span id="l83.53"> </span>
<a href="#l83.54"></a><span id="l83.54"> , mWriter_BeVerbose( ev-&gt;mEnv_BeVerbose )</span>
<a href="#l83.55"></a><span id="l83.55"> </span>
<a href="#l83.56"></a><span id="l83.56"> , mWriter_TableRowArrayPos( 0 )</span>
<a href="#l83.57"></a><span id="l83.57"> </span>
<a href="#l83.58"></a><span id="l83.58"> // empty constructors for map iterators:</span>
<a href="#l83.59"></a><span id="l83.59"> , mWriter_StoreAtomSpacesIter( )</span>
<a href="#l83.60"></a><span id="l83.60"> , mWriter_AtomSpaceAtomAidsIter( )</span>
<a href="#l83.61"></a><span id="l83.61" class="difflineminus">-  </span>
<a href="#l83.62"></a><span id="l83.62" class="difflineplus">+</span>
<a href="#l83.63"></a><span id="l83.63"> , mWriter_StoreRowSpacesIter( )</span>
<a href="#l83.64"></a><span id="l83.64"> , mWriter_RowSpaceTablesIter( )</span>
<a href="#l83.65"></a><span id="l83.65"> , mWriter_RowSpaceRowsIter( )</span>
<a href="#l83.66"></a><span id="l83.66"> {</span>
<a href="#l83.67"></a><span id="l83.67">   mWriter_GroupBuf[ 0 ] = 0;</span>
<a href="#l83.68"></a><span id="l83.68"> </span>
<a href="#l83.69"></a><span id="l83.69">   mWriter_SafeNameBuf[ 0 ] = 0;</span>
<a href="#l83.70"></a><span id="l83.70">   mWriter_SafeNameBuf[ morkWriter_kMaxColumnNameSize * 2 ] = 0;</span>
<a href="#l83.71"></a><span id="l83.71">   mWriter_ColNameBuf[ 0 ] = 0;</span>
<a href="#l83.72"></a><span id="l83.72">   mWriter_ColNameBuf[ morkWriter_kMaxColumnNameSize ] = 0;</span>
<a href="#l83.73"></a><span id="l83.73" class="difflineminus">-  </span>
<a href="#l83.74"></a><span id="l83.74" class="difflineplus">+</span>
<a href="#l83.75"></a><span id="l83.75">   mdbYarn* y = &amp;mWriter_ColYarn;</span>
<a href="#l83.76"></a><span id="l83.76">   y-&gt;mYarn_Buf = mWriter_ColNameBuf; // where to put col bytes</span>
<a href="#l83.77"></a><span id="l83.77">   y-&gt;mYarn_Fill = 0; // set later by writer</span>
<a href="#l83.78"></a><span id="l83.78">   y-&gt;mYarn_Size = morkWriter_kMaxColumnNameSize; // our buf size</span>
<a href="#l83.79"></a><span id="l83.79">   y-&gt;mYarn_More = 0; // set later by writer</span>
<a href="#l83.80"></a><span id="l83.80">   y-&gt;mYarn_Form = 0; // set later by writer</span>
<a href="#l83.81"></a><span id="l83.81">   y-&gt;mYarn_Grow = 0; // do not allow buffer growth</span>
<a href="#l83.82"></a><span id="l83.82" class="difflineminus">-  </span>
<a href="#l83.83"></a><span id="l83.83" class="difflineplus">+</span>
<a href="#l83.84"></a><span id="l83.84">   y = &amp;mWriter_SafeYarn;</span>
<a href="#l83.85"></a><span id="l83.85">   y-&gt;mYarn_Buf = mWriter_SafeNameBuf; // where to put col bytes</span>
<a href="#l83.86"></a><span id="l83.86">   y-&gt;mYarn_Fill = 0; // set later by writer</span>
<a href="#l83.87"></a><span id="l83.87">   y-&gt;mYarn_Size = morkWriter_kMaxColumnNameSize * 2; // our buf size</span>
<a href="#l83.88"></a><span id="l83.88">   y-&gt;mYarn_More = 0; // set later by writer</span>
<a href="#l83.89"></a><span id="l83.89">   y-&gt;mYarn_Form = 0; // set later by writer</span>
<a href="#l83.90"></a><span id="l83.90">   y-&gt;mYarn_Grow = 0; // do not allow buffer growth</span>
<a href="#l83.91"></a><span id="l83.91" class="difflineminus">-  </span>
<a href="#l83.92"></a><span id="l83.92" class="difflineplus">+</span>
<a href="#l83.93"></a><span id="l83.93">   if ( ev-&gt;Good() )</span>
<a href="#l83.94"></a><span id="l83.94">   {</span>
<a href="#l83.95"></a><span id="l83.95">     if ( ioSlotHeap &amp;&amp; ioFile &amp;&amp; ioStore )</span>
<a href="#l83.96"></a><span id="l83.96">     {</span>
<a href="#l83.97"></a><span id="l83.97">       morkStore::SlotWeakStore(ioStore, ev, &amp;mWriter_Store);</span>
<a href="#l83.98"></a><span id="l83.98">       nsIMdbFile_SlotStrongFile(ioFile, ev, &amp;mWriter_File);</span>
<a href="#l83.99"></a><span id="l83.99">       nsIMdbHeap_SlotStrongHeap(ioSlotHeap, ev, &amp;mWriter_SlotHeap);</span>
<a href="#l83.100"></a><span id="l83.100">       if ( ev-&gt;Good() )</span>
<a href="#l83.101"></a><span id="l83.101" class="difflineat">@@ -193,25 +193,25 @@ morkWriter::morkWriter(morkEnv* ev, cons</span>
<a href="#l83.102"></a><span id="l83.102">   }</span>
<a href="#l83.103"></a><span id="l83.103"> }</span>
<a href="#l83.104"></a><span id="l83.104"> </span>
<a href="#l83.105"></a><span id="l83.105"> </span>
<a href="#l83.106"></a><span id="l83.106"> void</span>
<a href="#l83.107"></a><span id="l83.107"> morkWriter::MakeWriterStream(morkEnv* ev) // give writer a suitable stream</span>
<a href="#l83.108"></a><span id="l83.108"> {</span>
<a href="#l83.109"></a><span id="l83.109">   mWriter_Incremental = !mWriter_NeedDirtyAll; // opposites</span>
<a href="#l83.110"></a><span id="l83.110" class="difflineminus">-  </span>
<a href="#l83.111"></a><span id="l83.111" class="difflineplus">+</span>
<a href="#l83.112"></a><span id="l83.112">   if ( !mWriter_Stream &amp;&amp; ev-&gt;Good() )</span>
<a href="#l83.113"></a><span id="l83.113">   {</span>
<a href="#l83.114"></a><span id="l83.114">     if ( mWriter_File )</span>
<a href="#l83.115"></a><span id="l83.115">     {</span>
<a href="#l83.116"></a><span id="l83.116">       morkStream* stream = 0;</span>
<a href="#l83.117"></a><span id="l83.117">       mork_bool frozen = morkBool_kFalse; // need to modify</span>
<a href="#l83.118"></a><span id="l83.118">       nsIMdbHeap* heap = mWriter_SlotHeap;</span>
<a href="#l83.119"></a><span id="l83.119" class="difflineminus">-    </span>
<a href="#l83.120"></a><span id="l83.120" class="difflineplus">+</span>
<a href="#l83.121"></a><span id="l83.121">       if ( mWriter_Incremental )</span>
<a href="#l83.122"></a><span id="l83.122">       {</span>
<a href="#l83.123"></a><span id="l83.123">         stream = new(*heap, ev)</span>
<a href="#l83.124"></a><span id="l83.124">           morkStream(ev, morkUsage::kHeap, heap, mWriter_File,</span>
<a href="#l83.125"></a><span id="l83.125">             morkWriter_kStreamBufSize, frozen);</span>
<a href="#l83.126"></a><span id="l83.126">       }</span>
<a href="#l83.127"></a><span id="l83.127">       else // compress commit</span>
<a href="#l83.128"></a><span id="l83.128">       {</span>
<a href="#l83.129"></a><span id="l83.129" class="difflineat">@@ -225,17 +225,17 @@ morkWriter::MakeWriterStream(morkEnv* ev</span>
<a href="#l83.130"></a><span id="l83.130">             stream = new(*heap, ev)</span>
<a href="#l83.131"></a><span id="l83.131">               morkStream(ev, morkUsage::kHeap, heap, bud,</span>
<a href="#l83.132"></a><span id="l83.132">                 morkWriter_kStreamBufSize, frozen);</span>
<a href="#l83.133"></a><span id="l83.133">           }</span>
<a href="#l83.134"></a><span id="l83.134">           else</span>
<a href="#l83.135"></a><span id="l83.135">             bud-&gt;Release();</span>
<a href="#l83.136"></a><span id="l83.136">         }</span>
<a href="#l83.137"></a><span id="l83.137">       }</span>
<a href="#l83.138"></a><span id="l83.138" class="difflineminus">-        </span>
<a href="#l83.139"></a><span id="l83.139" class="difflineplus">+</span>
<a href="#l83.140"></a><span id="l83.140">       if ( stream )</span>
<a href="#l83.141"></a><span id="l83.141">       {</span>
<a href="#l83.142"></a><span id="l83.142">         if ( ev-&gt;Good() )</span>
<a href="#l83.143"></a><span id="l83.143">           mWriter_Stream = stream;</span>
<a href="#l83.144"></a><span id="l83.144">         else</span>
<a href="#l83.145"></a><span id="l83.145">           stream-&gt;CutStrongRef(ev-&gt;AsMdbEnv());</span>
<a href="#l83.146"></a><span id="l83.146">       }</span>
<a href="#l83.147"></a><span id="l83.147">     }</span>
<a href="#l83.148"></a><span id="l83.148" class="difflineat">@@ -256,17 +256,17 @@ morkWriter::CloseWriter(morkEnv* ev) // </span>
<a href="#l83.149"></a><span id="l83.149">       nsIMdbHeap_SlotStrongHeap((nsIMdbHeap*) 0, ev, &amp;mWriter_SlotHeap);</span>
<a href="#l83.150"></a><span id="l83.150">       this-&gt;MarkShut();</span>
<a href="#l83.151"></a><span id="l83.151">     }</span>
<a href="#l83.152"></a><span id="l83.152">     else</span>
<a href="#l83.153"></a><span id="l83.153">       this-&gt;NonNodeError(ev);</span>
<a href="#l83.154"></a><span id="l83.154"> }</span>
<a href="#l83.155"></a><span id="l83.155"> </span>
<a href="#l83.156"></a><span id="l83.156"> // } ===== end morkNode methods =====</span>
<a href="#l83.157"></a><span id="l83.157" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l83.158"></a><span id="l83.158" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l83.159"></a><span id="l83.159"> </span>
<a href="#l83.160"></a><span id="l83.160"> /*static*/ void</span>
<a href="#l83.161"></a><span id="l83.161"> morkWriter::NonWriterTypeError(morkEnv* ev)</span>
<a href="#l83.162"></a><span id="l83.162"> {</span>
<a href="#l83.163"></a><span id="l83.163">   ev-&gt;NewError(&quot;non morkWriter&quot;);</span>
<a href="#l83.164"></a><span id="l83.164"> }</span>
<a href="#l83.165"></a><span id="l83.165"> </span>
<a href="#l83.166"></a><span id="l83.166"> /*static*/ void</span>
<a href="#l83.167"></a><span id="l83.167" class="difflineat">@@ -303,78 +303,78 @@ mork_bool</span>
<a href="#l83.168"></a><span id="l83.168"> morkWriter::WriteMore(morkEnv* ev) // call until IsWritingDone() is true</span>
<a href="#l83.169"></a><span id="l83.169"> {</span>
<a href="#l83.170"></a><span id="l83.170">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l83.171"></a><span id="l83.171">   {</span>
<a href="#l83.172"></a><span id="l83.172">     if ( this-&gt;IsWriter() )</span>
<a href="#l83.173"></a><span id="l83.173">     {</span>
<a href="#l83.174"></a><span id="l83.174">       if ( !mWriter_Stream )</span>
<a href="#l83.175"></a><span id="l83.175">         this-&gt;MakeWriterStream(ev);</span>
<a href="#l83.176"></a><span id="l83.176" class="difflineminus">-        </span>
<a href="#l83.177"></a><span id="l83.177" class="difflineplus">+</span>
<a href="#l83.178"></a><span id="l83.178">       if ( mWriter_Stream )</span>
<a href="#l83.179"></a><span id="l83.179">       {</span>
<a href="#l83.180"></a><span id="l83.180">         if ( ev-&gt;Bad() )</span>
<a href="#l83.181"></a><span id="l83.181">         {</span>
<a href="#l83.182"></a><span id="l83.182">           ev-&gt;NewWarning(&quot;writing stops on error&quot;);</span>
<a href="#l83.183"></a><span id="l83.183">           mWriter_Phase = morkWriter_kPhaseWritingDone;</span>
<a href="#l83.184"></a><span id="l83.184">         }</span>
<a href="#l83.185"></a><span id="l83.185">         switch( mWriter_Phase )</span>
<a href="#l83.186"></a><span id="l83.186">         {</span>
<a href="#l83.187"></a><span id="l83.187">           case morkWriter_kPhaseNothingDone:</span>
<a href="#l83.188"></a><span id="l83.188">             OnNothingDone(ev); break;</span>
<a href="#l83.189"></a><span id="l83.189" class="difflineminus">-          </span>
<a href="#l83.190"></a><span id="l83.190" class="difflineplus">+</span>
<a href="#l83.191"></a><span id="l83.191">           case morkWriter_kPhaseDirtyAllDone:</span>
<a href="#l83.192"></a><span id="l83.192">             OnDirtyAllDone(ev); break;</span>
<a href="#l83.193"></a><span id="l83.193" class="difflineminus">-          </span>
<a href="#l83.194"></a><span id="l83.194" class="difflineplus">+</span>
<a href="#l83.195"></a><span id="l83.195">           case morkWriter_kPhasePutHeaderDone:</span>
<a href="#l83.196"></a><span id="l83.196">             OnPutHeaderDone(ev); break;</span>
<a href="#l83.197"></a><span id="l83.197" class="difflineminus">-          </span>
<a href="#l83.198"></a><span id="l83.198" class="difflineplus">+</span>
<a href="#l83.199"></a><span id="l83.199">           case morkWriter_kPhaseRenumberAllDone:</span>
<a href="#l83.200"></a><span id="l83.200">             OnRenumberAllDone(ev); break;</span>
<a href="#l83.201"></a><span id="l83.201" class="difflineminus">-          </span>
<a href="#l83.202"></a><span id="l83.202" class="difflineplus">+</span>
<a href="#l83.203"></a><span id="l83.203">           case morkWriter_kPhaseStoreAtomSpaces:</span>
<a href="#l83.204"></a><span id="l83.204">             OnStoreAtomSpaces(ev); break;</span>
<a href="#l83.205"></a><span id="l83.205" class="difflineminus">-          </span>
<a href="#l83.206"></a><span id="l83.206" class="difflineplus">+</span>
<a href="#l83.207"></a><span id="l83.207">           case morkWriter_kPhaseAtomSpaceAtomAids:</span>
<a href="#l83.208"></a><span id="l83.208">             OnAtomSpaceAtomAids(ev); break;</span>
<a href="#l83.209"></a><span id="l83.209" class="difflineminus">-          </span>
<a href="#l83.210"></a><span id="l83.210" class="difflineplus">+</span>
<a href="#l83.211"></a><span id="l83.211">           case morkWriter_kPhaseStoreRowSpacesTables:</span>
<a href="#l83.212"></a><span id="l83.212">             OnStoreRowSpacesTables(ev); break;</span>
<a href="#l83.213"></a><span id="l83.213" class="difflineminus">-          </span>
<a href="#l83.214"></a><span id="l83.214" class="difflineplus">+</span>
<a href="#l83.215"></a><span id="l83.215">           case morkWriter_kPhaseRowSpaceTables:</span>
<a href="#l83.216"></a><span id="l83.216">             OnRowSpaceTables(ev); break;</span>
<a href="#l83.217"></a><span id="l83.217" class="difflineminus">-          </span>
<a href="#l83.218"></a><span id="l83.218" class="difflineplus">+</span>
<a href="#l83.219"></a><span id="l83.219">           case morkWriter_kPhaseTableRowArray:</span>
<a href="#l83.220"></a><span id="l83.220">             OnTableRowArray(ev); break;</span>
<a href="#l83.221"></a><span id="l83.221" class="difflineminus">-          </span>
<a href="#l83.222"></a><span id="l83.222" class="difflineplus">+</span>
<a href="#l83.223"></a><span id="l83.223">           case morkWriter_kPhaseStoreRowSpacesRows:</span>
<a href="#l83.224"></a><span id="l83.224">             OnStoreRowSpacesRows(ev); break;</span>
<a href="#l83.225"></a><span id="l83.225" class="difflineminus">-          </span>
<a href="#l83.226"></a><span id="l83.226" class="difflineplus">+</span>
<a href="#l83.227"></a><span id="l83.227">           case morkWriter_kPhaseRowSpaceRows:</span>
<a href="#l83.228"></a><span id="l83.228">             OnRowSpaceRows(ev); break;</span>
<a href="#l83.229"></a><span id="l83.229" class="difflineminus">-          </span>
<a href="#l83.230"></a><span id="l83.230" class="difflineplus">+</span>
<a href="#l83.231"></a><span id="l83.231">           case morkWriter_kPhaseContentDone:</span>
<a href="#l83.232"></a><span id="l83.232">             OnContentDone(ev); break;</span>
<a href="#l83.233"></a><span id="l83.233" class="difflineminus">-          </span>
<a href="#l83.234"></a><span id="l83.234" class="difflineplus">+</span>
<a href="#l83.235"></a><span id="l83.235">           case morkWriter_kPhaseWritingDone:</span>
<a href="#l83.236"></a><span id="l83.236">             OnWritingDone(ev); break;</span>
<a href="#l83.237"></a><span id="l83.237" class="difflineminus">-          </span>
<a href="#l83.238"></a><span id="l83.238" class="difflineplus">+</span>
<a href="#l83.239"></a><span id="l83.239">           default:</span>
<a href="#l83.240"></a><span id="l83.240">             this-&gt;UnsupportedPhaseError(ev);</span>
<a href="#l83.241"></a><span id="l83.241">         }</span>
<a href="#l83.242"></a><span id="l83.242">       }</span>
<a href="#l83.243"></a><span id="l83.243">       else</span>
<a href="#l83.244"></a><span id="l83.244">         this-&gt;NilWriterStreamError(ev);</span>
<a href="#l83.245"></a><span id="l83.245">     }</span>
<a href="#l83.246"></a><span id="l83.246">     else</span>
<a href="#l83.247"></a><span id="l83.247">       this-&gt;NonWriterTypeError(ev);</span>
<a href="#l83.248"></a><span id="l83.248">   }</span>
<a href="#l83.249"></a><span id="l83.249">   else</span>
<a href="#l83.250"></a><span id="l83.250">     this-&gt;NonOpenNodeError(ev);</span>
<a href="#l83.251"></a><span id="l83.251" class="difflineminus">-    </span>
<a href="#l83.252"></a><span id="l83.252" class="difflineplus">+</span>
<a href="#l83.253"></a><span id="l83.253">   return ev-&gt;Good();</span>
<a href="#l83.254"></a><span id="l83.254"> }</span>
<a href="#l83.255"></a><span id="l83.255"> </span>
<a href="#l83.256"></a><span id="l83.256"> static const char morkWriter_kHexDigits[] = &quot;0123456789ABCDEF&quot;;</span>
<a href="#l83.257"></a><span id="l83.257"> </span>
<a href="#l83.258"></a><span id="l83.258"> mork_size</span>
<a href="#l83.259"></a><span id="l83.259"> morkWriter::WriteYarn(morkEnv* ev, const mdbYarn* inYarn)</span>
<a href="#l83.260"></a><span id="l83.260">   // return number of atom bytes written on the current line (which</span>
<a href="#l83.261"></a><span id="l83.261" class="difflineat">@@ -396,17 +396,17 @@ morkWriter::WriteYarn(morkEnv* ev, const</span>
<a href="#l83.262"></a><span id="l83.262">     const mork_u1* end = b + fill;</span>
<a href="#l83.263"></a><span id="l83.263">     while ( b &lt; end &amp;&amp; ev-&gt;Good() )</span>
<a href="#l83.264"></a><span id="l83.264">     {</span>
<a href="#l83.265"></a><span id="l83.265">       if ( lineSize + outSize &gt;= mWriter_MaxLine ) // continue line?</span>
<a href="#l83.266"></a><span id="l83.266">       {</span>
<a href="#l83.267"></a><span id="l83.267">         stream-&gt;PutByteThenNewline(ev, '\\');</span>
<a href="#l83.268"></a><span id="l83.268">         mWriter_LineSize = lineSize = outSize = 0;</span>
<a href="#l83.269"></a><span id="l83.269">       }</span>
<a href="#l83.270"></a><span id="l83.270" class="difflineminus">-      </span>
<a href="#l83.271"></a><span id="l83.271" class="difflineplus">+</span>
<a href="#l83.272"></a><span id="l83.272">       c = *b++; // next byte to print</span>
<a href="#l83.273"></a><span id="l83.273">       if ( morkCh_IsValue(c) )</span>
<a href="#l83.274"></a><span id="l83.274">       {</span>
<a href="#l83.275"></a><span id="l83.275">         stream-&gt;Putc(ev, c);</span>
<a href="#l83.276"></a><span id="l83.276">         ++outSize; // c</span>
<a href="#l83.277"></a><span id="l83.277">       }</span>
<a href="#l83.278"></a><span id="l83.278">       else if ( c == ')' || c == '$' || c == '\\' )</span>
<a href="#l83.279"></a><span id="l83.279">       {</span>
<a href="#l83.280"></a><span id="l83.280" class="difflineat">@@ -419,40 +419,40 @@ morkWriter::WriteYarn(morkEnv* ev, const</span>
<a href="#l83.281"></a><span id="l83.281">         outSize += 3; // '$' hex hex</span>
<a href="#l83.282"></a><span id="l83.282">         stream-&gt;Putc(ev, '$');</span>
<a href="#l83.283"></a><span id="l83.283">         stream-&gt;Putc(ev, morkWriter_kHexDigits[ (c &gt;&gt; 4) &amp; 0x0F ]);</span>
<a href="#l83.284"></a><span id="l83.284">         stream-&gt;Putc(ev, morkWriter_kHexDigits[ c &amp; 0x0F ]);</span>
<a href="#l83.285"></a><span id="l83.285">       }</span>
<a href="#l83.286"></a><span id="l83.286">     }</span>
<a href="#l83.287"></a><span id="l83.287">   }</span>
<a href="#l83.288"></a><span id="l83.288">   mWriter_LineSize += outSize;</span>
<a href="#l83.289"></a><span id="l83.289" class="difflineminus">-    </span>
<a href="#l83.290"></a><span id="l83.290" class="difflineplus">+</span>
<a href="#l83.291"></a><span id="l83.291">   return outSize;</span>
<a href="#l83.292"></a><span id="l83.292"> }</span>
<a href="#l83.293"></a><span id="l83.293"> </span>
<a href="#l83.294"></a><span id="l83.294"> mork_size</span>
<a href="#l83.295"></a><span id="l83.295"> morkWriter::WriteAtom(morkEnv* ev, const morkAtom* inAtom)</span>
<a href="#l83.296"></a><span id="l83.296">   // return number of atom bytes written on the current line (which</span>
<a href="#l83.297"></a><span id="l83.297">   // implies that escaped line breaks will make the size value smaller</span>
<a href="#l83.298"></a><span id="l83.298">   // than the entire atom's size, since only part goes on a last line).</span>
<a href="#l83.299"></a><span id="l83.299"> {</span>
<a href="#l83.300"></a><span id="l83.300">   mork_size outSize = 0;</span>
<a href="#l83.301"></a><span id="l83.301">   mdbYarn yarn; // to ref content inside atom</span>
<a href="#l83.302"></a><span id="l83.302"> </span>
<a href="#l83.303"></a><span id="l83.303">   if ( morkAtom::AliasYarn(inAtom, &amp;yarn) )</span>
<a href="#l83.304"></a><span id="l83.304">   {</span>
<a href="#l83.305"></a><span id="l83.305">     if ( mWriter_DidStartDict &amp;&amp; yarn.mYarn_Form != mWriter_DictForm )</span>
<a href="#l83.306"></a><span id="l83.306" class="difflineminus">-      this-&gt;ChangeDictForm(ev, yarn.mYarn_Form);  </span>
<a href="#l83.307"></a><span id="l83.307" class="difflineminus">-      </span>
<a href="#l83.308"></a><span id="l83.308" class="difflineplus">+      this-&gt;ChangeDictForm(ev, yarn.mYarn_Form);</span>
<a href="#l83.309"></a><span id="l83.309" class="difflineplus">+</span>
<a href="#l83.310"></a><span id="l83.310">     outSize = this-&gt;WriteYarn(ev, &amp;yarn);</span>
<a href="#l83.311"></a><span id="l83.311">     // mWriter_LineSize += stream-&gt;Write(ev, inYarn-&gt;mYarn_Buf, outSize);</span>
<a href="#l83.312"></a><span id="l83.312">   }</span>
<a href="#l83.313"></a><span id="l83.313">   else</span>
<a href="#l83.314"></a><span id="l83.314">     inAtom-&gt;BadAtomKindError(ev);</span>
<a href="#l83.315"></a><span id="l83.315" class="difflineminus">-    </span>
<a href="#l83.316"></a><span id="l83.316" class="difflineplus">+</span>
<a href="#l83.317"></a><span id="l83.317">   return outSize;</span>
<a href="#l83.318"></a><span id="l83.318"> }</span>
<a href="#l83.319"></a><span id="l83.319"> </span>
<a href="#l83.320"></a><span id="l83.320"> void</span>
<a href="#l83.321"></a><span id="l83.321"> morkWriter::WriteAtomSpaceAsDict(morkEnv* ev, morkAtomSpace* ioSpace)</span>
<a href="#l83.322"></a><span id="l83.322"> {</span>
<a href="#l83.323"></a><span id="l83.323">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.324"></a><span id="l83.324">   nsIMdbEnv *mdbev = ev-&gt;AsMdbEnv();</span>
<a href="#l83.325"></a><span id="l83.325" class="difflineat">@@ -475,63 +475,63 @@ morkWriter::WriteAtomSpaceAsDict(morkEnv</span>
<a href="#l83.326"></a><span id="l83.326">     mdbYarn yarn; // to ref content inside atom</span>
<a href="#l83.327"></a><span id="l83.327">     char buf[ 64 ]; // buffer for staging the dict alias hex ID</span>
<a href="#l83.328"></a><span id="l83.328">     char* idBuf = buf + 1; // where the id always starts</span>
<a href="#l83.329"></a><span id="l83.329">     buf[ 0 ] = '('; // we always start with open paren</span>
<a href="#l83.330"></a><span id="l83.330">     morkBookAtom* atom = 0;</span>
<a href="#l83.331"></a><span id="l83.331">     morkAtomAidMapIter* ai = &amp;mWriter_AtomSpaceAtomAidsIter;</span>
<a href="#l83.332"></a><span id="l83.332">     ai-&gt;InitAtomAidMapIter(ev, &amp;ioSpace-&gt;mAtomSpace_AtomAids);</span>
<a href="#l83.333"></a><span id="l83.333">     mork_change* c = 0;</span>
<a href="#l83.334"></a><span id="l83.334" class="difflineminus">-    </span>
<a href="#l83.335"></a><span id="l83.335" class="difflineplus">+</span>
<a href="#l83.336"></a><span id="l83.336">     for ( c = ai-&gt;FirstAtom(ev, &amp;atom); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l83.337"></a><span id="l83.337">           c = ai-&gt;NextAtom(ev, &amp;atom) )</span>
<a href="#l83.338"></a><span id="l83.338">     {</span>
<a href="#l83.339"></a><span id="l83.339">       if ( atom )</span>
<a href="#l83.340"></a><span id="l83.340">       {</span>
<a href="#l83.341"></a><span id="l83.341">         if ( atom-&gt;IsAtomDirty() )</span>
<a href="#l83.342"></a><span id="l83.342">         {</span>
<a href="#l83.343"></a><span id="l83.343">           atom-&gt;SetAtomClean(); // neutralize change</span>
<a href="#l83.344"></a><span id="l83.344"> </span>
<a href="#l83.345"></a><span id="l83.345">           morkAtom::AliasYarn(atom, &amp;yarn);</span>
<a href="#l83.346"></a><span id="l83.346">           mork_size size = ev-&gt;TokenAsHex(idBuf, atom-&gt;mBookAtom_Id);</span>
<a href="#l83.347"></a><span id="l83.347"> </span>
<a href="#l83.348"></a><span id="l83.348">           if ( yarn.mYarn_Form != mWriter_DictForm )</span>
<a href="#l83.349"></a><span id="l83.349">             this-&gt;ChangeDictForm(ev, yarn.mYarn_Form);</span>
<a href="#l83.350"></a><span id="l83.350"> </span>
<a href="#l83.351"></a><span id="l83.351" class="difflineminus">-          mork_size pending = yarn.mYarn_Fill + size + </span>
<a href="#l83.352"></a><span id="l83.352" class="difflineplus">+          mork_size pending = yarn.mYarn_Fill + size +</span>
<a href="#l83.353"></a><span id="l83.353">             morkWriter_kYarnEscapeSlop + 4;</span>
<a href="#l83.354"></a><span id="l83.354">           this-&gt;IndentOverMaxLine(ev, pending, morkWriter_kDictAliasDepth);</span>
<a href="#l83.355"></a><span id="l83.355">           mork_size bytesWritten;</span>
<a href="#l83.356"></a><span id="l83.356">           stream-&gt;Write(mdbev, buf, size+1, &amp;bytesWritten); //  + '('</span>
<a href="#l83.357"></a><span id="l83.357">           mWriter_LineSize += bytesWritten;</span>
<a href="#l83.358"></a><span id="l83.358" class="difflineminus">-          </span>
<a href="#l83.359"></a><span id="l83.359" class="difflineplus">+</span>
<a href="#l83.360"></a><span id="l83.360">           pending -= ( size + 1 );</span>
<a href="#l83.361"></a><span id="l83.361">           this-&gt;IndentOverMaxLine(ev, pending, morkWriter_kDictAliasValueDepth);</span>
<a href="#l83.362"></a><span id="l83.362">           stream-&gt;Putc(ev, '='); // start alias</span>
<a href="#l83.363"></a><span id="l83.363">           ++mWriter_LineSize;</span>
<a href="#l83.364"></a><span id="l83.364" class="difflineminus">-          </span>
<a href="#l83.365"></a><span id="l83.365" class="difflineplus">+</span>
<a href="#l83.366"></a><span id="l83.366">           this-&gt;WriteYarn(ev, &amp;yarn);</span>
<a href="#l83.367"></a><span id="l83.367">           stream-&gt;Putc(ev, ')'); // end alias</span>
<a href="#l83.368"></a><span id="l83.368">           ++mWriter_LineSize;</span>
<a href="#l83.369"></a><span id="l83.369" class="difflineminus">-          </span>
<a href="#l83.370"></a><span id="l83.370" class="difflineplus">+</span>
<a href="#l83.371"></a><span id="l83.371">           ++mWriter_DoneCount;</span>
<a href="#l83.372"></a><span id="l83.372">         }</span>
<a href="#l83.373"></a><span id="l83.373">       }</span>
<a href="#l83.374"></a><span id="l83.374">       else</span>
<a href="#l83.375"></a><span id="l83.375">         ev-&gt;NilPointerError();</span>
<a href="#l83.376"></a><span id="l83.376">     }</span>
<a href="#l83.377"></a><span id="l83.377">     ai-&gt;CloseMapIter(ev);</span>
<a href="#l83.378"></a><span id="l83.378">   }</span>
<a href="#l83.379"></a><span id="l83.379" class="difflineminus">-  </span>
<a href="#l83.380"></a><span id="l83.380" class="difflineplus">+</span>
<a href="#l83.381"></a><span id="l83.381">   if ( ev-&gt;Good() )</span>
<a href="#l83.382"></a><span id="l83.382">   {</span>
<a href="#l83.383"></a><span id="l83.383">     ioSpace-&gt;SetAtomSpaceClean();</span>
<a href="#l83.384"></a><span id="l83.384">     // this-&gt;IndentAsNeeded(ev, 0);</span>
<a href="#l83.385"></a><span id="l83.385">     // stream-&gt;PutByteThenNewline(ev, '&gt;'); // end dict</span>
<a href="#l83.386"></a><span id="l83.386" class="difflineminus">-    </span>
<a href="#l83.387"></a><span id="l83.387" class="difflineplus">+</span>
<a href="#l83.388"></a><span id="l83.388">     stream-&gt;Putc(ev, '&gt;'); // end dict</span>
<a href="#l83.389"></a><span id="l83.389">     ++mWriter_LineSize;</span>
<a href="#l83.390"></a><span id="l83.390">   }</span>
<a href="#l83.391"></a><span id="l83.391"> }</span>
<a href="#l83.392"></a><span id="l83.392"> </span>
<a href="#l83.393"></a><span id="l83.393"> /*</span>
<a href="#l83.394"></a><span id="l83.394"> (I'm putting the text of this message in file morkWriter.cpp.)</span>
<a href="#l83.395"></a><span id="l83.395"> </span>
<a href="#l83.396"></a><span id="l83.396" class="difflineat">@@ -578,82 +578,82 @@ Presumably if they are truly useless, th</span>
<a href="#l83.397"></a><span id="l83.397"> in later sessions and will get collected during the next compress</span>
<a href="#l83.398"></a><span id="l83.398"> commit.  So we wait to collect them until they become all dead, and</span>
<a href="#l83.399"></a><span id="l83.399"> not just mostly dead.  (At which time you can feel free to go through</span>
<a href="#l83.400"></a><span id="l83.400"> their pockets looking for loose change.)</span>
<a href="#l83.401"></a><span id="l83.401"> */</span>
<a href="#l83.402"></a><span id="l83.402"> </span>
<a href="#l83.403"></a><span id="l83.403"> mork_bool</span>
<a href="#l83.404"></a><span id="l83.404"> morkWriter::DirtyAll(morkEnv* ev)</span>
<a href="#l83.405"></a><span id="l83.405" class="difflineminus">-  // DirtyAll() visits every store sub-object and marks </span>
<a href="#l83.406"></a><span id="l83.406" class="difflineplus">+  // DirtyAll() visits every store sub-object and marks</span>
<a href="#l83.407"></a><span id="l83.407">   // them dirty, including every table, row, cell, and atom.  The return</span>
<a href="#l83.408"></a><span id="l83.408">   // equals ev-&gt;Good(), to show whether any error happened.  This method is</span>
<a href="#l83.409"></a><span id="l83.409">   // intended for use in the beginning of a &quot;compress commit&quot; which writes</span>
<a href="#l83.410"></a><span id="l83.410">   // all store content, whether dirty or not.  We dirty everything first so</span>
<a href="#l83.411"></a><span id="l83.411">   // that later iterations over content can mark things clean as they are</span>
<a href="#l83.412"></a><span id="l83.412">   // written, and organize the process of serialization so that objects are</span>
<a href="#l83.413"></a><span id="l83.413" class="difflineminus">-  // written only at need (because of being dirty).  Note the method can </span>
<a href="#l83.414"></a><span id="l83.414" class="difflineplus">+  // written only at need (because of being dirty).  Note the method can</span>
<a href="#l83.415"></a><span id="l83.415">   // stop early when any error happens, since this will abort any commit.</span>
<a href="#l83.416"></a><span id="l83.416"> {</span>
<a href="#l83.417"></a><span id="l83.417">   morkStore* store = mWriter_Store;</span>
<a href="#l83.418"></a><span id="l83.418">   if ( store )</span>
<a href="#l83.419"></a><span id="l83.419">   {</span>
<a href="#l83.420"></a><span id="l83.420">     store-&gt;SetStoreDirty();</span>
<a href="#l83.421"></a><span id="l83.421">     mork_change* c = 0;</span>
<a href="#l83.422"></a><span id="l83.422"> </span>
<a href="#l83.423"></a><span id="l83.423">     if ( ev-&gt;Good() )</span>
<a href="#l83.424"></a><span id="l83.424">     {</span>
<a href="#l83.425"></a><span id="l83.425">       morkAtomSpaceMapIter* asi = &amp;mWriter_StoreAtomSpacesIter;</span>
<a href="#l83.426"></a><span id="l83.426">       asi-&gt;InitAtomSpaceMapIter(ev, &amp;store-&gt;mStore_AtomSpaces);</span>
<a href="#l83.427"></a><span id="l83.427"> </span>
<a href="#l83.428"></a><span id="l83.428">       mork_scope* key = 0; // ignore keys in map</span>
<a href="#l83.429"></a><span id="l83.429">       morkAtomSpace* space = 0; // old val node in the map</span>
<a href="#l83.430"></a><span id="l83.430" class="difflineminus">-      </span>
<a href="#l83.431"></a><span id="l83.431" class="difflineplus">+</span>
<a href="#l83.432"></a><span id="l83.432">       for ( c = asi-&gt;FirstAtomSpace(ev, key, &amp;space); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l83.433"></a><span id="l83.433">             c = asi-&gt;NextAtomSpace(ev, key, &amp;space) )</span>
<a href="#l83.434"></a><span id="l83.434">       {</span>
<a href="#l83.435"></a><span id="l83.435">         if ( space )</span>
<a href="#l83.436"></a><span id="l83.436">         {</span>
<a href="#l83.437"></a><span id="l83.437">           if ( space-&gt;IsAtomSpace() )</span>
<a href="#l83.438"></a><span id="l83.438">           {</span>
<a href="#l83.439"></a><span id="l83.439">             space-&gt;SetAtomSpaceDirty();</span>
<a href="#l83.440"></a><span id="l83.440">             morkBookAtom* atom = 0;</span>
<a href="#l83.441"></a><span id="l83.441">             morkAtomAidMapIter* ai = &amp;mWriter_AtomSpaceAtomAidsIter;</span>
<a href="#l83.442"></a><span id="l83.442">             ai-&gt;InitAtomAidMapIter(ev, &amp;space-&gt;mAtomSpace_AtomAids);</span>
<a href="#l83.443"></a><span id="l83.443" class="difflineminus">-            </span>
<a href="#l83.444"></a><span id="l83.444" class="difflineplus">+</span>
<a href="#l83.445"></a><span id="l83.445">             for ( c = ai-&gt;FirstAtom(ev, &amp;atom); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l83.446"></a><span id="l83.446">                   c = ai-&gt;NextAtom(ev, &amp;atom) )</span>
<a href="#l83.447"></a><span id="l83.447">             {</span>
<a href="#l83.448"></a><span id="l83.448">               if ( atom )</span>
<a href="#l83.449"></a><span id="l83.449">               {</span>
<a href="#l83.450"></a><span id="l83.450">                 atom-&gt;SetAtomDirty();</span>
<a href="#l83.451"></a><span id="l83.451">                 ++mWriter_TotalCount;</span>
<a href="#l83.452"></a><span id="l83.452">               }</span>
<a href="#l83.453"></a><span id="l83.453">               else</span>
<a href="#l83.454"></a><span id="l83.454">                 ev-&gt;NilPointerError();</span>
<a href="#l83.455"></a><span id="l83.455">             }</span>
<a href="#l83.456"></a><span id="l83.456" class="difflineminus">-            </span>
<a href="#l83.457"></a><span id="l83.457" class="difflineplus">+</span>
<a href="#l83.458"></a><span id="l83.458">             ai-&gt;CloseMapIter(ev);</span>
<a href="#l83.459"></a><span id="l83.459">           }</span>
<a href="#l83.460"></a><span id="l83.460">           else</span>
<a href="#l83.461"></a><span id="l83.461">             space-&gt;NonAtomSpaceTypeError(ev);</span>
<a href="#l83.462"></a><span id="l83.462">         }</span>
<a href="#l83.463"></a><span id="l83.463">         else</span>
<a href="#l83.464"></a><span id="l83.464">           ev-&gt;NilPointerError();</span>
<a href="#l83.465"></a><span id="l83.465">       }</span>
<a href="#l83.466"></a><span id="l83.466">     }</span>
<a href="#l83.467"></a><span id="l83.467" class="difflineminus">-    </span>
<a href="#l83.468"></a><span id="l83.468" class="difflineplus">+</span>
<a href="#l83.469"></a><span id="l83.469">     if ( ev-&gt;Good() )</span>
<a href="#l83.470"></a><span id="l83.470">     {</span>
<a href="#l83.471"></a><span id="l83.471">       morkRowSpaceMapIter* rsi = &amp;mWriter_StoreRowSpacesIter;</span>
<a href="#l83.472"></a><span id="l83.472">       rsi-&gt;InitRowSpaceMapIter(ev, &amp;store-&gt;mStore_RowSpaces);</span>
<a href="#l83.473"></a><span id="l83.473"> </span>
<a href="#l83.474"></a><span id="l83.474">       mork_scope* key = 0; // ignore keys in map</span>
<a href="#l83.475"></a><span id="l83.475">       morkRowSpace* space = 0; // old val node in the map</span>
<a href="#l83.476"></a><span id="l83.476" class="difflineminus">-      </span>
<a href="#l83.477"></a><span id="l83.477" class="difflineplus">+</span>
<a href="#l83.478"></a><span id="l83.478">       for ( c = rsi-&gt;FirstRowSpace(ev, key, &amp;space); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l83.479"></a><span id="l83.479">             c = rsi-&gt;NextRowSpace(ev, key, &amp;space) )</span>
<a href="#l83.480"></a><span id="l83.480">       {</span>
<a href="#l83.481"></a><span id="l83.481">         if ( space )</span>
<a href="#l83.482"></a><span id="l83.482">         {</span>
<a href="#l83.483"></a><span id="l83.483">           if ( space-&gt;IsRowSpace() )</span>
<a href="#l83.484"></a><span id="l83.484">           {</span>
<a href="#l83.485"></a><span id="l83.485">             space-&gt;SetRowSpaceDirty();</span>
<a href="#l83.486"></a><span id="l83.486" class="difflineat">@@ -662,47 +662,47 @@ morkWriter::DirtyAll(morkEnv* ev)</span>
<a href="#l83.487"></a><span id="l83.487"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l83.488"></a><span id="l83.488">               morkRowProbeMapIter* ri = &amp;mWriter_RowSpaceRowsIter;</span>
<a href="#l83.489"></a><span id="l83.489"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l83.490"></a><span id="l83.490">               morkRowMapIter* ri = &amp;mWriter_RowSpaceRowsIter;</span>
<a href="#l83.491"></a><span id="l83.491"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l83.492"></a><span id="l83.492">               ri-&gt;InitRowMapIter(ev, &amp;space-&gt;mRowSpace_Rows);</span>
<a href="#l83.493"></a><span id="l83.493"> </span>
<a href="#l83.494"></a><span id="l83.494">               morkRow* row = 0; // old key row in the map</span>
<a href="#l83.495"></a><span id="l83.495" class="difflineminus">-                </span>
<a href="#l83.496"></a><span id="l83.496" class="difflineplus">+</span>
<a href="#l83.497"></a><span id="l83.497">               for ( c = ri-&gt;FirstRow(ev, &amp;row); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l83.498"></a><span id="l83.498">                     c = ri-&gt;NextRow(ev, &amp;row) )</span>
<a href="#l83.499"></a><span id="l83.499">               {</span>
<a href="#l83.500"></a><span id="l83.500">                 if ( row &amp;&amp; row-&gt;IsRow() ) // need to dirty row?</span>
<a href="#l83.501"></a><span id="l83.501">                 {</span>
<a href="#l83.502"></a><span id="l83.502">                 	if ( row-&gt;IsRowUsed() || row-&gt;IsRowDirty() )</span>
<a href="#l83.503"></a><span id="l83.503">                 	{</span>
<a href="#l83.504"></a><span id="l83.504"> 	                  row-&gt;DirtyAllRowContent(ev);</span>
<a href="#l83.505"></a><span id="l83.505"> 	                  ++mWriter_TotalCount;</span>
<a href="#l83.506"></a><span id="l83.506">                 	}</span>
<a href="#l83.507"></a><span id="l83.507">                 }</span>
<a href="#l83.508"></a><span id="l83.508">                 else</span>
<a href="#l83.509"></a><span id="l83.509">                   row-&gt;NonRowTypeWarning(ev);</span>
<a href="#l83.510"></a><span id="l83.510">               }</span>
<a href="#l83.511"></a><span id="l83.511">               ri-&gt;CloseMapIter(ev);</span>
<a href="#l83.512"></a><span id="l83.512">             }</span>
<a href="#l83.513"></a><span id="l83.513" class="difflineminus">-            </span>
<a href="#l83.514"></a><span id="l83.514" class="difflineplus">+</span>
<a href="#l83.515"></a><span id="l83.515">             if ( ev-&gt;Good() )</span>
<a href="#l83.516"></a><span id="l83.516">             {</span>
<a href="#l83.517"></a><span id="l83.517">               morkTableMapIter* ti = &amp;mWriter_RowSpaceTablesIter;</span>
<a href="#l83.518"></a><span id="l83.518">               ti-&gt;InitTableMapIter(ev, &amp;space-&gt;mRowSpace_Tables);</span>
<a href="#l83.519"></a><span id="l83.519"> </span>
<a href="#l83.520"></a><span id="l83.520"> #ifdef MORK_BEAD_OVER_NODE_MAPS</span>
<a href="#l83.521"></a><span id="l83.521">               morkTable* table = ti-&gt;FirstTable(ev);</span>
<a href="#l83.522"></a><span id="l83.522" class="difflineminus">-                </span>
<a href="#l83.523"></a><span id="l83.523" class="difflineplus">+</span>
<a href="#l83.524"></a><span id="l83.524">               for ( ; table &amp;&amp; ev-&gt;Good(); table = ti-&gt;NextTable(ev) )</span>
<a href="#l83.525"></a><span id="l83.525"> #else /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l83.526"></a><span id="l83.526">               mork_tid* tableKey = 0; // ignore keys in table map</span>
<a href="#l83.527"></a><span id="l83.527">               morkTable* table = 0; // old key row in the map</span>
<a href="#l83.528"></a><span id="l83.528" class="difflineminus">-                </span>
<a href="#l83.529"></a><span id="l83.529" class="difflineplus">+</span>
<a href="#l83.530"></a><span id="l83.530">               for ( c = ti-&gt;FirstTable(ev, tableKey, &amp;table); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l83.531"></a><span id="l83.531">                     c = ti-&gt;NextTable(ev, tableKey, &amp;table) )</span>
<a href="#l83.532"></a><span id="l83.532"> #endif /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l83.533"></a><span id="l83.533">               {</span>
<a href="#l83.534"></a><span id="l83.534">                 if ( table &amp;&amp; table-&gt;IsTable() ) // need to dirty table?</span>
<a href="#l83.535"></a><span id="l83.535">                 {</span>
<a href="#l83.536"></a><span id="l83.536">                 	if ( table-&gt;IsTableUsed() || table-&gt;IsTableDirty() )</span>
<a href="#l83.537"></a><span id="l83.537">                 	{</span>
<a href="#l83.538"></a><span id="l83.538" class="difflineat">@@ -724,41 +724,41 @@ morkWriter::DirtyAll(morkEnv* ev)</span>
<a href="#l83.539"></a><span id="l83.539">         }</span>
<a href="#l83.540"></a><span id="l83.540">         else</span>
<a href="#l83.541"></a><span id="l83.541">           ev-&gt;NilPointerError();</span>
<a href="#l83.542"></a><span id="l83.542">       }</span>
<a href="#l83.543"></a><span id="l83.543">     }</span>
<a href="#l83.544"></a><span id="l83.544">   }</span>
<a href="#l83.545"></a><span id="l83.545">   else</span>
<a href="#l83.546"></a><span id="l83.546">     this-&gt;NilWriterStoreError(ev);</span>
<a href="#l83.547"></a><span id="l83.547" class="difflineminus">-  </span>
<a href="#l83.548"></a><span id="l83.548" class="difflineplus">+</span>
<a href="#l83.549"></a><span id="l83.549">   return ev-&gt;Good();</span>
<a href="#l83.550"></a><span id="l83.550"> }</span>
<a href="#l83.551"></a><span id="l83.551"> </span>
<a href="#l83.552"></a><span id="l83.552"> </span>
<a href="#l83.553"></a><span id="l83.553"> mork_bool</span>
<a href="#l83.554"></a><span id="l83.554"> morkWriter::OnNothingDone(morkEnv* ev)</span>
<a href="#l83.555"></a><span id="l83.555"> {</span>
<a href="#l83.556"></a><span id="l83.556">   mWriter_Incremental = !mWriter_NeedDirtyAll; // opposites</span>
<a href="#l83.557"></a><span id="l83.557" class="difflineminus">-  </span>
<a href="#l83.558"></a><span id="l83.558" class="difflineplus">+</span>
<a href="#l83.559"></a><span id="l83.559">   if (!mWriter_Store-&gt;IsStoreDirty() &amp;&amp; !mWriter_NeedDirtyAll)</span>
<a href="#l83.560"></a><span id="l83.560">   {</span>
<a href="#l83.561"></a><span id="l83.561">     mWriter_Phase = morkWriter_kPhaseWritingDone;</span>
<a href="#l83.562"></a><span id="l83.562">     return morkBool_kTrue;</span>
<a href="#l83.563"></a><span id="l83.563">   }</span>
<a href="#l83.564"></a><span id="l83.564"> </span>
<a href="#l83.565"></a><span id="l83.565">   // morkStream* stream = mWriter_Stream;</span>
<a href="#l83.566"></a><span id="l83.566">   if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.567"></a><span id="l83.567">     this-&gt;DirtyAll(ev);</span>
<a href="#l83.568"></a><span id="l83.568" class="difflineminus">-    </span>
<a href="#l83.569"></a><span id="l83.569" class="difflineplus">+</span>
<a href="#l83.570"></a><span id="l83.570">   if ( ev-&gt;Good() )</span>
<a href="#l83.571"></a><span id="l83.571">     mWriter_Phase = morkWriter_kPhaseDirtyAllDone;</span>
<a href="#l83.572"></a><span id="l83.572">   else</span>
<a href="#l83.573"></a><span id="l83.573">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.574"></a><span id="l83.574" class="difflineminus">-    </span>
<a href="#l83.575"></a><span id="l83.575" class="difflineplus">+</span>
<a href="#l83.576"></a><span id="l83.576">   return ev-&gt;Good();</span>
<a href="#l83.577"></a><span id="l83.577"> }</span>
<a href="#l83.578"></a><span id="l83.578"> </span>
<a href="#l83.579"></a><span id="l83.579"> mork_bool</span>
<a href="#l83.580"></a><span id="l83.580"> morkWriter::StartGroup(morkEnv* ev)</span>
<a href="#l83.581"></a><span id="l83.581"> {</span>
<a href="#l83.582"></a><span id="l83.582">   nsIMdbEnv *mdbev = ev-&gt;AsMdbEnv();</span>
<a href="#l83.583"></a><span id="l83.583">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.584"></a><span id="l83.584" class="difflineat">@@ -766,100 +766,100 @@ morkWriter::StartGroup(morkEnv* ev)</span>
<a href="#l83.585"></a><span id="l83.585">   mWriter_DidEndGroup = morkBool_kFalse;</span>
<a href="#l83.586"></a><span id="l83.586"> </span>
<a href="#l83.587"></a><span id="l83.587">   char buf[ 64 ];</span>
<a href="#l83.588"></a><span id="l83.588">   char* p = buf;</span>
<a href="#l83.589"></a><span id="l83.589">   *p++ = '@';</span>
<a href="#l83.590"></a><span id="l83.590">   *p++ = '$';</span>
<a href="#l83.591"></a><span id="l83.591">   *p++ = '$';</span>
<a href="#l83.592"></a><span id="l83.592">   *p++ = '{';</span>
<a href="#l83.593"></a><span id="l83.593" class="difflineminus">-  </span>
<a href="#l83.594"></a><span id="l83.594" class="difflineplus">+</span>
<a href="#l83.595"></a><span id="l83.595">   mork_token groupID = mWriter_CommitGroupIdentity;</span>
<a href="#l83.596"></a><span id="l83.596">   mork_fill idFill = ev-&gt;TokenAsHex(p, groupID);</span>
<a href="#l83.597"></a><span id="l83.597">   mWriter_GroupBufFill = 0;</span>
<a href="#l83.598"></a><span id="l83.598">   // ev-&gt;TokenAsHex(mWriter_GroupBuf, groupID);</span>
<a href="#l83.599"></a><span id="l83.599">   if ( idFill &lt; morkWriter_kGroupBufSize )</span>
<a href="#l83.600"></a><span id="l83.600">   {</span>
<a href="#l83.601"></a><span id="l83.601">     MORK_MEMCPY(mWriter_GroupBuf, p, idFill + 1);</span>
<a href="#l83.602"></a><span id="l83.602">     mWriter_GroupBufFill = idFill;</span>
<a href="#l83.603"></a><span id="l83.603">   }</span>
<a href="#l83.604"></a><span id="l83.604">   else</span>
<a href="#l83.605"></a><span id="l83.605">     *mWriter_GroupBuf = 0;</span>
<a href="#l83.606"></a><span id="l83.606" class="difflineminus">-    </span>
<a href="#l83.607"></a><span id="l83.607" class="difflineplus">+</span>
<a href="#l83.608"></a><span id="l83.608">   p += idFill;</span>
<a href="#l83.609"></a><span id="l83.609">   *p++ = '{';</span>
<a href="#l83.610"></a><span id="l83.610">   *p++ = '@';</span>
<a href="#l83.611"></a><span id="l83.611">   *p = 0;</span>
<a href="#l83.612"></a><span id="l83.612"> </span>
<a href="#l83.613"></a><span id="l83.613">   stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.614"></a><span id="l83.614" class="difflineminus">-  </span>
<a href="#l83.615"></a><span id="l83.615" class="difflineplus">+</span>
<a href="#l83.616"></a><span id="l83.616">   morkStore* store = mWriter_Store;</span>
<a href="#l83.617"></a><span id="l83.617">   if ( store ) // might need to capture commit group position?</span>
<a href="#l83.618"></a><span id="l83.618">   {</span>
<a href="#l83.619"></a><span id="l83.619">     mork_pos groupPos;</span>
<a href="#l83.620"></a><span id="l83.620">     stream-&gt;Tell(mdbev, &amp;groupPos);</span>
<a href="#l83.621"></a><span id="l83.621">     if ( !store-&gt;mStore_FirstCommitGroupPos )</span>
<a href="#l83.622"></a><span id="l83.622">       store-&gt;mStore_FirstCommitGroupPos = groupPos;</span>
<a href="#l83.623"></a><span id="l83.623">     else if ( !store-&gt;mStore_SecondCommitGroupPos )</span>
<a href="#l83.624"></a><span id="l83.624">       store-&gt;mStore_SecondCommitGroupPos = groupPos;</span>
<a href="#l83.625"></a><span id="l83.625">   }</span>
<a href="#l83.626"></a><span id="l83.626" class="difflineminus">-  </span>
<a href="#l83.627"></a><span id="l83.627" class="difflineplus">+</span>
<a href="#l83.628"></a><span id="l83.628">   mork_size bytesWritten;</span>
<a href="#l83.629"></a><span id="l83.629">   stream-&gt;Write(mdbev, buf, idFill + 6, &amp;bytesWritten); // '@$${' + idFill + '{@'</span>
<a href="#l83.630"></a><span id="l83.630">   stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.631"></a><span id="l83.631">   mWriter_LineSize = 0;</span>
<a href="#l83.632"></a><span id="l83.632" class="difflineminus">-  </span>
<a href="#l83.633"></a><span id="l83.633" class="difflineplus">+</span>
<a href="#l83.634"></a><span id="l83.634">   return ev-&gt;Good();</span>
<a href="#l83.635"></a><span id="l83.635"> }</span>
<a href="#l83.636"></a><span id="l83.636"> </span>
<a href="#l83.637"></a><span id="l83.637"> mork_bool</span>
<a href="#l83.638"></a><span id="l83.638"> morkWriter::CommitGroup(morkEnv* ev)</span>
<a href="#l83.639"></a><span id="l83.639"> {</span>
<a href="#l83.640"></a><span id="l83.640">   if ( mWriter_DidStartGroup )</span>
<a href="#l83.641"></a><span id="l83.641">   {</span>
<a href="#l83.642"></a><span id="l83.642">     nsIMdbEnv *mdbev = ev-&gt;AsMdbEnv();</span>
<a href="#l83.643"></a><span id="l83.643">     mork_size bytesWritten;</span>
<a href="#l83.644"></a><span id="l83.644">     morkStream* stream = mWriter_Stream;</span>
<a href="#l83.645"></a><span id="l83.645" class="difflineminus">-  </span>
<a href="#l83.646"></a><span id="l83.646" class="difflineplus">+</span>
<a href="#l83.647"></a><span id="l83.647">     if ( mWriter_LineSize )</span>
<a href="#l83.648"></a><span id="l83.648">       stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.649"></a><span id="l83.649" class="difflineminus">-      </span>
<a href="#l83.650"></a><span id="l83.650" class="difflineplus">+</span>
<a href="#l83.651"></a><span id="l83.651">     stream-&gt;Putc(ev, '@');</span>
<a href="#l83.652"></a><span id="l83.652">     stream-&gt;Putc(ev, '$');</span>
<a href="#l83.653"></a><span id="l83.653">     stream-&gt;Putc(ev, '$');</span>
<a href="#l83.654"></a><span id="l83.654">     stream-&gt;Putc(ev, '}');</span>
<a href="#l83.655"></a><span id="l83.655" class="difflineminus">-    </span>
<a href="#l83.656"></a><span id="l83.656" class="difflineplus">+</span>
<a href="#l83.657"></a><span id="l83.657">     mork_fill bufFill = mWriter_GroupBufFill;</span>
<a href="#l83.658"></a><span id="l83.658">     if ( bufFill )</span>
<a href="#l83.659"></a><span id="l83.659">       stream-&gt;Write(mdbev, mWriter_GroupBuf, bufFill, &amp;bytesWritten);</span>
<a href="#l83.660"></a><span id="l83.660"> </span>
<a href="#l83.661"></a><span id="l83.661">     stream-&gt;Putc(ev, '}');</span>
<a href="#l83.662"></a><span id="l83.662">     stream-&gt;Putc(ev, '@');</span>
<a href="#l83.663"></a><span id="l83.663">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.664"></a><span id="l83.664"> </span>
<a href="#l83.665"></a><span id="l83.665">     mWriter_LineSize = 0;</span>
<a href="#l83.666"></a><span id="l83.666">   }</span>
<a href="#l83.667"></a><span id="l83.667"> </span>
<a href="#l83.668"></a><span id="l83.668">   mWriter_DidStartGroup = morkBool_kFalse;</span>
<a href="#l83.669"></a><span id="l83.669">   mWriter_DidEndGroup = morkBool_kTrue;</span>
<a href="#l83.670"></a><span id="l83.670" class="difflineminus">-  </span>
<a href="#l83.671"></a><span id="l83.671" class="difflineplus">+</span>
<a href="#l83.672"></a><span id="l83.672">   return ev-&gt;Good();</span>
<a href="#l83.673"></a><span id="l83.673"> }</span>
<a href="#l83.674"></a><span id="l83.674"> </span>
<a href="#l83.675"></a><span id="l83.675"> mork_bool</span>
<a href="#l83.676"></a><span id="l83.676"> morkWriter::AbortGroup(morkEnv* ev)</span>
<a href="#l83.677"></a><span id="l83.677"> {</span>
<a href="#l83.678"></a><span id="l83.678">   if ( mWriter_DidStartGroup )</span>
<a href="#l83.679"></a><span id="l83.679">   {</span>
<a href="#l83.680"></a><span id="l83.680">     morkStream* stream = mWriter_Stream;</span>
<a href="#l83.681"></a><span id="l83.681">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.682"></a><span id="l83.682">     stream-&gt;PutStringThenNewline(ev, &quot;@$$}~~}@&quot;);</span>
<a href="#l83.683"></a><span id="l83.683">     mWriter_LineSize = 0;</span>
<a href="#l83.684"></a><span id="l83.684">   }</span>
<a href="#l83.685"></a><span id="l83.685" class="difflineminus">-  </span>
<a href="#l83.686"></a><span id="l83.686" class="difflineplus">+</span>
<a href="#l83.687"></a><span id="l83.687">   mWriter_DidStartGroup = morkBool_kFalse;</span>
<a href="#l83.688"></a><span id="l83.688">   mWriter_DidEndGroup = morkBool_kTrue;</span>
<a href="#l83.689"></a><span id="l83.689"> </span>
<a href="#l83.690"></a><span id="l83.690">   return ev-&gt;Good();</span>
<a href="#l83.691"></a><span id="l83.691"> }</span>
<a href="#l83.692"></a><span id="l83.692"> </span>
<a href="#l83.693"></a><span id="l83.693"> </span>
<a href="#l83.694"></a><span id="l83.694"> mork_bool</span>
<a href="#l83.695"></a><span id="l83.695" class="difflineat">@@ -887,68 +887,68 @@ morkWriter::OnDirtyAllDone(morkEnv* ev)</span>
<a href="#l83.696"></a><span id="l83.696">         {</span>
<a href="#l83.697"></a><span id="l83.697">           stream-&gt;PutStringThenNewline(ev, morkWriter_kFileHeader);</span>
<a href="#l83.698"></a><span id="l83.698">           mWriter_LineSize = 0;</span>
<a href="#l83.699"></a><span id="l83.699">         }</span>
<a href="#l83.700"></a><span id="l83.700">         this-&gt;StartGroup(ev); // begin incremental transaction</span>
<a href="#l83.701"></a><span id="l83.701">       }</span>
<a href="#l83.702"></a><span id="l83.702">     }</span>
<a href="#l83.703"></a><span id="l83.703">   }</span>
<a href="#l83.704"></a><span id="l83.704" class="difflineminus">-    </span>
<a href="#l83.705"></a><span id="l83.705" class="difflineplus">+</span>
<a href="#l83.706"></a><span id="l83.706">   if ( ev-&gt;Good() )</span>
<a href="#l83.707"></a><span id="l83.707">     mWriter_Phase = morkWriter_kPhasePutHeaderDone;</span>
<a href="#l83.708"></a><span id="l83.708">   else</span>
<a href="#l83.709"></a><span id="l83.709">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.710"></a><span id="l83.710" class="difflineminus">-    </span>
<a href="#l83.711"></a><span id="l83.711" class="difflineplus">+</span>
<a href="#l83.712"></a><span id="l83.712">   return ev-&gt;Good();</span>
<a href="#l83.713"></a><span id="l83.713"> }</span>
<a href="#l83.714"></a><span id="l83.714"> </span>
<a href="#l83.715"></a><span id="l83.715"> mork_bool</span>
<a href="#l83.716"></a><span id="l83.716"> morkWriter::OnPutHeaderDone(morkEnv* ev)</span>
<a href="#l83.717"></a><span id="l83.717"> {</span>
<a href="#l83.718"></a><span id="l83.718">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.719"></a><span id="l83.719">   if ( mWriter_LineSize )</span>
<a href="#l83.720"></a><span id="l83.720">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.721"></a><span id="l83.721" class="difflineminus">-  </span>
<a href="#l83.722"></a><span id="l83.722" class="difflineplus">+</span>
<a href="#l83.723"></a><span id="l83.723">   // if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.724"></a><span id="l83.724">   //   stream-&gt;PutStringThenNewline(ev, &quot;// OnPutHeaderDone()&quot;);</span>
<a href="#l83.725"></a><span id="l83.725">   mWriter_LineSize = 0;</span>
<a href="#l83.726"></a><span id="l83.726" class="difflineminus">-  </span>
<a href="#l83.727"></a><span id="l83.727" class="difflineplus">+</span>
<a href="#l83.728"></a><span id="l83.728">   if ( mWriter_NeedDirtyAll ) // compress commit</span>
<a href="#l83.729"></a><span id="l83.729">   {</span>
<a href="#l83.730"></a><span id="l83.730">     morkStore* store = mWriter_Store;</span>
<a href="#l83.731"></a><span id="l83.731">     if ( store )</span>
<a href="#l83.732"></a><span id="l83.732">       store-&gt;RenumberAllCollectableContent(ev);</span>
<a href="#l83.733"></a><span id="l83.733">     else</span>
<a href="#l83.734"></a><span id="l83.734">       this-&gt;NilWriterStoreError(ev);</span>
<a href="#l83.735"></a><span id="l83.735">   }</span>
<a href="#l83.736"></a><span id="l83.736" class="difflineminus">-    </span>
<a href="#l83.737"></a><span id="l83.737" class="difflineplus">+</span>
<a href="#l83.738"></a><span id="l83.738">   if ( ev-&gt;Good() )</span>
<a href="#l83.739"></a><span id="l83.739">     mWriter_Phase = morkWriter_kPhaseRenumberAllDone;</span>
<a href="#l83.740"></a><span id="l83.740">   else</span>
<a href="#l83.741"></a><span id="l83.741">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.742"></a><span id="l83.742" class="difflineminus">-    </span>
<a href="#l83.743"></a><span id="l83.743" class="difflineplus">+</span>
<a href="#l83.744"></a><span id="l83.744">   return ev-&gt;Good();</span>
<a href="#l83.745"></a><span id="l83.745"> }</span>
<a href="#l83.746"></a><span id="l83.746"> </span>
<a href="#l83.747"></a><span id="l83.747"> mork_bool</span>
<a href="#l83.748"></a><span id="l83.748"> morkWriter::OnRenumberAllDone(morkEnv* ev)</span>
<a href="#l83.749"></a><span id="l83.749"> {</span>
<a href="#l83.750"></a><span id="l83.750">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.751"></a><span id="l83.751">   if ( mWriter_LineSize )</span>
<a href="#l83.752"></a><span id="l83.752">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.753"></a><span id="l83.753" class="difflineminus">-    </span>
<a href="#l83.754"></a><span id="l83.754" class="difflineplus">+</span>
<a href="#l83.755"></a><span id="l83.755">   // if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.756"></a><span id="l83.756">   //  stream-&gt;PutStringThenNewline(ev, &quot;// OnRenumberAllDone()&quot;);</span>
<a href="#l83.757"></a><span id="l83.757">   mWriter_LineSize = 0;</span>
<a href="#l83.758"></a><span id="l83.758" class="difflineminus">-  </span>
<a href="#l83.759"></a><span id="l83.759" class="difflineplus">+</span>
<a href="#l83.760"></a><span id="l83.760">   if ( mWriter_NeedDirtyAll ) // compress commit</span>
<a href="#l83.761"></a><span id="l83.761">   {</span>
<a href="#l83.762"></a><span id="l83.762">   }</span>
<a href="#l83.763"></a><span id="l83.763" class="difflineminus">-    </span>
<a href="#l83.764"></a><span id="l83.764" class="difflineplus">+</span>
<a href="#l83.765"></a><span id="l83.765">   if ( ev-&gt;Good() )</span>
<a href="#l83.766"></a><span id="l83.766">     mWriter_Phase = morkWriter_kPhaseStoreAtomSpaces;</span>
<a href="#l83.767"></a><span id="l83.767">   else</span>
<a href="#l83.768"></a><span id="l83.768">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.769"></a><span id="l83.769"> </span>
<a href="#l83.770"></a><span id="l83.770">   return ev-&gt;Good();</span>
<a href="#l83.771"></a><span id="l83.771"> }</span>
<a href="#l83.772"></a><span id="l83.772"> </span>
<a href="#l83.773"></a><span id="l83.773" class="difflineat">@@ -957,44 +957,44 @@ morkWriter::OnStoreAtomSpaces(morkEnv* e</span>
<a href="#l83.774"></a><span id="l83.774"> {</span>
<a href="#l83.775"></a><span id="l83.775">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.776"></a><span id="l83.776">   if ( mWriter_LineSize )</span>
<a href="#l83.777"></a><span id="l83.777">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.778"></a><span id="l83.778"> </span>
<a href="#l83.779"></a><span id="l83.779">   // if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.780"></a><span id="l83.780">   //   stream-&gt;PutStringThenNewline(ev, &quot;// OnStoreAtomSpaces()&quot;);</span>
<a href="#l83.781"></a><span id="l83.781">   mWriter_LineSize = 0;</span>
<a href="#l83.782"></a><span id="l83.782" class="difflineminus">-  </span>
<a href="#l83.783"></a><span id="l83.783" class="difflineplus">+</span>
<a href="#l83.784"></a><span id="l83.784">   if ( mWriter_NeedDirtyAll ) // compress commit</span>
<a href="#l83.785"></a><span id="l83.785">   {</span>
<a href="#l83.786"></a><span id="l83.786">   }</span>
<a href="#l83.787"></a><span id="l83.787" class="difflineminus">-  </span>
<a href="#l83.788"></a><span id="l83.788" class="difflineplus">+</span>
<a href="#l83.789"></a><span id="l83.789">   if ( ev-&gt;Good() )</span>
<a href="#l83.790"></a><span id="l83.790">   {</span>
<a href="#l83.791"></a><span id="l83.791">     morkStore* store = mWriter_Store;</span>
<a href="#l83.792"></a><span id="l83.792">     if ( store )</span>
<a href="#l83.793"></a><span id="l83.793">     {</span>
<a href="#l83.794"></a><span id="l83.794">       morkAtomSpace* space = store-&gt;LazyGetGroundColumnSpace(ev);</span>
<a href="#l83.795"></a><span id="l83.795">       if ( space &amp;&amp; space-&gt;IsAtomSpaceDirty() )</span>
<a href="#l83.796"></a><span id="l83.796">       {</span>
<a href="#l83.797"></a><span id="l83.797">         // stream-&gt;PutStringThenNewline(ev, &quot;// ground column space dict:&quot;);</span>
<a href="#l83.798"></a><span id="l83.798" class="difflineminus">-        </span>
<a href="#l83.799"></a><span id="l83.799" class="difflineplus">+</span>
<a href="#l83.800"></a><span id="l83.800">         if ( mWriter_LineSize )</span>
<a href="#l83.801"></a><span id="l83.801">         {</span>
<a href="#l83.802"></a><span id="l83.802">           stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.803"></a><span id="l83.803">           mWriter_LineSize = 0;</span>
<a href="#l83.804"></a><span id="l83.804">         }</span>
<a href="#l83.805"></a><span id="l83.805">         this-&gt;WriteAtomSpaceAsDict(ev, space);</span>
<a href="#l83.806"></a><span id="l83.806">         space-&gt;SetAtomSpaceClean();</span>
<a href="#l83.807"></a><span id="l83.807">       }</span>
<a href="#l83.808"></a><span id="l83.808">     }</span>
<a href="#l83.809"></a><span id="l83.809">     else</span>
<a href="#l83.810"></a><span id="l83.810">       this-&gt;NilWriterStoreError(ev);</span>
<a href="#l83.811"></a><span id="l83.811">   }</span>
<a href="#l83.812"></a><span id="l83.812" class="difflineminus">-    </span>
<a href="#l83.813"></a><span id="l83.813" class="difflineplus">+</span>
<a href="#l83.814"></a><span id="l83.814">   if ( ev-&gt;Good() )</span>
<a href="#l83.815"></a><span id="l83.815">     mWriter_Phase = morkWriter_kPhaseStoreRowSpacesTables;</span>
<a href="#l83.816"></a><span id="l83.816">   else</span>
<a href="#l83.817"></a><span id="l83.817">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.818"></a><span id="l83.818"> </span>
<a href="#l83.819"></a><span id="l83.819">   return ev-&gt;Good();</span>
<a href="#l83.820"></a><span id="l83.820"> }</span>
<a href="#l83.821"></a><span id="l83.821"> </span>
<a href="#l83.822"></a><span id="l83.822" class="difflineat">@@ -1003,21 +1003,21 @@ morkWriter::OnAtomSpaceAtomAids(morkEnv*</span>
<a href="#l83.823"></a><span id="l83.823"> {</span>
<a href="#l83.824"></a><span id="l83.824">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.825"></a><span id="l83.825">   if ( mWriter_LineSize )</span>
<a href="#l83.826"></a><span id="l83.826">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.827"></a><span id="l83.827"> </span>
<a href="#l83.828"></a><span id="l83.828">   // if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.829"></a><span id="l83.829">   //   stream-&gt;PutStringThenNewline(ev, &quot;// OnAtomSpaceAtomAids()&quot;);</span>
<a href="#l83.830"></a><span id="l83.830">   mWriter_LineSize = 0;</span>
<a href="#l83.831"></a><span id="l83.831" class="difflineminus">-  </span>
<a href="#l83.832"></a><span id="l83.832" class="difflineplus">+</span>
<a href="#l83.833"></a><span id="l83.833">   if ( mWriter_NeedDirtyAll ) // compress commit</span>
<a href="#l83.834"></a><span id="l83.834">   {</span>
<a href="#l83.835"></a><span id="l83.835">   }</span>
<a href="#l83.836"></a><span id="l83.836" class="difflineminus">-    </span>
<a href="#l83.837"></a><span id="l83.837" class="difflineplus">+</span>
<a href="#l83.838"></a><span id="l83.838">   if ( ev-&gt;Good() )</span>
<a href="#l83.839"></a><span id="l83.839">     mWriter_Phase = morkWriter_kPhaseStoreRowSpacesTables;</span>
<a href="#l83.840"></a><span id="l83.840">   else</span>
<a href="#l83.841"></a><span id="l83.841">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.842"></a><span id="l83.842"> </span>
<a href="#l83.843"></a><span id="l83.843">   return ev-&gt;Good();</span>
<a href="#l83.844"></a><span id="l83.844"> }</span>
<a href="#l83.845"></a><span id="l83.845"> </span>
<a href="#l83.846"></a><span id="l83.846" class="difflineat">@@ -1028,74 +1028,74 @@ morkWriter::WriteAllStoreTables(morkEnv*</span>
<a href="#l83.847"></a><span id="l83.847">   if ( store &amp;&amp; ev-&gt;Good() )</span>
<a href="#l83.848"></a><span id="l83.848">   {</span>
<a href="#l83.849"></a><span id="l83.849">     morkRowSpaceMapIter* rsi = &amp;mWriter_StoreRowSpacesIter;</span>
<a href="#l83.850"></a><span id="l83.850">     rsi-&gt;InitRowSpaceMapIter(ev, &amp;store-&gt;mStore_RowSpaces);</span>
<a href="#l83.851"></a><span id="l83.851"> </span>
<a href="#l83.852"></a><span id="l83.852">     mork_scope* key = 0; // ignore keys in map</span>
<a href="#l83.853"></a><span id="l83.853">     morkRowSpace* space = 0; // old val node in the map</span>
<a href="#l83.854"></a><span id="l83.854">     mork_change* c = 0;</span>
<a href="#l83.855"></a><span id="l83.855" class="difflineminus">-    </span>
<a href="#l83.856"></a><span id="l83.856" class="difflineplus">+</span>
<a href="#l83.857"></a><span id="l83.857">     for ( c = rsi-&gt;FirstRowSpace(ev, key, &amp;space); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l83.858"></a><span id="l83.858">           c = rsi-&gt;NextRowSpace(ev, key, &amp;space) )</span>
<a href="#l83.859"></a><span id="l83.859">     {</span>
<a href="#l83.860"></a><span id="l83.860">       if ( space )</span>
<a href="#l83.861"></a><span id="l83.861">       {</span>
<a href="#l83.862"></a><span id="l83.862">         if ( space-&gt;IsRowSpace() )</span>
<a href="#l83.863"></a><span id="l83.863">         {</span>
<a href="#l83.864"></a><span id="l83.864">           space-&gt;SetRowSpaceClean();</span>
<a href="#l83.865"></a><span id="l83.865">           if ( ev-&gt;Good() )</span>
<a href="#l83.866"></a><span id="l83.866">           {</span>
<a href="#l83.867"></a><span id="l83.867">             morkTableMapIter* ti = &amp;mWriter_RowSpaceTablesIter;</span>
<a href="#l83.868"></a><span id="l83.868">             ti-&gt;InitTableMapIter(ev, &amp;space-&gt;mRowSpace_Tables);</span>
<a href="#l83.869"></a><span id="l83.869"> </span>
<a href="#l83.870"></a><span id="l83.870"> #ifdef MORK_BEAD_OVER_NODE_MAPS</span>
<a href="#l83.871"></a><span id="l83.871">             morkTable* table = ti-&gt;FirstTable(ev);</span>
<a href="#l83.872"></a><span id="l83.872" class="difflineminus">-              </span>
<a href="#l83.873"></a><span id="l83.873" class="difflineplus">+</span>
<a href="#l83.874"></a><span id="l83.874">             for ( ; table &amp;&amp; ev-&gt;Good(); table = ti-&gt;NextTable(ev) )</span>
<a href="#l83.875"></a><span id="l83.875"> #else /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l83.876"></a><span id="l83.876">             mork_tid* key2 = 0; // ignore keys in table map</span>
<a href="#l83.877"></a><span id="l83.877">             morkTable* table = 0; // old key row in the map</span>
<a href="#l83.878"></a><span id="l83.878" class="difflineminus">-              </span>
<a href="#l83.879"></a><span id="l83.879" class="difflineplus">+</span>
<a href="#l83.880"></a><span id="l83.880">             for ( c = ti-&gt;FirstTable(ev, key2, &amp;table); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l83.881"></a><span id="l83.881">                   c = ti-&gt;NextTable(ev, key2, &amp;table) )</span>
<a href="#l83.882"></a><span id="l83.882"> #endif /*MORK_BEAD_OVER_NODE_MAPS*/</span>
<a href="#l83.883"></a><span id="l83.883">             {</span>
<a href="#l83.884"></a><span id="l83.884">               if ( table &amp;&amp; table-&gt;IsTable() )</span>
<a href="#l83.885"></a><span id="l83.885">               {</span>
<a href="#l83.886"></a><span id="l83.886">                 if ( table-&gt;IsTableDirty() )</span>
<a href="#l83.887"></a><span id="l83.887">                 {</span>
<a href="#l83.888"></a><span id="l83.888">                   mWriter_BeVerbose =</span>
<a href="#l83.889"></a><span id="l83.889">                     ( ev-&gt;mEnv_BeVerbose || table-&gt;IsTableVerbose() );</span>
<a href="#l83.890"></a><span id="l83.890" class="difflineminus">-                    </span>
<a href="#l83.891"></a><span id="l83.891" class="difflineplus">+</span>
<a href="#l83.892"></a><span id="l83.892">                   if ( this-&gt;PutTableDict(ev, table) )</span>
<a href="#l83.893"></a><span id="l83.893">                     this-&gt;PutTable(ev, table);</span>
<a href="#l83.894"></a><span id="l83.894"> </span>
<a href="#l83.895"></a><span id="l83.895">                   table-&gt;SetTableClean(ev);</span>
<a href="#l83.896"></a><span id="l83.896">                   mWriter_BeVerbose = ev-&gt;mEnv_BeVerbose;</span>
<a href="#l83.897"></a><span id="l83.897">                 }</span>
<a href="#l83.898"></a><span id="l83.898">               }</span>
<a href="#l83.899"></a><span id="l83.899">               else</span>
<a href="#l83.900"></a><span id="l83.900">                 table-&gt;NonTableTypeWarning(ev);</span>
<a href="#l83.901"></a><span id="l83.901">             }</span>
<a href="#l83.902"></a><span id="l83.902">             ti-&gt;CloseMapIter(ev);</span>
<a href="#l83.903"></a><span id="l83.903">           }</span>
<a href="#l83.904"></a><span id="l83.904">           if ( ev-&gt;Good() )</span>
<a href="#l83.905"></a><span id="l83.905">           {</span>
<a href="#l83.906"></a><span id="l83.906">             mWriter_TableRowScope = 0; // ensure no table context now</span>
<a href="#l83.907"></a><span id="l83.907" class="difflineminus">-            </span>
<a href="#l83.908"></a><span id="l83.908" class="difflineplus">+</span>
<a href="#l83.909"></a><span id="l83.909"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l83.910"></a><span id="l83.910">             morkRowProbeMapIter* ri = &amp;mWriter_RowSpaceRowsIter;</span>
<a href="#l83.911"></a><span id="l83.911"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l83.912"></a><span id="l83.912">             morkRowMapIter* ri = &amp;mWriter_RowSpaceRowsIter;</span>
<a href="#l83.913"></a><span id="l83.913"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l83.914"></a><span id="l83.914">             ri-&gt;InitRowMapIter(ev, &amp;space-&gt;mRowSpace_Rows);</span>
<a href="#l83.915"></a><span id="l83.915"> </span>
<a href="#l83.916"></a><span id="l83.916">             morkRow* row = 0; // old row in the map</span>
<a href="#l83.917"></a><span id="l83.917" class="difflineminus">-              </span>
<a href="#l83.918"></a><span id="l83.918" class="difflineplus">+</span>
<a href="#l83.919"></a><span id="l83.919">             for ( c = ri-&gt;FirstRow(ev, &amp;row); c &amp;&amp; ev-&gt;Good();</span>
<a href="#l83.920"></a><span id="l83.920">                   c = ri-&gt;NextRow(ev, &amp;row) )</span>
<a href="#l83.921"></a><span id="l83.921">             {</span>
<a href="#l83.922"></a><span id="l83.922">               if ( row &amp;&amp; row-&gt;IsRow() )</span>
<a href="#l83.923"></a><span id="l83.923">               {</span>
<a href="#l83.924"></a><span id="l83.924">                 // later we should also check that table use count is nonzero:</span>
<a href="#l83.925"></a><span id="l83.925">                 if ( row-&gt;IsRowDirty() ) // &amp;&amp; row-&gt;IsRowUsed() ??</span>
<a href="#l83.926"></a><span id="l83.926">                 {</span>
<a href="#l83.927"></a><span id="l83.927" class="difflineat">@@ -1103,17 +1103,17 @@ morkWriter::WriteAllStoreTables(morkEnv*</span>
<a href="#l83.928"></a><span id="l83.928">                   if ( this-&gt;PutRowDict(ev, row) )</span>
<a href="#l83.929"></a><span id="l83.929">                   {</span>
<a href="#l83.930"></a><span id="l83.930">                     if ( ev-&gt;Good() &amp;&amp; mWriter_DidStartDict )</span>
<a href="#l83.931"></a><span id="l83.931">                     {</span>
<a href="#l83.932"></a><span id="l83.932">                       this-&gt;EndDict(ev);</span>
<a href="#l83.933"></a><span id="l83.933">                       if ( mWriter_LineSize &lt; 32 &amp;&amp; ev-&gt;Good() )</span>
<a href="#l83.934"></a><span id="l83.934">                         mWriter_SuppressDirtyRowNewline = morkBool_kTrue;</span>
<a href="#l83.935"></a><span id="l83.935">                     }</span>
<a href="#l83.936"></a><span id="l83.936" class="difflineminus">-                      </span>
<a href="#l83.937"></a><span id="l83.937" class="difflineplus">+</span>
<a href="#l83.938"></a><span id="l83.938">                     if ( ev-&gt;Good() )</span>
<a href="#l83.939"></a><span id="l83.939">                       this-&gt;PutRow(ev, row);</span>
<a href="#l83.940"></a><span id="l83.940">                   }</span>
<a href="#l83.941"></a><span id="l83.941">                   mWriter_BeVerbose = ev-&gt;mEnv_BeVerbose;</span>
<a href="#l83.942"></a><span id="l83.942">                 }</span>
<a href="#l83.943"></a><span id="l83.943">               }</span>
<a href="#l83.944"></a><span id="l83.944">               else</span>
<a href="#l83.945"></a><span id="l83.945">                 row-&gt;NonRowTypeWarning(ev);</span>
<a href="#l83.946"></a><span id="l83.946" class="difflineat">@@ -1135,24 +1135,24 @@ morkWriter::OnStoreRowSpacesTables(morkE</span>
<a href="#l83.947"></a><span id="l83.947"> {</span>
<a href="#l83.948"></a><span id="l83.948">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.949"></a><span id="l83.949">   if ( mWriter_LineSize )</span>
<a href="#l83.950"></a><span id="l83.950">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.951"></a><span id="l83.951"> </span>
<a href="#l83.952"></a><span id="l83.952">   // if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.953"></a><span id="l83.953">   //   stream-&gt;PutStringThenNewline(ev, &quot;// OnStoreRowSpacesTables()&quot;);</span>
<a href="#l83.954"></a><span id="l83.954">   mWriter_LineSize = 0;</span>
<a href="#l83.955"></a><span id="l83.955" class="difflineminus">-  </span>
<a href="#l83.956"></a><span id="l83.956" class="difflineplus">+</span>
<a href="#l83.957"></a><span id="l83.957">   if ( mWriter_NeedDirtyAll ) // compress commit</span>
<a href="#l83.958"></a><span id="l83.958">   {</span>
<a href="#l83.959"></a><span id="l83.959">   }</span>
<a href="#l83.960"></a><span id="l83.960" class="difflineminus">-  </span>
<a href="#l83.961"></a><span id="l83.961" class="difflineplus">+</span>
<a href="#l83.962"></a><span id="l83.962">   // later we'll break this up, but today we'll write all in one shot:</span>
<a href="#l83.963"></a><span id="l83.963">   this-&gt;WriteAllStoreTables(ev);</span>
<a href="#l83.964"></a><span id="l83.964" class="difflineminus">-    </span>
<a href="#l83.965"></a><span id="l83.965" class="difflineplus">+</span>
<a href="#l83.966"></a><span id="l83.966">   if ( ev-&gt;Good() )</span>
<a href="#l83.967"></a><span id="l83.967">     mWriter_Phase = morkWriter_kPhaseStoreRowSpacesRows;</span>
<a href="#l83.968"></a><span id="l83.968">   else</span>
<a href="#l83.969"></a><span id="l83.969">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.970"></a><span id="l83.970"> </span>
<a href="#l83.971"></a><span id="l83.971">   return ev-&gt;Good();</span>
<a href="#l83.972"></a><span id="l83.972"> }</span>
<a href="#l83.973"></a><span id="l83.973"> </span>
<a href="#l83.974"></a><span id="l83.974" class="difflineat">@@ -1161,21 +1161,21 @@ morkWriter::OnRowSpaceTables(morkEnv* ev</span>
<a href="#l83.975"></a><span id="l83.975"> {</span>
<a href="#l83.976"></a><span id="l83.976">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.977"></a><span id="l83.977">   if ( mWriter_LineSize )</span>
<a href="#l83.978"></a><span id="l83.978">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.979"></a><span id="l83.979"> </span>
<a href="#l83.980"></a><span id="l83.980">   // if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.981"></a><span id="l83.981">   //   stream-&gt;PutStringThenNewline(ev, &quot;// OnRowSpaceTables()&quot;);</span>
<a href="#l83.982"></a><span id="l83.982">   mWriter_LineSize = 0;</span>
<a href="#l83.983"></a><span id="l83.983" class="difflineminus">-  </span>
<a href="#l83.984"></a><span id="l83.984" class="difflineplus">+</span>
<a href="#l83.985"></a><span id="l83.985">   if ( mWriter_NeedDirtyAll ) // compress commit</span>
<a href="#l83.986"></a><span id="l83.986">   {</span>
<a href="#l83.987"></a><span id="l83.987">   }</span>
<a href="#l83.988"></a><span id="l83.988" class="difflineminus">-    </span>
<a href="#l83.989"></a><span id="l83.989" class="difflineplus">+</span>
<a href="#l83.990"></a><span id="l83.990">   if ( ev-&gt;Good() )</span>
<a href="#l83.991"></a><span id="l83.991">     mWriter_Phase = morkWriter_kPhaseStoreRowSpacesRows;</span>
<a href="#l83.992"></a><span id="l83.992">   else</span>
<a href="#l83.993"></a><span id="l83.993">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.994"></a><span id="l83.994"> </span>
<a href="#l83.995"></a><span id="l83.995">   return ev-&gt;Good();</span>
<a href="#l83.996"></a><span id="l83.996"> }</span>
<a href="#l83.997"></a><span id="l83.997"> </span>
<a href="#l83.998"></a><span id="l83.998" class="difflineat">@@ -1184,21 +1184,21 @@ morkWriter::OnTableRowArray(morkEnv* ev)</span>
<a href="#l83.999"></a><span id="l83.999"> {</span>
<a href="#l83.1000"></a><span id="l83.1000">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1001"></a><span id="l83.1001">   if ( mWriter_LineSize )</span>
<a href="#l83.1002"></a><span id="l83.1002">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.1003"></a><span id="l83.1003"> </span>
<a href="#l83.1004"></a><span id="l83.1004">   // if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.1005"></a><span id="l83.1005">   //   stream-&gt;PutStringThenNewline(ev, &quot;// OnTableRowArray()&quot;);</span>
<a href="#l83.1006"></a><span id="l83.1006">   mWriter_LineSize = 0;</span>
<a href="#l83.1007"></a><span id="l83.1007" class="difflineminus">-  </span>
<a href="#l83.1008"></a><span id="l83.1008" class="difflineplus">+</span>
<a href="#l83.1009"></a><span id="l83.1009">   if ( mWriter_NeedDirtyAll ) // compress commit</span>
<a href="#l83.1010"></a><span id="l83.1010">   {</span>
<a href="#l83.1011"></a><span id="l83.1011">   }</span>
<a href="#l83.1012"></a><span id="l83.1012" class="difflineminus">-    </span>
<a href="#l83.1013"></a><span id="l83.1013" class="difflineplus">+</span>
<a href="#l83.1014"></a><span id="l83.1014">   if ( ev-&gt;Good() )</span>
<a href="#l83.1015"></a><span id="l83.1015">     mWriter_Phase = morkWriter_kPhaseStoreRowSpacesRows;</span>
<a href="#l83.1016"></a><span id="l83.1016">   else</span>
<a href="#l83.1017"></a><span id="l83.1017">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.1018"></a><span id="l83.1018"> </span>
<a href="#l83.1019"></a><span id="l83.1019">   return ev-&gt;Good();</span>
<a href="#l83.1020"></a><span id="l83.1020"> }</span>
<a href="#l83.1021"></a><span id="l83.1021"> </span>
<a href="#l83.1022"></a><span id="l83.1022" class="difflineat">@@ -1207,21 +1207,21 @@ morkWriter::OnStoreRowSpacesRows(morkEnv</span>
<a href="#l83.1023"></a><span id="l83.1023"> {</span>
<a href="#l83.1024"></a><span id="l83.1024">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1025"></a><span id="l83.1025">   if ( mWriter_LineSize )</span>
<a href="#l83.1026"></a><span id="l83.1026">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.1027"></a><span id="l83.1027"> </span>
<a href="#l83.1028"></a><span id="l83.1028">   // if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.1029"></a><span id="l83.1029">   //   stream-&gt;PutStringThenNewline(ev, &quot;// OnStoreRowSpacesRows()&quot;);</span>
<a href="#l83.1030"></a><span id="l83.1030">   mWriter_LineSize = 0;</span>
<a href="#l83.1031"></a><span id="l83.1031" class="difflineminus">-  </span>
<a href="#l83.1032"></a><span id="l83.1032" class="difflineplus">+</span>
<a href="#l83.1033"></a><span id="l83.1033">   if ( mWriter_NeedDirtyAll ) // compress commit</span>
<a href="#l83.1034"></a><span id="l83.1034">   {</span>
<a href="#l83.1035"></a><span id="l83.1035">   }</span>
<a href="#l83.1036"></a><span id="l83.1036" class="difflineminus">-    </span>
<a href="#l83.1037"></a><span id="l83.1037" class="difflineplus">+</span>
<a href="#l83.1038"></a><span id="l83.1038">   if ( ev-&gt;Good() )</span>
<a href="#l83.1039"></a><span id="l83.1039">     mWriter_Phase = morkWriter_kPhaseContentDone;</span>
<a href="#l83.1040"></a><span id="l83.1040">   else</span>
<a href="#l83.1041"></a><span id="l83.1041">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.1042"></a><span id="l83.1042"> </span>
<a href="#l83.1043"></a><span id="l83.1043">   return ev-&gt;Good();</span>
<a href="#l83.1044"></a><span id="l83.1044"> }</span>
<a href="#l83.1045"></a><span id="l83.1045"> </span>
<a href="#l83.1046"></a><span id="l83.1046" class="difflineat">@@ -1230,21 +1230,21 @@ morkWriter::OnRowSpaceRows(morkEnv* ev)</span>
<a href="#l83.1047"></a><span id="l83.1047"> {</span>
<a href="#l83.1048"></a><span id="l83.1048">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1049"></a><span id="l83.1049">   if ( mWriter_LineSize )</span>
<a href="#l83.1050"></a><span id="l83.1050">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.1051"></a><span id="l83.1051"> </span>
<a href="#l83.1052"></a><span id="l83.1052">   // if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.1053"></a><span id="l83.1053">   //   stream-&gt;PutStringThenNewline(ev, &quot;// OnRowSpaceRows()&quot;);</span>
<a href="#l83.1054"></a><span id="l83.1054">   mWriter_LineSize = 0;</span>
<a href="#l83.1055"></a><span id="l83.1055" class="difflineminus">-  </span>
<a href="#l83.1056"></a><span id="l83.1056" class="difflineplus">+</span>
<a href="#l83.1057"></a><span id="l83.1057">   if ( mWriter_NeedDirtyAll ) // compress commit</span>
<a href="#l83.1058"></a><span id="l83.1058">   {</span>
<a href="#l83.1059"></a><span id="l83.1059">   }</span>
<a href="#l83.1060"></a><span id="l83.1060" class="difflineminus">-    </span>
<a href="#l83.1061"></a><span id="l83.1061" class="difflineplus">+</span>
<a href="#l83.1062"></a><span id="l83.1062">   if ( ev-&gt;Good() )</span>
<a href="#l83.1063"></a><span id="l83.1063">     mWriter_Phase = morkWriter_kPhaseContentDone;</span>
<a href="#l83.1064"></a><span id="l83.1064">   else</span>
<a href="#l83.1065"></a><span id="l83.1065">     mWriter_Phase = morkWriter_kPhaseWritingDone; // stop on error</span>
<a href="#l83.1066"></a><span id="l83.1066"> </span>
<a href="#l83.1067"></a><span id="l83.1067">   return ev-&gt;Good();</span>
<a href="#l83.1068"></a><span id="l83.1068"> }</span>
<a href="#l83.1069"></a><span id="l83.1069"> </span>
<a href="#l83.1070"></a><span id="l83.1070" class="difflineat">@@ -1253,45 +1253,45 @@ morkWriter::OnContentDone(morkEnv* ev)</span>
<a href="#l83.1071"></a><span id="l83.1071"> {</span>
<a href="#l83.1072"></a><span id="l83.1072">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1073"></a><span id="l83.1073">   if ( mWriter_LineSize )</span>
<a href="#l83.1074"></a><span id="l83.1074">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.1075"></a><span id="l83.1075"> </span>
<a href="#l83.1076"></a><span id="l83.1076">   // if ( mWriter_NeedDirtyAll )</span>
<a href="#l83.1077"></a><span id="l83.1077">   //   stream-&gt;PutStringThenNewline(ev, &quot;// OnContentDone()&quot;);</span>
<a href="#l83.1078"></a><span id="l83.1078">   mWriter_LineSize = 0;</span>
<a href="#l83.1079"></a><span id="l83.1079" class="difflineminus">-  </span>
<a href="#l83.1080"></a><span id="l83.1080" class="difflineplus">+</span>
<a href="#l83.1081"></a><span id="l83.1081">   if ( mWriter_Incremental )</span>
<a href="#l83.1082"></a><span id="l83.1082">   {</span>
<a href="#l83.1083"></a><span id="l83.1083">     if ( ev-&gt;Good() )</span>
<a href="#l83.1084"></a><span id="l83.1084">       this-&gt;CommitGroup(ev);</span>
<a href="#l83.1085"></a><span id="l83.1085">     else</span>
<a href="#l83.1086"></a><span id="l83.1086">       this-&gt;AbortGroup(ev);</span>
<a href="#l83.1087"></a><span id="l83.1087">   }</span>
<a href="#l83.1088"></a><span id="l83.1088">   else if ( mWriter_Store &amp;&amp; ev-&gt;Good() )</span>
<a href="#l83.1089"></a><span id="l83.1089">   {</span>
<a href="#l83.1090"></a><span id="l83.1090">     // after rewriting everything, there are no transaction groups:</span>
<a href="#l83.1091"></a><span id="l83.1091">     mWriter_Store-&gt;mStore_FirstCommitGroupPos = 0;</span>
<a href="#l83.1092"></a><span id="l83.1092">     mWriter_Store-&gt;mStore_SecondCommitGroupPos = 0;</span>
<a href="#l83.1093"></a><span id="l83.1093">   }</span>
<a href="#l83.1094"></a><span id="l83.1094" class="difflineminus">-  </span>
<a href="#l83.1095"></a><span id="l83.1095" class="difflineplus">+</span>
<a href="#l83.1096"></a><span id="l83.1096">   stream-&gt;Flush(ev-&gt;AsMdbEnv());</span>
<a href="#l83.1097"></a><span id="l83.1097">   nsIMdbFile* bud = mWriter_Bud;</span>
<a href="#l83.1098"></a><span id="l83.1098">   if ( bud )</span>
<a href="#l83.1099"></a><span id="l83.1099">   {</span>
<a href="#l83.1100"></a><span id="l83.1100">     bud-&gt;Flush(ev-&gt;AsMdbEnv());</span>
<a href="#l83.1101"></a><span id="l83.1101">     bud-&gt;BecomeTrunk(ev-&gt;AsMdbEnv());</span>
<a href="#l83.1102"></a><span id="l83.1102">     nsIMdbFile_SlotStrongFile((nsIMdbFile*) 0, ev, &amp;mWriter_Bud);</span>
<a href="#l83.1103"></a><span id="l83.1103">   }</span>
<a href="#l83.1104"></a><span id="l83.1104">   else if ( !mWriter_Incremental ) // should have a bud?</span>
<a href="#l83.1105"></a><span id="l83.1105">     this-&gt;NilWriterBudError(ev);</span>
<a href="#l83.1106"></a><span id="l83.1106" class="difflineminus">-    </span>
<a href="#l83.1107"></a><span id="l83.1107" class="difflineplus">+</span>
<a href="#l83.1108"></a><span id="l83.1108">   mWriter_Phase = morkWriter_kPhaseWritingDone; // stop always</span>
<a href="#l83.1109"></a><span id="l83.1109">   mWriter_DoneCount = mWriter_TotalCount;</span>
<a href="#l83.1110"></a><span id="l83.1110" class="difflineminus">-  </span>
<a href="#l83.1111"></a><span id="l83.1111" class="difflineplus">+</span>
<a href="#l83.1112"></a><span id="l83.1112">   return ev-&gt;Good();</span>
<a href="#l83.1113"></a><span id="l83.1113"> }</span>
<a href="#l83.1114"></a><span id="l83.1114"> </span>
<a href="#l83.1115"></a><span id="l83.1115"> mork_bool</span>
<a href="#l83.1116"></a><span id="l83.1116"> morkWriter::OnWritingDone(morkEnv* ev)</span>
<a href="#l83.1117"></a><span id="l83.1117"> {</span>
<a href="#l83.1118"></a><span id="l83.1118">   mWriter_DoneCount = mWriter_TotalCount;</span>
<a href="#l83.1119"></a><span id="l83.1119">   ev-&gt;NewWarning(&quot;writing is done&quot;);</span>
<a href="#l83.1120"></a><span id="l83.1120" class="difflineat">@@ -1322,26 +1322,26 @@ morkWriter::PutTableChange(morkEnv* ev, </span>
<a href="#l83.1121"></a><span id="l83.1121">     p += posSize;</span>
<a href="#l83.1122"></a><span id="l83.1122">     *p++ = ' ';</span>
<a href="#l83.1123"></a><span id="l83.1123">     mork_size bytesWritten;</span>
<a href="#l83.1124"></a><span id="l83.1124">     mWriter_Stream-&gt;Write(mdbev, buf, posSize + 2, &amp;bytesWritten);</span>
<a href="#l83.1125"></a><span id="l83.1125">     mWriter_LineSize += bytesWritten;</span>
<a href="#l83.1126"></a><span id="l83.1126">   }</span>
<a href="#l83.1127"></a><span id="l83.1127">   else</span>
<a href="#l83.1128"></a><span id="l83.1128">     inChange-&gt;UnknownChangeError(ev);</span>
<a href="#l83.1129"></a><span id="l83.1129" class="difflineminus">-  </span>
<a href="#l83.1130"></a><span id="l83.1130" class="difflineplus">+</span>
<a href="#l83.1131"></a><span id="l83.1131">   return ev-&gt;Good();</span>
<a href="#l83.1132"></a><span id="l83.1132"> }</span>
<a href="#l83.1133"></a><span id="l83.1133"> </span>
<a href="#l83.1134"></a><span id="l83.1134"> mork_bool</span>
<a href="#l83.1135"></a><span id="l83.1135"> morkWriter::PutTable(morkEnv* ev, morkTable* ioTable)</span>
<a href="#l83.1136"></a><span id="l83.1136"> {</span>
<a href="#l83.1137"></a><span id="l83.1137">   if ( ev-&gt;Good() )</span>
<a href="#l83.1138"></a><span id="l83.1138">     this-&gt;StartTable(ev, ioTable);</span>
<a href="#l83.1139"></a><span id="l83.1139" class="difflineminus">-    </span>
<a href="#l83.1140"></a><span id="l83.1140" class="difflineplus">+</span>
<a href="#l83.1141"></a><span id="l83.1141">   if ( ev-&gt;Good() )</span>
<a href="#l83.1142"></a><span id="l83.1142">   {</span>
<a href="#l83.1143"></a><span id="l83.1143">     if ( ioTable-&gt;IsTableRewrite() || mWriter_NeedDirtyAll )</span>
<a href="#l83.1144"></a><span id="l83.1144">     {</span>
<a href="#l83.1145"></a><span id="l83.1145">       morkArray* array = &amp;ioTable-&gt;mTable_RowArray; // vector of rows</span>
<a href="#l83.1146"></a><span id="l83.1146">       mork_fill fill = array-&gt;mArray_Fill; // count of rows</span>
<a href="#l83.1147"></a><span id="l83.1147">       morkRow** rows = (morkRow**) array-&gt;mArray_Slots;</span>
<a href="#l83.1148"></a><span id="l83.1148">       if ( rows &amp;&amp; fill )</span>
<a href="#l83.1149"></a><span id="l83.1149" class="difflineat">@@ -1360,43 +1360,43 @@ morkWriter::PutTable(morkEnv* ev, morkTa</span>
<a href="#l83.1150"></a><span id="l83.1150">       morkNext* next = list-&gt;GetListHead();</span>
<a href="#l83.1151"></a><span id="l83.1151">       while ( next &amp;&amp; ev-&gt;Good() )</span>
<a href="#l83.1152"></a><span id="l83.1152">       {</span>
<a href="#l83.1153"></a><span id="l83.1153">         this-&gt;PutTableChange(ev, (morkTableChange*) next);</span>
<a href="#l83.1154"></a><span id="l83.1154">         next = next-&gt;GetNextLink();</span>
<a href="#l83.1155"></a><span id="l83.1155">       }</span>
<a href="#l83.1156"></a><span id="l83.1156">     }</span>
<a href="#l83.1157"></a><span id="l83.1157">   }</span>
<a href="#l83.1158"></a><span id="l83.1158" class="difflineminus">-    </span>
<a href="#l83.1159"></a><span id="l83.1159" class="difflineplus">+</span>
<a href="#l83.1160"></a><span id="l83.1160">   if ( ev-&gt;Good() )</span>
<a href="#l83.1161"></a><span id="l83.1161">     this-&gt;EndTable(ev);</span>
<a href="#l83.1162"></a><span id="l83.1162" class="difflineminus">-  </span>
<a href="#l83.1163"></a><span id="l83.1163" class="difflineplus">+</span>
<a href="#l83.1164"></a><span id="l83.1164">   ioTable-&gt;SetTableClean(ev); // note this also cleans change list</span>
<a href="#l83.1165"></a><span id="l83.1165">   mWriter_TableRowScope = 0;</span>
<a href="#l83.1166"></a><span id="l83.1166"> </span>
<a href="#l83.1167"></a><span id="l83.1167">   ++mWriter_DoneCount;</span>
<a href="#l83.1168"></a><span id="l83.1168">   return ev-&gt;Good();</span>
<a href="#l83.1169"></a><span id="l83.1169"> }</span>
<a href="#l83.1170"></a><span id="l83.1170"> </span>
<a href="#l83.1171"></a><span id="l83.1171"> mork_bool</span>
<a href="#l83.1172"></a><span id="l83.1172"> morkWriter::PutTableDict(morkEnv* ev, morkTable* ioTable)</span>
<a href="#l83.1173"></a><span id="l83.1173"> {</span>
<a href="#l83.1174"></a><span id="l83.1174">   morkRowSpace* space = ioTable-&gt;mTable_RowSpace;</span>
<a href="#l83.1175"></a><span id="l83.1175">   mWriter_TableRowScope = space-&gt;SpaceScope();</span>
<a href="#l83.1176"></a><span id="l83.1176">   mWriter_TableForm = 0;     // (f=iso-8859-1)</span>
<a href="#l83.1177"></a><span id="l83.1177">   mWriter_TableAtomScope = 'v'; // (a=v)</span>
<a href="#l83.1178"></a><span id="l83.1178">   mWriter_TableKind = ioTable-&gt;mTable_Kind;</span>
<a href="#l83.1179"></a><span id="l83.1179" class="difflineminus">-  </span>
<a href="#l83.1180"></a><span id="l83.1180" class="difflineplus">+</span>
<a href="#l83.1181"></a><span id="l83.1181">   mWriter_RowForm = mWriter_TableForm;</span>
<a href="#l83.1182"></a><span id="l83.1182">   mWriter_RowAtomScope = mWriter_TableAtomScope;</span>
<a href="#l83.1183"></a><span id="l83.1183">   mWriter_RowScope = mWriter_TableRowScope;</span>
<a href="#l83.1184"></a><span id="l83.1184" class="difflineminus">-  </span>
<a href="#l83.1185"></a><span id="l83.1185" class="difflineplus">+</span>
<a href="#l83.1186"></a><span id="l83.1186">   mWriter_DictForm = mWriter_TableForm;</span>
<a href="#l83.1187"></a><span id="l83.1187">   mWriter_DictAtomScope = mWriter_TableAtomScope;</span>
<a href="#l83.1188"></a><span id="l83.1188" class="difflineminus">-  </span>
<a href="#l83.1189"></a><span id="l83.1189" class="difflineplus">+</span>
<a href="#l83.1190"></a><span id="l83.1190">   // if ( ev-&gt;Good() )</span>
<a href="#l83.1191"></a><span id="l83.1191">   //  this-&gt;StartDict(ev); // delay as long as possible</span>
<a href="#l83.1192"></a><span id="l83.1192"> </span>
<a href="#l83.1193"></a><span id="l83.1193">   if ( ev-&gt;Good() )</span>
<a href="#l83.1194"></a><span id="l83.1194">   {</span>
<a href="#l83.1195"></a><span id="l83.1195">     morkRow* r = ioTable-&gt;mTable_MetaRow;</span>
<a href="#l83.1196"></a><span id="l83.1196">     if ( r )</span>
<a href="#l83.1197"></a><span id="l83.1197">     {</span>
<a href="#l83.1198"></a><span id="l83.1198" class="difflineat">@@ -1431,48 +1431,48 @@ morkWriter::PutTableDict(morkEnv* ev, mo</span>
<a href="#l83.1199"></a><span id="l83.1199">       r = ((morkTableChange*) next)-&gt;mTableChange_Row;</span>
<a href="#l83.1200"></a><span id="l83.1200">       if  ( r &amp;&amp; r-&gt;IsRow() )</span>
<a href="#l83.1201"></a><span id="l83.1201">         this-&gt;PutRowDict(ev, r);</span>
<a href="#l83.1202"></a><span id="l83.1202">       next = next-&gt;GetNextLink();</span>
<a href="#l83.1203"></a><span id="l83.1203">     }</span>
<a href="#l83.1204"></a><span id="l83.1204">   }</span>
<a href="#l83.1205"></a><span id="l83.1205">   if ( ev-&gt;Good() )</span>
<a href="#l83.1206"></a><span id="l83.1206">     this-&gt;EndDict(ev);</span>
<a href="#l83.1207"></a><span id="l83.1207" class="difflineminus">-  </span>
<a href="#l83.1208"></a><span id="l83.1208" class="difflineplus">+</span>
<a href="#l83.1209"></a><span id="l83.1209">   return ev-&gt;Good();</span>
<a href="#l83.1210"></a><span id="l83.1210"> }</span>
<a href="#l83.1211"></a><span id="l83.1211" class="difflineminus">-  </span>
<a href="#l83.1212"></a><span id="l83.1212" class="difflineplus">+</span>
<a href="#l83.1213"></a><span id="l83.1213"> void</span>
<a href="#l83.1214"></a><span id="l83.1214"> morkWriter::WriteTokenToTokenMetaCell(morkEnv* ev,</span>
<a href="#l83.1215"></a><span id="l83.1215">   mork_token inCol, mork_token inValue)</span>
<a href="#l83.1216"></a><span id="l83.1216"> {</span>
<a href="#l83.1217"></a><span id="l83.1217">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1218"></a><span id="l83.1218">   mork_bool isKindCol = ( morkStore_kKindColumn == inCol );</span>
<a href="#l83.1219"></a><span id="l83.1219">   mork_u1 valSep = (mork_u1) (( isKindCol )? '^' : '=');</span>
<a href="#l83.1220"></a><span id="l83.1220" class="difflineminus">-  </span>
<a href="#l83.1221"></a><span id="l83.1221" class="difflineplus">+</span>
<a href="#l83.1222"></a><span id="l83.1222">   char buf[ 128 ]; // buffer for staging the two hex IDs</span>
<a href="#l83.1223"></a><span id="l83.1223">   char* p = buf;</span>
<a href="#l83.1224"></a><span id="l83.1224"> </span>
<a href="#l83.1225"></a><span id="l83.1225">   mork_size bytesWritten;</span>
<a href="#l83.1226"></a><span id="l83.1226">   if ( inCol &lt; 0x80 )</span>
<a href="#l83.1227"></a><span id="l83.1227">   {</span>
<a href="#l83.1228"></a><span id="l83.1228">     stream-&gt;Putc(ev, '(');</span>
<a href="#l83.1229"></a><span id="l83.1229">     stream-&gt;Putc(ev, (char) inCol);</span>
<a href="#l83.1230"></a><span id="l83.1230">     stream-&gt;Putc(ev, valSep);</span>
<a href="#l83.1231"></a><span id="l83.1231">   }</span>
<a href="#l83.1232"></a><span id="l83.1232">   else</span>
<a href="#l83.1233"></a><span id="l83.1233">   {</span>
<a href="#l83.1234"></a><span id="l83.1234">     *p++ = '('; // we always start with open paren</span>
<a href="#l83.1235"></a><span id="l83.1235" class="difflineminus">-    </span>
<a href="#l83.1236"></a><span id="l83.1236" class="difflineplus">+</span>
<a href="#l83.1237"></a><span id="l83.1237">     *p++ = '^'; // indicates col is hex ID</span>
<a href="#l83.1238"></a><span id="l83.1238">     mork_size colSize = ev-&gt;TokenAsHex(p, inCol);</span>
<a href="#l83.1239"></a><span id="l83.1239">     p += colSize;</span>
<a href="#l83.1240"></a><span id="l83.1240">     *p++ = (char) valSep;</span>
<a href="#l83.1241"></a><span id="l83.1241">     stream-&gt;Write(ev-&gt;AsMdbEnv(), buf, colSize + 3, &amp;bytesWritten);</span>
<a href="#l83.1242"></a><span id="l83.1242" class="difflineminus">-    </span>
<a href="#l83.1243"></a><span id="l83.1243" class="difflineplus">+</span>
<a href="#l83.1244"></a><span id="l83.1244">     mWriter_LineSize += bytesWritten;</span>
<a href="#l83.1245"></a><span id="l83.1245">   }</span>
<a href="#l83.1246"></a><span id="l83.1246"> </span>
<a href="#l83.1247"></a><span id="l83.1247">   if ( isKindCol )</span>
<a href="#l83.1248"></a><span id="l83.1248">   {</span>
<a href="#l83.1249"></a><span id="l83.1249">     p = buf;</span>
<a href="#l83.1250"></a><span id="l83.1250">     mork_size valSize = ev-&gt;TokenAsHex(p, inValue);</span>
<a href="#l83.1251"></a><span id="l83.1251">     p += valSize;</span>
<a href="#l83.1252"></a><span id="l83.1252" class="difflineat">@@ -1487,50 +1487,50 @@ morkWriter::WriteTokenToTokenMetaCell(mo</span>
<a href="#l83.1253"></a><span id="l83.1253">     this-&gt;IndentAsNeeded(ev, morkWriter_kTableMetaCellValueDepth);</span>
<a href="#l83.1254"></a><span id="l83.1254">     mdbYarn* yarn = &amp;mWriter_ColYarn;</span>
<a href="#l83.1255"></a><span id="l83.1255">     // mork_u1* yarnBuf = (mork_u1*) yarn-&gt;mYarn_Buf;</span>
<a href="#l83.1256"></a><span id="l83.1256">     mWriter_Store-&gt;TokenToString(ev, inValue, yarn);</span>
<a href="#l83.1257"></a><span id="l83.1257">     this-&gt;WriteYarn(ev, yarn);</span>
<a href="#l83.1258"></a><span id="l83.1258">     stream-&gt;Putc(ev, ')');</span>
<a href="#l83.1259"></a><span id="l83.1259">     ++mWriter_LineSize;</span>
<a href="#l83.1260"></a><span id="l83.1260">   }</span>
<a href="#l83.1261"></a><span id="l83.1261" class="difflineminus">-  </span>
<a href="#l83.1262"></a><span id="l83.1262" class="difflineplus">+</span>
<a href="#l83.1263"></a><span id="l83.1263">   // mork_fill fill = yarn-&gt;mYarn_Fill;</span>
<a href="#l83.1264"></a><span id="l83.1264">   // yarnBuf[ fill ] = ')'; // append terminator</span>
<a href="#l83.1265"></a><span id="l83.1265">   // mWriter_LineSize += stream-&gt;Write(ev, yarnBuf, fill + 1); // +1 for ')'</span>
<a href="#l83.1266"></a><span id="l83.1266"> }</span>
<a href="#l83.1267"></a><span id="l83.1267" class="difflineminus">-  </span>
<a href="#l83.1268"></a><span id="l83.1268" class="difflineplus">+</span>
<a href="#l83.1269"></a><span id="l83.1269"> void</span>
<a href="#l83.1270"></a><span id="l83.1270"> morkWriter::WriteStringToTokenDictCell(morkEnv* ev,</span>
<a href="#l83.1271"></a><span id="l83.1271">   const char* inCol, mork_token inValue)</span>
<a href="#l83.1272"></a><span id="l83.1272">   // Note inCol should begin with '(' and end with '=', with col in between.</span>
<a href="#l83.1273"></a><span id="l83.1273"> {</span>
<a href="#l83.1274"></a><span id="l83.1274">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1275"></a><span id="l83.1275">   mWriter_LineSize += stream-&gt;PutString(ev, inCol);</span>
<a href="#l83.1276"></a><span id="l83.1276"> </span>
<a href="#l83.1277"></a><span id="l83.1277">   this-&gt;IndentAsNeeded(ev, morkWriter_kDictMetaCellValueDepth);</span>
<a href="#l83.1278"></a><span id="l83.1278">   mdbYarn* yarn = &amp;mWriter_ColYarn;</span>
<a href="#l83.1279"></a><span id="l83.1279">   // mork_u1* yarnBuf = (mork_u1*) yarn-&gt;mYarn_Buf;</span>
<a href="#l83.1280"></a><span id="l83.1280">   mWriter_Store-&gt;TokenToString(ev, inValue, yarn);</span>
<a href="#l83.1281"></a><span id="l83.1281">   this-&gt;WriteYarn(ev, yarn);</span>
<a href="#l83.1282"></a><span id="l83.1282">   stream-&gt;Putc(ev, ')');</span>
<a href="#l83.1283"></a><span id="l83.1283">   ++mWriter_LineSize;</span>
<a href="#l83.1284"></a><span id="l83.1284" class="difflineminus">-  </span>
<a href="#l83.1285"></a><span id="l83.1285" class="difflineplus">+</span>
<a href="#l83.1286"></a><span id="l83.1286">   // mork_fill fill = yarn-&gt;mYarn_Fill;</span>
<a href="#l83.1287"></a><span id="l83.1287">   // yarnBuf[ fill ] = ')'; // append terminator</span>
<a href="#l83.1288"></a><span id="l83.1288">   // mWriter_LineSize += stream-&gt;Write(ev, yarnBuf, fill + 1); // +1 for ')'</span>
<a href="#l83.1289"></a><span id="l83.1289"> }</span>
<a href="#l83.1290"></a><span id="l83.1290"> </span>
<a href="#l83.1291"></a><span id="l83.1291"> void</span>
<a href="#l83.1292"></a><span id="l83.1292"> morkWriter::ChangeDictAtomScope(morkEnv* ev, mork_scope inScope)</span>
<a href="#l83.1293"></a><span id="l83.1293"> {</span>
<a href="#l83.1294"></a><span id="l83.1294">   if ( inScope != mWriter_DictAtomScope )</span>
<a href="#l83.1295"></a><span id="l83.1295">   {</span>
<a href="#l83.1296"></a><span id="l83.1296">     ev-&gt;NewWarning(&quot;unexpected atom scope change&quot;);</span>
<a href="#l83.1297"></a><span id="l83.1297" class="difflineminus">-    </span>
<a href="#l83.1298"></a><span id="l83.1298" class="difflineplus">+</span>
<a href="#l83.1299"></a><span id="l83.1299">     morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1300"></a><span id="l83.1300">     if ( mWriter_LineSize )</span>
<a href="#l83.1301"></a><span id="l83.1301">       stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.1302"></a><span id="l83.1302">     mWriter_LineSize = 0;</span>
<a href="#l83.1303"></a><span id="l83.1303"> </span>
<a href="#l83.1304"></a><span id="l83.1304">     char buf[ 128 ]; // buffer for staging the two hex IDs</span>
<a href="#l83.1305"></a><span id="l83.1305">     char* p = buf;</span>
<a href="#l83.1306"></a><span id="l83.1306">     *p++ = '&lt;'; // we always start with open paren</span>
<a href="#l83.1307"></a><span id="l83.1307" class="difflineat">@@ -1555,17 +1555,17 @@ morkWriter::ChangeDictAtomScope(morkEnv*</span>
<a href="#l83.1308"></a><span id="l83.1308">     *p = 0;</span>
<a href="#l83.1309"></a><span id="l83.1309"> </span>
<a href="#l83.1310"></a><span id="l83.1310">     mork_size pending = scopeSize + 6;</span>
<a href="#l83.1311"></a><span id="l83.1311">     this-&gt;IndentOverMaxLine(ev, pending, morkWriter_kDictAliasDepth);</span>
<a href="#l83.1312"></a><span id="l83.1312">     mork_size bytesWritten;</span>
<a href="#l83.1313"></a><span id="l83.1313"> </span>
<a href="#l83.1314"></a><span id="l83.1314">     stream-&gt;Write(ev-&gt;AsMdbEnv(), buf, pending, &amp;bytesWritten);</span>
<a href="#l83.1315"></a><span id="l83.1315">     mWriter_LineSize += bytesWritten;</span>
<a href="#l83.1316"></a><span id="l83.1316" class="difflineminus">-      </span>
<a href="#l83.1317"></a><span id="l83.1317" class="difflineplus">+</span>
<a href="#l83.1318"></a><span id="l83.1318">     mWriter_DictAtomScope = inScope;</span>
<a href="#l83.1319"></a><span id="l83.1319">   }</span>
<a href="#l83.1320"></a><span id="l83.1320"> }</span>
<a href="#l83.1321"></a><span id="l83.1321"> </span>
<a href="#l83.1322"></a><span id="l83.1322"> void</span>
<a href="#l83.1323"></a><span id="l83.1323"> morkWriter::ChangeRowForm(morkEnv* ev, mork_cscode inNewForm)</span>
<a href="#l83.1324"></a><span id="l83.1324"> {</span>
<a href="#l83.1325"></a><span id="l83.1325">   if ( inNewForm != mWriter_RowForm )</span>
<a href="#l83.1326"></a><span id="l83.1326" class="difflineat">@@ -1588,27 +1588,27 @@ morkWriter::ChangeRowForm(morkEnv* ev, m</span>
<a href="#l83.1327"></a><span id="l83.1327">       formSize = ev-&gt;TokenAsHex(p, inNewForm);</span>
<a href="#l83.1328"></a><span id="l83.1328">       p += formSize;</span>
<a href="#l83.1329"></a><span id="l83.1329">     }</span>
<a href="#l83.1330"></a><span id="l83.1330">     else</span>
<a href="#l83.1331"></a><span id="l83.1331">     {</span>
<a href="#l83.1332"></a><span id="l83.1332">       *p++ = '='; // indicates col is imm byte</span>
<a href="#l83.1333"></a><span id="l83.1333">       *p++ = (char) (mork_u1) inNewForm;</span>
<a href="#l83.1334"></a><span id="l83.1334">     }</span>
<a href="#l83.1335"></a><span id="l83.1335" class="difflineminus">-    </span>
<a href="#l83.1336"></a><span id="l83.1336" class="difflineplus">+</span>
<a href="#l83.1337"></a><span id="l83.1337">     *p++ = ')';</span>
<a href="#l83.1338"></a><span id="l83.1338">     *p++ = ']';</span>
<a href="#l83.1339"></a><span id="l83.1339">     *p = 0;</span>
<a href="#l83.1340"></a><span id="l83.1340"> </span>
<a href="#l83.1341"></a><span id="l83.1341">     mork_size pending = formSize + 6;</span>
<a href="#l83.1342"></a><span id="l83.1342">     this-&gt;IndentOverMaxLine(ev, pending, morkWriter_kRowCellDepth);</span>
<a href="#l83.1343"></a><span id="l83.1343">     mork_size bytesWritten;</span>
<a href="#l83.1344"></a><span id="l83.1344">     stream-&gt;Write(ev-&gt;AsMdbEnv(), buf, pending, &amp;bytesWritten);</span>
<a href="#l83.1345"></a><span id="l83.1345">     mWriter_LineSize += bytesWritten;</span>
<a href="#l83.1346"></a><span id="l83.1346" class="difflineminus">-      </span>
<a href="#l83.1347"></a><span id="l83.1347" class="difflineplus">+</span>
<a href="#l83.1348"></a><span id="l83.1348">     mWriter_RowForm = inNewForm;</span>
<a href="#l83.1349"></a><span id="l83.1349">   }</span>
<a href="#l83.1350"></a><span id="l83.1350"> }</span>
<a href="#l83.1351"></a><span id="l83.1351"> </span>
<a href="#l83.1352"></a><span id="l83.1352"> void</span>
<a href="#l83.1353"></a><span id="l83.1353"> morkWriter::ChangeDictForm(morkEnv* ev, mork_cscode inNewForm)</span>
<a href="#l83.1354"></a><span id="l83.1354"> {</span>
<a href="#l83.1355"></a><span id="l83.1355">   if ( inNewForm != mWriter_DictForm )</span>
<a href="#l83.1356"></a><span id="l83.1356" class="difflineat">@@ -1631,62 +1631,62 @@ morkWriter::ChangeDictForm(morkEnv* ev, </span>
<a href="#l83.1357"></a><span id="l83.1357">       formSize = ev-&gt;TokenAsHex(p, inNewForm);</span>
<a href="#l83.1358"></a><span id="l83.1358">       p += formSize;</span>
<a href="#l83.1359"></a><span id="l83.1359">     }</span>
<a href="#l83.1360"></a><span id="l83.1360">     else</span>
<a href="#l83.1361"></a><span id="l83.1361">     {</span>
<a href="#l83.1362"></a><span id="l83.1362">       *p++ = '='; // indicates col is imm byte</span>
<a href="#l83.1363"></a><span id="l83.1363">       *p++ = (char) (mork_u1) inNewForm;</span>
<a href="#l83.1364"></a><span id="l83.1364">     }</span>
<a href="#l83.1365"></a><span id="l83.1365" class="difflineminus">-    </span>
<a href="#l83.1366"></a><span id="l83.1366" class="difflineplus">+</span>
<a href="#l83.1367"></a><span id="l83.1367">     *p++ = ')';</span>
<a href="#l83.1368"></a><span id="l83.1368">     *p++ = '&gt;';</span>
<a href="#l83.1369"></a><span id="l83.1369">     *p = 0;</span>
<a href="#l83.1370"></a><span id="l83.1370"> </span>
<a href="#l83.1371"></a><span id="l83.1371">     mork_size pending = formSize + 6;</span>
<a href="#l83.1372"></a><span id="l83.1372">     this-&gt;IndentOverMaxLine(ev, pending, morkWriter_kDictAliasDepth);</span>
<a href="#l83.1373"></a><span id="l83.1373" class="difflineminus">-    </span>
<a href="#l83.1374"></a><span id="l83.1374" class="difflineplus">+</span>
<a href="#l83.1375"></a><span id="l83.1375">     mork_size bytesWritten;</span>
<a href="#l83.1376"></a><span id="l83.1376">     stream-&gt;Write(ev-&gt;AsMdbEnv(), buf, pending, &amp;bytesWritten);</span>
<a href="#l83.1377"></a><span id="l83.1377">     mWriter_LineSize += bytesWritten;</span>
<a href="#l83.1378"></a><span id="l83.1378" class="difflineminus">-      </span>
<a href="#l83.1379"></a><span id="l83.1379" class="difflineplus">+</span>
<a href="#l83.1380"></a><span id="l83.1380">     mWriter_DictForm = inNewForm;</span>
<a href="#l83.1381"></a><span id="l83.1381">   }</span>
<a href="#l83.1382"></a><span id="l83.1382"> }</span>
<a href="#l83.1383"></a><span id="l83.1383"> </span>
<a href="#l83.1384"></a><span id="l83.1384"> void</span>
<a href="#l83.1385"></a><span id="l83.1385"> morkWriter::StartDict(morkEnv* ev)</span>
<a href="#l83.1386"></a><span id="l83.1386"> {</span>
<a href="#l83.1387"></a><span id="l83.1387">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1388"></a><span id="l83.1388">   if ( mWriter_DidStartDict )</span>
<a href="#l83.1389"></a><span id="l83.1389">   {</span>
<a href="#l83.1390"></a><span id="l83.1390">     stream-&gt;Putc(ev, '&gt;'); // end dict</span>
<a href="#l83.1391"></a><span id="l83.1391">     ++mWriter_LineSize;</span>
<a href="#l83.1392"></a><span id="l83.1392">   }</span>
<a href="#l83.1393"></a><span id="l83.1393">   mWriter_DidStartDict = morkBool_kTrue;</span>
<a href="#l83.1394"></a><span id="l83.1394">   mWriter_DidEndDict = morkBool_kFalse;</span>
<a href="#l83.1395"></a><span id="l83.1395" class="difflineminus">-  </span>
<a href="#l83.1396"></a><span id="l83.1396" class="difflineplus">+</span>
<a href="#l83.1397"></a><span id="l83.1397">   if ( mWriter_LineSize )</span>
<a href="#l83.1398"></a><span id="l83.1398">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.1399"></a><span id="l83.1399">   mWriter_LineSize = 0;</span>
<a href="#l83.1400"></a><span id="l83.1400" class="difflineminus">-  </span>
<a href="#l83.1401"></a><span id="l83.1401" class="difflineplus">+</span>
<a href="#l83.1402"></a><span id="l83.1402">   if ( mWriter_TableRowScope ) // blank line before table's dict?</span>
<a href="#l83.1403"></a><span id="l83.1403">     stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.1404"></a><span id="l83.1404" class="difflineminus">-    </span>
<a href="#l83.1405"></a><span id="l83.1405" class="difflineplus">+</span>
<a href="#l83.1406"></a><span id="l83.1406">   if ( mWriter_DictForm || mWriter_DictAtomScope != 'v' )</span>
<a href="#l83.1407"></a><span id="l83.1407">   {</span>
<a href="#l83.1408"></a><span id="l83.1408">     stream-&gt;Putc(ev, '&lt;');</span>
<a href="#l83.1409"></a><span id="l83.1409">     stream-&gt;Putc(ev, ' ');</span>
<a href="#l83.1410"></a><span id="l83.1410">     stream-&gt;Putc(ev, '&lt;');</span>
<a href="#l83.1411"></a><span id="l83.1411">     mWriter_LineSize = 3;</span>
<a href="#l83.1412"></a><span id="l83.1412">     if ( mWriter_DictForm )</span>
<a href="#l83.1413"></a><span id="l83.1413">       this-&gt;WriteStringToTokenDictCell(ev, &quot;(f=&quot;, mWriter_DictForm);</span>
<a href="#l83.1414"></a><span id="l83.1414">     if ( mWriter_DictAtomScope != 'v' )</span>
<a href="#l83.1415"></a><span id="l83.1415">       this-&gt;WriteStringToTokenDictCell(ev, &quot;(a=&quot;, mWriter_DictAtomScope);</span>
<a href="#l83.1416"></a><span id="l83.1416" class="difflineminus">-  </span>
<a href="#l83.1417"></a><span id="l83.1417" class="difflineplus">+</span>
<a href="#l83.1418"></a><span id="l83.1418">     stream-&gt;Putc(ev, '&gt;');</span>
<a href="#l83.1419"></a><span id="l83.1419">     ++mWriter_LineSize;</span>
<a href="#l83.1420"></a><span id="l83.1420"> </span>
<a href="#l83.1421"></a><span id="l83.1421">     mWriter_LineSize = stream-&gt;PutIndent(ev, morkWriter_kDictAliasDepth);</span>
<a href="#l83.1422"></a><span id="l83.1422">   }</span>
<a href="#l83.1423"></a><span id="l83.1423">   else</span>
<a href="#l83.1424"></a><span id="l83.1424">   {</span>
<a href="#l83.1425"></a><span id="l83.1425">     stream-&gt;Putc(ev, '&lt;');</span>
<a href="#l83.1426"></a><span id="l83.1426" class="difflineat">@@ -1708,17 +1708,17 @@ morkWriter::EndDict(morkEnv* ev)</span>
<a href="#l83.1427"></a><span id="l83.1427">   mWriter_DidEndDict = morkBool_kTrue;</span>
<a href="#l83.1428"></a><span id="l83.1428"> }</span>
<a href="#l83.1429"></a><span id="l83.1429"> </span>
<a href="#l83.1430"></a><span id="l83.1430"> void</span>
<a href="#l83.1431"></a><span id="l83.1431"> morkWriter::StartTable(morkEnv* ev, morkTable* ioTable)</span>
<a href="#l83.1432"></a><span id="l83.1432"> {</span>
<a href="#l83.1433"></a><span id="l83.1433">   mdbOid toid; // to receive table oid</span>
<a href="#l83.1434"></a><span id="l83.1434">   ioTable-&gt;GetTableOid(ev, &amp;toid);</span>
<a href="#l83.1435"></a><span id="l83.1435" class="difflineminus">-  </span>
<a href="#l83.1436"></a><span id="l83.1436" class="difflineplus">+</span>
<a href="#l83.1437"></a><span id="l83.1437">   if ( ev-&gt;Good() )</span>
<a href="#l83.1438"></a><span id="l83.1438">   {</span>
<a href="#l83.1439"></a><span id="l83.1439">     morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1440"></a><span id="l83.1440">     if ( mWriter_LineSize )</span>
<a href="#l83.1441"></a><span id="l83.1441">       stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.1442"></a><span id="l83.1442">     mWriter_LineSize = 0;</span>
<a href="#l83.1443"></a><span id="l83.1443">     // stream-&gt;PutLineBreak(ev);</span>
<a href="#l83.1444"></a><span id="l83.1444"> </span>
<a href="#l83.1445"></a><span id="l83.1445" class="difflineat">@@ -1734,86 +1734,86 @@ morkWriter::StartTable(morkEnv* ev, mork</span>
<a href="#l83.1446"></a><span id="l83.1446">       ++mWriter_LineSize;</span>
<a href="#l83.1447"></a><span id="l83.1447">     }</span>
<a href="#l83.1448"></a><span id="l83.1448">     mork_size oidSize = ev-&gt;OidAsHex(p, toid);</span>
<a href="#l83.1449"></a><span id="l83.1449">     p += oidSize;</span>
<a href="#l83.1450"></a><span id="l83.1450">     *p++ = ' '; // punct 2</span>
<a href="#l83.1451"></a><span id="l83.1451">     *p++ = '{'; // punct 3</span>
<a href="#l83.1452"></a><span id="l83.1452">     if (mWriter_BeVerbose)</span>
<a href="#l83.1453"></a><span id="l83.1453">     {</span>
<a href="#l83.1454"></a><span id="l83.1454" class="difflineminus">-    </span>
<a href="#l83.1455"></a><span id="l83.1455" class="difflineplus">+</span>
<a href="#l83.1456"></a><span id="l83.1456">       *p++ = '/'; // punct=4</span>
<a href="#l83.1457"></a><span id="l83.1457">       *p++ = '*'; // punct=5</span>
<a href="#l83.1458"></a><span id="l83.1458">       *p++ = 'r'; // punct=6</span>
<a href="#l83.1459"></a><span id="l83.1459">       *p++ = '='; // punct=7</span>
<a href="#l83.1460"></a><span id="l83.1460"> </span>
<a href="#l83.1461"></a><span id="l83.1461">       mork_token tableUses = (mork_token) ioTable-&gt;mTable_GcUses;</span>
<a href="#l83.1462"></a><span id="l83.1462">       mork_size usesSize = ev-&gt;TokenAsHex(p, tableUses);</span>
<a href="#l83.1463"></a><span id="l83.1463">       punctSize += usesSize;</span>
<a href="#l83.1464"></a><span id="l83.1464">       p += usesSize;</span>
<a href="#l83.1465"></a><span id="l83.1465" class="difflineminus">-    </span>
<a href="#l83.1466"></a><span id="l83.1466" class="difflineplus">+</span>
<a href="#l83.1467"></a><span id="l83.1467">       *p++ = '*'; // punct=8</span>
<a href="#l83.1468"></a><span id="l83.1468">       *p++ = '/'; // punct=9</span>
<a href="#l83.1469"></a><span id="l83.1469">       *p++ = ' '; // punct=10</span>
<a href="#l83.1470"></a><span id="l83.1470">     }</span>
<a href="#l83.1471"></a><span id="l83.1471">     mork_size bytesWritten;</span>
<a href="#l83.1472"></a><span id="l83.1472"> </span>
<a href="#l83.1473"></a><span id="l83.1473">     stream-&gt;Write(ev-&gt;AsMdbEnv(), buf, oidSize + punctSize, &amp;bytesWritten);</span>
<a href="#l83.1474"></a><span id="l83.1474">     mWriter_LineSize += bytesWritten;</span>
<a href="#l83.1475"></a><span id="l83.1475"> </span>
<a href="#l83.1476"></a><span id="l83.1476">     mork_kind tk = mWriter_TableKind;</span>
<a href="#l83.1477"></a><span id="l83.1477">     if ( tk )</span>
<a href="#l83.1478"></a><span id="l83.1478">     {</span>
<a href="#l83.1479"></a><span id="l83.1479">       this-&gt;IndentAsNeeded(ev, morkWriter_kTableMetaCellDepth);</span>
<a href="#l83.1480"></a><span id="l83.1480">       this-&gt;WriteTokenToTokenMetaCell(ev, morkStore_kKindColumn, tk);</span>
<a href="#l83.1481"></a><span id="l83.1481">     }</span>
<a href="#l83.1482"></a><span id="l83.1482" class="difflineminus">-      </span>
<a href="#l83.1483"></a><span id="l83.1483" class="difflineplus">+</span>
<a href="#l83.1484"></a><span id="l83.1484">     stream-&gt;Putc(ev, '('); // start 's' col cell</span>
<a href="#l83.1485"></a><span id="l83.1485">     stream-&gt;Putc(ev, 's'); // column</span>
<a href="#l83.1486"></a><span id="l83.1486">     stream-&gt;Putc(ev, '='); // column</span>
<a href="#l83.1487"></a><span id="l83.1487">     mWriter_LineSize += 3;</span>
<a href="#l83.1488"></a><span id="l83.1488"> </span>
<a href="#l83.1489"></a><span id="l83.1489">     int prio = (int) ioTable-&gt;mTable_Priority;</span>
<a href="#l83.1490"></a><span id="l83.1490">     if ( prio &gt; 9 ) // need to force down to max decimal digit?</span>
<a href="#l83.1491"></a><span id="l83.1491">       prio = 9;</span>
<a href="#l83.1492"></a><span id="l83.1492">     prio += '0'; // add base digit zero</span>
<a href="#l83.1493"></a><span id="l83.1493">     stream-&gt;Putc(ev, prio); // priority: (s=0</span>
<a href="#l83.1494"></a><span id="l83.1494">     ++mWriter_LineSize;</span>
<a href="#l83.1495"></a><span id="l83.1495" class="difflineminus">-    </span>
<a href="#l83.1496"></a><span id="l83.1496" class="difflineplus">+</span>
<a href="#l83.1497"></a><span id="l83.1497">     if ( ioTable-&gt;IsTableUnique() )</span>
<a href="#l83.1498"></a><span id="l83.1498">     {</span>
<a href="#l83.1499"></a><span id="l83.1499">       stream-&gt;Putc(ev, 'u'); // (s=0u</span>
<a href="#l83.1500"></a><span id="l83.1500">       ++mWriter_LineSize;</span>
<a href="#l83.1501"></a><span id="l83.1501">     }</span>
<a href="#l83.1502"></a><span id="l83.1502">     if ( ioTable-&gt;IsTableVerbose() )</span>
<a href="#l83.1503"></a><span id="l83.1503">     {</span>
<a href="#l83.1504"></a><span id="l83.1504">       stream-&gt;Putc(ev, 'v'); // (s=0uv</span>
<a href="#l83.1505"></a><span id="l83.1505">       ++mWriter_LineSize;</span>
<a href="#l83.1506"></a><span id="l83.1506">     }</span>
<a href="#l83.1507"></a><span id="l83.1507" class="difflineminus">-    </span>
<a href="#l83.1508"></a><span id="l83.1508" class="difflineplus">+</span>
<a href="#l83.1509"></a><span id="l83.1509">     // stream-&gt;Putc(ev, ':'); // (s=0uv:</span>
<a href="#l83.1510"></a><span id="l83.1510">     // stream-&gt;Putc(ev, 'c'); // (s=0uv:c</span>
<a href="#l83.1511"></a><span id="l83.1511">     stream-&gt;Putc(ev, ')'); // end 's' col cell (s=0uv:c)</span>
<a href="#l83.1512"></a><span id="l83.1512">     mWriter_LineSize += 1; // maybe 3 if we add ':' and 'c'</span>
<a href="#l83.1513"></a><span id="l83.1513"> </span>
<a href="#l83.1514"></a><span id="l83.1514">     morkRow* r = ioTable-&gt;mTable_MetaRow;</span>
<a href="#l83.1515"></a><span id="l83.1515">     if ( r )</span>
<a href="#l83.1516"></a><span id="l83.1516">     {</span>
<a href="#l83.1517"></a><span id="l83.1517">       if ( r-&gt;IsRow() )</span>
<a href="#l83.1518"></a><span id="l83.1518">       {</span>
<a href="#l83.1519"></a><span id="l83.1519">         mWriter_SuppressDirtyRowNewline = morkBool_kTrue;</span>
<a href="#l83.1520"></a><span id="l83.1520">         this-&gt;PutRow(ev, r);</span>
<a href="#l83.1521"></a><span id="l83.1521">       }</span>
<a href="#l83.1522"></a><span id="l83.1522">       else</span>
<a href="#l83.1523"></a><span id="l83.1523">         r-&gt;NonRowTypeError(ev);</span>
<a href="#l83.1524"></a><span id="l83.1524">     }</span>
<a href="#l83.1525"></a><span id="l83.1525" class="difflineminus">-    </span>
<a href="#l83.1526"></a><span id="l83.1526" class="difflineplus">+</span>
<a href="#l83.1527"></a><span id="l83.1527">     stream-&gt;Putc(ev, '}'); // end meta</span>
<a href="#l83.1528"></a><span id="l83.1528">     ++mWriter_LineSize;</span>
<a href="#l83.1529"></a><span id="l83.1529" class="difflineminus">-    </span>
<a href="#l83.1530"></a><span id="l83.1530" class="difflineplus">+</span>
<a href="#l83.1531"></a><span id="l83.1531">     if ( mWriter_LineSize &lt; mWriter_MaxIndent )</span>
<a href="#l83.1532"></a><span id="l83.1532">     {</span>
<a href="#l83.1533"></a><span id="l83.1533">       stream-&gt;Putc(ev, ' '); // nice white space</span>
<a href="#l83.1534"></a><span id="l83.1534">       ++mWriter_LineSize;</span>
<a href="#l83.1535"></a><span id="l83.1535">     }</span>
<a href="#l83.1536"></a><span id="l83.1536">   }</span>
<a href="#l83.1537"></a><span id="l83.1537"> }</span>
<a href="#l83.1538"></a><span id="l83.1538"> </span>
<a href="#l83.1539"></a><span id="l83.1539" class="difflineat">@@ -1852,47 +1852,47 @@ morkWriter::PutRowDict(morkEnv* ev, mork</span>
<a href="#l83.1540"></a><span id="l83.1540">         {</span>
<a href="#l83.1541"></a><span id="l83.1541">           if ( !this-&gt;DidStartDict() )</span>
<a href="#l83.1542"></a><span id="l83.1542">           {</span>
<a href="#l83.1543"></a><span id="l83.1543">             this-&gt;StartDict(ev);</span>
<a href="#l83.1544"></a><span id="l83.1544">             if ( ev-&gt;Bad() )</span>
<a href="#l83.1545"></a><span id="l83.1545">               break;</span>
<a href="#l83.1546"></a><span id="l83.1546">           }</span>
<a href="#l83.1547"></a><span id="l83.1547">           atom-&gt;SetAtomClean(); // neutralize change</span>
<a href="#l83.1548"></a><span id="l83.1548" class="difflineminus">-          </span>
<a href="#l83.1549"></a><span id="l83.1549" class="difflineplus">+</span>
<a href="#l83.1550"></a><span id="l83.1550">           this-&gt;IndentAsNeeded(ev, morkWriter_kDictAliasDepth);</span>
<a href="#l83.1551"></a><span id="l83.1551">           morkBookAtom* ba = (morkBookAtom*) atom;</span>
<a href="#l83.1552"></a><span id="l83.1552">           mork_size size = ev-&gt;TokenAsHex(idBuf, ba-&gt;mBookAtom_Id);</span>
<a href="#l83.1553"></a><span id="l83.1553">           mork_size bytesWritten;</span>
<a href="#l83.1554"></a><span id="l83.1554">           stream-&gt;Write(ev-&gt;AsMdbEnv(), buf, size+1, &amp;bytesWritten); // '('</span>
<a href="#l83.1555"></a><span id="l83.1555">           mWriter_LineSize += bytesWritten;</span>
<a href="#l83.1556"></a><span id="l83.1556"> </span>
<a href="#l83.1557"></a><span id="l83.1557">           if ( morkAtom::AliasYarn(atom, &amp;yarn) )</span>
<a href="#l83.1558"></a><span id="l83.1558">           {</span>
<a href="#l83.1559"></a><span id="l83.1559">             mork_scope atomScope = atom-&gt;GetBookAtomSpaceScope(ev);</span>
<a href="#l83.1560"></a><span id="l83.1560">             if ( atomScope &amp;&amp; atomScope != mWriter_DictAtomScope )</span>
<a href="#l83.1561"></a><span id="l83.1561">               this-&gt;ChangeDictAtomScope(ev, atomScope);</span>
<a href="#l83.1562"></a><span id="l83.1562" class="difflineminus">-            </span>
<a href="#l83.1563"></a><span id="l83.1563" class="difflineplus">+</span>
<a href="#l83.1564"></a><span id="l83.1564">             if ( mWriter_DidStartDict &amp;&amp; yarn.mYarn_Form != mWriter_DictForm )</span>
<a href="#l83.1565"></a><span id="l83.1565" class="difflineminus">-              this-&gt;ChangeDictForm(ev, yarn.mYarn_Form);  </span>
<a href="#l83.1566"></a><span id="l83.1566" class="difflineminus">-      </span>
<a href="#l83.1567"></a><span id="l83.1567" class="difflineplus">+              this-&gt;ChangeDictForm(ev, yarn.mYarn_Form);</span>
<a href="#l83.1568"></a><span id="l83.1568" class="difflineplus">+</span>
<a href="#l83.1569"></a><span id="l83.1569">             mork_size pending = yarn.mYarn_Fill + morkWriter_kYarnEscapeSlop + 1;</span>
<a href="#l83.1570"></a><span id="l83.1570">             this-&gt;IndentOverMaxLine(ev, pending, morkWriter_kDictAliasValueDepth);</span>
<a href="#l83.1571"></a><span id="l83.1571" class="difflineminus">-              </span>
<a href="#l83.1572"></a><span id="l83.1572" class="difflineplus">+</span>
<a href="#l83.1573"></a><span id="l83.1573">             stream-&gt;Putc(ev, '='); // start value</span>
<a href="#l83.1574"></a><span id="l83.1574">             ++mWriter_LineSize;</span>
<a href="#l83.1575"></a><span id="l83.1575" class="difflineminus">-      </span>
<a href="#l83.1576"></a><span id="l83.1576" class="difflineplus">+</span>
<a href="#l83.1577"></a><span id="l83.1577">             this-&gt;WriteYarn(ev, &amp;yarn);</span>
<a href="#l83.1578"></a><span id="l83.1578"> </span>
<a href="#l83.1579"></a><span id="l83.1579">             stream-&gt;Putc(ev, ')'); // end value</span>
<a href="#l83.1580"></a><span id="l83.1580">             ++mWriter_LineSize;</span>
<a href="#l83.1581"></a><span id="l83.1581">           }</span>
<a href="#l83.1582"></a><span id="l83.1582">           else</span>
<a href="#l83.1583"></a><span id="l83.1583">             atom-&gt;BadAtomKindError(ev);</span>
<a href="#l83.1584"></a><span id="l83.1584" class="difflineminus">-                      </span>
<a href="#l83.1585"></a><span id="l83.1585" class="difflineplus">+</span>
<a href="#l83.1586"></a><span id="l83.1586">           ++mWriter_DoneCount;</span>
<a href="#l83.1587"></a><span id="l83.1587">         }</span>
<a href="#l83.1588"></a><span id="l83.1588">       }</span>
<a href="#l83.1589"></a><span id="l83.1589">     }</span>
<a href="#l83.1590"></a><span id="l83.1590">   }</span>
<a href="#l83.1591"></a><span id="l83.1591">   return ev-&gt;Good();</span>
<a href="#l83.1592"></a><span id="l83.1592"> }</span>
<a href="#l83.1593"></a><span id="l83.1593"> </span>
<a href="#l83.1594"></a><span id="l83.1594" class="difflineat">@@ -1976,22 +1976,22 @@ morkWriter::PutVerboseRowCells(morkEnv* </span>
<a href="#l83.1595"></a><span id="l83.1595"> mork_bool</span>
<a href="#l83.1596"></a><span id="l83.1596"> morkWriter::PutCell(morkEnv* ev, morkCell* ioCell, mork_bool inWithVal)</span>
<a href="#l83.1597"></a><span id="l83.1597"> {</span>
<a href="#l83.1598"></a><span id="l83.1598">   morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1599"></a><span id="l83.1599">   char buf[ 128 ]; // buffer for staging hex ids</span>
<a href="#l83.1600"></a><span id="l83.1600">   char* idBuf = buf + 2; // where the id always starts</span>
<a href="#l83.1601"></a><span id="l83.1601">   buf[ 0 ] = '('; // we always start with open paren</span>
<a href="#l83.1602"></a><span id="l83.1602">   buf[ 1 ] = '^'; // column is always a hex ID</span>
<a href="#l83.1603"></a><span id="l83.1603" class="difflineminus">-  </span>
<a href="#l83.1604"></a><span id="l83.1604" class="difflineplus">+</span>
<a href="#l83.1605"></a><span id="l83.1605">   mork_size colSize = 0; // the size of col hex ID</span>
<a href="#l83.1606"></a><span id="l83.1606">   mork_size bytesWritten;</span>
<a href="#l83.1607"></a><span id="l83.1607" class="difflineminus">-  </span>
<a href="#l83.1608"></a><span id="l83.1608" class="difflineplus">+</span>
<a href="#l83.1609"></a><span id="l83.1609">   morkAtom* atom = (inWithVal)? ioCell-&gt;GetAtom() : (morkAtom*) 0;</span>
<a href="#l83.1610"></a><span id="l83.1610" class="difflineminus">-  </span>
<a href="#l83.1611"></a><span id="l83.1611" class="difflineplus">+</span>
<a href="#l83.1612"></a><span id="l83.1612">   mork_column col = ioCell-&gt;GetColumn();</span>
<a href="#l83.1613"></a><span id="l83.1613">   char* p = idBuf;</span>
<a href="#l83.1614"></a><span id="l83.1614">   colSize = ev-&gt;TokenAsHex(p, col);</span>
<a href="#l83.1615"></a><span id="l83.1615">   p += colSize;</span>
<a href="#l83.1616"></a><span id="l83.1616"> </span>
<a href="#l83.1617"></a><span id="l83.1617">   mdbYarn yarn; // to ref content inside atom</span>
<a href="#l83.1618"></a><span id="l83.1618">   morkAtom::AliasYarn(atom, &amp;yarn); // works even when atom==nil</span>
<a href="#l83.1619"></a><span id="l83.1619"> </span>
<a href="#l83.1620"></a><span id="l83.1620" class="difflineat">@@ -2004,17 +2004,17 @@ morkWriter::PutCell(morkEnv* ev, morkCel</span>
<a href="#l83.1621"></a><span id="l83.1621">     *p++ = '^';</span>
<a href="#l83.1622"></a><span id="l83.1622">     morkBookAtom* ba = (morkBookAtom*) atom;</span>
<a href="#l83.1623"></a><span id="l83.1623"> </span>
<a href="#l83.1624"></a><span id="l83.1624">     mork_size valSize = ev-&gt;TokenAsHex(p, ba-&gt;mBookAtom_Id);</span>
<a href="#l83.1625"></a><span id="l83.1625">     mork_fill yarnFill = yarn.mYarn_Fill;</span>
<a href="#l83.1626"></a><span id="l83.1626">     mork_bool putImmYarn = ( yarnFill &lt;= valSize );</span>
<a href="#l83.1627"></a><span id="l83.1627">     if ( putImmYarn )</span>
<a href="#l83.1628"></a><span id="l83.1628">       putImmYarn = this-&gt;IsYarnAllValue(&amp;yarn);</span>
<a href="#l83.1629"></a><span id="l83.1629" class="difflineminus">-    </span>
<a href="#l83.1630"></a><span id="l83.1630" class="difflineplus">+</span>
<a href="#l83.1631"></a><span id="l83.1631">     if ( putImmYarn ) // value no bigger than id?</span>
<a href="#l83.1632"></a><span id="l83.1632">     {</span>
<a href="#l83.1633"></a><span id="l83.1633">       p[ -1 ] = '='; // go back and clobber '^' with '=' instead</span>
<a href="#l83.1634"></a><span id="l83.1634">       if ( yarnFill )</span>
<a href="#l83.1635"></a><span id="l83.1635">       {</span>
<a href="#l83.1636"></a><span id="l83.1636">         MORK_MEMCPY(p, yarn.mYarn_Buf, yarnFill);</span>
<a href="#l83.1637"></a><span id="l83.1637">         p += yarnFill;</span>
<a href="#l83.1638"></a><span id="l83.1638">       }</span>
<a href="#l83.1639"></a><span id="l83.1639" class="difflineat">@@ -2046,17 +2046,17 @@ morkWriter::PutCell(morkEnv* ev, morkCel</span>
<a href="#l83.1640"></a><span id="l83.1640">     mork_size bytesWritten;</span>
<a href="#l83.1641"></a><span id="l83.1641">     stream-&gt;Write(ev-&gt;AsMdbEnv(), buf, colSize + 2, &amp;bytesWritten);</span>
<a href="#l83.1642"></a><span id="l83.1642">     mWriter_LineSize += bytesWritten;</span>
<a href="#l83.1643"></a><span id="l83.1643"> </span>
<a href="#l83.1644"></a><span id="l83.1644">     pending -= ( colSize + 2 );</span>
<a href="#l83.1645"></a><span id="l83.1645">     this-&gt;IndentOverMaxLine(ev, pending, morkWriter_kRowCellDepth);</span>
<a href="#l83.1646"></a><span id="l83.1646">     stream-&gt;Putc(ev, '=');</span>
<a href="#l83.1647"></a><span id="l83.1647">     ++mWriter_LineSize;</span>
<a href="#l83.1648"></a><span id="l83.1648" class="difflineminus">-    </span>
<a href="#l83.1649"></a><span id="l83.1649" class="difflineplus">+</span>
<a href="#l83.1650"></a><span id="l83.1650">     this-&gt;WriteYarn(ev, &amp;yarn);</span>
<a href="#l83.1651"></a><span id="l83.1651">     stream-&gt;Putc(ev, ')'); // end cell</span>
<a href="#l83.1652"></a><span id="l83.1652">     ++mWriter_LineSize;</span>
<a href="#l83.1653"></a><span id="l83.1653">   }</span>
<a href="#l83.1654"></a><span id="l83.1654">   return ev-&gt;Good();</span>
<a href="#l83.1655"></a><span id="l83.1655"> }</span>
<a href="#l83.1656"></a><span id="l83.1656"> </span>
<a href="#l83.1657"></a><span id="l83.1657"> mork_bool</span>
<a href="#l83.1658"></a><span id="l83.1658" class="difflineat">@@ -2085,100 +2085,100 @@ morkWriter::PutRow(morkEnv* ev, morkRow*</span>
<a href="#l83.1659"></a><span id="l83.1659">     mWriter_RowForm = mWriter_TableForm;</span>
<a href="#l83.1660"></a><span id="l83.1660"> </span>
<a href="#l83.1661"></a><span id="l83.1661">     mork_size bytesWritten;</span>
<a href="#l83.1662"></a><span id="l83.1662">     morkStream* stream = mWriter_Stream;</span>
<a href="#l83.1663"></a><span id="l83.1663">     char buf[ 128 + 16 ]; // buffer for staging hex</span>
<a href="#l83.1664"></a><span id="l83.1664">     char* p = buf;</span>
<a href="#l83.1665"></a><span id="l83.1665">     mdbOid* roid = &amp;ioRow-&gt;mRow_Oid;</span>
<a href="#l83.1666"></a><span id="l83.1666">     mork_size ridSize = 0;</span>
<a href="#l83.1667"></a><span id="l83.1667" class="difflineminus">-    </span>
<a href="#l83.1668"></a><span id="l83.1668" class="difflineplus">+</span>
<a href="#l83.1669"></a><span id="l83.1669">     mork_scope tableScope = mWriter_TableRowScope;</span>
<a href="#l83.1670"></a><span id="l83.1670"> </span>
<a href="#l83.1671"></a><span id="l83.1671">     if ( ioRow-&gt;IsRowDirty() )</span>
<a href="#l83.1672"></a><span id="l83.1672">     {</span>
<a href="#l83.1673"></a><span id="l83.1673">       if ( mWriter_SuppressDirtyRowNewline || !mWriter_LineSize )</span>
<a href="#l83.1674"></a><span id="l83.1674">         mWriter_SuppressDirtyRowNewline = morkBool_kFalse;</span>
<a href="#l83.1675"></a><span id="l83.1675">       else</span>
<a href="#l83.1676"></a><span id="l83.1676">       {</span>
<a href="#l83.1677"></a><span id="l83.1677">         if ( tableScope ) // in a table?</span>
<a href="#l83.1678"></a><span id="l83.1678">           mWriter_LineSize = stream-&gt;PutIndent(ev, morkWriter_kRowDepth);</span>
<a href="#l83.1679"></a><span id="l83.1679">         else</span>
<a href="#l83.1680"></a><span id="l83.1680">           mWriter_LineSize = stream-&gt;PutIndent(ev, 0); // no indent</span>
<a href="#l83.1681"></a><span id="l83.1681">       }</span>
<a href="#l83.1682"></a><span id="l83.1682" class="difflineminus">-      </span>
<a href="#l83.1683"></a><span id="l83.1683" class="difflineplus">+</span>
<a href="#l83.1684"></a><span id="l83.1684"> //      mork_rid rid = roid-&gt;mOid_Id;</span>
<a href="#l83.1685"></a><span id="l83.1685">       *p++ = '['; // start row punct=1</span>
<a href="#l83.1686"></a><span id="l83.1686">       mork_size punctSize = (mWriter_BeVerbose) ? 9 : 1; // counting &quot;[ /*r=*/ &quot;</span>
<a href="#l83.1687"></a><span id="l83.1687" class="difflineminus">-      </span>
<a href="#l83.1688"></a><span id="l83.1688" class="difflineplus">+</span>
<a href="#l83.1689"></a><span id="l83.1689">       mork_bool rowRewrite = ioRow-&gt;IsRowRewrite();</span>
<a href="#l83.1690"></a><span id="l83.1690" class="difflineminus">-            </span>
<a href="#l83.1691"></a><span id="l83.1691" class="difflineplus">+</span>
<a href="#l83.1692"></a><span id="l83.1692">       if ( rowRewrite &amp;&amp; mWriter_Incremental )</span>
<a href="#l83.1693"></a><span id="l83.1693">       {</span>
<a href="#l83.1694"></a><span id="l83.1694">         *p++ = '-';</span>
<a href="#l83.1695"></a><span id="l83.1695">         ++punctSize; // counting '-'</span>
<a href="#l83.1696"></a><span id="l83.1696">         ++mWriter_LineSize;</span>
<a href="#l83.1697"></a><span id="l83.1697">       }</span>
<a href="#l83.1698"></a><span id="l83.1698"> </span>
<a href="#l83.1699"></a><span id="l83.1699">       if ( tableScope &amp;&amp; roid-&gt;mOid_Scope == tableScope )</span>
<a href="#l83.1700"></a><span id="l83.1700">         ridSize = ev-&gt;TokenAsHex(p, roid-&gt;mOid_Id);</span>
<a href="#l83.1701"></a><span id="l83.1701">       else</span>
<a href="#l83.1702"></a><span id="l83.1702">         ridSize = ev-&gt;OidAsHex(p, *roid);</span>
<a href="#l83.1703"></a><span id="l83.1703" class="difflineminus">-      </span>
<a href="#l83.1704"></a><span id="l83.1704" class="difflineplus">+</span>
<a href="#l83.1705"></a><span id="l83.1705">       p += ridSize;</span>
<a href="#l83.1706"></a><span id="l83.1706" class="difflineminus">-      </span>
<a href="#l83.1707"></a><span id="l83.1707" class="difflineplus">+</span>
<a href="#l83.1708"></a><span id="l83.1708">       if (mWriter_BeVerbose)</span>
<a href="#l83.1709"></a><span id="l83.1709">       {</span>
<a href="#l83.1710"></a><span id="l83.1710">         *p++ = ' '; // punct=2</span>
<a href="#l83.1711"></a><span id="l83.1711">         *p++ = '/'; // punct=3</span>
<a href="#l83.1712"></a><span id="l83.1712">         *p++ = '*'; // punct=4</span>
<a href="#l83.1713"></a><span id="l83.1713">         *p++ = 'r'; // punct=5</span>
<a href="#l83.1714"></a><span id="l83.1714">         *p++ = '='; // punct=6</span>
<a href="#l83.1715"></a><span id="l83.1715"> </span>
<a href="#l83.1716"></a><span id="l83.1716">         mork_size usesSize = ev-&gt;TokenAsHex(p, (mork_token) ioRow-&gt;mRow_GcUses);</span>
<a href="#l83.1717"></a><span id="l83.1717">         punctSize += usesSize;</span>
<a href="#l83.1718"></a><span id="l83.1718">         p += usesSize;</span>
<a href="#l83.1719"></a><span id="l83.1719" class="difflineminus">-      </span>
<a href="#l83.1720"></a><span id="l83.1720" class="difflineplus">+</span>
<a href="#l83.1721"></a><span id="l83.1721">         *p++ = '*'; // punct=7</span>
<a href="#l83.1722"></a><span id="l83.1722">         *p++ = '/'; // punct=8</span>
<a href="#l83.1723"></a><span id="l83.1723">         *p++ = ' '; // punct=9</span>
<a href="#l83.1724"></a><span id="l83.1724">       }</span>
<a href="#l83.1725"></a><span id="l83.1725">       stream-&gt;Write(ev-&gt;AsMdbEnv(), buf, ridSize + punctSize, &amp;bytesWritten);</span>
<a href="#l83.1726"></a><span id="l83.1726">       mWriter_LineSize += bytesWritten;</span>
<a href="#l83.1727"></a><span id="l83.1727" class="difflineminus">-      </span>
<a href="#l83.1728"></a><span id="l83.1728" class="difflineplus">+</span>
<a href="#l83.1729"></a><span id="l83.1729">       // special case situation where row puts exactly one column:</span>
<a href="#l83.1730"></a><span id="l83.1730">       if ( !rowRewrite &amp;&amp; mWriter_Incremental &amp;&amp; ioRow-&gt;HasRowDelta() )</span>
<a href="#l83.1731"></a><span id="l83.1731">       {</span>
<a href="#l83.1732"></a><span id="l83.1732">         mork_column col = ioRow-&gt;GetDeltaColumn();</span>
<a href="#l83.1733"></a><span id="l83.1733">         morkCell dummy(col, morkChange_kNil, (morkAtom*) 0);</span>
<a href="#l83.1734"></a><span id="l83.1734">         morkCell* cell = 0;</span>
<a href="#l83.1735"></a><span id="l83.1735" class="difflineminus">-        </span>
<a href="#l83.1736"></a><span id="l83.1736" class="difflineplus">+</span>
<a href="#l83.1737"></a><span id="l83.1737">         mork_bool withVal = ( ioRow-&gt;GetDeltaChange() != morkChange_kCut );</span>
<a href="#l83.1738"></a><span id="l83.1738" class="difflineminus">-        </span>
<a href="#l83.1739"></a><span id="l83.1739" class="difflineplus">+</span>
<a href="#l83.1740"></a><span id="l83.1740">         if ( withVal )</span>
<a href="#l83.1741"></a><span id="l83.1741">         {</span>
<a href="#l83.1742"></a><span id="l83.1742">           mork_pos cellPos = 0; // dummy pos</span>
<a href="#l83.1743"></a><span id="l83.1743">           cell = ioRow-&gt;GetCell(ev, col, &amp;cellPos);</span>
<a href="#l83.1744"></a><span id="l83.1744">         }</span>
<a href="#l83.1745"></a><span id="l83.1745">         if ( !cell )</span>
<a href="#l83.1746"></a><span id="l83.1746">           cell = &amp;dummy;</span>
<a href="#l83.1747"></a><span id="l83.1747" class="difflineminus">-          </span>
<a href="#l83.1748"></a><span id="l83.1748" class="difflineplus">+</span>
<a href="#l83.1749"></a><span id="l83.1749">         if ( mWriter_BeVerbose )</span>
<a href="#l83.1750"></a><span id="l83.1750">           this-&gt;PutVerboseCell(ev, cell, withVal);</span>
<a href="#l83.1751"></a><span id="l83.1751">         else</span>
<a href="#l83.1752"></a><span id="l83.1752">           this-&gt;PutCell(ev, cell, withVal);</span>
<a href="#l83.1753"></a><span id="l83.1753">       }</span>
<a href="#l83.1754"></a><span id="l83.1754">       else // put entire row?</span>
<a href="#l83.1755"></a><span id="l83.1755">       {</span>
<a href="#l83.1756"></a><span id="l83.1756">         if ( mWriter_BeVerbose )</span>
<a href="#l83.1757"></a><span id="l83.1757">           this-&gt;PutVerboseRowCells(ev, ioRow); // write all, verbosely</span>
<a href="#l83.1758"></a><span id="l83.1758">         else</span>
<a href="#l83.1759"></a><span id="l83.1759">           this-&gt;PutRowCells(ev, ioRow); // write all, hex notation</span>
<a href="#l83.1760"></a><span id="l83.1760">       }</span>
<a href="#l83.1761"></a><span id="l83.1761" class="difflineminus">-        </span>
<a href="#l83.1762"></a><span id="l83.1762" class="difflineplus">+</span>
<a href="#l83.1763"></a><span id="l83.1763">       stream-&gt;Putc(ev, ']'); // end row</span>
<a href="#l83.1764"></a><span id="l83.1764">       ++mWriter_LineSize;</span>
<a href="#l83.1765"></a><span id="l83.1765">     }</span>
<a href="#l83.1766"></a><span id="l83.1766">     else</span>
<a href="#l83.1767"></a><span id="l83.1767">     {</span>
<a href="#l83.1768"></a><span id="l83.1768">       this-&gt;IndentAsNeeded(ev, morkWriter_kRowDepth);</span>
<a href="#l83.1769"></a><span id="l83.1769"> </span>
<a href="#l83.1770"></a><span id="l83.1770">       if ( tableScope &amp;&amp; roid-&gt;mOid_Scope == tableScope )</span>
<a href="#l83.1771"></a><span id="l83.1771" class="difflineat">@@ -2193,14 +2193,14 @@ morkWriter::PutRow(morkEnv* ev, morkRow*</span>
<a href="#l83.1772"></a><span id="l83.1772">     }</span>
<a href="#l83.1773"></a><span id="l83.1773"> </span>
<a href="#l83.1774"></a><span id="l83.1774">     ++mWriter_DoneCount;</span>
<a href="#l83.1775"></a><span id="l83.1775"> </span>
<a href="#l83.1776"></a><span id="l83.1776">     ioRow-&gt;SetRowClean(); // try to do this at the very last</span>
<a href="#l83.1777"></a><span id="l83.1777">   }</span>
<a href="#l83.1778"></a><span id="l83.1778">   else</span>
<a href="#l83.1779"></a><span id="l83.1779">     ioRow-&gt;NonRowTypeWarning(ev);</span>
<a href="#l83.1780"></a><span id="l83.1780" class="difflineminus">-  </span>
<a href="#l83.1781"></a><span id="l83.1781" class="difflineplus">+</span>
<a href="#l83.1782"></a><span id="l83.1782">   return ev-&gt;Good();</span>
<a href="#l83.1783"></a><span id="l83.1783"> }</span>
<a href="#l83.1784"></a><span id="l83.1784"> </span>
<a href="#l83.1785"></a><span id="l83.1785"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l83.1786"></a><span id="l83.1786"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l84.1"></a><span id="l84.1" class="difflineminus">--- a/db/mork/src/morkWriter.h</span>
<a href="#l84.2"></a><span id="l84.2" class="difflineplus">+++ b/db/mork/src/morkWriter.h</span>
<a href="#l84.3"></a><span id="l84.3" class="difflineat">@@ -40,17 +40,17 @@</span>
<a href="#l84.4"></a><span id="l84.4"> </span>
<a href="#l84.5"></a><span id="l84.5"> #ifndef _MORKSTREAM_</span>
<a href="#l84.6"></a><span id="l84.6"> #include &quot;morkStream.h&quot;</span>
<a href="#l84.7"></a><span id="l84.7"> #endif</span>
<a href="#l84.8"></a><span id="l84.8"> </span>
<a href="#l84.9"></a><span id="l84.9"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l84.10"></a><span id="l84.10"> </span>
<a href="#l84.11"></a><span id="l84.11"> </span>
<a href="#l84.12"></a><span id="l84.12" class="difflineminus">-#define morkWriter_kStreamBufSize /*i*/ (16 * 1024) /* buffer size for stream */ </span>
<a href="#l84.13"></a><span id="l84.13" class="difflineplus">+#define morkWriter_kStreamBufSize /*i*/ (16 * 1024) /* buffer size for stream */</span>
<a href="#l84.14"></a><span id="l84.14"> </span>
<a href="#l84.15"></a><span id="l84.15"> #define morkDerived_kWriter  /*i*/ 0x5772 /* ascii 'Wr' */</span>
<a href="#l84.16"></a><span id="l84.16"> </span>
<a href="#l84.17"></a><span id="l84.17"> #define morkWriter_kPhaseNothingDone          0 /* nothing has yet been done */</span>
<a href="#l84.18"></a><span id="l84.18"> #define morkWriter_kPhaseDirtyAllDone         1 /* DirtyAll() is done */</span>
<a href="#l84.19"></a><span id="l84.19"> #define morkWriter_kPhasePutHeaderDone        2 /* PutHeader() is done */</span>
<a href="#l84.20"></a><span id="l84.20"> </span>
<a href="#l84.21"></a><span id="l84.21"> #define morkWriter_kPhaseRenumberAllDone      3 /* RenumberAll() is done */</span>
<a href="#l84.22"></a><span id="l84.22" class="difflineat">@@ -115,75 +115,75 @@ public: // state is public because the e</span>
<a href="#l84.23"></a><span id="l84.23">   morkStore*   mWriter_Store;      // weak ref to committing store</span>
<a href="#l84.24"></a><span id="l84.24">   nsIMdbFile*  mWriter_File;       // strong ref to store's file</span>
<a href="#l84.25"></a><span id="l84.25">   nsIMdbFile*  mWriter_Bud;        // strong ref to bud of mWriter_File</span>
<a href="#l84.26"></a><span id="l84.26">   morkStream*  mWriter_Stream;     // strong ref to stream on bud file</span>
<a href="#l84.27"></a><span id="l84.27">   nsIMdbHeap*  mWriter_SlotHeap;   // strong ref to slot heap</span>
<a href="#l84.28"></a><span id="l84.28"> </span>
<a href="#l84.29"></a><span id="l84.29">   // GroupIdentity should be based on mStore_CommitGroupIdentity:</span>
<a href="#l84.30"></a><span id="l84.30">   mork_gid     mWriter_CommitGroupIdentity; // transaction ID number</span>
<a href="#l84.31"></a><span id="l84.31" class="difflineminus">-  </span>
<a href="#l84.32"></a><span id="l84.32" class="difflineplus">+</span>
<a href="#l84.33"></a><span id="l84.33">   // GroupBuf holds a hex version of mWriter_CommitGroupIdentity:</span>
<a href="#l84.34"></a><span id="l84.34">   char         mWriter_GroupBuf[ morkWriter_kGroupBufSize ];</span>
<a href="#l84.35"></a><span id="l84.35">   mork_fill    mWriter_GroupBufFill; // actual bytes in GroupBuf</span>
<a href="#l84.36"></a><span id="l84.36" class="difflineminus">-  </span>
<a href="#l84.37"></a><span id="l84.37" class="difflineplus">+</span>
<a href="#l84.38"></a><span id="l84.38">   mork_count   mWriter_TotalCount;  // count of all things to be written</span>
<a href="#l84.39"></a><span id="l84.39">   mork_count   mWriter_DoneCount;   // count of things already written</span>
<a href="#l84.40"></a><span id="l84.40" class="difflineminus">-  </span>
<a href="#l84.41"></a><span id="l84.41" class="difflineplus">+</span>
<a href="#l84.42"></a><span id="l84.42">   mork_size    mWriter_LineSize;  // length of current line being written</span>
<a href="#l84.43"></a><span id="l84.43">   mork_size    mWriter_MaxIndent; // line size forcing a line break</span>
<a href="#l84.44"></a><span id="l84.44">   mork_size    mWriter_MaxLine;   // line size forcing a value continuation</span>
<a href="#l84.45"></a><span id="l84.45" class="difflineminus">-  </span>
<a href="#l84.46"></a><span id="l84.46" class="difflineplus">+</span>
<a href="#l84.47"></a><span id="l84.47">   mork_cscode  mWriter_TableForm;     // current charset metainfo</span>
<a href="#l84.48"></a><span id="l84.48">   mork_scope   mWriter_TableAtomScope;   // current atom scope</span>
<a href="#l84.49"></a><span id="l84.49">   mork_scope   mWriter_TableRowScope;    // current row scope</span>
<a href="#l84.50"></a><span id="l84.50">   mork_kind    mWriter_TableKind;        // current table kind</span>
<a href="#l84.51"></a><span id="l84.51" class="difflineminus">-  </span>
<a href="#l84.52"></a><span id="l84.52" class="difflineplus">+</span>
<a href="#l84.53"></a><span id="l84.53">   mork_cscode  mWriter_RowForm;         // current charset metainfo</span>
<a href="#l84.54"></a><span id="l84.54">   mork_scope   mWriter_RowAtomScope;    // current atom scope</span>
<a href="#l84.55"></a><span id="l84.55">   mork_scope   mWriter_RowScope;        // current row scope</span>
<a href="#l84.56"></a><span id="l84.56" class="difflineminus">-  </span>
<a href="#l84.57"></a><span id="l84.57" class="difflineplus">+</span>
<a href="#l84.58"></a><span id="l84.58">   mork_cscode  mWriter_DictForm;      // current charset metainfo</span>
<a href="#l84.59"></a><span id="l84.59">   mork_scope   mWriter_DictAtomScope;    // current atom scope</span>
<a href="#l84.60"></a><span id="l84.60" class="difflineminus">- </span>
<a href="#l84.61"></a><span id="l84.61" class="difflineplus">+</span>
<a href="#l84.62"></a><span id="l84.62">   mork_bool    mWriter_NeedDirtyAll;  // need to call DirtyAll()</span>
<a href="#l84.63"></a><span id="l84.63">   mork_bool    mWriter_Incremental;   // opposite of mWriter_NeedDirtyAll</span>
<a href="#l84.64"></a><span id="l84.64">   mork_bool    mWriter_DidStartDict;  // true when a dict has been started</span>
<a href="#l84.65"></a><span id="l84.65">   mork_bool    mWriter_DidEndDict;    // true when a dict has been ended</span>
<a href="#l84.66"></a><span id="l84.66"> </span>
<a href="#l84.67"></a><span id="l84.67">   mork_bool    mWriter_SuppressDirtyRowNewline; // for table meta rows</span>
<a href="#l84.68"></a><span id="l84.68">   mork_bool    mWriter_DidStartGroup; // true when a group has been started</span>
<a href="#l84.69"></a><span id="l84.69">   mork_bool    mWriter_DidEndGroup;    // true when a group has been ended</span>
<a href="#l84.70"></a><span id="l84.70">   mork_u1      mWriter_Phase;         // status of writing process</span>
<a href="#l84.71"></a><span id="l84.71"> </span>
<a href="#l84.72"></a><span id="l84.72">   mork_bool    mWriter_BeVerbose; // driven by env and table verbose settings:</span>
<a href="#l84.73"></a><span id="l84.73">   // mWriter_BeVerbose equals ( ev-&gt;mEnv_BeVerbose || table-&gt;IsTableVerbose() )</span>
<a href="#l84.74"></a><span id="l84.74" class="difflineminus">-  </span>
<a href="#l84.75"></a><span id="l84.75" class="difflineplus">+</span>
<a href="#l84.76"></a><span id="l84.76">   mork_u1      mWriter_Pad[ 3 ];  // for u4 alignment</span>
<a href="#l84.77"></a><span id="l84.77"> </span>
<a href="#l84.78"></a><span id="l84.78">   mork_pos     mWriter_TableRowArrayPos;  // index into mTable_RowArray</span>
<a href="#l84.79"></a><span id="l84.79" class="difflineminus">-   </span>
<a href="#l84.80"></a><span id="l84.80" class="difflineplus">+</span>
<a href="#l84.81"></a><span id="l84.81">   char         mWriter_SafeNameBuf[ (morkWriter_kMaxColumnNameSize * 2) + 4 ];</span>
<a href="#l84.82"></a><span id="l84.82">   // Note: extra four bytes in ColNameBuf means we can always append to yarn</span>
<a href="#l84.83"></a><span id="l84.83"> </span>
<a href="#l84.84"></a><span id="l84.84">   char         mWriter_ColNameBuf[ morkWriter_kMaxColumnNameSize + 4 ];</span>
<a href="#l84.85"></a><span id="l84.85">   // Note: extra four bytes in ColNameBuf means we can always append to yarn</span>
<a href="#l84.86"></a><span id="l84.86" class="difflineminus">-  </span>
<a href="#l84.87"></a><span id="l84.87" class="difflineplus">+</span>
<a href="#l84.88"></a><span id="l84.88">   mdbYarn      mWriter_ColYarn; // a yarn to describe space in ColNameBuf:</span>
<a href="#l84.89"></a><span id="l84.89">   // mYarn_Buf == mWriter_ColNameBuf, mYarn_Size == morkWriter_kMaxColumnNameSize</span>
<a href="#l84.90"></a><span id="l84.90" class="difflineminus">-  </span>
<a href="#l84.91"></a><span id="l84.91" class="difflineplus">+</span>
<a href="#l84.92"></a><span id="l84.92">   mdbYarn      mWriter_SafeYarn; // a yarn to describe space in ColNameBuf:</span>
<a href="#l84.93"></a><span id="l84.93">   // mYarn_Buf == mWriter_SafeNameBuf, mYarn_Size == (kMaxColumnNameSize * 2)</span>
<a href="#l84.94"></a><span id="l84.94"> </span>
<a href="#l84.95"></a><span id="l84.95">   morkAtomSpaceMapIter  mWriter_StoreAtomSpacesIter;   // for mStore_AtomSpaces</span>
<a href="#l84.96"></a><span id="l84.96">   morkAtomAidMapIter  mWriter_AtomSpaceAtomAidsIter; // for AtomSpace_AtomAids</span>
<a href="#l84.97"></a><span id="l84.97" class="difflineminus">-  </span>
<a href="#l84.98"></a><span id="l84.98" class="difflineplus">+</span>
<a href="#l84.99"></a><span id="l84.99">   morkRowSpaceMapIter  mWriter_StoreRowSpacesIter;    // for mStore_RowSpaces</span>
<a href="#l84.100"></a><span id="l84.100">   morkTableMapIter  mWriter_RowSpaceTablesIter;    // for mRowSpace_Tables</span>
<a href="#l84.101"></a><span id="l84.101" class="difflineminus">-  </span>
<a href="#l84.102"></a><span id="l84.102" class="difflineplus">+</span>
<a href="#l84.103"></a><span id="l84.103"> #ifdef MORK_ENABLE_PROBE_MAPS</span>
<a href="#l84.104"></a><span id="l84.104">   morkRowProbeMapIter  mWriter_RowSpaceRowsIter; // for mRowSpace_Rows</span>
<a href="#l84.105"></a><span id="l84.105"> #else /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l84.106"></a><span id="l84.106">   morkRowMapIter  mWriter_RowSpaceRowsIter;      // for mRowSpace_Rows</span>
<a href="#l84.107"></a><span id="l84.107"> #endif /*MORK_ENABLE_PROBE_MAPS*/</span>
<a href="#l84.108"></a><span id="l84.108"> </span>
<a href="#l84.109"></a><span id="l84.109"> // { ===== begin morkNode interface =====</span>
<a href="#l84.110"></a><span id="l84.110"> public: // morkNode virtual methods</span>
<a href="#l84.111"></a><span id="l84.111" class="difflineat">@@ -216,51 +216,51 @@ public: // typing &amp; errors</span>
<a href="#l84.112"></a><span id="l84.112"> public: // utitlities</span>
<a href="#l84.113"></a><span id="l84.113">   void ChangeRowForm(morkEnv* ev, mork_cscode inNewForm);</span>
<a href="#l84.114"></a><span id="l84.114">   void ChangeDictForm(morkEnv* ev, mork_cscode inNewForm);</span>
<a href="#l84.115"></a><span id="l84.115">   void ChangeDictAtomScope(morkEnv* ev, mork_scope inScope);</span>
<a href="#l84.116"></a><span id="l84.116"> </span>
<a href="#l84.117"></a><span id="l84.117"> public: // inlines</span>
<a href="#l84.118"></a><span id="l84.118">   mork_bool DidStartDict() const { return mWriter_DidStartDict; }</span>
<a href="#l84.119"></a><span id="l84.119">   mork_bool DidEndDict() const { return mWriter_DidEndDict; }</span>
<a href="#l84.120"></a><span id="l84.120" class="difflineminus">-  </span>
<a href="#l84.121"></a><span id="l84.121" class="difflineplus">+</span>
<a href="#l84.122"></a><span id="l84.122">   void IndentAsNeeded(morkEnv* ev, mork_size inDepth)</span>
<a href="#l84.123"></a><span id="l84.123" class="difflineminus">-  { </span>
<a href="#l84.124"></a><span id="l84.124" class="difflineplus">+  {</span>
<a href="#l84.125"></a><span id="l84.125">     if ( mWriter_LineSize &gt; mWriter_MaxIndent )</span>
<a href="#l84.126"></a><span id="l84.126">       mWriter_LineSize = mWriter_Stream-&gt;PutIndent(ev, inDepth);</span>
<a href="#l84.127"></a><span id="l84.127">   }</span>
<a href="#l84.128"></a><span id="l84.128" class="difflineminus">-  </span>
<a href="#l84.129"></a><span id="l84.129" class="difflineplus">+</span>
<a href="#l84.130"></a><span id="l84.130">   void IndentOverMaxLine(morkEnv* ev,</span>
<a href="#l84.131"></a><span id="l84.131">     mork_size inPendingSize, mork_size inDepth)</span>
<a href="#l84.132"></a><span id="l84.132" class="difflineminus">-  { </span>
<a href="#l84.133"></a><span id="l84.133" class="difflineplus">+  {</span>
<a href="#l84.134"></a><span id="l84.134">     if ( mWriter_LineSize + inPendingSize &gt; mWriter_MaxLine )</span>
<a href="#l84.135"></a><span id="l84.135">       mWriter_LineSize = mWriter_Stream-&gt;PutIndent(ev, inDepth);</span>
<a href="#l84.136"></a><span id="l84.136">   }</span>
<a href="#l84.137"></a><span id="l84.137"> </span>
<a href="#l84.138"></a><span id="l84.138"> public: // delayed construction</span>
<a href="#l84.139"></a><span id="l84.139"> </span>
<a href="#l84.140"></a><span id="l84.140">   void MakeWriterStream(morkEnv* ev); // give writer a suitable stream</span>
<a href="#l84.141"></a><span id="l84.141"> </span>
<a href="#l84.142"></a><span id="l84.142"> public: // iterative/asynchronous writing</span>
<a href="#l84.143"></a><span id="l84.143" class="difflineminus">-  </span>
<a href="#l84.144"></a><span id="l84.144" class="difflineplus">+</span>
<a href="#l84.145"></a><span id="l84.145">   mork_bool WriteMore(morkEnv* ev); // call until IsWritingDone() is true</span>
<a href="#l84.146"></a><span id="l84.146" class="difflineminus">-  </span>
<a href="#l84.147"></a><span id="l84.147" class="difflineplus">+</span>
<a href="#l84.148"></a><span id="l84.148">   mork_bool IsWritingDone() const // don't call WriteMore() any longer?</span>
<a href="#l84.149"></a><span id="l84.149">   { return mWriter_Phase == morkWriter_kPhaseWritingDone; }</span>
<a href="#l84.150"></a><span id="l84.150"> </span>
<a href="#l84.151"></a><span id="l84.151"> public: // marking all content dirty</span>
<a href="#l84.152"></a><span id="l84.152">   mork_bool DirtyAll(morkEnv* ev);</span>
<a href="#l84.153"></a><span id="l84.153" class="difflineminus">-  // DirtyAll() visits every store sub-object and marks </span>
<a href="#l84.154"></a><span id="l84.154" class="difflineplus">+  // DirtyAll() visits every store sub-object and marks</span>
<a href="#l84.155"></a><span id="l84.155">   // them dirty, including every table, row, cell, and atom.  The return</span>
<a href="#l84.156"></a><span id="l84.156">   // equals ev-&gt;Good(), to show whether any error happened.  This method is</span>
<a href="#l84.157"></a><span id="l84.157">   // intended for use in the beginning of a &quot;compress commit&quot; which writes</span>
<a href="#l84.158"></a><span id="l84.158">   // all store content, whether dirty or not.  We dirty everything first so</span>
<a href="#l84.159"></a><span id="l84.159">   // that later iterations over content can mark things clean as they are</span>
<a href="#l84.160"></a><span id="l84.160">   // written, and organize the process of serialization so that objects are</span>
<a href="#l84.161"></a><span id="l84.161" class="difflineminus">-  // written only at need (because of being dirty).  Note the method can </span>
<a href="#l84.162"></a><span id="l84.162" class="difflineplus">+  // written only at need (because of being dirty).  Note the method can</span>
<a href="#l84.163"></a><span id="l84.163">   // stop early when any error happens, since this will abort any commit.</span>
<a href="#l84.164"></a><span id="l84.164"> </span>
<a href="#l84.165"></a><span id="l84.165"> public: // group commit transactions</span>
<a href="#l84.166"></a><span id="l84.166"> </span>
<a href="#l84.167"></a><span id="l84.167">   mork_bool StartGroup(morkEnv* ev);</span>
<a href="#l84.168"></a><span id="l84.168">   mork_bool CommitGroup(morkEnv* ev);</span>
<a href="#l84.169"></a><span id="l84.169">   mork_bool AbortGroup(morkEnv* ev);</span>
<a href="#l84.170"></a><span id="l84.170"> </span>
<a href="#l84.171"></a><span id="l84.171" class="difflineat">@@ -288,20 +288,20 @@ public: // writing dict items first pass</span>
<a href="#l84.172"></a><span id="l84.172">   mork_bool PutTableDict(morkEnv* ev, morkTable* ioTable);</span>
<a href="#l84.173"></a><span id="l84.173">   mork_bool PutRowDict(morkEnv* ev, morkRow* ioRow);</span>
<a href="#l84.174"></a><span id="l84.174"> </span>
<a href="#l84.175"></a><span id="l84.175"> public: // writing node content second pass</span>
<a href="#l84.176"></a><span id="l84.176">   mork_bool PutTable(morkEnv* ev, morkTable* ioTable);</span>
<a href="#l84.177"></a><span id="l84.177">   mork_bool PutRow(morkEnv* ev, morkRow* ioRow);</span>
<a href="#l84.178"></a><span id="l84.178">   mork_bool PutRowCells(morkEnv* ev, morkRow* ioRow);</span>
<a href="#l84.179"></a><span id="l84.179">   mork_bool PutVerboseRowCells(morkEnv* ev, morkRow* ioRow);</span>
<a href="#l84.180"></a><span id="l84.180" class="difflineminus">-  </span>
<a href="#l84.181"></a><span id="l84.181" class="difflineplus">+</span>
<a href="#l84.182"></a><span id="l84.182">   mork_bool PutCell(morkEnv* ev, morkCell* ioCell, mork_bool inWithVal);</span>
<a href="#l84.183"></a><span id="l84.183">   mork_bool PutVerboseCell(morkEnv* ev, morkCell* ioCell, mork_bool inWithVal);</span>
<a href="#l84.184"></a><span id="l84.184" class="difflineminus">-  </span>
<a href="#l84.185"></a><span id="l84.185" class="difflineplus">+</span>
<a href="#l84.186"></a><span id="l84.186">   mork_bool PutTableChange(morkEnv* ev, const morkTableChange* inChange);</span>
<a href="#l84.187"></a><span id="l84.187"> </span>
<a href="#l84.188"></a><span id="l84.188"> public: // other writer methods</span>
<a href="#l84.189"></a><span id="l84.189"> </span>
<a href="#l84.190"></a><span id="l84.190">   mork_bool IsYarnAllValue(const mdbYarn* inYarn);</span>
<a href="#l84.191"></a><span id="l84.191"> </span>
<a href="#l84.192"></a><span id="l84.192">   mork_size WriteYarn(morkEnv* ev, const mdbYarn* inYarn);</span>
<a href="#l84.193"></a><span id="l84.193">   // return number of atom bytes written on the current line (which</span>
<a href="#l84.194"></a><span id="l84.194" class="difflineat">@@ -310,34 +310,34 @@ public: // other writer methods</span>
<a href="#l84.195"></a><span id="l84.195"> </span>
<a href="#l84.196"></a><span id="l84.196">   mork_size WriteAtom(morkEnv* ev, const morkAtom* inAtom);</span>
<a href="#l84.197"></a><span id="l84.197">   // return number of atom bytes written on the current line (which</span>
<a href="#l84.198"></a><span id="l84.198">   // implies that escaped line breaks will make the size value smaller</span>
<a href="#l84.199"></a><span id="l84.199">   // than the entire atom's size, since only part goes on a last line).</span>
<a href="#l84.200"></a><span id="l84.200"> </span>
<a href="#l84.201"></a><span id="l84.201">   void WriteAllStoreTables(morkEnv* ev);</span>
<a href="#l84.202"></a><span id="l84.202">   void WriteAtomSpaceAsDict(morkEnv* ev, morkAtomSpace* ioSpace);</span>
<a href="#l84.203"></a><span id="l84.203" class="difflineminus">-  </span>
<a href="#l84.204"></a><span id="l84.204" class="difflineplus">+</span>
<a href="#l84.205"></a><span id="l84.205">   void WriteTokenToTokenMetaCell(morkEnv* ev, mork_token inCol,</span>
<a href="#l84.206"></a><span id="l84.206">     mork_token inValue);</span>
<a href="#l84.207"></a><span id="l84.207" class="difflineminus">-  void WriteStringToTokenDictCell(morkEnv* ev, const char* inCol, </span>
<a href="#l84.208"></a><span id="l84.208" class="difflineplus">+  void WriteStringToTokenDictCell(morkEnv* ev, const char* inCol,</span>
<a href="#l84.209"></a><span id="l84.209">     mork_token inValue);</span>
<a href="#l84.210"></a><span id="l84.210">   // Note inCol should begin with '(' and end with '=', with col in between.</span>
<a href="#l84.211"></a><span id="l84.211"> </span>
<a href="#l84.212"></a><span id="l84.212">   void StartDict(morkEnv* ev);</span>
<a href="#l84.213"></a><span id="l84.213">   void EndDict(morkEnv* ev);</span>
<a href="#l84.214"></a><span id="l84.214"> </span>
<a href="#l84.215"></a><span id="l84.215">   void StartTable(morkEnv* ev, morkTable* ioTable);</span>
<a href="#l84.216"></a><span id="l84.216">   void EndTable(morkEnv* ev);</span>
<a href="#l84.217"></a><span id="l84.217"> </span>
<a href="#l84.218"></a><span id="l84.218"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l84.219"></a><span id="l84.219">   static void SlotWeakWriter(morkWriter* me,</span>
<a href="#l84.220"></a><span id="l84.220">     morkEnv* ev, morkWriter** ioSlot)</span>
<a href="#l84.221"></a><span id="l84.221">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l84.222"></a><span id="l84.222" class="difflineminus">-  </span>
<a href="#l84.223"></a><span id="l84.223" class="difflineplus">+</span>
<a href="#l84.224"></a><span id="l84.224">   static void SlotStrongWriter(morkWriter* me,</span>
<a href="#l84.225"></a><span id="l84.225">     morkEnv* ev, morkWriter** ioSlot)</span>
<a href="#l84.226"></a><span id="l84.226">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l84.227"></a><span id="l84.227"> };</span>
<a href="#l84.228"></a><span id="l84.228"> </span>
<a href="#l84.229"></a><span id="l84.229"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l84.230"></a><span id="l84.230"> </span>
<a href="#l84.231"></a><span id="l84.231"> #endif /* _MORKTABLEROWCURSOR_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l85.1"></a><span id="l85.1" class="difflineminus">--- a/db/mork/src/morkYarn.cpp</span>
<a href="#l85.2"></a><span id="l85.2" class="difflineplus">+++ b/db/mork/src/morkYarn.cpp</span>
<a href="#l85.3"></a><span id="l85.3" class="difflineat">@@ -20,17 +20,17 @@</span>
<a href="#l85.4"></a><span id="l85.4"> #endif</span>
<a href="#l85.5"></a><span id="l85.5"> </span>
<a href="#l85.6"></a><span id="l85.6"> #ifndef _MORKYARN_</span>
<a href="#l85.7"></a><span id="l85.7"> #include &quot;morkYarn.h&quot;</span>
<a href="#l85.8"></a><span id="l85.8"> #endif</span>
<a href="#l85.9"></a><span id="l85.9"> </span>
<a href="#l85.10"></a><span id="l85.10"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l85.11"></a><span id="l85.11"> </span>
<a href="#l85.12"></a><span id="l85.12" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l85.13"></a><span id="l85.13" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l85.14"></a><span id="l85.14"> // { ===== begin morkNode interface =====</span>
<a href="#l85.15"></a><span id="l85.15"> </span>
<a href="#l85.16"></a><span id="l85.16"> /*public virtual*/ void</span>
<a href="#l85.17"></a><span id="l85.17"> morkYarn::CloseMorkNode(morkEnv* ev) /*i*/ // CloseYarn() only if open</span>
<a href="#l85.18"></a><span id="l85.18"> {</span>
<a href="#l85.19"></a><span id="l85.19">   if ( this-&gt;IsOpenNode() )</span>
<a href="#l85.20"></a><span id="l85.20">   {</span>
<a href="#l85.21"></a><span id="l85.21">     this-&gt;MarkClosing();</span>
<a href="#l85.22"></a><span id="l85.22" class="difflineat">@@ -59,17 +59,17 @@ morkYarn::CloseYarn(morkEnv* ev) /*i*/ /</span>
<a href="#l85.23"></a><span id="l85.23"> {</span>
<a href="#l85.24"></a><span id="l85.24">     if ( this-&gt;IsNode() )</span>
<a href="#l85.25"></a><span id="l85.25">       this-&gt;MarkShut();</span>
<a href="#l85.26"></a><span id="l85.26">     else</span>
<a href="#l85.27"></a><span id="l85.27">       this-&gt;NonNodeError(ev);</span>
<a href="#l85.28"></a><span id="l85.28"> }</span>
<a href="#l85.29"></a><span id="l85.29"> </span>
<a href="#l85.30"></a><span id="l85.30"> // } ===== end morkNode methods =====</span>
<a href="#l85.31"></a><span id="l85.31" class="difflineminus">-// ````` ````` ````` ````` ````` </span>
<a href="#l85.32"></a><span id="l85.32" class="difflineplus">+// ````` ````` ````` ````` `````</span>
<a href="#l85.33"></a><span id="l85.33"> </span>
<a href="#l85.34"></a><span id="l85.34"> /*static*/ void</span>
<a href="#l85.35"></a><span id="l85.35"> morkYarn::NonYarnTypeError(morkEnv* ev)</span>
<a href="#l85.36"></a><span id="l85.36"> {</span>
<a href="#l85.37"></a><span id="l85.37">   ev-&gt;NewError(&quot;non morkYarn&quot;);</span>
<a href="#l85.38"></a><span id="l85.38"> }</span>
<a href="#l85.39"></a><span id="l85.39"> </span>
<a href="#l85.40"></a><span id="l85.40"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l86.1"></a><span id="l86.1" class="difflineminus">--- a/db/mork/src/morkYarn.h</span>
<a href="#l86.2"></a><span id="l86.2" class="difflineplus">+++ b/db/mork/src/morkYarn.h</span>
<a href="#l86.3"></a><span id="l86.3" class="difflineat">@@ -16,28 +16,28 @@</span>
<a href="#l86.4"></a><span id="l86.4"> #define morkDerived_kYarn     /*i*/ 0x7952 /* ascii 'yR' */</span>
<a href="#l86.5"></a><span id="l86.5"> </span>
<a href="#l86.6"></a><span id="l86.6"> /*| morkYarn: a reference counted nsIMdbYarn C struct.  This is for use in those</span>
<a href="#l86.7"></a><span id="l86.7"> **| few cases where single instances of reference counted buffers are needed</span>
<a href="#l86.8"></a><span id="l86.8"> **| in Mork, and we expect few enough instances that overhead is not a factor</span>
<a href="#l86.9"></a><span id="l86.9"> **| in decided whether to use such a thing.</span>
<a href="#l86.10"></a><span id="l86.10"> |*/</span>
<a href="#l86.11"></a><span id="l86.11"> class morkYarn : public morkNode { // refcounted yarn</span>
<a href="#l86.12"></a><span id="l86.12" class="difflineminus">-  </span>
<a href="#l86.13"></a><span id="l86.13" class="difflineplus">+</span>
<a href="#l86.14"></a><span id="l86.14"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l86.15"></a><span id="l86.15">   // nsIMdbHeap*       mNode_Heap;</span>
<a href="#l86.16"></a><span id="l86.16"> </span>
<a href="#l86.17"></a><span id="l86.17">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l86.18"></a><span id="l86.18">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l86.19"></a><span id="l86.19" class="difflineminus">-  </span>
<a href="#l86.20"></a><span id="l86.20" class="difflineplus">+</span>
<a href="#l86.21"></a><span id="l86.21">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l86.22"></a><span id="l86.22">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l86.23"></a><span id="l86.23">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l86.24"></a><span id="l86.24">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l86.25"></a><span id="l86.25" class="difflineminus">-  </span>
<a href="#l86.26"></a><span id="l86.26" class="difflineplus">+</span>
<a href="#l86.27"></a><span id="l86.27">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l86.28"></a><span id="l86.28">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l86.29"></a><span id="l86.29"> </span>
<a href="#l86.30"></a><span id="l86.30"> public: // state is public because the entire Mork system is private</span>
<a href="#l86.31"></a><span id="l86.31">   mdbYarn  mYarn_Body;</span>
<a href="#l86.32"></a><span id="l86.32"> </span>
<a href="#l86.33"></a><span id="l86.33"> // { ===== begin morkNode interface =====</span>
<a href="#l86.34"></a><span id="l86.34"> public: // morkNode virtual methods</span>
<a href="#l86.35"></a><span id="l86.35" class="difflineat">@@ -59,17 +59,17 @@ public: // dynamic type identification</span>
<a href="#l86.36"></a><span id="l86.36"> </span>
<a href="#l86.37"></a><span id="l86.37"> public: // typing</span>
<a href="#l86.38"></a><span id="l86.38">   static void NonYarnTypeError(morkEnv* ev);</span>
<a href="#l86.39"></a><span id="l86.39"> </span>
<a href="#l86.40"></a><span id="l86.40"> public: // typesafe refcounting inlines calling inherited morkNode methods</span>
<a href="#l86.41"></a><span id="l86.41">   static void SlotWeakYarn(morkYarn* me,</span>
<a href="#l86.42"></a><span id="l86.42">     morkEnv* ev, morkYarn** ioSlot)</span>
<a href="#l86.43"></a><span id="l86.43">   { morkNode::SlotWeakNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l86.44"></a><span id="l86.44" class="difflineminus">-  </span>
<a href="#l86.45"></a><span id="l86.45" class="difflineplus">+</span>
<a href="#l86.46"></a><span id="l86.46">   static void SlotStrongYarn(morkYarn* me,</span>
<a href="#l86.47"></a><span id="l86.47">     morkEnv* ev, morkYarn** ioSlot)</span>
<a href="#l86.48"></a><span id="l86.48">   { morkNode::SlotStrongNode((morkNode*) me, ev, (morkNode**) ioSlot); }</span>
<a href="#l86.49"></a><span id="l86.49"> };</span>
<a href="#l86.50"></a><span id="l86.50"> </span>
<a href="#l86.51"></a><span id="l86.51"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l86.52"></a><span id="l86.52"> </span>
<a href="#l86.53"></a><span id="l86.53"> #endif /* _MORKYARN_ */</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l87.1"></a><span id="l87.1" class="difflineminus">--- a/db/mork/src/morkZone.cpp</span>
<a href="#l87.2"></a><span id="l87.2" class="difflineplus">+++ b/db/mork/src/morkZone.cpp</span>
<a href="#l87.3"></a><span id="l87.3" class="difflineat">@@ -46,37 +46,37 @@ morkZone::~morkZone() // assert that Clo</span>
<a href="#l87.4"></a><span id="l87.4"> morkZone::morkZone(morkEnv* ev, const morkUsage&amp; inUsage,</span>
<a href="#l87.5"></a><span id="l87.5">   nsIMdbHeap* ioNodeHeap, nsIMdbHeap* ioZoneHeap)</span>
<a href="#l87.6"></a><span id="l87.6"> : morkNode(ev, inUsage, ioNodeHeap)</span>
<a href="#l87.7"></a><span id="l87.7"> , mZone_Heap( 0 )</span>
<a href="#l87.8"></a><span id="l87.8"> , mZone_HeapVolume( 0 )</span>
<a href="#l87.9"></a><span id="l87.9"> , mZone_BlockVolume( 0 )</span>
<a href="#l87.10"></a><span id="l87.10"> , mZone_RunVolume( 0 )</span>
<a href="#l87.11"></a><span id="l87.11"> , mZone_ChipVolume( 0 )</span>
<a href="#l87.12"></a><span id="l87.12" class="difflineminus">-  </span>
<a href="#l87.13"></a><span id="l87.13" class="difflineplus">+</span>
<a href="#l87.14"></a><span id="l87.14"> , mZone_FreeOldRunVolume( 0 )</span>
<a href="#l87.15"></a><span id="l87.15" class="difflineminus">-  </span>
<a href="#l87.16"></a><span id="l87.16" class="difflineplus">+</span>
<a href="#l87.17"></a><span id="l87.17"> , mZone_HunkCount( 0 )</span>
<a href="#l87.18"></a><span id="l87.18"> , mZone_FreeOldRunCount( 0 )</span>
<a href="#l87.19"></a><span id="l87.19"> </span>
<a href="#l87.20"></a><span id="l87.20"> , mZone_HunkList( 0 )</span>
<a href="#l87.21"></a><span id="l87.21"> , mZone_FreeOldRunList( 0 )</span>
<a href="#l87.22"></a><span id="l87.22" class="difflineminus">-  </span>
<a href="#l87.23"></a><span id="l87.23" class="difflineplus">+</span>
<a href="#l87.24"></a><span id="l87.24"> , mZone_At( 0 )</span>
<a href="#l87.25"></a><span id="l87.25"> , mZone_AtSize( 0 )</span>
<a href="#l87.26"></a><span id="l87.26" class="difflineminus">-    </span>
<a href="#l87.27"></a><span id="l87.27" class="difflineplus">+</span>
<a href="#l87.28"></a><span id="l87.28">   // morkRun*     mZone_FreeRuns[ morkZone_kBuckets + 1 ];</span>
<a href="#l87.29"></a><span id="l87.29"> {</span>
<a href="#l87.30"></a><span id="l87.30"> </span>
<a href="#l87.31"></a><span id="l87.31">   morkRun** runs = mZone_FreeRuns;</span>
<a href="#l87.32"></a><span id="l87.32">   morkRun** end = runs + (morkZone_kBuckets + 1); // one past last slot</span>
<a href="#l87.33"></a><span id="l87.33">   --runs; // prepare for preincrement</span>
<a href="#l87.34"></a><span id="l87.34">   while ( ++runs &lt; end ) // another slot in array?</span>
<a href="#l87.35"></a><span id="l87.35">     *runs = 0; // clear all the slots</span>
<a href="#l87.36"></a><span id="l87.36" class="difflineminus">-  </span>
<a href="#l87.37"></a><span id="l87.37" class="difflineplus">+</span>
<a href="#l87.38"></a><span id="l87.38">   if ( ev-&gt;Good() )</span>
<a href="#l87.39"></a><span id="l87.39">   {</span>
<a href="#l87.40"></a><span id="l87.40">     if ( ioZoneHeap )</span>
<a href="#l87.41"></a><span id="l87.41">     {</span>
<a href="#l87.42"></a><span id="l87.42">       nsIMdbHeap_SlotStrongHeap(ioZoneHeap, ev, &amp;mZone_Heap);</span>
<a href="#l87.43"></a><span id="l87.43">       if ( ev-&gt;Good() )</span>
<a href="#l87.44"></a><span id="l87.44">         mNode_Derived = morkDerived_kZone;</span>
<a href="#l87.45"></a><span id="l87.45">     }</span>
<a href="#l87.46"></a><span id="l87.46" class="difflineat">@@ -89,17 +89,17 @@ void morkZone::CloseZone(morkEnv* ev) //</span>
<a href="#l87.47"></a><span id="l87.47"> {</span>
<a href="#l87.48"></a><span id="l87.48">     if ( this-&gt;IsNode() )</span>
<a href="#l87.49"></a><span id="l87.49">     {</span>
<a href="#l87.50"></a><span id="l87.50">       nsIMdbHeap* heap = mZone_Heap;</span>
<a href="#l87.51"></a><span id="l87.51">       if ( heap )</span>
<a href="#l87.52"></a><span id="l87.52">       {</span>
<a href="#l87.53"></a><span id="l87.53">         morkHunk* hunk = 0;</span>
<a href="#l87.54"></a><span id="l87.54">         nsIMdbEnv* mev = ev-&gt;AsMdbEnv();</span>
<a href="#l87.55"></a><span id="l87.55" class="difflineminus">-        </span>
<a href="#l87.56"></a><span id="l87.56" class="difflineplus">+</span>
<a href="#l87.57"></a><span id="l87.57">         morkHunk* next = mZone_HunkList;</span>
<a href="#l87.58"></a><span id="l87.58">         while ( ( hunk = next ) != 0 )</span>
<a href="#l87.59"></a><span id="l87.59">         {</span>
<a href="#l87.60"></a><span id="l87.60"> #ifdef morkHunk_USE_TAG_SLOT</span>
<a href="#l87.61"></a><span id="l87.61">           if ( !hunk-&gt;HunkGoodTag()  )</span>
<a href="#l87.62"></a><span id="l87.62">             hunk-&gt;BadHunkTagWarning(ev);</span>
<a href="#l87.63"></a><span id="l87.63"> #endif /* morkHunk_USE_TAG_SLOT */</span>
<a href="#l87.64"></a><span id="l87.64"> </span>
<a href="#l87.65"></a><span id="l87.65" class="difflineat">@@ -148,23 +148,23 @@ morkRun::RunSizeAlignError(morkEnv* ev)</span>
<a href="#l87.66"></a><span id="l87.66"> </span>
<a href="#l87.67"></a><span id="l87.67"> // { ===== begin morkZone methods =====</span>
<a href="#l87.68"></a><span id="l87.68"> </span>
<a href="#l87.69"></a><span id="l87.69"> </span>
<a href="#l87.70"></a><span id="l87.70"> mork_size morkZone::zone_grow_at(morkEnv* ev, mork_size inNeededSize)</span>
<a href="#l87.71"></a><span id="l87.71"> {</span>
<a href="#l87.72"></a><span id="l87.72">   mZone_At = 0;       // remove any ref to current hunk</span>
<a href="#l87.73"></a><span id="l87.73">   mZone_AtSize = 0;   // zero available bytes in current hunk</span>
<a href="#l87.74"></a><span id="l87.74" class="difflineminus">-  </span>
<a href="#l87.75"></a><span id="l87.75" class="difflineplus">+</span>
<a href="#l87.76"></a><span id="l87.76">   mork_size runSize = 0; // actual size of a particular run</span>
<a href="#l87.77"></a><span id="l87.77" class="difflineminus">-  </span>
<a href="#l87.78"></a><span id="l87.78" class="difflineplus">+</span>
<a href="#l87.79"></a><span id="l87.79">   // try to find a run in old run list with at least inNeededSize bytes:</span>
<a href="#l87.80"></a><span id="l87.80">   morkRun* run = mZone_FreeOldRunList; // cursor in list scan</span>
<a href="#l87.81"></a><span id="l87.81">   morkRun* prev = 0; // the node before run in the list scan</span>
<a href="#l87.82"></a><span id="l87.82" class="difflineminus">- </span>
<a href="#l87.83"></a><span id="l87.83" class="difflineplus">+</span>
<a href="#l87.84"></a><span id="l87.84">   while ( run ) // another run in list to check?</span>
<a href="#l87.85"></a><span id="l87.85">   {</span>
<a href="#l87.86"></a><span id="l87.86">     morkOldRun* oldRun = (morkOldRun*) run;</span>
<a href="#l87.87"></a><span id="l87.87">     mork_size oldSize = oldRun-&gt;OldSize();</span>
<a href="#l87.88"></a><span id="l87.88">     if ( oldSize &gt;= inNeededSize ) // found one big enough?</span>
<a href="#l87.89"></a><span id="l87.89">     {</span>
<a href="#l87.90"></a><span id="l87.90">       runSize = oldSize;</span>
<a href="#l87.91"></a><span id="l87.91">       break; // end while loop early</span>
<a href="#l87.92"></a><span id="l87.92" class="difflineat">@@ -174,17 +174,17 @@ mork_size morkZone::zone_grow_at(morkEnv</span>
<a href="#l87.93"></a><span id="l87.93">   }</span>
<a href="#l87.94"></a><span id="l87.94">   if ( runSize &amp;&amp; run ) // found a usable old run?</span>
<a href="#l87.95"></a><span id="l87.95">   {</span>
<a href="#l87.96"></a><span id="l87.96">     morkRun* next = run-&gt;RunNext();</span>
<a href="#l87.97"></a><span id="l87.97">     if ( prev ) // another node in free list precedes run?</span>
<a href="#l87.98"></a><span id="l87.98">       prev-&gt;RunSetNext(next); // unlink run</span>
<a href="#l87.99"></a><span id="l87.99">     else</span>
<a href="#l87.100"></a><span id="l87.100">       mZone_FreeOldRunList = next; // unlink run from head of list</span>
<a href="#l87.101"></a><span id="l87.101" class="difflineminus">-      </span>
<a href="#l87.102"></a><span id="l87.102" class="difflineplus">+</span>
<a href="#l87.103"></a><span id="l87.103">     morkOldRun *oldRun = (morkOldRun *) run;</span>
<a href="#l87.104"></a><span id="l87.104">     oldRun-&gt;OldSetSize(runSize);</span>
<a href="#l87.105"></a><span id="l87.105">     mZone_At = (mork_u1*) run;</span>
<a href="#l87.106"></a><span id="l87.106">     mZone_AtSize = runSize;</span>
<a href="#l87.107"></a><span id="l87.107"> </span>
<a href="#l87.108"></a><span id="l87.108"> #ifdef morkZone_CONFIG_DEBUG</span>
<a href="#l87.109"></a><span id="l87.109"> #ifdef morkZone_CONFIG_ALIGN_8</span>
<a href="#l87.110"></a><span id="l87.110">     mork_ip lowThree = ((mork_ip) mZone_At) &amp; 7;</span>
<a href="#l87.111"></a><span id="l87.111" class="difflineat">@@ -196,112 +196,112 @@ mork_size morkZone::zone_grow_at(morkEnv</span>
<a href="#l87.112"></a><span id="l87.112">       ev-&gt;NewWarning(&quot;mZone_At not aligned&quot;);</span>
<a href="#l87.113"></a><span id="l87.113"> #endif /*morkZone_CONFIG_DEBUG*/</span>
<a href="#l87.114"></a><span id="l87.114">   }</span>
<a href="#l87.115"></a><span id="l87.115">   else // need to allocate a brand new run</span>
<a href="#l87.116"></a><span id="l87.116">   {</span>
<a href="#l87.117"></a><span id="l87.117">     inNeededSize += 7; // allow for possible alignment padding</span>
<a href="#l87.118"></a><span id="l87.118">     mork_size newSize = ( inNeededSize &gt; morkZone_kNewHunkSize )?</span>
<a href="#l87.119"></a><span id="l87.119">       inNeededSize : morkZone_kNewHunkSize;</span>
<a href="#l87.120"></a><span id="l87.120" class="difflineminus">-      </span>
<a href="#l87.121"></a><span id="l87.121" class="difflineplus">+</span>
<a href="#l87.122"></a><span id="l87.122">     morkHunk* hunk = this-&gt;zone_new_hunk(ev, newSize);</span>
<a href="#l87.123"></a><span id="l87.123">     if ( hunk )</span>
<a href="#l87.124"></a><span id="l87.124">     {</span>
<a href="#l87.125"></a><span id="l87.125">       morkRun* hunkRun = hunk-&gt;HunkRun();</span>
<a href="#l87.126"></a><span id="l87.126">       mork_u1* at = (mork_u1*) hunkRun-&gt;RunAsBlock();</span>
<a href="#l87.127"></a><span id="l87.127">       mork_ip lowBits = ((mork_ip) at) &amp; 7;</span>
<a href="#l87.128"></a><span id="l87.128">       if ( lowBits ) // not 8 byte aligned?</span>
<a href="#l87.129"></a><span id="l87.129">       {</span>
<a href="#l87.130"></a><span id="l87.130">         mork_ip skip = (8 - lowBits); // skip the complement to align</span>
<a href="#l87.131"></a><span id="l87.131">         at += skip;</span>
<a href="#l87.132"></a><span id="l87.132">         newSize -= skip;</span>
<a href="#l87.133"></a><span id="l87.133">       }</span>
<a href="#l87.134"></a><span id="l87.134">       mZone_At = at;</span>
<a href="#l87.135"></a><span id="l87.135">       mZone_AtSize = newSize;</span>
<a href="#l87.136"></a><span id="l87.136">     }</span>
<a href="#l87.137"></a><span id="l87.137">   }</span>
<a href="#l87.138"></a><span id="l87.138" class="difflineminus">-  </span>
<a href="#l87.139"></a><span id="l87.139" class="difflineplus">+</span>
<a href="#l87.140"></a><span id="l87.140">   return mZone_AtSize;</span>
<a href="#l87.141"></a><span id="l87.141"> }</span>
<a href="#l87.142"></a><span id="l87.142"> </span>
<a href="#l87.143"></a><span id="l87.143" class="difflineminus">-morkHunk* morkZone::zone_new_hunk(morkEnv* ev, mdb_size inSize) // alloc  </span>
<a href="#l87.144"></a><span id="l87.144" class="difflineplus">+morkHunk* morkZone::zone_new_hunk(morkEnv* ev, mdb_size inSize) // alloc</span>
<a href="#l87.145"></a><span id="l87.145"> {</span>
<a href="#l87.146"></a><span id="l87.146">   mdb_size hunkSize = inSize + sizeof(morkHunk);</span>
<a href="#l87.147"></a><span id="l87.147">   void* outBlock = 0; // we are going straight to the heap:</span>
<a href="#l87.148"></a><span id="l87.148">   mZone_Heap-&gt;Alloc(ev-&gt;AsMdbEnv(), hunkSize, &amp;outBlock);</span>
<a href="#l87.149"></a><span id="l87.149">   if ( outBlock )</span>
<a href="#l87.150"></a><span id="l87.150">   {</span>
<a href="#l87.151"></a><span id="l87.151"> #ifdef morkZone_CONFIG_VOL_STATS</span>
<a href="#l87.152"></a><span id="l87.152">     mZone_HeapVolume += hunkSize; // track all heap allocations</span>
<a href="#l87.153"></a><span id="l87.153"> #endif /* morkZone_CONFIG_VOL_STATS */</span>
<a href="#l87.154"></a><span id="l87.154" class="difflineminus">-  </span>
<a href="#l87.155"></a><span id="l87.155" class="difflineplus">+</span>
<a href="#l87.156"></a><span id="l87.156">     morkHunk* hunk = (morkHunk*) outBlock;</span>
<a href="#l87.157"></a><span id="l87.157"> #ifdef morkHunk_USE_TAG_SLOT</span>
<a href="#l87.158"></a><span id="l87.158">     hunk-&gt;HunkInitTag();</span>
<a href="#l87.159"></a><span id="l87.159"> #endif /* morkHunk_USE_TAG_SLOT */</span>
<a href="#l87.160"></a><span id="l87.160" class="difflineminus">-  </span>
<a href="#l87.161"></a><span id="l87.161" class="difflineplus">+</span>
<a href="#l87.162"></a><span id="l87.162">     hunk-&gt;HunkSetNext(mZone_HunkList);</span>
<a href="#l87.163"></a><span id="l87.163">     mZone_HunkList = hunk;</span>
<a href="#l87.164"></a><span id="l87.164">     ++mZone_HunkCount;</span>
<a href="#l87.165"></a><span id="l87.165" class="difflineminus">-    </span>
<a href="#l87.166"></a><span id="l87.166" class="difflineplus">+</span>
<a href="#l87.167"></a><span id="l87.167">     morkRun* run = hunk-&gt;HunkRun();</span>
<a href="#l87.168"></a><span id="l87.168">     run-&gt;RunSetSize(inSize);</span>
<a href="#l87.169"></a><span id="l87.169"> #ifdef morkRun_USE_TAG_SLOT</span>
<a href="#l87.170"></a><span id="l87.170">     run-&gt;RunInitTag();</span>
<a href="#l87.171"></a><span id="l87.171"> #endif /* morkRun_USE_TAG_SLOT */</span>
<a href="#l87.172"></a><span id="l87.172" class="difflineminus">-    </span>
<a href="#l87.173"></a><span id="l87.173" class="difflineplus">+</span>
<a href="#l87.174"></a><span id="l87.174">     return hunk;</span>
<a href="#l87.175"></a><span id="l87.175">   }</span>
<a href="#l87.176"></a><span id="l87.176">   if ( ev-&gt;Good() ) // got this far without any error reported yet?</span>
<a href="#l87.177"></a><span id="l87.177">     ev-&gt;OutOfMemoryError();</span>
<a href="#l87.178"></a><span id="l87.178">   return (morkHunk*) 0;</span>
<a href="#l87.179"></a><span id="l87.179"> }</span>
<a href="#l87.180"></a><span id="l87.180"> </span>
<a href="#l87.181"></a><span id="l87.181" class="difflineminus">-void* morkZone::zone_new_chip(morkEnv* ev, mdb_size inSize) // alloc  </span>
<a href="#l87.182"></a><span id="l87.182" class="difflineplus">+void* morkZone::zone_new_chip(morkEnv* ev, mdb_size inSize) // alloc</span>
<a href="#l87.183"></a><span id="l87.183"> {</span>
<a href="#l87.184"></a><span id="l87.184"> #ifdef morkZone_CONFIG_VOL_STATS</span>
<a href="#l87.185"></a><span id="l87.185">   mZone_BlockVolume += inSize; // sum sizes of both chips and runs</span>
<a href="#l87.186"></a><span id="l87.186"> #endif /* morkZone_CONFIG_VOL_STATS */</span>
<a href="#l87.187"></a><span id="l87.187" class="difflineminus">-  </span>
<a href="#l87.188"></a><span id="l87.188" class="difflineplus">+</span>
<a href="#l87.189"></a><span id="l87.189">   mork_u1* at = mZone_At;</span>
<a href="#l87.190"></a><span id="l87.190">   mork_size atSize = mZone_AtSize; // available bytes in current hunk</span>
<a href="#l87.191"></a><span id="l87.191">   if ( atSize &gt;= inSize ) // current hunk can satisfy request?</span>
<a href="#l87.192"></a><span id="l87.192">   {</span>
<a href="#l87.193"></a><span id="l87.193">     mZone_At = at + inSize;</span>
<a href="#l87.194"></a><span id="l87.194">     mZone_AtSize = atSize - inSize;</span>
<a href="#l87.195"></a><span id="l87.195">     return at;</span>
<a href="#l87.196"></a><span id="l87.196">   }</span>
<a href="#l87.197"></a><span id="l87.197">   else if ( atSize &gt; morkZone_kMaxHunkWaste ) // over max waste allowed?</span>
<a href="#l87.198"></a><span id="l87.198">   {</span>
<a href="#l87.199"></a><span id="l87.199">     morkHunk* hunk = this-&gt;zone_new_hunk(ev, inSize);</span>
<a href="#l87.200"></a><span id="l87.200">     if ( hunk )</span>
<a href="#l87.201"></a><span id="l87.201">       return hunk-&gt;HunkRun();</span>
<a href="#l87.202"></a><span id="l87.202" class="difflineminus">-      </span>
<a href="#l87.203"></a><span id="l87.203" class="difflineplus">+</span>
<a href="#l87.204"></a><span id="l87.204">     return (void*) 0; // show allocation has failed</span>
<a href="#l87.205"></a><span id="l87.205">   }</span>
<a href="#l87.206"></a><span id="l87.206">   else // get ourselves a new hunk for suballocation:</span>
<a href="#l87.207"></a><span id="l87.207">   {</span>
<a href="#l87.208"></a><span id="l87.208">     atSize = this-&gt;zone_grow_at(ev, inSize); // get a new hunk</span>
<a href="#l87.209"></a><span id="l87.209">   }</span>
<a href="#l87.210"></a><span id="l87.210"> </span>
<a href="#l87.211"></a><span id="l87.211">   if ( atSize &gt;= inSize ) // current hunk can satisfy request?</span>
<a href="#l87.212"></a><span id="l87.212">   {</span>
<a href="#l87.213"></a><span id="l87.213">     at = mZone_At;</span>
<a href="#l87.214"></a><span id="l87.214">     mZone_At = at + inSize;</span>
<a href="#l87.215"></a><span id="l87.215">     mZone_AtSize = atSize - inSize;</span>
<a href="#l87.216"></a><span id="l87.216">     return at;</span>
<a href="#l87.217"></a><span id="l87.217">   }</span>
<a href="#l87.218"></a><span id="l87.218" class="difflineminus">-  </span>
<a href="#l87.219"></a><span id="l87.219" class="difflineplus">+</span>
<a href="#l87.220"></a><span id="l87.220">   if ( ev-&gt;Good() ) // got this far without any error reported yet?</span>
<a href="#l87.221"></a><span id="l87.221">     ev-&gt;OutOfMemoryError();</span>
<a href="#l87.222"></a><span id="l87.222" class="difflineminus">-    </span>
<a href="#l87.223"></a><span id="l87.223" class="difflineplus">+</span>
<a href="#l87.224"></a><span id="l87.224">   return (void*) 0; // show allocation has failed</span>
<a href="#l87.225"></a><span id="l87.225"> }</span>
<a href="#l87.226"></a><span id="l87.226"> </span>
<a href="#l87.227"></a><span id="l87.227" class="difflineminus">-void* morkZone::ZoneNewChip(morkEnv* ev, mdb_size inSize) // alloc  </span>
<a href="#l87.228"></a><span id="l87.228" class="difflineplus">+void* morkZone::ZoneNewChip(morkEnv* ev, mdb_size inSize) // alloc</span>
<a href="#l87.229"></a><span id="l87.229"> {</span>
<a href="#l87.230"></a><span id="l87.230"> #ifdef morkZone_CONFIG_ARENA</span>
<a href="#l87.231"></a><span id="l87.231"> </span>
<a href="#l87.232"></a><span id="l87.232"> #ifdef morkZone_CONFIG_DEBUG</span>
<a href="#l87.233"></a><span id="l87.233">   if ( !this-&gt;IsZone() )</span>
<a href="#l87.234"></a><span id="l87.234">     this-&gt;NonZoneTypeError(ev);</span>
<a href="#l87.235"></a><span id="l87.235">   else if ( !mZone_Heap )</span>
<a href="#l87.236"></a><span id="l87.236">     this-&gt;NilZoneHeapError(ev);</span>
<a href="#l87.237"></a><span id="l87.237" class="difflineat">@@ -321,21 +321,21 @@ void* morkZone::ZoneNewChip(morkEnv* ev,</span>
<a href="#l87.238"></a><span id="l87.238"> </span>
<a href="#l87.239"></a><span id="l87.239">   return this-&gt;zone_new_chip(ev, inSize);</span>
<a href="#l87.240"></a><span id="l87.240"> </span>
<a href="#l87.241"></a><span id="l87.241"> #else /*morkZone_CONFIG_ARENA*/</span>
<a href="#l87.242"></a><span id="l87.242">   void* outBlock = 0;</span>
<a href="#l87.243"></a><span id="l87.243">   mZone_Heap-&gt;Alloc(ev-&gt;AsMdbEnv(), inSize, &amp;outBlock);</span>
<a href="#l87.244"></a><span id="l87.244">   return outBlock;</span>
<a href="#l87.245"></a><span id="l87.245"> #endif /*morkZone_CONFIG_ARENA*/</span>
<a href="#l87.246"></a><span id="l87.246" class="difflineminus">-  </span>
<a href="#l87.247"></a><span id="l87.247" class="difflineplus">+</span>
<a href="#l87.248"></a><span id="l87.248"> }</span>
<a href="#l87.249"></a><span id="l87.249" class="difflineminus">-  </span>
<a href="#l87.250"></a><span id="l87.250" class="difflineplus">+</span>
<a href="#l87.251"></a><span id="l87.251"> // public: // ...but runs do indeed know how big they are</span>
<a href="#l87.252"></a><span id="l87.252" class="difflineminus">-void* morkZone::ZoneNewRun(morkEnv* ev, mdb_size inSize) // alloc  </span>
<a href="#l87.253"></a><span id="l87.253" class="difflineplus">+void* morkZone::ZoneNewRun(morkEnv* ev, mdb_size inSize) // alloc</span>
<a href="#l87.254"></a><span id="l87.254"> {</span>
<a href="#l87.255"></a><span id="l87.255"> #ifdef morkZone_CONFIG_ARENA</span>
<a href="#l87.256"></a><span id="l87.256"> </span>
<a href="#l87.257"></a><span id="l87.257"> #ifdef morkZone_CONFIG_DEBUG</span>
<a href="#l87.258"></a><span id="l87.258">   if ( !this-&gt;IsZone() )</span>
<a href="#l87.259"></a><span id="l87.259">     this-&gt;NonZoneTypeError(ev);</span>
<a href="#l87.260"></a><span id="l87.260">   else if ( !mZone_Heap )</span>
<a href="#l87.261"></a><span id="l87.261">     this-&gt;NilZoneHeapError(ev);</span>
<a href="#l87.262"></a><span id="l87.262" class="difflineat">@@ -362,20 +362,20 @@ void* morkZone::ZoneNewRun(morkEnv* ev, </span>
<a href="#l87.263"></a><span id="l87.263">   if ( run )</span>
<a href="#l87.264"></a><span id="l87.264">   {</span>
<a href="#l87.265"></a><span id="l87.265">     run-&gt;RunSetSize(inSize);</span>
<a href="#l87.266"></a><span id="l87.266"> #ifdef morkRun_USE_TAG_SLOT</span>
<a href="#l87.267"></a><span id="l87.267">     run-&gt;RunInitTag();</span>
<a href="#l87.268"></a><span id="l87.268"> #endif /* morkRun_USE_TAG_SLOT */</span>
<a href="#l87.269"></a><span id="l87.269">     return run-&gt;RunAsBlock();</span>
<a href="#l87.270"></a><span id="l87.270">   }</span>
<a href="#l87.271"></a><span id="l87.271" class="difflineminus">-  </span>
<a href="#l87.272"></a><span id="l87.272" class="difflineplus">+</span>
<a href="#l87.273"></a><span id="l87.273">   if ( ev-&gt;Good() ) // got this far without any error reported yet?</span>
<a href="#l87.274"></a><span id="l87.274">     ev-&gt;OutOfMemoryError();</span>
<a href="#l87.275"></a><span id="l87.275" class="difflineminus">-  </span>
<a href="#l87.276"></a><span id="l87.276" class="difflineplus">+</span>
<a href="#l87.277"></a><span id="l87.277">   return (void*) 0; // indicate failed allocation</span>
<a href="#l87.278"></a><span id="l87.278"> </span>
<a href="#l87.279"></a><span id="l87.279"> #else /*morkZone_CONFIG_ARENA*/</span>
<a href="#l87.280"></a><span id="l87.280">   void* outBlock = 0;</span>
<a href="#l87.281"></a><span id="l87.281">   mZone_Heap-&gt;Alloc(ev-&gt;AsMdbEnv(), inSize, &amp;outBlock);</span>
<a href="#l87.282"></a><span id="l87.282">   return outBlock;</span>
<a href="#l87.283"></a><span id="l87.283"> #endif /*morkZone_CONFIG_ARENA*/</span>
<a href="#l87.284"></a><span id="l87.284"> }</span>
<a href="#l87.285"></a><span id="l87.285" class="difflineat">@@ -453,60 +453,60 @@ void* morkZone::ZoneGrowRun(morkEnv* ev,</span>
<a href="#l87.286"></a><span id="l87.286"> </span>
<a href="#l87.287"></a><span id="l87.287">   if ( inSize &gt; runSize )</span>
<a href="#l87.288"></a><span id="l87.288">   {</span>
<a href="#l87.289"></a><span id="l87.289">     void* newBuf = this-&gt;ZoneNewRun(ev, inSize);</span>
<a href="#l87.290"></a><span id="l87.290">     if ( newBuf )</span>
<a href="#l87.291"></a><span id="l87.291">     {</span>
<a href="#l87.292"></a><span id="l87.292">       MORK_MEMCPY(newBuf, ioRunBlock, runSize);</span>
<a href="#l87.293"></a><span id="l87.293">       this-&gt;ZoneZapRun(ev, ioRunBlock);</span>
<a href="#l87.294"></a><span id="l87.294" class="difflineminus">-      </span>
<a href="#l87.295"></a><span id="l87.295" class="difflineplus">+</span>
<a href="#l87.296"></a><span id="l87.296">       return newBuf;</span>
<a href="#l87.297"></a><span id="l87.297">     }</span>
<a href="#l87.298"></a><span id="l87.298">   }</span>
<a href="#l87.299"></a><span id="l87.299">   else</span>
<a href="#l87.300"></a><span id="l87.300">     return ioRunBlock; // old size is big enough</span>
<a href="#l87.301"></a><span id="l87.301" class="difflineminus">-  </span>
<a href="#l87.302"></a><span id="l87.302" class="difflineplus">+</span>
<a href="#l87.303"></a><span id="l87.303">   if ( ev-&gt;Good() ) // got this far without any error reported yet?</span>
<a href="#l87.304"></a><span id="l87.304">     ev-&gt;OutOfMemoryError();</span>
<a href="#l87.305"></a><span id="l87.305" class="difflineminus">-  </span>
<a href="#l87.306"></a><span id="l87.306" class="difflineplus">+</span>
<a href="#l87.307"></a><span id="l87.307">   return (void*) 0; // indicate failed allocation</span>
<a href="#l87.308"></a><span id="l87.308"> </span>
<a href="#l87.309"></a><span id="l87.309"> #else /*morkZone_CONFIG_ARENA*/</span>
<a href="#l87.310"></a><span id="l87.310">   void* outBlock = 0;</span>
<a href="#l87.311"></a><span id="l87.311">   mZone_Heap-&gt;Free(ev-&gt;AsMdbEnv(), ioRunBlock);</span>
<a href="#l87.312"></a><span id="l87.312">   return outBlock;</span>
<a href="#l87.313"></a><span id="l87.313"> #endif /*morkZone_CONFIG_ARENA*/</span>
<a href="#l87.314"></a><span id="l87.314"> }</span>
<a href="#l87.315"></a><span id="l87.315"> </span>
<a href="#l87.316"></a><span id="l87.316"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l87.317"></a><span id="l87.317"> </span>
<a href="#l87.318"></a><span id="l87.318"> // { ===== begin nsIMdbHeap methods =====</span>
<a href="#l87.319"></a><span id="l87.319"> /*virtual*/ nsresult</span>
<a href="#l87.320"></a><span id="l87.320"> morkZone::Alloc(nsIMdbEnv* mev, // allocate a piece of memory</span>
<a href="#l87.321"></a><span id="l87.321" class="difflineminus">-  mdb_size inSize,   // requested size of new memory block </span>
<a href="#l87.322"></a><span id="l87.322" class="difflineplus">+  mdb_size inSize,   // requested size of new memory block</span>
<a href="#l87.323"></a><span id="l87.323">   void** outBlock)  // memory block of inSize bytes, or nil</span>
<a href="#l87.324"></a><span id="l87.324"> {</span>
<a href="#l87.325"></a><span id="l87.325">   nsresult outErr = NS_OK;</span>
<a href="#l87.326"></a><span id="l87.326">   void* block = 0;</span>
<a href="#l87.327"></a><span id="l87.327">   morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l87.328"></a><span id="l87.328">   if ( ev )</span>
<a href="#l87.329"></a><span id="l87.329">   {</span>
<a href="#l87.330"></a><span id="l87.330">     block = this-&gt;ZoneNewRun(ev, inSize);</span>
<a href="#l87.331"></a><span id="l87.331">     outErr = ev-&gt;AsErr();</span>
<a href="#l87.332"></a><span id="l87.332">   }</span>
<a href="#l87.333"></a><span id="l87.333">   else</span>
<a href="#l87.334"></a><span id="l87.334">     outErr = morkEnv_kOutOfMemoryError;</span>
<a href="#l87.335"></a><span id="l87.335"> </span>
<a href="#l87.336"></a><span id="l87.336">   if ( outBlock )</span>
<a href="#l87.337"></a><span id="l87.337">     *outBlock = block;</span>
<a href="#l87.338"></a><span id="l87.338" class="difflineminus">-    </span>
<a href="#l87.339"></a><span id="l87.339" class="difflineplus">+</span>
<a href="#l87.340"></a><span id="l87.340">   return outErr;</span>
<a href="#l87.341"></a><span id="l87.341"> }</span>
<a href="#l87.342"></a><span id="l87.342" class="difflineminus">-  </span>
<a href="#l87.343"></a><span id="l87.343" class="difflineplus">+</span>
<a href="#l87.344"></a><span id="l87.344"> /*virtual*/ nsresult</span>
<a href="#l87.345"></a><span id="l87.345"> morkZone::Free(nsIMdbEnv* mev, // free block allocated earlier by Alloc()</span>
<a href="#l87.346"></a><span id="l87.346">   void* inBlock)</span>
<a href="#l87.347"></a><span id="l87.347"> {</span>
<a href="#l87.348"></a><span id="l87.348">   nsresult outErr = NS_OK;</span>
<a href="#l87.349"></a><span id="l87.349">   if ( inBlock )</span>
<a href="#l87.350"></a><span id="l87.350">   {</span>
<a href="#l87.351"></a><span id="l87.351">     morkEnv* ev = morkEnv::FromMdbEnv(mev);</span>
<a href="#l87.352"></a><span id="l87.352" class="difflineat">@@ -514,14 +514,14 @@ morkZone::Free(nsIMdbEnv* mev, // free b</span>
<a href="#l87.353"></a><span id="l87.353">     {</span>
<a href="#l87.354"></a><span id="l87.354">       this-&gt;ZoneZapRun(ev, inBlock);</span>
<a href="#l87.355"></a><span id="l87.355">       outErr = ev-&gt;AsErr();</span>
<a href="#l87.356"></a><span id="l87.356">     }</span>
<a href="#l87.357"></a><span id="l87.357">     else</span>
<a href="#l87.358"></a><span id="l87.358">       // XXX 1 is not a valid nsresult</span>
<a href="#l87.359"></a><span id="l87.359">       outErr = static_cast&lt;nsresult&gt;(1);</span>
<a href="#l87.360"></a><span id="l87.360">   }</span>
<a href="#l87.361"></a><span id="l87.361" class="difflineminus">-    </span>
<a href="#l87.362"></a><span id="l87.362" class="difflineplus">+</span>
<a href="#l87.363"></a><span id="l87.363">   return outErr;</span>
<a href="#l87.364"></a><span id="l87.364"> }</span>
<a href="#l87.365"></a><span id="l87.365"> </span>
<a href="#l87.366"></a><span id="l87.366"> // } ===== end nsIMdbHeap methods =====</span>
<a href="#l87.367"></a><span id="l87.367"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l88.1"></a><span id="l88.1" class="difflineminus">--- a/db/mork/src/morkZone.h</span>
<a href="#l88.2"></a><span id="l88.2" class="difflineplus">+++ b/db/mork/src/morkZone.h</span>
<a href="#l88.3"></a><span id="l88.3" class="difflineat">@@ -69,35 +69,35 @@</span>
<a href="#l88.4"></a><span id="l88.4"> class morkRun {</span>
<a href="#l88.5"></a><span id="l88.5"> </span>
<a href="#l88.6"></a><span id="l88.6"> protected: // member variable slots</span>
<a href="#l88.7"></a><span id="l88.7"> #ifdef morkRun_USE_TAG_SLOT</span>
<a href="#l88.8"></a><span id="l88.8">   mork_u4   mRun_Tag; // force 8 byte alignment after mRun_Next</span>
<a href="#l88.9"></a><span id="l88.9"> #endif /* morkRun_USE_TAG_SLOT */</span>
<a href="#l88.10"></a><span id="l88.10"> </span>
<a href="#l88.11"></a><span id="l88.11">   morkRun*  mRun_Next;</span>
<a href="#l88.12"></a><span id="l88.12" class="difflineminus">-  </span>
<a href="#l88.13"></a><span id="l88.13" class="difflineplus">+</span>
<a href="#l88.14"></a><span id="l88.14"> public: // pointer interpretation of mRun_Next (when inside a list):</span>
<a href="#l88.15"></a><span id="l88.15">   morkRun*   RunNext() const { return mRun_Next; }</span>
<a href="#l88.16"></a><span id="l88.16">   void       RunSetNext(morkRun* ioNext) { mRun_Next = ioNext; }</span>
<a href="#l88.17"></a><span id="l88.17" class="difflineminus">-  </span>
<a href="#l88.18"></a><span id="l88.18" class="difflineplus">+</span>
<a href="#l88.19"></a><span id="l88.19"> public: // size interpretation of mRun_Next (when not inside a list):</span>
<a href="#l88.20"></a><span id="l88.20">   mork_size  RunSize() const { return (mork_size) ((mork_ip) mRun_Next); }</span>
<a href="#l88.21"></a><span id="l88.21">   void       RunSetSize(mork_size inSize)</span>
<a href="#l88.22"></a><span id="l88.22">              { mRun_Next = (morkRun*) ((mork_ip) inSize); }</span>
<a href="#l88.23"></a><span id="l88.23" class="difflineminus">-  </span>
<a href="#l88.24"></a><span id="l88.24" class="difflineplus">+</span>
<a href="#l88.25"></a><span id="l88.25"> public: // maintenance and testing of optional tag magic signature slot:</span>
<a href="#l88.26"></a><span id="l88.26"> #ifdef morkRun_USE_TAG_SLOT</span>
<a href="#l88.27"></a><span id="l88.27">   void       RunInitTag() { mRun_Tag = morkRun_kTag; }</span>
<a href="#l88.28"></a><span id="l88.28">   mork_bool  RunGoodTag() { return ( mRun_Tag == morkRun_kTag ); }</span>
<a href="#l88.29"></a><span id="l88.29"> #endif /* morkRun_USE_TAG_SLOT */</span>
<a href="#l88.30"></a><span id="l88.30" class="difflineminus">-  </span>
<a href="#l88.31"></a><span id="l88.31" class="difflineplus">+</span>
<a href="#l88.32"></a><span id="l88.32"> public: // conversion back and forth to inline block following run instance:</span>
<a href="#l88.33"></a><span id="l88.33">   void* RunAsBlock() { return (((mork_u1*) this) + sizeof(morkRun)); }</span>
<a href="#l88.34"></a><span id="l88.34" class="difflineminus">-  </span>
<a href="#l88.35"></a><span id="l88.35" class="difflineplus">+</span>
<a href="#l88.36"></a><span id="l88.36">   static morkRun* BlockAsRun(void* ioBlock)</span>
<a href="#l88.37"></a><span id="l88.37">   { return (morkRun*) (((mork_u1*) ioBlock) - sizeof(morkRun)); }</span>
<a href="#l88.38"></a><span id="l88.38"> </span>
<a href="#l88.39"></a><span id="l88.39"> public: // typing &amp; errors</span>
<a href="#l88.40"></a><span id="l88.40">   static void BadRunTagError(morkEnv* ev);</span>
<a href="#l88.41"></a><span id="l88.41">   static void RunSizeAlignError(morkEnv* ev);</span>
<a href="#l88.42"></a><span id="l88.42"> };</span>
<a href="#l88.43"></a><span id="l88.43"> </span>
<a href="#l88.44"></a><span id="l88.44" class="difflineat">@@ -105,21 +105,21 @@ public: // typing &amp; errors</span>
<a href="#l88.45"></a><span id="l88.45"> </span>
<a href="#l88.46"></a><span id="l88.46"> </span>
<a href="#l88.47"></a><span id="l88.47"> /*| morkOldRun: more space to record size when run is put into old free list</span>
<a href="#l88.48"></a><span id="l88.48"> |*/</span>
<a href="#l88.49"></a><span id="l88.49"> class morkOldRun : public morkRun {</span>
<a href="#l88.50"></a><span id="l88.50"> </span>
<a href="#l88.51"></a><span id="l88.51"> protected: // need another size field when mRun_Next is used for linkage:</span>
<a href="#l88.52"></a><span id="l88.52">   mdb_size mOldRun_Size;</span>
<a href="#l88.53"></a><span id="l88.53" class="difflineminus">-  </span>
<a href="#l88.54"></a><span id="l88.54" class="difflineplus">+</span>
<a href="#l88.55"></a><span id="l88.55"> public: // size getter/setter</span>
<a href="#l88.56"></a><span id="l88.56">   mork_size  OldSize() const { return mOldRun_Size; }</span>
<a href="#l88.57"></a><span id="l88.57">   void       OldSetSize(mork_size inSize) { mOldRun_Size = inSize; }</span>
<a href="#l88.58"></a><span id="l88.58" class="difflineminus">-  </span>
<a href="#l88.59"></a><span id="l88.59" class="difflineplus">+</span>
<a href="#l88.60"></a><span id="l88.60"> };</span>
<a href="#l88.61"></a><span id="l88.61"> </span>
<a href="#l88.62"></a><span id="l88.62"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l88.63"></a><span id="l88.63"> </span>
<a href="#l88.64"></a><span id="l88.64"> #define morkHunk_kTag ((mork_u4) 0x68556E4B ) /* ascii 'hUnK' */</span>
<a href="#l88.65"></a><span id="l88.65"> </span>
<a href="#l88.66"></a><span id="l88.66"> /*| morkHunk: structure used by morkZone for heap allocations.</span>
<a href="#l88.67"></a><span id="l88.67"> |*/</span>
<a href="#l88.68"></a><span id="l88.68" class="difflineat">@@ -127,44 +127,44 @@ class morkHunk {</span>
<a href="#l88.69"></a><span id="l88.69"> </span>
<a href="#l88.70"></a><span id="l88.70"> protected: // member variable slots</span>
<a href="#l88.71"></a><span id="l88.71"> </span>
<a href="#l88.72"></a><span id="l88.72"> #ifdef morkHunk_USE_TAG_SLOT</span>
<a href="#l88.73"></a><span id="l88.73">   mork_u4   mHunk_Tag; // force 8 byte alignment after mHunk_Next</span>
<a href="#l88.74"></a><span id="l88.74"> #endif /* morkHunk_USE_TAG_SLOT */</span>
<a href="#l88.75"></a><span id="l88.75"> </span>
<a href="#l88.76"></a><span id="l88.76">   morkHunk* mHunk_Next;</span>
<a href="#l88.77"></a><span id="l88.77" class="difflineminus">-  </span>
<a href="#l88.78"></a><span id="l88.78" class="difflineplus">+</span>
<a href="#l88.79"></a><span id="l88.79">   morkRun   mHunk_Run;</span>
<a href="#l88.80"></a><span id="l88.80" class="difflineminus">-  </span>
<a href="#l88.81"></a><span id="l88.81" class="difflineplus">+</span>
<a href="#l88.82"></a><span id="l88.82"> public: // setters</span>
<a href="#l88.83"></a><span id="l88.83">   void      HunkSetNext(morkHunk* ioNext) { mHunk_Next = ioNext; }</span>
<a href="#l88.84"></a><span id="l88.84" class="difflineminus">-  </span>
<a href="#l88.85"></a><span id="l88.85" class="difflineplus">+</span>
<a href="#l88.86"></a><span id="l88.86"> public: // getters</span>
<a href="#l88.87"></a><span id="l88.87">   morkHunk* HunkNext() const { return mHunk_Next; }</span>
<a href="#l88.88"></a><span id="l88.88"> </span>
<a href="#l88.89"></a><span id="l88.89">   morkRun*  HunkRun() { return &amp;mHunk_Run; }</span>
<a href="#l88.90"></a><span id="l88.90" class="difflineminus">-  </span>
<a href="#l88.91"></a><span id="l88.91" class="difflineplus">+</span>
<a href="#l88.92"></a><span id="l88.92"> public: // maintenance and testing of optional tag magic signature slot:</span>
<a href="#l88.93"></a><span id="l88.93"> #ifdef morkHunk_USE_TAG_SLOT</span>
<a href="#l88.94"></a><span id="l88.94">   void       HunkInitTag() { mHunk_Tag = morkHunk_kTag; }</span>
<a href="#l88.95"></a><span id="l88.95">   mork_bool  HunkGoodTag() { return ( mHunk_Tag == morkHunk_kTag ); }</span>
<a href="#l88.96"></a><span id="l88.96"> #endif /* morkHunk_USE_TAG_SLOT */</span>
<a href="#l88.97"></a><span id="l88.97"> </span>
<a href="#l88.98"></a><span id="l88.98"> public: // typing &amp; errors</span>
<a href="#l88.99"></a><span id="l88.99">   static void BadHunkTagWarning(morkEnv* ev);</span>
<a href="#l88.100"></a><span id="l88.100" class="difflineminus">-  </span>
<a href="#l88.101"></a><span id="l88.101" class="difflineplus">+</span>
<a href="#l88.102"></a><span id="l88.102"> };</span>
<a href="#l88.103"></a><span id="l88.103"> </span>
<a href="#l88.104"></a><span id="l88.104"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l88.105"></a><span id="l88.105"> </span>
<a href="#l88.106"></a><span id="l88.106"> /*| kNewHunkSize: the default size for a hunk, assuming we must allocate</span>
<a href="#l88.107"></a><span id="l88.107"> **| a new one whenever the free hunk list does not already have.  Note this</span>
<a href="#l88.108"></a><span id="l88.108"> **| number should not be changed without also considering suitable changes</span>
<a href="#l88.109"></a><span id="l88.109" class="difflineminus">-**| in the related kMaxHunkWaste and kMinHunkSize constants. </span>
<a href="#l88.110"></a><span id="l88.110" class="difflineplus">+**| in the related kMaxHunkWaste and kMinHunkSize constants.</span>
<a href="#l88.111"></a><span id="l88.111"> |*/</span>
<a href="#l88.112"></a><span id="l88.112"> #define morkZone_kNewHunkSize ((mork_size) (64 * 1024)) /* 64K per hunk */</span>
<a href="#l88.113"></a><span id="l88.113"> </span>
<a href="#l88.114"></a><span id="l88.114"> /*| kMaxFreeVolume: some number of bytes of free space in the free hunk list</span>
<a href="#l88.115"></a><span id="l88.115"> **| over which we no longer want to add more free hunks to the list, for fear</span>
<a href="#l88.116"></a><span id="l88.116"> **| of accumulating too much unused, fragmented free space.  This should be a</span>
<a href="#l88.117"></a><span id="l88.117"> **| small multiple of kNewHunkSize, say about two to four times as great, to</span>
<a href="#l88.118"></a><span id="l88.118"> **| allow for no more free hunk space than fits in a handful of new hunks.</span>
<a href="#l88.119"></a><span id="l88.119" class="difflineat">@@ -218,101 +218,101 @@ public: // typing &amp; errors</span>
<a href="#l88.120"></a><span id="l88.120"> |*/</span>
<a href="#l88.121"></a><span id="l88.121"> class morkZone : public morkNode, public nsIMdbHeap {</span>
<a href="#l88.122"></a><span id="l88.122"> </span>
<a href="#l88.123"></a><span id="l88.123"> // public: // slots inherited from morkNode (meant to inform only)</span>
<a href="#l88.124"></a><span id="l88.124">   // nsIMdbHeap*       mNode_Heap;</span>
<a href="#l88.125"></a><span id="l88.125"> </span>
<a href="#l88.126"></a><span id="l88.126">   // mork_base      mNode_Base;     // must equal morkBase_kNode</span>
<a href="#l88.127"></a><span id="l88.127">   // mork_derived   mNode_Derived;  // depends on specific node subclass</span>
<a href="#l88.128"></a><span id="l88.128" class="difflineminus">-  </span>
<a href="#l88.129"></a><span id="l88.129" class="difflineplus">+</span>
<a href="#l88.130"></a><span id="l88.130">   // mork_access    mNode_Access;   // kOpen, kClosing, kShut, or kDead</span>
<a href="#l88.131"></a><span id="l88.131">   // mork_usage     mNode_Usage;    // kHeap, kStack, kMember, kGlobal, kNone</span>
<a href="#l88.132"></a><span id="l88.132">   // mork_able      mNode_Mutable;  // can this node be modified?</span>
<a href="#l88.133"></a><span id="l88.133">   // mork_load      mNode_Load;     // is this node clean or dirty?</span>
<a href="#l88.134"></a><span id="l88.134" class="difflineminus">-  </span>
<a href="#l88.135"></a><span id="l88.135" class="difflineplus">+</span>
<a href="#l88.136"></a><span id="l88.136">   // mork_uses      mNode_Uses;     // refcount for strong refs</span>
<a href="#l88.137"></a><span id="l88.137">   // mork_refs      mNode_Refs;     // refcount for strong refs + weak refs</span>
<a href="#l88.138"></a><span id="l88.138"> </span>
<a href="#l88.139"></a><span id="l88.139"> public: // state is public because the entire Mork system is private</span>
<a href="#l88.140"></a><span id="l88.140"> </span>
<a href="#l88.141"></a><span id="l88.141">   nsIMdbHeap*  mZone_Heap; // strong ref to heap allocating all space</span>
<a href="#l88.142"></a><span id="l88.142" class="difflineminus">-  </span>
<a href="#l88.143"></a><span id="l88.143" class="difflineplus">+</span>
<a href="#l88.144"></a><span id="l88.144">   mork_size    mZone_HeapVolume;  // total bytes allocated from heap</span>
<a href="#l88.145"></a><span id="l88.145">   mork_size    mZone_BlockVolume; // total bytes in all zone blocks</span>
<a href="#l88.146"></a><span id="l88.146">   mork_size    mZone_RunVolume;   // total bytes in all zone runs</span>
<a href="#l88.147"></a><span id="l88.147">   mork_size    mZone_ChipVolume;  // total bytes in all zone chips</span>
<a href="#l88.148"></a><span id="l88.148" class="difflineminus">-  </span>
<a href="#l88.149"></a><span id="l88.149" class="difflineplus">+</span>
<a href="#l88.150"></a><span id="l88.150">   mork_size    mZone_FreeOldRunVolume; // total bytes in all used hunks</span>
<a href="#l88.151"></a><span id="l88.151" class="difflineminus">-  </span>
<a href="#l88.152"></a><span id="l88.152" class="difflineplus">+</span>
<a href="#l88.153"></a><span id="l88.153">   mork_count   mZone_HunkCount;        // total number of used hunks</span>
<a href="#l88.154"></a><span id="l88.154">   mork_count   mZone_FreeOldRunCount;  // total free old runs</span>
<a href="#l88.155"></a><span id="l88.155"> </span>
<a href="#l88.156"></a><span id="l88.156" class="difflineminus">-  morkHunk*    mZone_HunkList;       // linked list of all used hunks  </span>
<a href="#l88.157"></a><span id="l88.157" class="difflineplus">+  morkHunk*    mZone_HunkList;       // linked list of all used hunks</span>
<a href="#l88.158"></a><span id="l88.158">   morkRun*     mZone_FreeOldRunList; // linked list of free old runs</span>
<a href="#l88.159"></a><span id="l88.159" class="difflineminus">-  </span>
<a href="#l88.160"></a><span id="l88.160" class="difflineplus">+</span>
<a href="#l88.161"></a><span id="l88.161">   // note mZone_At is a byte pointer for single byte address arithmetic:</span>
<a href="#l88.162"></a><span id="l88.162">   mork_u1*     mZone_At;     // current position in most recent hunk</span>
<a href="#l88.163"></a><span id="l88.163">   mork_size    mZone_AtSize; // number of bytes remaining in this hunk</span>
<a href="#l88.164"></a><span id="l88.164" class="difflineminus">-  </span>
<a href="#l88.165"></a><span id="l88.165" class="difflineplus">+</span>
<a href="#l88.166"></a><span id="l88.166">   // kBuckets+1 so indexes zero through kBuckets are all okay to use:</span>
<a href="#l88.167"></a><span id="l88.167" class="difflineminus">-  </span>
<a href="#l88.168"></a><span id="l88.168" class="difflineplus">+</span>
<a href="#l88.169"></a><span id="l88.169">   morkRun*     mZone_FreeRuns[ morkZone_kBuckets + 1 ];</span>
<a href="#l88.170"></a><span id="l88.170">   // Each piece of memory stored in list mZone_FreeRuns[ i ] has an</span>
<a href="#l88.171"></a><span id="l88.171">   // allocation size equal to sizeof(morkRun) + (i * kRoundSize), so</span>
<a href="#l88.172"></a><span id="l88.172">   // that callers can be given a piece of memory with (i * kRoundSize)</span>
<a href="#l88.173"></a><span id="l88.173">   // bytes of writeable space while reserving the first sizeof(morkRun)</span>
<a href="#l88.174"></a><span id="l88.174">   // bytes to keep track of size information for later re-use.  Note</span>
<a href="#l88.175"></a><span id="l88.175">   // that mZone_FreeRuns[ 0 ] is unused because no run will be zero</span>
<a href="#l88.176"></a><span id="l88.176" class="difflineminus">-  // bytes in size (and morkZone plans to complain about zero sizes). </span>
<a href="#l88.177"></a><span id="l88.177" class="difflineplus">+  // bytes in size (and morkZone plans to complain about zero sizes).</span>
<a href="#l88.178"></a><span id="l88.178"> </span>
<a href="#l88.179"></a><span id="l88.179"> protected: // zone utilities</span>
<a href="#l88.180"></a><span id="l88.180" class="difflineminus">-  </span>
<a href="#l88.181"></a><span id="l88.181" class="difflineplus">+</span>
<a href="#l88.182"></a><span id="l88.182">   mork_size zone_grow_at(morkEnv* ev, mork_size inNeededSize);</span>
<a href="#l88.183"></a><span id="l88.183"> </span>
<a href="#l88.184"></a><span id="l88.184" class="difflineminus">-  void*     zone_new_chip(morkEnv* ev, mdb_size inSize); // alloc  </span>
<a href="#l88.185"></a><span id="l88.185" class="difflineminus">-  morkHunk* zone_new_hunk(morkEnv* ev, mdb_size inRunSize); // alloc  </span>
<a href="#l88.186"></a><span id="l88.186" class="difflineplus">+  void*     zone_new_chip(morkEnv* ev, mdb_size inSize); // alloc</span>
<a href="#l88.187"></a><span id="l88.187" class="difflineplus">+  morkHunk* zone_new_hunk(morkEnv* ev, mdb_size inRunSize); // alloc</span>
<a href="#l88.188"></a><span id="l88.188"> </span>
<a href="#l88.189"></a><span id="l88.189"> // { ===== begin nsIMdbHeap methods =====</span>
<a href="#l88.190"></a><span id="l88.190"> public:</span>
<a href="#l88.191"></a><span id="l88.191">   NS_IMETHOD Alloc(nsIMdbEnv* ev, // allocate a piece of memory</span>
<a href="#l88.192"></a><span id="l88.192" class="difflineminus">-    mdb_size inSize,   // requested size of new memory block </span>
<a href="#l88.193"></a><span id="l88.193" class="difflineplus">+    mdb_size inSize,   // requested size of new memory block</span>
<a href="#l88.194"></a><span id="l88.194">     void** outBlock) override; // memory block of inSize bytes, or nil</span>
<a href="#l88.195"></a><span id="l88.195" class="difflineminus">-    </span>
<a href="#l88.196"></a><span id="l88.196" class="difflineplus">+</span>
<a href="#l88.197"></a><span id="l88.197">   NS_IMETHOD Free(nsIMdbEnv* ev, // free block allocated earlier by Alloc()</span>
<a href="#l88.198"></a><span id="l88.198">     void* inBlock) override;</span>
<a href="#l88.199"></a><span id="l88.199"> </span>
<a href="#l88.200"></a><span id="l88.200">   virtual size_t GetUsedSize() override { return mZone_Heap-&gt;GetUsedSize(); }</span>
<a href="#l88.201"></a><span id="l88.201"> // } ===== end nsIMdbHeap methods =====</span>
<a href="#l88.202"></a><span id="l88.202"> </span>
<a href="#l88.203"></a><span id="l88.203"> // { ===== begin morkNode interface =====</span>
<a href="#l88.204"></a><span id="l88.204"> public: // morkNode virtual methods</span>
<a href="#l88.205"></a><span id="l88.205">   virtual void CloseMorkNode(morkEnv* ev) override; // CloseZone() only if open</span>
<a href="#l88.206"></a><span id="l88.206">   virtual ~morkZone(); // assert that CloseMap() executed earlier</span>
<a href="#l88.207"></a><span id="l88.207"> </span>
<a href="#l88.208"></a><span id="l88.208"> public: // morkMap construction &amp; destruction</span>
<a href="#l88.209"></a><span id="l88.209" class="difflineminus">-  morkZone(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioNodeHeap, </span>
<a href="#l88.210"></a><span id="l88.210" class="difflineplus">+  morkZone(morkEnv* ev, const morkUsage&amp; inUsage, nsIMdbHeap* ioNodeHeap,</span>
<a href="#l88.211"></a><span id="l88.211">     nsIMdbHeap* ioZoneHeap);</span>
<a href="#l88.212"></a><span id="l88.212" class="difflineminus">-  </span>
<a href="#l88.213"></a><span id="l88.213" class="difflineplus">+</span>
<a href="#l88.214"></a><span id="l88.214">   void CloseZone(morkEnv* ev); // called by CloseMorkNode()</span>
<a href="#l88.215"></a><span id="l88.215" class="difflineminus">-  </span>
<a href="#l88.216"></a><span id="l88.216" class="difflineplus">+</span>
<a href="#l88.217"></a><span id="l88.217"> public: // dynamic type identification</span>
<a href="#l88.218"></a><span id="l88.218">   mork_bool IsZone() const</span>
<a href="#l88.219"></a><span id="l88.219">   { return IsNode() &amp;&amp; mNode_Derived == morkDerived_kZone; }</span>
<a href="#l88.220"></a><span id="l88.220"> // } ===== end morkNode methods =====</span>
<a href="#l88.221"></a><span id="l88.221"> </span>
<a href="#l88.222"></a><span id="l88.222"> // { ===== begin morkZone methods =====</span>
<a href="#l88.223"></a><span id="l88.223"> public: // chips do not know how big they are...</span>
<a href="#l88.224"></a><span id="l88.224" class="difflineminus">-  void* ZoneNewChip(morkEnv* ev, mdb_size inSize); // alloc  </span>
<a href="#l88.225"></a><span id="l88.225" class="difflineminus">-    </span>
<a href="#l88.226"></a><span id="l88.226" class="difflineplus">+  void* ZoneNewChip(morkEnv* ev, mdb_size inSize); // alloc</span>
<a href="#l88.227"></a><span id="l88.227" class="difflineplus">+</span>
<a href="#l88.228"></a><span id="l88.228"> public: // ...but runs do indeed know how big they are</span>
<a href="#l88.229"></a><span id="l88.229" class="difflineminus">-  void* ZoneNewRun(morkEnv* ev, mdb_size inSize); // alloc  </span>
<a href="#l88.230"></a><span id="l88.230" class="difflineplus">+  void* ZoneNewRun(morkEnv* ev, mdb_size inSize); // alloc</span>
<a href="#l88.231"></a><span id="l88.231">   void  ZoneZapRun(morkEnv* ev, void* ioRunBody); // free</span>
<a href="#l88.232"></a><span id="l88.232">   void* ZoneGrowRun(morkEnv* ev, void* ioRunBody, mdb_size inSize); // realloc</span>
<a href="#l88.233"></a><span id="l88.233" class="difflineminus">-    </span>
<a href="#l88.234"></a><span id="l88.234" class="difflineplus">+</span>
<a href="#l88.235"></a><span id="l88.235"> // } ===== end morkZone methods =====</span>
<a href="#l88.236"></a><span id="l88.236"> </span>
<a href="#l88.237"></a><span id="l88.237"> public: // typing &amp; errors</span>
<a href="#l88.238"></a><span id="l88.238">   static void NonZoneTypeError(morkEnv* ev);</span>
<a href="#l88.239"></a><span id="l88.239">   static void NilZoneHeapError(morkEnv* ev);</span>
<a href="#l88.240"></a><span id="l88.240">   static void BadZoneTagError(morkEnv* ev);</span>
<a href="#l88.241"></a><span id="l88.241"> };</span>
<a href="#l88.242"></a><span id="l88.242"> </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l89.1"></a><span id="l89.1" class="difflineminus">--- a/db/mork/src/orkinHeap.h</span>
<a href="#l89.2"></a><span id="l89.2" class="difflineplus">+++ b/db/mork/src/orkinHeap.h</span>
<a href="#l89.3"></a><span id="l89.3" class="difflineat">@@ -13,37 +13,37 @@</span>
<a href="#l89.4"></a><span id="l89.4"> #ifndef _MORK_</span>
<a href="#l89.5"></a><span id="l89.5"> #include &quot;mork.h&quot;</span>
<a href="#l89.6"></a><span id="l89.6"> #endif</span>
<a href="#l89.7"></a><span id="l89.7"> </span>
<a href="#l89.8"></a><span id="l89.8"> //3456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789</span>
<a href="#l89.9"></a><span id="l89.9"> </span>
<a href="#l89.10"></a><span id="l89.10"> #define orkinHeap_kTag 0x68456150 /* ascii 'hEaP' */</span>
<a href="#l89.11"></a><span id="l89.11"> </span>
<a href="#l89.12"></a><span id="l89.12" class="difflineminus">-/*| orkinHeap: </span>
<a href="#l89.13"></a><span id="l89.13" class="difflineplus">+/*| orkinHeap:</span>
<a href="#l89.14"></a><span id="l89.14"> |*/</span>
<a href="#l89.15"></a><span id="l89.15"> class orkinHeap : public nsIMdbHeap { //</span>
<a href="#l89.16"></a><span id="l89.16"> protected:</span>
<a href="#l89.17"></a><span id="l89.17">   size_t mUsedSize;</span>
<a href="#l89.18"></a><span id="l89.18"> </span>
<a href="#l89.19"></a><span id="l89.19"> public:</span>
<a href="#l89.20"></a><span id="l89.20">   orkinHeap(); // does nothing</span>
<a href="#l89.21"></a><span id="l89.21">   virtual ~orkinHeap(); // does nothing</span>
<a href="#l89.22"></a><span id="l89.22" class="difflineminus">-    </span>
<a href="#l89.23"></a><span id="l89.23" class="difflineplus">+</span>
<a href="#l89.24"></a><span id="l89.24"> private: // copying is not allowed</span>
<a href="#l89.25"></a><span id="l89.25">   orkinHeap(const orkinHeap&amp; other);</span>
<a href="#l89.26"></a><span id="l89.26">   orkinHeap&amp; operator=(const orkinHeap&amp; other);</span>
<a href="#l89.27"></a><span id="l89.27"> </span>
<a href="#l89.28"></a><span id="l89.28"> public:</span>
<a href="#l89.29"></a><span id="l89.29"> </span>
<a href="#l89.30"></a><span id="l89.30"> // { ===== begin nsIMdbHeap methods =====</span>
<a href="#l89.31"></a><span id="l89.31">   NS_IMETHOD Alloc(nsIMdbEnv* ev, // allocate a piece of memory</span>
<a href="#l89.32"></a><span id="l89.32" class="difflineminus">-    mdb_size inSize,   // requested size of new memory block </span>
<a href="#l89.33"></a><span id="l89.33" class="difflineplus">+    mdb_size inSize,   // requested size of new memory block</span>
<a href="#l89.34"></a><span id="l89.34">     void** outBlock);  // memory block of inSize bytes, or nil</span>
<a href="#l89.35"></a><span id="l89.35" class="difflineminus">-    </span>
<a href="#l89.36"></a><span id="l89.36" class="difflineplus">+</span>
<a href="#l89.37"></a><span id="l89.37">   NS_IMETHOD Free(nsIMdbEnv* ev, // free block allocated earlier by Alloc()</span>
<a href="#l89.38"></a><span id="l89.38">     void* inBlock);</span>
<a href="#l89.39"></a><span id="l89.39"> </span>
<a href="#l89.40"></a><span id="l89.40">   virtual size_t GetUsedSize();</span>
<a href="#l89.41"></a><span id="l89.41"> // } ===== end nsIMdbHeap methods =====</span>
<a href="#l89.42"></a><span id="l89.42"> </span>
<a href="#l89.43"></a><span id="l89.43"> };</span>
<a href="#l89.44"></a><span id="l89.44"> </span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

