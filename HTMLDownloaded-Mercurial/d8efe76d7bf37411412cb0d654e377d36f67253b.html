<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 975:d8efe76d7bf37411412cb0d654e377d36f67253b</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ d8efe76d7bf37411412cb0d654e377d36f67253b" />
<meta property="og:url" content="/comm-central/rev/d8efe76d7bf37411412cb0d654e377d36f67253b" />
<meta property="og:description" content="status commit on refactor, pre-merge." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / d8efe76d7bf37411412cb0d654e377d36f67253b 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/d8efe76d7bf37411412cb0d654e377d36f67253b">shortlog</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/d8efe76d7bf37411412cb0d654e377d36f67253b">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b">files</a> |
changeset |
<a href="/comm-central/raw-rev/d8efe76d7bf37411412cb0d654e377d36f67253b">raw</a>  | <a href="/comm-central/archive/d8efe76d7bf37411412cb0d654e377d36f67253b.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
status commit on refactor, pre-merge.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 17 Oct 2008 23:58:21 -0700</td></tr>

<tr>
 <td>changeset 975</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/d8efe76d7bf37411412cb0d654e377d36f67253b">d8efe76d7bf37411412cb0d654e377d36f67253b</a></td>
</tr>



<tr>
<td>parent 974</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/06fabe695ede97f7960935c4515e2e867a3eefec">06fabe695ede97f7960935c4515e2e867a3eefec</a>
</td>
</tr>

<tr>
<td>child 976</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/7c775651aae3eae5df5106c3e8b09a9d311d7e6e">7c775651aae3eae5df5106c3e8b09a9d311d7e6e</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=d8efe76d7bf37411412cb0d654e377d36f67253b">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">status commit on refactor, pre-merge.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/components/glautocomp.js">components/glautocomp.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b/components/glautocomp.js">file</a> |
<a href="/comm-central/annotate/d8efe76d7bf37411412cb0d654e377d36f67253b/components/glautocomp.js">annotate</a> |
<a href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/components/glautocomp.js">diff</a> |
<a href="/comm-central/comparison/d8efe76d7bf37411412cb0d654e377d36f67253b/components/glautocomp.js">comparison</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b/components/glautocomp.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/components/jsmimeemitter.js">components/jsmimeemitter.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b/components/jsmimeemitter.js">file</a> |
<a href="/comm-central/annotate/d8efe76d7bf37411412cb0d654e377d36f67253b/components/jsmimeemitter.js">annotate</a> |
<a href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/components/jsmimeemitter.js">diff</a> |
<a href="/comm-central/comparison/d8efe76d7bf37411412cb0d654e377d36f67253b/components/jsmimeemitter.js">comparison</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b/components/jsmimeemitter.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/content/glodacomplete.xml">content/glodacomplete.xml</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b/content/glodacomplete.xml">file</a> |
<a href="/comm-central/annotate/d8efe76d7bf37411412cb0d654e377d36f67253b/content/glodacomplete.xml">annotate</a> |
<a href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/content/glodacomplete.xml">diff</a> |
<a href="/comm-central/comparison/d8efe76d7bf37411412cb0d654e377d36f67253b/content/glodacomplete.xml">comparison</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b/content/glodacomplete.xml">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/collection.js">file</a> |
<a href="/comm-central/annotate/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/collection.js">comparison</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datamodel.js">modules/datamodel.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datamodel.js">file</a> |
<a href="/comm-central/annotate/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datamodel.js">annotate</a> |
<a href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datamodel.js">diff</a> |
<a href="/comm-central/comparison/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datamodel.js">comparison</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datamodel.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/explattr.js">modules/explattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/explattr.js">file</a> |
<a href="/comm-central/annotate/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/explattr.js">annotate</a> |
<a href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/explattr.js">diff</a> |
<a href="/comm-central/comparison/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/explattr.js">comparison</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/explattr.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/fundattr.js">modules/fundattr.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/fundattr.js">file</a> |
<a href="/comm-central/annotate/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/fundattr.js">annotate</a> |
<a href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/fundattr.js">diff</a> |
<a href="/comm-central/comparison/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/fundattr.js">comparison</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/fundattr.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/gloda.js">modules/gloda.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/gloda.js">file</a> |
<a href="/comm-central/annotate/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/gloda.js">annotate</a> |
<a href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/gloda.js">diff</a> |
<a href="/comm-central/comparison/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/gloda.js">comparison</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/gloda.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/query.js">modules/query.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/query.js">file</a> |
<a href="/comm-central/annotate/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/query.js">annotate</a> |
<a href="/comm-central/diff/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/query.js">diff</a> |
<a href="/comm-central/comparison/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/query.js">comparison</a> |
<a href="/comm-central/log/d8efe76d7bf37411412cb0d654e377d36f67253b/modules/query.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/components/glautocomp.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/components/glautocomp.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -47,28 +47,28 @@ var LOG = null;</span>
<a href="#l1.4"></a><span id="l1.4"> </span>
<a href="#l1.5"></a><span id="l1.5"> var Gloda = null;</span>
<a href="#l1.6"></a><span id="l1.6"> var GlodaUtils = null;</span>
<a href="#l1.7"></a><span id="l1.7"> var MultiSuffixTree = null;</span>
<a href="#l1.8"></a><span id="l1.8"> var FreeTagNoun = null;</span>
<a href="#l1.9"></a><span id="l1.9"> </span>
<a href="#l1.10"></a><span id="l1.10"> function ResultRowSingle(aItem, aCriteriaType, aCriteria) {</span>
<a href="#l1.11"></a><span id="l1.11">   this.nounID = aItem.NOUN_ID;</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  this.nounMeta = Gloda._nounIDToMeta[this.nounID];</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  this.nounDef = Gloda._nounIDToDef[this.nounID];</span>
<a href="#l1.14"></a><span id="l1.14">   this.criteriaType = aCriteriaType;</span>
<a href="#l1.15"></a><span id="l1.15">   this.criteria = aCriteria;</span>
<a href="#l1.16"></a><span id="l1.16">   this.item = aItem;</span>
<a href="#l1.17"></a><span id="l1.17"> }</span>
<a href="#l1.18"></a><span id="l1.18"> ResultRowSingle.prototype = {</span>
<a href="#l1.19"></a><span id="l1.19">   multi: false</span>
<a href="#l1.20"></a><span id="l1.20"> };</span>
<a href="#l1.21"></a><span id="l1.21"> </span>
<a href="#l1.22"></a><span id="l1.22"> function ResultRowMulti(aNounID, aCriteriaType, aCriteria, aQuery) {</span>
<a href="#l1.23"></a><span id="l1.23">   this.nounID = aNounID;</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineminus">-  this.nounMeta = Gloda._nounIDToMeta[aNounID];</span>
<a href="#l1.25"></a><span id="l1.25" class="difflineplus">+  this.nounDef = Gloda._nounIDToDef[aNounID];</span>
<a href="#l1.26"></a><span id="l1.26">   this.criteriaType = aCriteriaType;</span>
<a href="#l1.27"></a><span id="l1.27">   this.criteria = aCriteria;</span>
<a href="#l1.28"></a><span id="l1.28">   this.collection = aQuery.getCollection(this);</span>
<a href="#l1.29"></a><span id="l1.29">   this.renderer = null;</span>
<a href="#l1.30"></a><span id="l1.30"> }</span>
<a href="#l1.31"></a><span id="l1.31"> ResultRowMulti.prototype = {</span>
<a href="#l1.32"></a><span id="l1.32">   multi: true,</span>
<a href="#l1.33"></a><span id="l1.33">   onItemsAdded: function(aItems) {</span>
<a href="#l1.34"></a><span id="l1.34" class="difflineat">@@ -153,17 +153,17 @@ nsAutoCompleteGlodaResult.prototype = {</span>
<a href="#l1.35"></a><span id="l1.35">       return thing.name || thing.subject;</span>
<a href="#l1.36"></a><span id="l1.36">   },</span>
<a href="#l1.37"></a><span id="l1.37">   // rich uses this to be the &quot;type&quot;</span>
<a href="#l1.38"></a><span id="l1.38">   getStyleAt: function(aIndex) {</span>
<a href="#l1.39"></a><span id="l1.39">     let row = this._results[aIndex];</span>
<a href="#l1.40"></a><span id="l1.40">     if (row.multi)</span>
<a href="#l1.41"></a><span id="l1.41">       return &quot;gloda-multi&quot;;</span>
<a href="#l1.42"></a><span id="l1.42">     else</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineminus">-      return &quot;gloda-single-&quot; + row.nounMeta.name;</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+      return &quot;gloda-single-&quot; + row.nounDef.name;</span>
<a href="#l1.45"></a><span id="l1.45">   },</span>
<a href="#l1.46"></a><span id="l1.46">   // rich uses this to be the icon</span>
<a href="#l1.47"></a><span id="l1.47">   getImageAt: function(aIndex) {</span>
<a href="#l1.48"></a><span id="l1.48">     let thing = this._results[aIndex];</span>
<a href="#l1.49"></a><span id="l1.49">     if (!thing.value)</span>
<a href="#l1.50"></a><span id="l1.50">       return null;</span>
<a href="#l1.51"></a><span id="l1.51"> </span>
<a href="#l1.52"></a><span id="l1.52">     let md5hash = GlodaUtils.md5HashString(thing.value);</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/components/jsmimeemitter.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/components/jsmimeemitter.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -84,102 +84,101 @@ function MimeMessageEmitter() {</span>
<a href="#l2.4"></a><span id="l2.4">   this._curMsg = null;</span>
<a href="#l2.5"></a><span id="l2.5">   </span>
<a href="#l2.6"></a><span id="l2.6">   this._messageIndex = 0;</span>
<a href="#l2.7"></a><span id="l2.7">   this._allSubMessages = [];</span>
<a href="#l2.8"></a><span id="l2.8"> }</span>
<a href="#l2.9"></a><span id="l2.9"> </span>
<a href="#l2.10"></a><span id="l2.10"> MimeMessageEmitter.prototype = {</span>
<a href="#l2.11"></a><span id="l2.11">   classDescription: &quot;JS Mime Message Emitter&quot;,</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  classID: Components.ID(&quot;{80578315-7021-40f9-9717-413cacf2fa7d}&quot;),</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineminus">-  contractID: &quot;@mozilla.org/steeldestined/jsmimeemitter;1&quot;,</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+  classID: Components.ID(&quot;{8cddbbbc-7ced-46b0-a936-8cddd1928c24}&quot;),</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+  contractID: &quot;@mozilla.org/gloda/jsmimeemitter;1&quot;,</span>
<a href="#l2.16"></a><span id="l2.16">   </span>
<a href="#l2.17"></a><span id="l2.17">   _partRE: new RegExp(&quot;^[^?]+\?(?:[^&amp;]+&amp;)*part=([^&amp;]+)(?:&amp;[^&amp;]+)*$&quot;),</span>
<a href="#l2.18"></a><span id="l2.18">   </span>
<a href="#l2.19"></a><span id="l2.19">   _xpcom_categories: [{</span>
<a href="#l2.20"></a><span id="l2.20">     category: &quot;mime-emitter&quot;,</span>
<a href="#l2.21"></a><span id="l2.21">     entry:</span>
<a href="#l2.22"></a><span id="l2.22">       &quot;@mozilla.org/messenger/mimeemitter;1?type=application/x-js-mime-message&quot;,</span>
<a href="#l2.23"></a><span id="l2.23">   }],</span>
<a href="#l2.24"></a><span id="l2.24">   </span>
<a href="#l2.25"></a><span id="l2.25">   QueryInterface: XPCOMUtils.generateQI([Ci.nsIMimeEmitter]),</span>
<a href="#l2.26"></a><span id="l2.26"> </span>
<a href="#l2.27"></a><span id="l2.27" class="difflineminus">-  Initialize: function mime_emitter_Initialize(aUrl, aChannel, aFormat) {</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineplus">+  initialize: function mime_emitter_initialize(aUrl, aChannel, aFormat) {</span>
<a href="#l2.29"></a><span id="l2.29">     this._url = aUrl;</span>
<a href="#l2.30"></a><span id="l2.30">     this._curMsg = this._parentMsg = this._rootMsg = new this._mimeMsg.MimeMessage();</span>
<a href="#l2.31"></a><span id="l2.31">     </span>
<a href="#l2.32"></a><span id="l2.32">     this._mimeMsg.MsgHdrToMimeMessage.RESULT_RENDEVOUZ[aUrl.spec] =</span>
<a href="#l2.33"></a><span id="l2.33">       this._rootMsg;</span>
<a href="#l2.34"></a><span id="l2.34">     </span>
<a href="#l2.35"></a><span id="l2.35">     this._channel = aChannel;</span>
<a href="#l2.36"></a><span id="l2.36">   },</span>
<a href="#l2.37"></a><span id="l2.37">   </span>
<a href="#l2.38"></a><span id="l2.38" class="difflineminus">-  Complete: function mime_emitter_Complete() {</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+  complete: function mime_emitter_complete() {</span>
<a href="#l2.40"></a><span id="l2.40">     // null out everything we can.  secretive cycles are eating us alive.</span>
<a href="#l2.41"></a><span id="l2.41">     this._url = null;</span>
<a href="#l2.42"></a><span id="l2.42">     this._channel = null;</span>
<a href="#l2.43"></a><span id="l2.43">     </span>
<a href="#l2.44"></a><span id="l2.44">     this._inputStream = null;</span>
<a href="#l2.45"></a><span id="l2.45">     this._outputStream = null;</span>
<a href="#l2.46"></a><span id="l2.46">     </span>
<a href="#l2.47"></a><span id="l2.47">     this._outputListener = null;</span>
<a href="#l2.48"></a><span id="l2.48"> </span>
<a href="#l2.49"></a><span id="l2.49">     this._curMsg = this._parentMsg = this._messageStack = this._rootMsg = null;</span>
<a href="#l2.50"></a><span id="l2.50">     this._messageIndex = null;</span>
<a href="#l2.51"></a><span id="l2.51">     this._allSubMessages = null;</span>
<a href="#l2.52"></a><span id="l2.52">   },</span>
<a href="#l2.53"></a><span id="l2.53">   </span>
<a href="#l2.54"></a><span id="l2.54" class="difflineminus">-  SetPipe: function mime_emitter_SetPipe(aInputStream, aOutputStream) {</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineplus">+  setPipe: function mime_emitter_setPipe(aInputStream, aOutputStream) {</span>
<a href="#l2.56"></a><span id="l2.56">     this._inputStream = aInputStream;</span>
<a href="#l2.57"></a><span id="l2.57">     this._outputStream = aOutputStream;</span>
<a href="#l2.58"></a><span id="l2.58">   },</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineminus">-  // can we use getters/setters to replace explicit functions on the interface?</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineminus">-  SetOutputListener: function mime_emitter_SetOutputListener(aListener) {</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+  set outputListener(aListener) {</span>
<a href="#l2.62"></a><span id="l2.62">     this._outputListener = aListener;</span>
<a href="#l2.63"></a><span id="l2.63">   },</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineminus">-  GetOutputListener: function mime_emitter_GetOutputListener() {</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineplus">+  get outputListener() {</span>
<a href="#l2.66"></a><span id="l2.66">     return this._outputListener;</span>
<a href="#l2.67"></a><span id="l2.67">   }, </span>
<a href="#l2.68"></a><span id="l2.68">   </span>
<a href="#l2.69"></a><span id="l2.69">   // ----- Header Routines</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineminus">-  StartHeader: function mime_emitter_StartHeader(aIsRootMailHeader,</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+  startHeader: function mime_emitter_startHeader(aIsRootMailHeader,</span>
<a href="#l2.72"></a><span id="l2.72">       aIsHeaderOnly, aMsgID, aOutputCharset) {</span>
<a href="#l2.73"></a><span id="l2.73">     </span>
<a href="#l2.74"></a><span id="l2.74">     if (aIsRootMailHeader) {</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineminus">-      this.UpdateCharacterSet(aOutputCharset);</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+      this.updateCharacterSet(aOutputCharset);</span>
<a href="#l2.77"></a><span id="l2.77">       // nothing to do curMsg-wise, already initialized.</span>
<a href="#l2.78"></a><span id="l2.78">     }</span>
<a href="#l2.79"></a><span id="l2.79">     else {</span>
<a href="#l2.80"></a><span id="l2.80">       this._curMsg = new this._mimeMsg.MimeMessage();</span>
<a href="#l2.81"></a><span id="l2.81">       this._parentMsg.messages.push(this._curMsg);</span>
<a href="#l2.82"></a><span id="l2.82">       this._allSubMessages.push(this._curMsg);</span>
<a href="#l2.83"></a><span id="l2.83">     }</span>
<a href="#l2.84"></a><span id="l2.84">   },</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineminus">-  AddHeaderField: function mime_emitter_AddHeaderField(aField, aValue) {</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineplus">+  addHeaderField: function mime_emitter_addHeaderField(aField, aValue) {</span>
<a href="#l2.87"></a><span id="l2.87">     let lowerField = aField.toLowerCase();</span>
<a href="#l2.88"></a><span id="l2.88">     if (lowerField in this._curMsg.headers)</span>
<a href="#l2.89"></a><span id="l2.89">       this._curMsg.headers[lowerField].push(aValue);</span>
<a href="#l2.90"></a><span id="l2.90">     else</span>
<a href="#l2.91"></a><span id="l2.91">       this._curMsg.headers[lowerField] = [aValue];</span>
<a href="#l2.92"></a><span id="l2.92">   },</span>
<a href="#l2.93"></a><span id="l2.93">   addAllHeaders: function mime_emitter_addAllHeaders(aAllHeaders, aHeaderSize) {</span>
<a href="#l2.94"></a><span id="l2.94">     // This is called by the parsing code after the calls to AddHeaderField (or</span>
<a href="#l2.95"></a><span id="l2.95">     //  AddAttachmentField if the part is an attachment), and seems to serve</span>
<a href="#l2.96"></a><span id="l2.96">     //  a specialized, quasi-redundant purpose.  (nsMimeBaseEmitter creates a</span>
<a href="#l2.97"></a><span id="l2.97">     //  nsIMimeHeaders instance and hands it to the nsIMsgMailNewsUrl.)</span>
<a href="#l2.98"></a><span id="l2.98">     // nop</span>
<a href="#l2.99"></a><span id="l2.99">   },</span>
<a href="#l2.100"></a><span id="l2.100" class="difflineminus">-  WriteHTMLHeaders: function mime_emitter_WriteHTMLHeaders() {</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineplus">+  writeHTMLHeaders: function mime_emitter_writeHTMLHeaders() {</span>
<a href="#l2.102"></a><span id="l2.102">     // It does't look like this should even be part of the interface; I think</span>
<a href="#l2.103"></a><span id="l2.103">     //  only the nsMimeHtmlDisplayEmitter::EndHeader call calls this signature.</span>
<a href="#l2.104"></a><span id="l2.104">     // nop</span>
<a href="#l2.105"></a><span id="l2.105">   },</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineminus">-  EndHeader: function mime_emitter_EndHeader() {</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineplus">+  endHeader: function mime_emitter_endHeader() {</span>
<a href="#l2.108"></a><span id="l2.108">   },</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineminus">-  UpdateCharacterSet: function mime_emitter_UpdateCharacterSet(aCharset) {</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineplus">+  updateCharacterSet: function mime_emitter_updateCharacterSet(aCharset) {</span>
<a href="#l2.111"></a><span id="l2.111">     // for non US-ASCII, ISO-8859-1, or UTF-8 charsets (case-insensitive),</span>
<a href="#l2.112"></a><span id="l2.112">     //  nsMimeBaseEmitter grabs the channel's content type, nukes the &quot;charset=&quot;</span>
<a href="#l2.113"></a><span id="l2.113">     //  parameter if it exists, and tells the channel the updated content type</span>
<a href="#l2.114"></a><span id="l2.114">     //  and new character set.</span>
<a href="#l2.115"></a><span id="l2.115">     </span>
<a href="#l2.116"></a><span id="l2.116">     // Disabling for now; we get a NS_ERROR_NOT_IMPLEMENTED from the channel</span>
<a href="#l2.117"></a><span id="l2.117">     //  when we try and set the contentCharset... and I'm not totally up on the</span>
<a href="#l2.118"></a><span id="l2.118">     //  intent of why we were doing this in the first place.</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineat">@@ -241,17 +240,17 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l2.120"></a><span id="l2.120">     }</span>
<a href="#l2.121"></a><span id="l2.121">   },</span>
<a href="#l2.122"></a><span id="l2.122">   </span>
<a href="#l2.123"></a><span id="l2.123">   // ----- Attachment Routines</span>
<a href="#l2.124"></a><span id="l2.124">   // The attachment processing happens after the initial streaming phase (during</span>
<a href="#l2.125"></a><span id="l2.125">   //  which time we receive the messages, both bodies and headers).  Our caller</span>
<a href="#l2.126"></a><span id="l2.126">   //  traverses the libmime child object hierarchy, emitting an attachment for</span>
<a href="#l2.127"></a><span id="l2.127">   //  each leaf object or sub-message.</span>
<a href="#l2.128"></a><span id="l2.128" class="difflineminus">-  StartAttachment: function mime_emitter_StartAttachment(aName, aContentType,</span>
<a href="#l2.129"></a><span id="l2.129" class="difflineplus">+  startAttachment: function mime_emitter_startAttachment(aName, aContentType,</span>
<a href="#l2.130"></a><span id="l2.130">       aUrl, aNotDownloaded) {</span>
<a href="#l2.131"></a><span id="l2.131">     </span>
<a href="#l2.132"></a><span id="l2.132">     // we need to strip our magic flags from the URL</span>
<a href="#l2.133"></a><span id="l2.133">     aURl = aUrl.replace(&quot;header=filter&amp;emitter=js&amp;&quot;, &quot;&quot;);</span>
<a href="#l2.134"></a><span id="l2.134">     </span>
<a href="#l2.135"></a><span id="l2.135">     // the url should contain a part= piece that tells us the part name, which</span>
<a href="#l2.136"></a><span id="l2.136">     //  we then use to figure out where.</span>
<a href="#l2.137"></a><span id="l2.137">     let partMatch = this._partRE.exec(aUrl);</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineat">@@ -268,53 +267,53 @@ MimeMessageEmitter.prototype = {</span>
<a href="#l2.139"></a><span id="l2.139">       // create the attachment</span>
<a href="#l2.140"></a><span id="l2.140">       part = new this._mimeMsg.MimeMessageAttachment(partName,</span>
<a href="#l2.141"></a><span id="l2.141">           aName, aContentType, aUrl, aNotDownloaded);</span>
<a href="#l2.142"></a><span id="l2.142">     }</span>
<a href="#l2.143"></a><span id="l2.143">     </span>
<a href="#l2.144"></a><span id="l2.144">     this._putPart(part.partName.substring(2), &quot;1&quot;,</span>
<a href="#l2.145"></a><span id="l2.145">                   part, this._rootMsg);</span>
<a href="#l2.146"></a><span id="l2.146">   },</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineminus">-  AddAttachmentField: function mime_emitter_AddAttachmentField(aField, aValue) {</span>
<a href="#l2.148"></a><span id="l2.148" class="difflineplus">+  addAttachmentField: function mime_emitter_addAttachmentField(aField, aValue) {</span>
<a href="#l2.149"></a><span id="l2.149">     // this only gives us X-Mozilla-PartURL, which is the same as aUrl we</span>
<a href="#l2.150"></a><span id="l2.150">     //  already got previously, so need to do anything with this.</span>
<a href="#l2.151"></a><span id="l2.151">   },</span>
<a href="#l2.152"></a><span id="l2.152" class="difflineminus">-  EndAttachment: function mime_emitter_EndAttachment() {</span>
<a href="#l2.153"></a><span id="l2.153" class="difflineplus">+  endAttachment: function mime_emitter_endAttachment() {</span>
<a href="#l2.154"></a><span id="l2.154">     // don't need to do anything here, since we don't care about the headers.</span>
<a href="#l2.155"></a><span id="l2.155">   },</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineminus">-  EndAllAttachments: function mime_emitter_EndAllAttachments() {</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineplus">+  endAllAttachments: function mime_emitter_endAllAttachments() {</span>
<a href="#l2.158"></a><span id="l2.158">     // nop</span>
<a href="#l2.159"></a><span id="l2.159">   },</span>
<a href="#l2.160"></a><span id="l2.160">   </span>
<a href="#l2.161"></a><span id="l2.161">   // ----- Body Routines</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineminus">-  StartBody: function mime_emitter_StartBody(aIsBodyOnly, aMsgID, aOutCharset) {</span>
<a href="#l2.163"></a><span id="l2.163" class="difflineplus">+  startBody: function mime_emitter_startBody(aIsBodyOnly, aMsgID, aOutCharset) {</span>
<a href="#l2.164"></a><span id="l2.164">     this._messageStack.push(this._curMsg);</span>
<a href="#l2.165"></a><span id="l2.165">     this._parentMsg = this._curMsg;</span>
<a href="#l2.166"></a><span id="l2.166">   },</span>
<a href="#l2.167"></a><span id="l2.167">   </span>
<a href="#l2.168"></a><span id="l2.168" class="difflineminus">-  WriteBody: function mime_emitter_WriteBody(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l2.169"></a><span id="l2.169" class="difflineplus">+  writeBody: function mime_emitter_writeBody(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l2.170"></a><span id="l2.170">     this._curMsg.body += aBuf;</span>
<a href="#l2.171"></a><span id="l2.171">   },</span>
<a href="#l2.172"></a><span id="l2.172">   </span>
<a href="#l2.173"></a><span id="l2.173" class="difflineminus">-  EndBody: function mime_emitter_EndBody() {</span>
<a href="#l2.174"></a><span id="l2.174" class="difflineplus">+  endBody: function mime_emitter_endBody() {</span>
<a href="#l2.175"></a><span id="l2.175">     this._messageStack.pop();</span>
<a href="#l2.176"></a><span id="l2.176">     this._parentMsg = this._messageStack[this._messageStack.length - 1];</span>
<a href="#l2.177"></a><span id="l2.177">   },</span>
<a href="#l2.178"></a><span id="l2.178">   </span>
<a href="#l2.179"></a><span id="l2.179">   // ----- Generic Write (confusing)</span>
<a href="#l2.180"></a><span id="l2.180">   // (binary data writing...)</span>
<a href="#l2.181"></a><span id="l2.181" class="difflineminus">-  Write: function mime_emitter_Write(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l2.182"></a><span id="l2.182" class="difflineplus">+  write: function mime_emitter_write(aBuf, aSize, aOutAmountWritten) {</span>
<a href="#l2.183"></a><span id="l2.183">     // we don't actually ever get called because we don't have the attachment</span>
<a href="#l2.184"></a><span id="l2.184">     //  binary payloads pass through us, but we do the following just in case</span>
<a href="#l2.185"></a><span id="l2.185">     //  we did get called (otherwise the caller gets mad and throws exceptions).</span>
<a href="#l2.186"></a><span id="l2.186">     aOutAmountWritten.value = aSize;</span>
<a href="#l2.187"></a><span id="l2.187">   },</span>
<a href="#l2.188"></a><span id="l2.188">   </span>
<a href="#l2.189"></a><span id="l2.189">   // (string writing)</span>
<a href="#l2.190"></a><span id="l2.190" class="difflineminus">-  UtilityWrite: function mime_emitter_UtilityWrite(aBuf) {</span>
<a href="#l2.191"></a><span id="l2.191" class="difflineminus">-    this.Write(aBuf, aBuf.length, {});</span>
<a href="#l2.192"></a><span id="l2.192" class="difflineplus">+  utilityWrite: function mime_emitter_utilityWrite(aBuf) {</span>
<a href="#l2.193"></a><span id="l2.193" class="difflineplus">+    this.write(aBuf, aBuf.length, {});</span>
<a href="#l2.194"></a><span id="l2.194">   },</span>
<a href="#l2.195"></a><span id="l2.195"> };</span>
<a href="#l2.196"></a><span id="l2.196"> </span>
<a href="#l2.197"></a><span id="l2.197"> var components = [MimeMessageEmitter];</span>
<a href="#l2.198"></a><span id="l2.198"> function NSGetModule(compMgr, fileSpec) {</span>
<a href="#l2.199"></a><span id="l2.199">   return XPCOMUtils.generateModule(components);</span>
<a href="#l2.200"></a><span id="l2.200"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/content/glodacomplete.xml</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/content/glodacomplete.xml</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -553,34 +553,34 @@</span>
<a href="#l3.4"></a><span id="l3.4">         &lt;parameter name=&quot;aObj&quot;/&gt;</span>
<a href="#l3.5"></a><span id="l3.5">         &lt;body&gt;</span>
<a href="#l3.6"></a><span id="l3.6">           var node = document.createElementNS(</span>
<a href="#l3.7"></a><span id="l3.7">             &quot;http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul&quot;,</span>
<a href="#l3.8"></a><span id="l3.8">             &quot;richlistitem&quot;);</span>
<a href="#l3.9"></a><span id="l3.9">           </span>
<a href="#l3.10"></a><span id="l3.10">           node.obj = aObj;</span>
<a href="#l3.11"></a><span id="l3.11">           node.setAttribute(&quot;type&quot;,</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineminus">-                            &quot;gloda-&quot; + this.row.nounMeta.name + &quot;-chunk&quot;);</span>
<a href="#l3.13"></a><span id="l3.13" class="difflineplus">+                            &quot;gloda-&quot; + this.row.nounDef.name + &quot;-chunk&quot;);</span>
<a href="#l3.14"></a><span id="l3.14">           </span>
<a href="#l3.15"></a><span id="l3.15">           this._identityHolder.appendChild(node);</span>
<a href="#l3.16"></a><span id="l3.16">         &lt;/body&gt;</span>
<a href="#l3.17"></a><span id="l3.17">       &lt;/method&gt;</span>
<a href="#l3.18"></a><span id="l3.18">       </span>
<a href="#l3.19"></a><span id="l3.19">       &lt;method name=&quot;_adjustAcItem&quot;&gt;</span>
<a href="#l3.20"></a><span id="l3.20">         &lt;body&gt;</span>
<a href="#l3.21"></a><span id="l3.21">           &lt;![CDATA[</span>
<a href="#l3.22"></a><span id="l3.22">           // clear out any lingering children</span>
<a href="#l3.23"></a><span id="l3.23">           while (this._identityHolder.hasChildNodes())</span>
<a href="#l3.24"></a><span id="l3.24">             this._identityHolder.removeChild(this._identityHolder.firstChild);</span>
<a href="#l3.25"></a><span id="l3.25">           </span>
<a href="#l3.26"></a><span id="l3.26">           var row = this.row;</span>
<a href="#l3.27"></a><span id="l3.27">           if (row == null)</span>
<a href="#l3.28"></a><span id="l3.28">             return;</span>
<a href="#l3.29"></a><span id="l3.29">           </span>
<a href="#l3.30"></a><span id="l3.30" class="difflineminus">-          this._explanation.value = row.nounMeta.name + &quot;s &quot; +</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineplus">+          this._explanation.value = row.nounDef.name + &quot;s &quot; +</span>
<a href="#l3.32"></a><span id="l3.32">             row.criteriaType + &quot;ed &quot; + row.criteria;</span>
<a href="#l3.33"></a><span id="l3.33">           </span>
<a href="#l3.34"></a><span id="l3.34">           // render anyone already in there</span>
<a href="#l3.35"></a><span id="l3.35">           for each (let item in row.collection.items) {</span>
<a href="#l3.36"></a><span id="l3.36">             this.renderItem(item);</span>
<a href="#l3.37"></a><span id="l3.37">           }</span>
<a href="#l3.38"></a><span id="l3.38">           // listen up, yo.</span>
<a href="#l3.39"></a><span id="l3.39">           row.renderer = this;</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l4.1"></a><span id="l4.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l4.2"></a><span id="l4.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l4.3"></a><span id="l4.3" class="difflineat">@@ -66,17 +66,17 @@ var GlodaCollectionManager = {</span>
<a href="#l4.4"></a><span id="l4.4"> </span>
<a href="#l4.5"></a><span id="l4.5">   /**</span>
<a href="#l4.6"></a><span id="l4.6">    * Registers the existence of a collection with the collection manager.  This</span>
<a href="#l4.7"></a><span id="l4.7">    *  is done using a weak reference so that the collection can go away if it</span>
<a href="#l4.8"></a><span id="l4.8">    *  wants to.</span>
<a href="#l4.9"></a><span id="l4.9">    */</span>
<a href="#l4.10"></a><span id="l4.10">   registerCollection: function gloda_colm_registerCollection(aCollection) {</span>
<a href="#l4.11"></a><span id="l4.11">     let collections;</span>
<a href="#l4.12"></a><span id="l4.12" class="difflineminus">-    let nounID = aCollection.query._nounMeta.id;</span>
<a href="#l4.13"></a><span id="l4.13" class="difflineplus">+    let nounID = aCollection.query._nounDef.id;</span>
<a href="#l4.14"></a><span id="l4.14">     if (!(nounID in this._collectionsByNoun))</span>
<a href="#l4.15"></a><span id="l4.15">       collections = this._collectionsByNoun[nounID] = [];</span>
<a href="#l4.16"></a><span id="l4.16">     else {</span>
<a href="#l4.17"></a><span id="l4.17">       // purge dead weak references while we're at it</span>
<a href="#l4.18"></a><span id="l4.18">       collections = this._collectionsByNoun[nounID].filter(function (aRef) {</span>
<a href="#l4.19"></a><span id="l4.19">         return aRef.get(); });</span>
<a href="#l4.20"></a><span id="l4.20">       this._collectionsByNoun[nounID] = collections;</span>
<a href="#l4.21"></a><span id="l4.21">     }</span>
<a href="#l4.22"></a><span id="l4.22" class="difflineat">@@ -94,18 +94,18 @@ var GlodaCollectionManager = {</span>
<a href="#l4.23"></a><span id="l4.23">     for (let iColl = 0; iColl &lt; weakCollections.length; iColl++) {</span>
<a href="#l4.24"></a><span id="l4.24">       let collection = weakCollections[iColl].get();</span>
<a href="#l4.25"></a><span id="l4.25">       if (collection)</span>
<a href="#l4.26"></a><span id="l4.26">         collections.push(collection);</span>
<a href="#l4.27"></a><span id="l4.27">     }</span>
<a href="#l4.28"></a><span id="l4.28">     return collections;</span>
<a href="#l4.29"></a><span id="l4.29">   },</span>
<a href="#l4.30"></a><span id="l4.30">   </span>
<a href="#l4.31"></a><span id="l4.31" class="difflineminus">-  defineCache: function gloda_colm_defineCache(aNounMeta, aCacheSize) {</span>
<a href="#l4.32"></a><span id="l4.32" class="difflineminus">-    this._cachesByNoun[aNounMeta.id] = new GlodaLRUCacheCollection(aNounMeta,</span>
<a href="#l4.33"></a><span id="l4.33" class="difflineplus">+  defineCache: function gloda_colm_defineCache(aNounDef, aCacheSize) {</span>
<a href="#l4.34"></a><span id="l4.34" class="difflineplus">+    this._cachesByNoun[aNounDef.id] = new GlodaLRUCacheCollection(aNounDef,</span>
<a href="#l4.35"></a><span id="l4.35">                                                                    aCacheSize);</span>
<a href="#l4.36"></a><span id="l4.36">   },</span>
<a href="#l4.37"></a><span id="l4.37">   </span>
<a href="#l4.38"></a><span id="l4.38">   /**</span>
<a href="#l4.39"></a><span id="l4.39">    * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l4.40"></a><span id="l4.40">    *  given id.  Counts as a cache hit if found.  (And if it was't in a cache,</span>
<a href="#l4.41"></a><span id="l4.41">    *  but rather a collection, it is added to the cache.)</span>
<a href="#l4.42"></a><span id="l4.42">    */</span>
<a href="#l4.43"></a><span id="l4.43" class="difflineat">@@ -376,24 +376,24 @@ var GlodaCollectionManager = {</span>
<a href="#l4.44"></a><span id="l4.44">  * @class A current view of the set of first-class nouns meeting a given query.</span>
<a href="#l4.45"></a><span id="l4.45">  *  Assuming a listener is present, events are</span>
<a href="#l4.46"></a><span id="l4.46">  *  generated when new objects meet the query, existing objects no longer meet</span>
<a href="#l4.47"></a><span id="l4.47">  *  the query, or existing objects have experienced a change in attributes that</span>
<a href="#l4.48"></a><span id="l4.48">  *  does not affect their ability to be present (but the listener may care about</span>
<a href="#l4.49"></a><span id="l4.49">  *  because it is exposing those attributes).</span>
<a href="#l4.50"></a><span id="l4.50">  * @constructor </span>
<a href="#l4.51"></a><span id="l4.51">  */</span>
<a href="#l4.52"></a><span id="l4.52" class="difflineminus">-function GlodaCollection(aNounMeta, aItems, aQuery, aListener) {</span>
<a href="#l4.53"></a><span id="l4.53" class="difflineminus">-  // if aNounMeta is null, we are just being invoked for subclassing</span>
<a href="#l4.54"></a><span id="l4.54" class="difflineminus">-  if (aNounMeta === undefined)</span>
<a href="#l4.55"></a><span id="l4.55" class="difflineplus">+function GlodaCollection(aNounDef, aItems, aQuery, aListener) {</span>
<a href="#l4.56"></a><span id="l4.56" class="difflineplus">+  // if aNounDef is null, we are just being invoked for subclassing</span>
<a href="#l4.57"></a><span id="l4.57" class="difflineplus">+  if (aNounDef === undefined)</span>
<a href="#l4.58"></a><span id="l4.58">     return;</span>
<a href="#l4.59"></a><span id="l4.59"> </span>
<a href="#l4.60"></a><span id="l4.60" class="difflineminus">-  this._nounMeta = aNounMeta;</span>
<a href="#l4.61"></a><span id="l4.61" class="difflineplus">+  this._nounDef = aNounDef;</span>
<a href="#l4.62"></a><span id="l4.62">   // should we also maintain a unique value mapping...</span>
<a href="#l4.63"></a><span id="l4.63" class="difflineminus">-  if (this._nounMeta.usesUniqueValue)</span>
<a href="#l4.64"></a><span id="l4.64" class="difflineplus">+  if (this._nounDef.usesUniqueValue)</span>
<a href="#l4.65"></a><span id="l4.65">     this._uniqueValueMap = {};</span>
<a href="#l4.66"></a><span id="l4.66"> </span>
<a href="#l4.67"></a><span id="l4.67">   this.items = [];</span>
<a href="#l4.68"></a><span id="l4.68">   this._idMap = {};</span>
<a href="#l4.69"></a><span id="l4.69">   </span>
<a href="#l4.70"></a><span id="l4.70">   // force the listener to null for our call to _onItemsAdded; no events for</span>
<a href="#l4.71"></a><span id="l4.71">   //  the initial load-out.</span>
<a href="#l4.72"></a><span id="l4.72">   this._listener = null;</span>
<a href="#l4.73"></a><span id="l4.73" class="difflineat">@@ -481,18 +481,18 @@ GlodaCollection.prototype = {</span>
<a href="#l4.74"></a><span id="l4.74">       this._listener.onQueryCompleted(this);</span>
<a href="#l4.75"></a><span id="l4.75">   }</span>
<a href="#l4.76"></a><span id="l4.76"> };</span>
<a href="#l4.77"></a><span id="l4.77"> </span>
<a href="#l4.78"></a><span id="l4.78"> /**</span>
<a href="#l4.79"></a><span id="l4.79">  * Create an LRU cache collection for the given noun with the given size.</span>
<a href="#l4.80"></a><span id="l4.80">  * @constructor</span>
<a href="#l4.81"></a><span id="l4.81">  */</span>
<a href="#l4.82"></a><span id="l4.82" class="difflineminus">-function GlodaLRUCacheCollection(aNounMeta, aCacheSize) {</span>
<a href="#l4.83"></a><span id="l4.83" class="difflineminus">-  GlodaCollection.call(this, aNounMeta, null, null, null);</span>
<a href="#l4.84"></a><span id="l4.84" class="difflineplus">+function GlodaLRUCacheCollection(aNounDef, aCacheSize) {</span>
<a href="#l4.85"></a><span id="l4.85" class="difflineplus">+  GlodaCollection.call(this, aNounDef, null, null, null);</span>
<a href="#l4.86"></a><span id="l4.86">   </span>
<a href="#l4.87"></a><span id="l4.87">   this._head = null; // aka oldest!</span>
<a href="#l4.88"></a><span id="l4.88">   this._tail = null; // aka newest!</span>
<a href="#l4.89"></a><span id="l4.89">   this._size = 0;</span>
<a href="#l4.90"></a><span id="l4.90">   // let's keep things sane, and simplify our logic a little...</span>
<a href="#l4.91"></a><span id="l4.91">   if (aCacheSize &lt; 32)</span>
<a href="#l4.92"></a><span id="l4.92">     aCacheSize = 32;</span>
<a href="#l4.93"></a><span id="l4.93">   this._maxCacheSize = aCacheSize;</span>
<a href="#l4.94"></a><span id="l4.94" class="difflineat">@@ -543,17 +543,17 @@ GlodaLRUCacheCollection.prototype.add = </span>
<a href="#l4.95"></a><span id="l4.95">     // nuke from our id map</span>
<a href="#l4.96"></a><span id="l4.96">     delete this._idMap[item.id];</span>
<a href="#l4.97"></a><span id="l4.97">     if (this._uniqueValueMap)</span>
<a href="#l4.98"></a><span id="l4.98">       delete this._uniqueValueMap[item.uniqueValue];</span>
<a href="#l4.99"></a><span id="l4.99">     </span>
<a href="#l4.100"></a><span id="l4.100">     // flush dirty items to disk (they may not have this attribute, in which</span>
<a href="#l4.101"></a><span id="l4.101">     //  case, this returns false, which is fine.)</span>
<a href="#l4.102"></a><span id="l4.102">     if (item.dirty) {</span>
<a href="#l4.103"></a><span id="l4.103" class="difflineminus">-      this._nounMeta.objUpdate.call(this._nounMeta.datastore, item);</span>
<a href="#l4.104"></a><span id="l4.104" class="difflineplus">+      this._nounDef.objUpdate.call(this._nounDef.datastore, item);</span>
<a href="#l4.105"></a><span id="l4.105">       delete item.dirty;</span>
<a href="#l4.106"></a><span id="l4.106">     }</span>
<a href="#l4.107"></a><span id="l4.107">     </span>
<a href="#l4.108"></a><span id="l4.108">     this._size--;</span>
<a href="#l4.109"></a><span id="l4.109">   }</span>
<a href="#l4.110"></a><span id="l4.110"> };</span>
<a href="#l4.111"></a><span id="l4.111"> </span>
<a href="#l4.112"></a><span id="l4.112"> GlodaLRUCacheCollection.prototype.hit = function cache_hit(aItem) {</span>
<a href="#l4.113"></a><span id="l4.113" class="difflineat">@@ -603,19 +603,19 @@ GlodaLRUCacheCollection.prototype.delete</span>
<a href="#l4.114"></a><span id="l4.114"> }</span>
<a href="#l4.115"></a><span id="l4.115"> </span>
<a href="#l4.116"></a><span id="l4.116"> /**</span>
<a href="#l4.117"></a><span id="l4.117">  * If any of the cached items are dirty, commit them, and make them no longer</span>
<a href="#l4.118"></a><span id="l4.118">  *  dirty.</span>
<a href="#l4.119"></a><span id="l4.119">  */</span>
<a href="#l4.120"></a><span id="l4.120"> GlodaLRUCacheCollection.prototype.commitDirty = function cache_commitDirty() {</span>
<a href="#l4.121"></a><span id="l4.121">   // we can only do this if there is an update method available...</span>
<a href="#l4.122"></a><span id="l4.122" class="difflineminus">-  if (!this._nounMeta.objUpdate)</span>
<a href="#l4.123"></a><span id="l4.123" class="difflineplus">+  if (!this._nounDef.objUpdate)</span>
<a href="#l4.124"></a><span id="l4.124">     return;</span>
<a href="#l4.125"></a><span id="l4.125"> </span>
<a href="#l4.126"></a><span id="l4.126">   for each (let [iItem, item] in Iterator(this._idMap)) {</span>
<a href="#l4.127"></a><span id="l4.127">     if (item.dirty) {</span>
<a href="#l4.128"></a><span id="l4.128">       LOG.debug(&quot;flushing dirty: &quot; + item);</span>
<a href="#l4.129"></a><span id="l4.129" class="difflineminus">-      this._nounMeta.objUpdate.call(this._nounMeta.datastore, item);</span>
<a href="#l4.130"></a><span id="l4.130" class="difflineplus">+      this._nounDef.objUpdate.call(this._nounDef.datastore, item);</span>
<a href="#l4.131"></a><span id="l4.131">       delete item.dirty;</span>
<a href="#l4.132"></a><span id="l4.132">     }</span>
<a href="#l4.133"></a><span id="l4.133">   }</span>
<a href="#l4.134"></a><span id="l4.134"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l5.1"></a><span id="l5.1" class="difflineminus">--- a/modules/datamodel.js</span>
<a href="#l5.2"></a><span id="l5.2" class="difflineplus">+++ b/modules/datamodel.js</span>
<a href="#l5.3"></a><span id="l5.3" class="difflineat">@@ -45,58 +45,44 @@ const Cr = Components.results;</span>
<a href="#l5.4"></a><span id="l5.4"> const Cu = Components.utils;</span>
<a href="#l5.5"></a><span id="l5.5"> </span>
<a href="#l5.6"></a><span id="l5.6"> Cu.import(&quot;resource://gloda/modules/log4moz.js&quot;);</span>
<a href="#l5.7"></a><span id="l5.7"> const LOG = Log4Moz.Service.getLogger(&quot;gloda.datamodel&quot;);</span>
<a href="#l5.8"></a><span id="l5.8"> </span>
<a href="#l5.9"></a><span id="l5.9"> Cu.import(&quot;resource://gloda/modules/utils.js&quot;);</span>
<a href="#l5.10"></a><span id="l5.10"> </span>
<a href="#l5.11"></a><span id="l5.11"> /**</span>
<a href="#l5.12"></a><span id="l5.12" class="difflineminus">- * @class Represents a gloda attribute definition.</span>
<a href="#l5.13"></a><span id="l5.13" class="difflineplus">+ * @class Represents a gloda attribute definition's DB form.  This class</span>
<a href="#l5.14"></a><span id="l5.14" class="difflineplus">+ *  stores the information in the database relating to this attribute</span>
<a href="#l5.15"></a><span id="l5.15" class="difflineplus">+ *  definition.  Access its attrDef attribute to get at the realy juicy data.</span>
<a href="#l5.16"></a><span id="l5.16" class="difflineplus">+ *  This main interesting thing this class does is serve as the keeper of the</span>
<a href="#l5.17"></a><span id="l5.17" class="difflineplus">+ *  mapping from parameters to attribute ids in the database if this is a </span>
<a href="#l5.18"></a><span id="l5.18" class="difflineplus">+ *  parameterized attribute.</span>
<a href="#l5.19"></a><span id="l5.19">  */</span>
<a href="#l5.20"></a><span id="l5.20" class="difflineminus">-function GlodaAttributeDef(aDatastore, aID, aCompoundName, aProvider, aAttrType,</span>
<a href="#l5.21"></a><span id="l5.21" class="difflineminus">-                           aPluginName, aAttrName, aSubjectTypes,</span>
<a href="#l5.22"></a><span id="l5.22" class="difflineminus">-                           aObjectType, aObjectNounDef) {</span>
<a href="#l5.23"></a><span id="l5.23" class="difflineplus">+function GlodaAttributeDBDef(aDatastore, aID, aCompoundName, aAttrType,</span>
<a href="#l5.24"></a><span id="l5.24" class="difflineplus">+                           aPluginName, aAttrName) {</span>
<a href="#l5.25"></a><span id="l5.25">   this._datastore = aDatastore;</span>
<a href="#l5.26"></a><span id="l5.26">   this._id = aID;</span>
<a href="#l5.27"></a><span id="l5.27">   this._compoundName = aCompoundName;</span>
<a href="#l5.28"></a><span id="l5.28" class="difflineminus">-  this._provider = aProvider;</span>
<a href="#l5.29"></a><span id="l5.29">   this._attrType = aAttrType;</span>
<a href="#l5.30"></a><span id="l5.30">   this._pluginName = aPluginName;</span>
<a href="#l5.31"></a><span id="l5.31">   this._attrName = aAttrName;</span>
<a href="#l5.32"></a><span id="l5.32" class="difflineminus">-  this._subjectTypes = aSubjectTypes;</span>
<a href="#l5.33"></a><span id="l5.33" class="difflineminus">-  this._objectType = aObjectType;</span>
<a href="#l5.34"></a><span id="l5.34" class="difflineminus">-  this._objectNounDef = aObjectNounDef;</span>
<a href="#l5.35"></a><span id="l5.35" class="difflineminus">-</span>
<a href="#l5.36"></a><span id="l5.36" class="difflineminus">-  this.boundName = null;</span>
<a href="#l5.37"></a><span id="l5.37" class="difflineminus">-  this._singular = null;</span>
<a href="#l5.38"></a><span id="l5.38" class="difflineminus">-</span>
<a href="#l5.39"></a><span id="l5.39" class="difflineminus">-  this._special = 0; // not special</span>
<a href="#l5.40"></a><span id="l5.40" class="difflineminus">-  this._specialColumnName = null;</span>
<a href="#l5.41"></a><span id="l5.41" class="difflineplus">+  </span>
<a href="#l5.42"></a><span id="l5.42" class="difflineplus">+  this.attrDef = null;</span>
<a href="#l5.43"></a><span id="l5.43"> </span>
<a href="#l5.44"></a><span id="l5.44">   /** Map parameter values to the underlying database id. */</span>
<a href="#l5.45"></a><span id="l5.45">   this._parameterBindings = {};</span>
<a href="#l5.46"></a><span id="l5.46"> }</span>
<a href="#l5.47"></a><span id="l5.47"> </span>
<a href="#l5.48"></a><span id="l5.48"> GlodaAttributeDef.prototype = {</span>
<a href="#l5.49"></a><span id="l5.49">   get id() { return this._id; },</span>
<a href="#l5.50"></a><span id="l5.50" class="difflineminus">-  get provider() { return this._provider; },</span>
<a href="#l5.51"></a><span id="l5.51">   get attributeName() { return this._attrName; },</span>
<a href="#l5.52"></a><span id="l5.52"> </span>
<a href="#l5.53"></a><span id="l5.53" class="difflineminus">-  get objectNoun() { return this._objectType; },</span>
<a href="#l5.54"></a><span id="l5.54" class="difflineminus">-  get objectNounDef() { return this._objectNounDef; },</span>
<a href="#l5.55"></a><span id="l5.55" class="difflineminus">-</span>
<a href="#l5.56"></a><span id="l5.56" class="difflineminus">-  get isBound() { return this.boundName !== null; },</span>
<a href="#l5.57"></a><span id="l5.57" class="difflineminus">-  get singular() { return this._singular; },</span>
<a href="#l5.58"></a><span id="l5.58" class="difflineminus">-</span>
<a href="#l5.59"></a><span id="l5.59" class="difflineminus">-  get special() { return this._special; },</span>
<a href="#l5.60"></a><span id="l5.60" class="difflineminus">-  get specialColumnName() { return this._specialColumnName; },</span>
<a href="#l5.61"></a><span id="l5.61" class="difflineplus">+  get parameterBindings() { return this._parameterBindings; },</span>
<a href="#l5.62"></a><span id="l5.62">   </span>
<a href="#l5.63"></a><span id="l5.63" class="difflineminus">-  get parameterBindings() { return this._parameterBindings; },</span>
<a href="#l5.64"></a><span id="l5.64" class="difflineminus">-</span>
<a href="#l5.65"></a><span id="l5.65">   /**</span>
<a href="#l5.66"></a><span id="l5.66">    * Bind a parameter value to the attribute definition, allowing use of the</span>
<a href="#l5.67"></a><span id="l5.67">    *  attribute-parameter as an attribute.</span>
<a href="#l5.68"></a><span id="l5.68">    *</span>
<a href="#l5.69"></a><span id="l5.69">    * @return</span>
<a href="#l5.70"></a><span id="l5.70">    */</span>
<a href="#l5.71"></a><span id="l5.71">   bindParameter: function gloda_attr_bindParameter(aValue) {</span>
<a href="#l5.72"></a><span id="l5.72">     // people probably shouldn't call us with null, but handle it</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l6.1"></a><span id="l6.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l6.2"></a><span id="l6.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l6.3"></a><span id="l6.3" class="difflineat">@@ -134,47 +134,47 @@ PostCommitHandler.prototype = {</span>
<a href="#l6.4"></a><span id="l6.4">     GlodaDatastore._asyncCompleted();</span>
<a href="#l6.5"></a><span id="l6.5">   }</span>
<a href="#l6.6"></a><span id="l6.6"> };</span>
<a href="#l6.7"></a><span id="l6.7"> </span>
<a href="#l6.8"></a><span id="l6.8"> /**</span>
<a href="#l6.9"></a><span id="l6.9">  * @class Handles the results from a GlodaDatastore.queryFromQuery call.</span>
<a href="#l6.10"></a><span id="l6.10">  * @constructor</span>
<a href="#l6.11"></a><span id="l6.11">  */</span>
<a href="#l6.12"></a><span id="l6.12" class="difflineminus">-function QueryFromQueryCallback(aStatement, aNounMeta, aCollection) {</span>
<a href="#l6.13"></a><span id="l6.13" class="difflineplus">+function QueryFromQueryCallback(aStatement, aNounDef, aCollection) {</span>
<a href="#l6.14"></a><span id="l6.14">   this.statement = aStatement;</span>
<a href="#l6.15"></a><span id="l6.15" class="difflineminus">-  this.nounMeta = aNounMeta;</span>
<a href="#l6.16"></a><span id="l6.16" class="difflineplus">+  this.nounDef = aNounDef;</span>
<a href="#l6.17"></a><span id="l6.17">   this.collection = aCollection;</span>
<a href="#l6.18"></a><span id="l6.18">   </span>
<a href="#l6.19"></a><span id="l6.19">   this.referencesByNounID = {};</span>
<a href="#l6.20"></a><span id="l6.20"> </span>
<a href="#l6.21"></a><span id="l6.21">   GlodaDatastore._pendingAsyncStatements++;</span>
<a href="#l6.22"></a><span id="l6.22"> }</span>
<a href="#l6.23"></a><span id="l6.23"> </span>
<a href="#l6.24"></a><span id="l6.24"> QueryFromQueryCallback.prototype = {</span>
<a href="#l6.25"></a><span id="l6.25">   handleResult: function gloda_ds_qfq_handleResult(aResultSet) {</span>
<a href="#l6.26"></a><span id="l6.26">     let newItems = [];</span>
<a href="#l6.27"></a><span id="l6.27">     let row;</span>
<a href="#l6.28"></a><span id="l6.28" class="difflineminus">-    let nounMeta = this.nounMeta;</span>
<a href="#l6.29"></a><span id="l6.29" class="difflineplus">+    let nounDef = this.nounDef;</span>
<a href="#l6.30"></a><span id="l6.30">     while (row = aResultSet.getNextRow()) {</span>
<a href="#l6.31"></a><span id="l6.31" class="difflineminus">-      let item = nounMeta.objFromRow.call(nounMeta.datastore, row);</span>
<a href="#l6.32"></a><span id="l6.32" class="difflineplus">+      let item = nounDef.objFromRow.call(nounDef.datastore, row);</span>
<a href="#l6.33"></a><span id="l6.33">       GlodaDatastore.loadNounItem(item, this.referencesByNounID);</span>
<a href="#l6.34"></a><span id="l6.34">       newItems.push(item);</span>
<a href="#l6.35"></a><span id="l6.35">     }</span>
<a href="#l6.36"></a><span id="l6.36">     // have the collection manager attempt to replace the instances we just</span>
<a href="#l6.37"></a><span id="l6.37">     //  created with pre-existing instances.  there is some waste here...</span>
<a href="#l6.38"></a><span id="l6.38">     // XXX consider having collection manager take row objects with the</span>
<a href="#l6.39"></a><span id="l6.39">     //  knowledge of what index is the 'id' index and knowing what objFromRow</span>
<a href="#l6.40"></a><span id="l6.40">     //  method to call if it needs to realize the row.</span>
<a href="#l6.41"></a><span id="l6.41">     // queries have the potential to easily exceed the size of our cache, and</span>
<a href="#l6.42"></a><span id="l6.42">     //  will cause needless churn if so.  as such, indicate that we never want</span>
<a href="#l6.43"></a><span id="l6.43">     //  to have our items added to the cache.  after all, as long as our</span>
<a href="#l6.44"></a><span id="l6.44">     //  collection is alive, they can just be found there anyways.  (and when</span>
<a href="#l6.45"></a><span id="l6.45">     //  found there, they may be promoted to the cache anyways.)</span>
<a href="#l6.46"></a><span id="l6.46" class="difflineminus">-    GlodaCollectionManager.cacheLoadUnify(nounMeta.id, newItems, false);</span>
<a href="#l6.47"></a><span id="l6.47" class="difflineplus">+    GlodaCollectionManager.cacheLoadUnify(nounDef.id, newItems, false);</span>
<a href="#l6.48"></a><span id="l6.48"> </span>
<a href="#l6.49"></a><span id="l6.49">     // just directly tell the collection about the items.  we know the query</span>
<a href="#l6.50"></a><span id="l6.50">     //  matches (at least until we introduce predicates that we cannot express</span>
<a href="#l6.51"></a><span id="l6.51">     //  in SQL.)</span>
<a href="#l6.52"></a><span id="l6.52">     this.collection._onItemsAdded(newItems);</span>
<a href="#l6.53"></a><span id="l6.53">   },</span>
<a href="#l6.54"></a><span id="l6.54"> </span>
<a href="#l6.55"></a><span id="l6.55">   handleError: function gloda_ds_qfq_handleError(aError) {</span>
<a href="#l6.56"></a><span id="l6.56" class="difflineat">@@ -287,21 +287,22 @@ QueryFromQueryCallback.prototype = {</span>
<a href="#l6.57"></a><span id="l6.57"> var GlodaDatastore = {</span>
<a href="#l6.58"></a><span id="l6.58">   _log: null,</span>
<a href="#l6.59"></a><span id="l6.59"> </span>
<a href="#l6.60"></a><span id="l6.60">   /* see Gloda's documentation for these constants */</span>
<a href="#l6.61"></a><span id="l6.61">   kSpecialColumn: 1,</span>
<a href="#l6.62"></a><span id="l6.62">   kSpecialString: 2,</span>
<a href="#l6.63"></a><span id="l6.63">   kSpecialFulltext: 3,</span>
<a href="#l6.64"></a><span id="l6.64">   </span>
<a href="#l6.65"></a><span id="l6.65" class="difflineminus">-  kMagicAttrIDs: -1,</span>
<a href="#l6.66"></a><span id="l6.66" class="difflineminus">-  </span>
<a href="#l6.67"></a><span id="l6.67" class="difflineminus">-  kConstraintEquals: 0,</span>
<a href="#l6.68"></a><span id="l6.68" class="difflineplus">+  kConstraintIdIn: 0,</span>
<a href="#l6.69"></a><span id="l6.69">   kConstraintIn: 1,</span>
<a href="#l6.70"></a><span id="l6.70">   kConstraintRanges: 2,</span>
<a href="#l6.71"></a><span id="l6.71" class="difflineplus">+  kConstraintEquals: 3,</span>
<a href="#l6.72"></a><span id="l6.72" class="difflineplus">+  kConstraintStringLike: 4,</span>
<a href="#l6.73"></a><span id="l6.73" class="difflineplus">+  kConstraintFulltext: 5,</span>
<a href="#l6.74"></a><span id="l6.74"> </span>
<a href="#l6.75"></a><span id="l6.75">   /* ******************* SCHEMA ******************* */</span>
<a href="#l6.76"></a><span id="l6.76"> </span>
<a href="#l6.77"></a><span id="l6.77">   _schemaVersion: 10,</span>
<a href="#l6.78"></a><span id="l6.78">   _schema: {</span>
<a href="#l6.79"></a><span id="l6.79">     tables: {</span>
<a href="#l6.80"></a><span id="l6.80"> </span>
<a href="#l6.81"></a><span id="l6.81">       // ----- Messages</span>
<a href="#l6.82"></a><span id="l6.82" class="difflineat">@@ -954,20 +955,20 @@ var GlodaDatastore = {</span>
<a href="#l6.83"></a><span id="l6.83">    *  decrement the value when the statement completes.</span>
<a href="#l6.84"></a><span id="l6.84">    */</span>
<a href="#l6.85"></a><span id="l6.85">   trackAsync: function() {</span>
<a href="#l6.86"></a><span id="l6.86">     this._pendingAsyncStatements++;</span>
<a href="#l6.87"></a><span id="l6.87">     return this._asyncTrackerListener;</span>
<a href="#l6.88"></a><span id="l6.88">   },</span>
<a href="#l6.89"></a><span id="l6.89"> </span>
<a href="#l6.90"></a><span id="l6.90">   /* ********** Attribute Definitions ********** */</span>
<a href="#l6.91"></a><span id="l6.91" class="difflineminus">-  /** Maps (attribute def) compound names to the GlodaAttributeDef objects. */</span>
<a href="#l6.92"></a><span id="l6.92" class="difflineminus">-  _attributes: {},</span>
<a href="#l6.93"></a><span id="l6.93" class="difflineplus">+  /** Maps (attribute def) compound names to the GlodaAttributeDBDef objects. */</span>
<a href="#l6.94"></a><span id="l6.94" class="difflineplus">+  _attributeDBDefs: {},</span>
<a href="#l6.95"></a><span id="l6.95">   /** Map attribute ID to the definition and parameter value that produce it. */</span>
<a href="#l6.96"></a><span id="l6.96" class="difflineminus">-  _attributeIDToDef: {},</span>
<a href="#l6.97"></a><span id="l6.97" class="difflineplus">+  _attributeIDToDBDefAndParam: {},</span>
<a href="#l6.98"></a><span id="l6.98">   /**</span>
<a href="#l6.99"></a><span id="l6.99">    * We maintain the attributeDefinitions next id counter mainly because we can.</span>
<a href="#l6.100"></a><span id="l6.100">    *  Since we mediate the access, there's no real risk to doing so, and it</span>
<a href="#l6.101"></a><span id="l6.101">    *  allows us to keep the writes on the async connection without having to</span>
<a href="#l6.102"></a><span id="l6.102">    *  wait for a completion notification.</span>
<a href="#l6.103"></a><span id="l6.103">    */</span>
<a href="#l6.104"></a><span id="l6.104">   _nextAttributeId: 1,</span>
<a href="#l6.105"></a><span id="l6.105"> </span>
<a href="#l6.106"></a><span id="l6.106" class="difflineat">@@ -1010,19 +1011,19 @@ var GlodaDatastore = {</span>
<a href="#l6.107"></a><span id="l6.107"> </span>
<a href="#l6.108"></a><span id="l6.108">     iads.executeAsync(this.trackAsync());</span>
<a href="#l6.109"></a><span id="l6.109"> </span>
<a href="#l6.110"></a><span id="l6.110">     return attributeId;</span>
<a href="#l6.111"></a><span id="l6.111">   },</span>
<a href="#l6.112"></a><span id="l6.112"> </span>
<a href="#l6.113"></a><span id="l6.113">   /**</span>
<a href="#l6.114"></a><span id="l6.114">    * Sync-ly look-up all the attribute definitions, populating our authoritative</span>
<a href="#l6.115"></a><span id="l6.115" class="difflineminus">-   *  _attributes and _attributeIDToDef maps.  (In other words, once this method</span>
<a href="#l6.116"></a><span id="l6.116" class="difflineminus">-   *  is called, those maps should always be in sync with the underlying</span>
<a href="#l6.117"></a><span id="l6.117" class="difflineminus">-   *  database.)</span>
<a href="#l6.118"></a><span id="l6.118" class="difflineplus">+   *  _attributeDBDefss and _attributeIDToDBDefAndParam maps.  (In other words,</span>
<a href="#l6.119"></a><span id="l6.119" class="difflineplus">+   *  once this method is called, those maps should always be in sync with the</span>
<a href="#l6.120"></a><span id="l6.120" class="difflineplus">+   *  underlying database.)</span>
<a href="#l6.121"></a><span id="l6.121">    */</span>
<a href="#l6.122"></a><span id="l6.122">   getAllAttributes: function gloda_ds_getAllAttributes() {</span>
<a href="#l6.123"></a><span id="l6.123">     let stmt = this._createSyncStatement(</span>
<a href="#l6.124"></a><span id="l6.124">       &quot;SELECT id, attributeType, extensionName, name, parameter \</span>
<a href="#l6.125"></a><span id="l6.125">          FROM attributeDefinitions&quot;, true);</span>
<a href="#l6.126"></a><span id="l6.126"> </span>
<a href="#l6.127"></a><span id="l6.127">     // map compound name to the attribute</span>
<a href="#l6.128"></a><span id="l6.128">     let attribs = {};</span>
<a href="#l6.129"></a><span id="l6.129" class="difflineat">@@ -1040,48 +1041,46 @@ var GlodaDatastore = {</span>
<a href="#l6.130"></a><span id="l6.130">       let rowParameter = this._getVariant(stmt, 4);</span>
<a href="#l6.131"></a><span id="l6.131"> </span>
<a href="#l6.132"></a><span id="l6.132">       let compoundName = rowExtensionName + &quot;:&quot; + rowName;</span>
<a href="#l6.133"></a><span id="l6.133"> </span>
<a href="#l6.134"></a><span id="l6.134">       let attrib;</span>
<a href="#l6.135"></a><span id="l6.135">       if (compoundName in attribs) {</span>
<a href="#l6.136"></a><span id="l6.136">         attrib = attribs[compoundName];</span>
<a href="#l6.137"></a><span id="l6.137">       } else {</span>
<a href="#l6.138"></a><span id="l6.138" class="difflineminus">-        attrib = new GlodaAttributeDef(this, /* aID */ null,</span>
<a href="#l6.139"></a><span id="l6.139" class="difflineminus">-          compoundName, /* aProvider */ null, rowAttributeType,</span>
<a href="#l6.140"></a><span id="l6.140" class="difflineminus">-          rowExtensionName, rowName, /* subject types */ null,</span>
<a href="#l6.141"></a><span id="l6.141" class="difflineminus">-          /* obj type */ null, /* noun def */ null);</span>
<a href="#l6.142"></a><span id="l6.142" class="difflineplus">+        attrib = new GlodaAttributeDBDef(this, /* aID */ null,</span>
<a href="#l6.143"></a><span id="l6.143" class="difflineplus">+          compoundName, rowAttributeType, rowExtensionName, rowName);</span>
<a href="#l6.144"></a><span id="l6.144">         attribs[compoundName] = attrib;</span>
<a href="#l6.145"></a><span id="l6.145">       }</span>
<a href="#l6.146"></a><span id="l6.146">       // if the parameter is null, the id goes on the attribute def, otherwise</span>
<a href="#l6.147"></a><span id="l6.147">       //  it is a parameter binding and goes in the binding map.</span>
<a href="#l6.148"></a><span id="l6.148">       if (rowParameter == null) {</span>
<a href="#l6.149"></a><span id="l6.149">         attrib._id = rowId;</span>
<a href="#l6.150"></a><span id="l6.150">         idToAttribAndParam[rowId] = [attrib, null];</span>
<a href="#l6.151"></a><span id="l6.151">       } else {</span>
<a href="#l6.152"></a><span id="l6.152">         attrib._parameterBindings[rowParameter] = rowId;</span>
<a href="#l6.153"></a><span id="l6.153">         idToAttribAndParam[rowId] = [attrib, rowParameter];</span>
<a href="#l6.154"></a><span id="l6.154">       }</span>
<a href="#l6.155"></a><span id="l6.155">     }</span>
<a href="#l6.156"></a><span id="l6.156">     stmt.finalize();</span>
<a href="#l6.157"></a><span id="l6.157"> </span>
<a href="#l6.158"></a><span id="l6.158">     this._log.info(&quot;done loading all attribute defs&quot;);</span>
<a href="#l6.159"></a><span id="l6.159"> </span>
<a href="#l6.160"></a><span id="l6.160" class="difflineminus">-    this._attributes = attribs;</span>
<a href="#l6.161"></a><span id="l6.161" class="difflineminus">-    this._attributeIDToDef = idToAttribAndParam;</span>
<a href="#l6.162"></a><span id="l6.162" class="difflineplus">+    this._attributeDBDefs = attribs;</span>
<a href="#l6.163"></a><span id="l6.163" class="difflineplus">+    this._attributeIDToDBDefAndParam = idToAttribAndParam;</span>
<a href="#l6.164"></a><span id="l6.164">   },</span>
<a href="#l6.165"></a><span id="l6.165"> </span>
<a href="#l6.166"></a><span id="l6.166">   /**</span>
<a href="#l6.167"></a><span id="l6.167">    * Helper method for GlodaAttributeDef to tell us when their bindParameter</span>
<a href="#l6.168"></a><span id="l6.168">    *  method is called and they have created a new binding (using</span>
<a href="#l6.169"></a><span id="l6.169">    *  GlodaDatastore._createAttributeDef).  In theory, that method could take</span>
<a href="#l6.170"></a><span id="l6.170">    *  an additional argument and obviate the need for this method.</span>
<a href="#l6.171"></a><span id="l6.171">    */</span>
<a href="#l6.172"></a><span id="l6.172">   reportBinding: function gloda_ds_reportBinding(aID, aAttrDef, aParamValue) {</span>
<a href="#l6.173"></a><span id="l6.173" class="difflineminus">-    this._attributeIDToDef[aID] = [aAttrDef, aParamValue];</span>
<a href="#l6.174"></a><span id="l6.174" class="difflineplus">+    this._attributeIDToDBDefAndParam[aID] = [aAttrDef, aParamValue];</span>
<a href="#l6.175"></a><span id="l6.175">   },</span>
<a href="#l6.176"></a><span id="l6.176"> </span>
<a href="#l6.177"></a><span id="l6.177">   /* ********** Folders ********** */</span>
<a href="#l6.178"></a><span id="l6.178">   /** next folder (row) id to issue, populated by _getAllFolderMappings. */</span>
<a href="#l6.179"></a><span id="l6.179">   _nextFolderId: 1,</span>
<a href="#l6.180"></a><span id="l6.180"> </span>
<a href="#l6.181"></a><span id="l6.181">   get _insertFolderLocationStatement() {</span>
<a href="#l6.182"></a><span id="l6.182">     let statement = this._createAsyncStatement(</span>
<a href="#l6.183"></a><span id="l6.183" class="difflineat">@@ -2038,20 +2037,20 @@ var GlodaDatastore = {</span>
<a href="#l6.184"></a><span id="l6.184">     // A list of [attribute def object, (attr) parameter value, attribute value]</span>
<a href="#l6.185"></a><span id="l6.185">     let attribParamVals = []</span>
<a href="#l6.186"></a><span id="l6.186"> </span>
<a href="#l6.187"></a><span id="l6.187">     let smas = this._selectMessageAttributesByMessageIDStatement;</span>
<a href="#l6.188"></a><span id="l6.188"> </span>
<a href="#l6.189"></a><span id="l6.189">     smas.bindInt64Parameter(0, aMessage.id);</span>
<a href="#l6.190"></a><span id="l6.190">     while (this._syncStep(smas)) {</span>
<a href="#l6.191"></a><span id="l6.191">       let attributeID = smas.getInt64(0);</span>
<a href="#l6.192"></a><span id="l6.192" class="difflineminus">-      if (!(attributeID in this._attributeIDToDef)) {</span>
<a href="#l6.193"></a><span id="l6.193" class="difflineplus">+      if (!(attributeID in this._attributeIDToDBDefAndParam)) {</span>
<a href="#l6.194"></a><span id="l6.194">         this._log.error(&quot;Attribute ID &quot; + attributeID + &quot; not in our map!&quot;);</span>
<a href="#l6.195"></a><span id="l6.195">       }</span>
<a href="#l6.196"></a><span id="l6.196" class="difflineminus">-      let attribAndParam = this._attributeIDToDef[attributeID];</span>
<a href="#l6.197"></a><span id="l6.197" class="difflineplus">+      let attribAndParam = this._attributeIDToDBDefAndParam[attributeID];</span>
<a href="#l6.198"></a><span id="l6.198">       let val = smas.getDouble(1);</span>
<a href="#l6.199"></a><span id="l6.199">       attribParamVals.push([attribAndParam[0], attribAndParam[1], val]);</span>
<a href="#l6.200"></a><span id="l6.200">     }</span>
<a href="#l6.201"></a><span id="l6.201">     smas.reset();</span>
<a href="#l6.202"></a><span id="l6.202"> </span>
<a href="#l6.203"></a><span id="l6.203">     return attribParamVals;</span>
<a href="#l6.204"></a><span id="l6.204">   },</span>
<a href="#l6.205"></a><span id="l6.205"> </span>
<a href="#l6.206"></a><span id="l6.206" class="difflineat">@@ -2060,28 +2059,28 @@ var GlodaDatastore = {</span>
<a href="#l6.207"></a><span id="l6.207">   },</span>
<a href="#l6.208"></a><span id="l6.208">   _numberQuoter: function(aNum) {</span>
<a href="#l6.209"></a><span id="l6.209">     return aNum;</span>
<a href="#l6.210"></a><span id="l6.210">   },</span>
<a href="#l6.211"></a><span id="l6.211"> </span>
<a href="#l6.212"></a><span id="l6.212">   /* ===== Generic Attribute Support ===== */</span>
<a href="#l6.213"></a><span id="l6.213">   adjustAttributes: function gloda_ds_adjustAttributes(aItem, aAddDBAttributes,</span>
<a href="#l6.214"></a><span id="l6.214">       aRemoveDBAttributes) {</span>
<a href="#l6.215"></a><span id="l6.215" class="difflineminus">-    let nounMeta = aItem.NOUN_META;</span>
<a href="#l6.216"></a><span id="l6.216" class="difflineminus">-    let dbMeta = nounMeta._dbMeta;</span>
<a href="#l6.217"></a><span id="l6.217" class="difflineplus">+    let nounDef = aItem.NOUN_DEF;</span>
<a href="#l6.218"></a><span id="l6.218" class="difflineplus">+    let dbMeta = nounDef._dbMeta;</span>
<a href="#l6.219"></a><span id="l6.219">     if (dbMeta.insertAttrStatement === undefined) {</span>
<a href="#l6.220"></a><span id="l6.220">       dbMeta.insertAttrStatement = this._createAsyncStatement(</span>
<a href="#l6.221"></a><span id="l6.221" class="difflineminus">-        &quot;INSERT INTO &quot; + nounMeta.attrTableName +</span>
<a href="#l6.222"></a><span id="l6.222" class="difflineminus">-        &quot; (&quot; + nounMeta.attrIDColumnName + &quot;, attributeID, value) &quot; +</span>
<a href="#l6.223"></a><span id="l6.223" class="difflineplus">+        &quot;INSERT INTO &quot; + nounDef.attrTableName +</span>
<a href="#l6.224"></a><span id="l6.224" class="difflineplus">+        &quot; (&quot; + nounDef.attrIDColumnName + &quot;, attributeID, value) &quot; +</span>
<a href="#l6.225"></a><span id="l6.225">         &quot; VALUES (?1, ?2, ?3)&quot;);</span>
<a href="#l6.226"></a><span id="l6.226">       // we always create this at the same time (right here), no need to check</span>
<a href="#l6.227"></a><span id="l6.227">       dbMeta.deleteAttrStatement = this._createAsyncStatement(</span>
<a href="#l6.228"></a><span id="l6.228" class="difflineminus">-        &quot;DELETE FROM &quot; + nounMeta.attrTableName + &quot; WHERE &quot; +</span>
<a href="#l6.229"></a><span id="l6.229" class="difflineplus">+        &quot;DELETE FROM &quot; + nounDef.attrTableName + &quot; WHERE &quot; +</span>
<a href="#l6.230"></a><span id="l6.230">         &quot; attributeID = ?1 AND value = ?2 AND &quot; +</span>
<a href="#l6.231"></a><span id="l6.231" class="difflineminus">-        nounMeta.attrIDColumnName + &quot; = ?3&quot;);</span>
<a href="#l6.232"></a><span id="l6.232" class="difflineplus">+        nounDef.attrIDColumnName + &quot; = ?3&quot;);</span>
<a href="#l6.233"></a><span id="l6.233">     }</span>
<a href="#l6.234"></a><span id="l6.234"> </span>
<a href="#l6.235"></a><span id="l6.235">     let ias = dbMeta.insertAttrStatement;</span>
<a href="#l6.236"></a><span id="l6.236">     let das = dbMeta.deleteAttrStatement;</span>
<a href="#l6.237"></a><span id="l6.237">     this._beginTransaction();</span>
<a href="#l6.238"></a><span id="l6.238">     try {</span>
<a href="#l6.239"></a><span id="l6.239">       for (let iAttr = 0; iAttr &lt; aAddDBAttributes.length; iAttr++) {</span>
<a href="#l6.240"></a><span id="l6.240">         let attribValueTuple = aAddDBAttributes[iAttr];</span>
<a href="#l6.241"></a><span id="l6.241" class="difflineat">@@ -2119,22 +2118,22 @@ var GlodaDatastore = {</span>
<a href="#l6.242"></a><span id="l6.242">     }</span>
<a href="#l6.243"></a><span id="l6.243">     catch (ex) {</span>
<a href="#l6.244"></a><span id="l6.244">       this._rollbackTransaction();</span>
<a href="#l6.245"></a><span id="l6.245">       throw ex;</span>
<a href="#l6.246"></a><span id="l6.246">     }</span>
<a href="#l6.247"></a><span id="l6.247">   },</span>
<a href="#l6.248"></a><span id="l6.248"> </span>
<a href="#l6.249"></a><span id="l6.249">   clearAttributes: function gloda_ds_clearAttributes(aItem) {</span>
<a href="#l6.250"></a><span id="l6.250" class="difflineminus">-    let nounMeta = aItem.NOUN_META;</span>
<a href="#l6.251"></a><span id="l6.251" class="difflineplus">+    let nounDef = aItem.NOUN_DEF;</span>
<a href="#l6.252"></a><span id="l6.252">     let dbMeta = nounMeta._dbMeta;</span>
<a href="#l6.253"></a><span id="l6.253">     if (dbMeta.clearAttrStatement === undefined) {</span>
<a href="#l6.254"></a><span id="l6.254">       dbMeta.clearAttrStatement = this._createAsyncStatement(</span>
<a href="#l6.255"></a><span id="l6.255" class="difflineminus">-        &quot;DELETE FROM &quot; + nounMeta.attrTableName + &quot; WHERE &quot; +</span>
<a href="#l6.256"></a><span id="l6.256" class="difflineminus">-        nounMeta.attrIDColumnName + &quot; = ?1&quot;);</span>
<a href="#l6.257"></a><span id="l6.257" class="difflineplus">+        &quot;DELETE FROM &quot; + nounDef.attrTableName + &quot; WHERE &quot; +</span>
<a href="#l6.258"></a><span id="l6.258" class="difflineplus">+        nounDef.attrIDColumnName + &quot; = ?1&quot;);</span>
<a href="#l6.259"></a><span id="l6.259">     }</span>
<a href="#l6.260"></a><span id="l6.260">   </span>
<a href="#l6.261"></a><span id="l6.261">     if (aItem.id != null) {</span>
<a href="#l6.262"></a><span id="l6.262">       dbMeta.clearAttrStatement.bindInt64Parameter(0, aItem.id);</span>
<a href="#l6.263"></a><span id="l6.263">       dbMeta.clearAttrStatement.executeAsync(this.trackAsync());</span>
<a href="#l6.264"></a><span id="l6.264">     }</span>
<a href="#l6.265"></a><span id="l6.265">   },</span>
<a href="#l6.266"></a><span id="l6.266"> </span>
<a href="#l6.267"></a><span id="l6.267" class="difflineat">@@ -2144,169 +2143,238 @@ var GlodaDatastore = {</span>
<a href="#l6.268"></a><span id="l6.268">    *  for this reason.</span>
<a href="#l6.269"></a><span id="l6.269">    */</span>
<a href="#l6.270"></a><span id="l6.270">   get _escapeLikeStatement() {</span>
<a href="#l6.271"></a><span id="l6.271">     let statement = this._createAsyncStatement(&quot;SELECT 0&quot;);</span>
<a href="#l6.272"></a><span id="l6.272">     this.__defineGetter__(&quot;_escapeLikeStatement&quot;, function() statement);</span>
<a href="#l6.273"></a><span id="l6.273">     return this._escapeLikeStatement;</span>
<a href="#l6.274"></a><span id="l6.274">   },</span>
<a href="#l6.275"></a><span id="l6.275"> </span>
<a href="#l6.276"></a><span id="l6.276" class="difflineplus">+  _convertToDBValuesAndGroupByAttributeID:</span>
<a href="#l6.277"></a><span id="l6.277" class="difflineplus">+    function gloda_ds__convertToDBValuesAndGroupByAttributeID(aAttrDef,</span>
<a href="#l6.278"></a><span id="l6.278" class="difflineplus">+                                                              aValues) {</span>
<a href="#l6.279"></a><span id="l6.279" class="difflineplus">+    let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l6.280"></a><span id="l6.280" class="difflineplus">+    if (!aAttrDef.usesParameter) {</span>
<a href="#l6.281"></a><span id="l6.281" class="difflineplus">+      let dbValues = [];</span>
<a href="#l6.282"></a><span id="l6.282" class="difflineplus">+      for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l6.283"></a><span id="l6.283" class="difflineplus">+        dbValues.push(objectNounDef.toParamAndValue(aValues[iValue])[1]);</span>
<a href="#l6.284"></a><span id="l6.284" class="difflineplus">+      }</span>
<a href="#l6.285"></a><span id="l6.285" class="difflineplus">+      yield [aAttrDef.id, dbValues];</span>
<a href="#l6.286"></a><span id="l6.286" class="difflineplus">+      return;</span>
<a href="#l6.287"></a><span id="l6.287" class="difflineplus">+    }</span>
<a href="#l6.288"></a><span id="l6.288" class="difflineplus">+    </span>
<a href="#l6.289"></a><span id="l6.289" class="difflineplus">+    let curParam, attrID, dbValues;</span>
<a href="#l6.290"></a><span id="l6.290" class="difflineplus">+    let attrDBDef = aAttrDef.dbDef;</span>
<a href="#l6.291"></a><span id="l6.291" class="difflineplus">+    for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l6.292"></a><span id="l6.292" class="difflineplus">+      let [dbParam, dbValue] = objectNounDef.toParamAndValue(aValues[iValue]);</span>
<a href="#l6.293"></a><span id="l6.293" class="difflineplus">+      if (curParam === undefined) {</span>
<a href="#l6.294"></a><span id="l6.294" class="difflineplus">+        curParam = dbParam;</span>
<a href="#l6.295"></a><span id="l6.295" class="difflineplus">+        attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l6.296"></a><span id="l6.296" class="difflineplus">+        dbValues = [dbValue];</span>
<a href="#l6.297"></a><span id="l6.297" class="difflineplus">+      }</span>
<a href="#l6.298"></a><span id="l6.298" class="difflineplus">+      else if (curParam == dbParam) {</span>
<a href="#l6.299"></a><span id="l6.299" class="difflineplus">+        dbValues.push(dbValue);</span>
<a href="#l6.300"></a><span id="l6.300" class="difflineplus">+      }</span>
<a href="#l6.301"></a><span id="l6.301" class="difflineplus">+      else {</span>
<a href="#l6.302"></a><span id="l6.302" class="difflineplus">+        yield [attrID, dbValues];</span>
<a href="#l6.303"></a><span id="l6.303" class="difflineplus">+        curParam = dbParam;</span>
<a href="#l6.304"></a><span id="l6.304" class="difflineplus">+        attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l6.305"></a><span id="l6.305" class="difflineplus">+        dbValues = [dbValue];</span>
<a href="#l6.306"></a><span id="l6.306" class="difflineplus">+      }</span>
<a href="#l6.307"></a><span id="l6.307" class="difflineplus">+    }</span>
<a href="#l6.308"></a><span id="l6.308" class="difflineplus">+    if (dbValues !== undefined)</span>
<a href="#l6.309"></a><span id="l6.309" class="difflineplus">+      yield [attrID, dbValues];</span>
<a href="#l6.310"></a><span id="l6.310" class="difflineplus">+  },</span>
<a href="#l6.311"></a><span id="l6.311" class="difflineplus">+</span>
<a href="#l6.312"></a><span id="l6.312" class="difflineplus">+  _convertRangesToDBStringsAndGroupByAttributeID:</span>
<a href="#l6.313"></a><span id="l6.313" class="difflineplus">+    function gloda_ds__convertRangesToDBStringsAndGroupByAttributeID(aAttrDef,</span>
<a href="#l6.314"></a><span id="l6.314" class="difflineplus">+      aValues, aValueColumnName) {</span>
<a href="#l6.315"></a><span id="l6.315" class="difflineplus">+    let objectNounDef = aAttrDef.objectNounDef;</span>
<a href="#l6.316"></a><span id="l6.316" class="difflineplus">+    if (!aAttrDef.usesParameter) {</span>
<a href="#l6.317"></a><span id="l6.317" class="difflineplus">+      let dbStrings = [];</span>
<a href="#l6.318"></a><span id="l6.318" class="difflineplus">+      for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l6.319"></a><span id="l6.319" class="difflineplus">+        let [lowerVal, upperVal] = aValues[iValue];</span>
<a href="#l6.320"></a><span id="l6.320" class="difflineplus">+        // they both can't be null.  that is the law.</span>
<a href="#l6.321"></a><span id="l6.321" class="difflineplus">+        if (lowerVal == null)</span>
<a href="#l6.322"></a><span id="l6.322" class="difflineplus">+          dbStrings.push(aValueColumnName + &quot; &lt;= &quot; +</span>
<a href="#l6.323"></a><span id="l6.323" class="difflineplus">+                         objectNounDef.toParamAndValue(upperVal)[1]);</span>
<a href="#l6.324"></a><span id="l6.324" class="difflineplus">+        else if (upperVal == null)</span>
<a href="#l6.325"></a><span id="l6.325" class="difflineplus">+          dbStrings.push(aValueColumnName + &quot; &gt;= &quot; +</span>
<a href="#l6.326"></a><span id="l6.326" class="difflineplus">+                         objectNounDef.toParamAndValue(lowerVal)[1]);</span>
<a href="#l6.327"></a><span id="l6.327" class="difflineplus">+        else // no one is null!</span>
<a href="#l6.328"></a><span id="l6.328" class="difflineplus">+          dbStrings.push(aValueColumnName + &quot; BETWEEN &quot; +</span>
<a href="#l6.329"></a><span id="l6.329" class="difflineplus">+                         objectNounDef.toParamAndValue(lowerVal)[1] + &quot; AND &quot; +</span>
<a href="#l6.330"></a><span id="l6.330" class="difflineplus">+                         objectNounDef.toParamAndValue(upperVal)[1]);</span>
<a href="#l6.331"></a><span id="l6.331" class="difflineplus">+      }</span>
<a href="#l6.332"></a><span id="l6.332" class="difflineplus">+      yield [aAttrDef.id, dbStrings];</span>
<a href="#l6.333"></a><span id="l6.333" class="difflineplus">+      return;</span>
<a href="#l6.334"></a><span id="l6.334" class="difflineplus">+    }</span>
<a href="#l6.335"></a><span id="l6.335" class="difflineplus">+    </span>
<a href="#l6.336"></a><span id="l6.336" class="difflineplus">+    let curParam, attrID, dbStrings;</span>
<a href="#l6.337"></a><span id="l6.337" class="difflineplus">+    let attrDBDef = aAttrDef.dbDef;</span>
<a href="#l6.338"></a><span id="l6.338" class="difflineplus">+    for (let iValue = 0; iValue &lt; aValues.length; iValue++) {</span>
<a href="#l6.339"></a><span id="l6.339" class="difflineplus">+      let [lowerVal, upperVal] = aValues[iValue];</span>
<a href="#l6.340"></a><span id="l6.340" class="difflineplus">+</span>
<a href="#l6.341"></a><span id="l6.341" class="difflineplus">+      let dbString, dbParam, lowerDBVal, upperDBVal;</span>
<a href="#l6.342"></a><span id="l6.342" class="difflineplus">+      // they both can't be null.  that is the law.</span>
<a href="#l6.343"></a><span id="l6.343" class="difflineplus">+      if (lowerVal == null) {</span>
<a href="#l6.344"></a><span id="l6.344" class="difflineplus">+        [dbParam, upperDBVal] = objectNounDef.toParamAndValue(upperVal);</span>
<a href="#l6.345"></a><span id="l6.345" class="difflineplus">+        dbString = aValueColumnName + &quot; &lt;= &quot; + upperDBVal;</span>
<a href="#l6.346"></a><span id="l6.346" class="difflineplus">+      }</span>
<a href="#l6.347"></a><span id="l6.347" class="difflineplus">+      else if (upperVal == null) {</span>
<a href="#l6.348"></a><span id="l6.348" class="difflineplus">+        [dbParam, lowerDBVal] = objectNounDef.toParamAndValue(lowerVal);</span>
<a href="#l6.349"></a><span id="l6.349" class="difflineplus">+        dbString = aValueColumnName + &quot; &gt;= &quot; + lowerDBVal; </span>
<a href="#l6.350"></a><span id="l6.350" class="difflineplus">+      }</span>
<a href="#l6.351"></a><span id="l6.351" class="difflineplus">+      else { // no one is null!</span>
<a href="#l6.352"></a><span id="l6.352" class="difflineplus">+        [dbParam, lowerDBVal] = objectNounDef.toParamAndValue(lowerVal);</span>
<a href="#l6.353"></a><span id="l6.353" class="difflineplus">+        dbString = aValueColumnName + &quot; BETWEEN &quot; + lowerDBVal + &quot; AND &quot; +</span>
<a href="#l6.354"></a><span id="l6.354" class="difflineplus">+                   objectNounDef.toParamAndValue(upperVal)[1];</span>
<a href="#l6.355"></a><span id="l6.355" class="difflineplus">+      }</span>
<a href="#l6.356"></a><span id="l6.356" class="difflineplus">+</span>
<a href="#l6.357"></a><span id="l6.357" class="difflineplus">+      if (curParam === undefined) {</span>
<a href="#l6.358"></a><span id="l6.358" class="difflineplus">+        curParam = dbParam;</span>
<a href="#l6.359"></a><span id="l6.359" class="difflineplus">+        attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l6.360"></a><span id="l6.360" class="difflineplus">+        dbStrings = [dbString];</span>
<a href="#l6.361"></a><span id="l6.361" class="difflineplus">+      }</span>
<a href="#l6.362"></a><span id="l6.362" class="difflineplus">+      else if (curParam == dbParam) {</span>
<a href="#l6.363"></a><span id="l6.363" class="difflineplus">+        dbStrings.push(dbString);</span>
<a href="#l6.364"></a><span id="l6.364" class="difflineplus">+      }</span>
<a href="#l6.365"></a><span id="l6.365" class="difflineplus">+      else {</span>
<a href="#l6.366"></a><span id="l6.366" class="difflineplus">+        yield [attrID, dbStrings];</span>
<a href="#l6.367"></a><span id="l6.367" class="difflineplus">+        curParam = dbParam;</span>
<a href="#l6.368"></a><span id="l6.368" class="difflineplus">+        attrID = attrDBDef.bindParameter(curParam);</span>
<a href="#l6.369"></a><span id="l6.369" class="difflineplus">+        dbStrings = [dbString];</span>
<a href="#l6.370"></a><span id="l6.370" class="difflineplus">+      }</span>
<a href="#l6.371"></a><span id="l6.371" class="difflineplus">+    }</span>
<a href="#l6.372"></a><span id="l6.372" class="difflineplus">+    if (dbStrings !== undefined)</span>
<a href="#l6.373"></a><span id="l6.373" class="difflineplus">+      yield [attrID, dbStrings];</span>
<a href="#l6.374"></a><span id="l6.374" class="difflineplus">+  },</span>
<a href="#l6.375"></a><span id="l6.375" class="difflineplus">+</span>
<a href="#l6.376"></a><span id="l6.376">   /**</span>
<a href="#l6.377"></a><span id="l6.377">    * Perform a database query given a GlodaQueryClass instance that specifies</span>
<a href="#l6.378"></a><span id="l6.378">    *  a set of constraints relating to the noun type associated with the query.</span>
<a href="#l6.379"></a><span id="l6.379">    *  A GlodaCollection is returned containing the results of the look-up.</span>
<a href="#l6.380"></a><span id="l6.380">    *  By default the collection is &quot;live&quot;, and will mutate (generating events to</span>
<a href="#l6.381"></a><span id="l6.381">    *  its listener) as the state of the database changes.</span>
<a href="#l6.382"></a><span id="l6.382">    * This functionality is made user/extension visible by the Query's</span>
<a href="#l6.383"></a><span id="l6.383">    *  getCollection (asynchronous) and getAllSync (synchronous).</span>
<a href="#l6.384"></a><span id="l6.384">    */</span>
<a href="#l6.385"></a><span id="l6.385">   queryFromQuery: function gloda_ds_queryFromQuery(aQuery, aListener,</span>
<a href="#l6.386"></a><span id="l6.386">       bSynchronous, aListenerData) {</span>
<a href="#l6.387"></a><span id="l6.387">     // when changing this method, be sure that GlodaQuery's testMatch function</span>
<a href="#l6.388"></a><span id="l6.388">     //  likewise has its changes made.</span>
<a href="#l6.389"></a><span id="l6.389" class="difflineminus">-    let nounMeta = aQuery._nounMeta;</span>
<a href="#l6.390"></a><span id="l6.390" class="difflineplus">+    let nounDef = aQuery._nounDef;</span>
<a href="#l6.391"></a><span id="l6.391"> </span>
<a href="#l6.392"></a><span id="l6.392">     let whereClauses = [];</span>
<a href="#l6.393"></a><span id="l6.393">     let unionQueries = [aQuery].concat(aQuery._unions);</span>
<a href="#l6.394"></a><span id="l6.394">     let boundArgs = [];</span>
<a href="#l6.395"></a><span id="l6.395"> </span>
<a href="#l6.396"></a><span id="l6.396">     for (let iUnion = 0; iUnion &lt; unionQueries.length; iUnion++) {</span>
<a href="#l6.397"></a><span id="l6.397">       let curQuery = unionQueries[iUnion];</span>
<a href="#l6.398"></a><span id="l6.398">       let selects = [];</span>
<a href="#l6.399"></a><span id="l6.399"> </span>
<a href="#l6.400"></a><span id="l6.400">       for (let iConstraint = 0; iConstraint &lt; curQuery._constraints.length;</span>
<a href="#l6.401"></a><span id="l6.401">            iConstraint++) {</span>
<a href="#l6.402"></a><span id="l6.402" class="difflineminus">-        let attr_ors = curQuery._constraints[iConstraint];</span>
<a href="#l6.403"></a><span id="l6.403" class="difflineminus">-</span>
<a href="#l6.404"></a><span id="l6.404" class="difflineminus">-        let lastAttributeID = null;</span>
<a href="#l6.405"></a><span id="l6.405" class="difflineminus">-        let attrValueTests = [];</span>
<a href="#l6.406"></a><span id="l6.406" class="difflineminus">-        let valueTests = null;</span>
<a href="#l6.407"></a><span id="l6.407" class="difflineminus">-</span>
<a href="#l6.408"></a><span id="l6.408" class="difflineminus">-        // our implementation requires that everyone in attr_ors has the same</span>
<a href="#l6.409"></a><span id="l6.409" class="difflineminus">-        //  attribute.</span>
<a href="#l6.410"></a><span id="l6.410" class="difflineminus">-        let presumedAttr = attr_ors[0][0];</span>
<a href="#l6.411"></a><span id="l6.411" class="difflineminus">-</span>
<a href="#l6.412"></a><span id="l6.412" class="difflineminus">-        // -- handle full-text specially here, it's different than the other</span>
<a href="#l6.413"></a><span id="l6.413" class="difflineminus">-        //  cases...</span>
<a href="#l6.414"></a><span id="l6.414" class="difflineminus">-        if (presumedAttr.special == kSpecialFulltext) {</span>
<a href="#l6.415"></a><span id="l6.415" class="difflineminus">-          let matchStr = [APV[2] for each</span>
<a href="#l6.416"></a><span id="l6.416" class="difflineminus">-            ([iAPV, APV] in Iterator(attr_ors))].join(&quot; OR &quot;);</span>
<a href="#l6.417"></a><span id="l6.417" class="difflineminus">-          matchStr.replace(&quot;'&quot;, &quot;''&quot;);</span>
<a href="#l6.418"></a><span id="l6.418" class="difflineminus">-</span>
<a href="#l6.419"></a><span id="l6.419" class="difflineminus">-          // for example, the match</span>
<a href="#l6.420"></a><span id="l6.420" class="difflineminus">-          let ftSelect = &quot;SELECT docid FROM &quot; + nounMeta.tableName + &quot;Text&quot; +</span>
<a href="#l6.421"></a><span id="l6.421" class="difflineminus">-            &quot; WHERE &quot; + presumedAttr.specialColumnName + &quot; MATCH '&quot; +</span>
<a href="#l6.422"></a><span id="l6.422" class="difflineminus">-            matchStr + &quot;'&quot;;</span>
<a href="#l6.423"></a><span id="l6.423" class="difflineminus">-          selects.push(ftSelect);</span>
<a href="#l6.424"></a><span id="l6.424" class="difflineminus">-</span>
<a href="#l6.425"></a><span id="l6.425" class="difflineminus">-          // bypass the logic used by the other cases</span>
<a href="#l6.426"></a><span id="l6.426" class="difflineminus">-          continue;</span>
<a href="#l6.427"></a><span id="l6.427" class="difflineplus">+        let constraint = curQuery._constraints[iConstraint];</span>
<a href="#l6.428"></a><span id="l6.428" class="difflineplus">+        let [constraintType, attrDef] = constraint;</span>
<a href="#l6.429"></a><span id="l6.429" class="difflineplus">+        let constraintValues = constraint.slice(2);</span>
<a href="#l6.430"></a><span id="l6.430" class="difflineplus">+        </span>
<a href="#l6.431"></a><span id="l6.431" class="difflineplus">+        let idColumnName, tableColumnName;</span>
<a href="#l6.432"></a><span id="l6.432" class="difflineplus">+        if (constraintType == this.kConstraintIdIn) {</span>
<a href="#l6.433"></a><span id="l6.433" class="difflineplus">+          // we don't need any of the next cases' setup code, and we especially</span>
<a href="#l6.434"></a><span id="l6.434" class="difflineplus">+          //  would prefer that attrDef isn't accessed since it's null for us.</span>
<a href="#l6.435"></a><span id="l6.435">         }</span>
<a href="#l6.436"></a><span id="l6.436" class="difflineminus">-</span>
<a href="#l6.437"></a><span id="l6.437" class="difflineminus">-        let tableName, idColumnName, valueColumnName, valueQuoter;</span>
<a href="#l6.438"></a><span id="l6.438" class="difflineminus">-        if (presumedAttr.special == kSpecialColumn ||</span>
<a href="#l6.439"></a><span id="l6.439" class="difflineminus">-            presumedAttr.special == kSpecialString) {</span>
<a href="#l6.440"></a><span id="l6.440" class="difflineminus">-          tableName = nounMeta.tableName;</span>
<a href="#l6.441"></a><span id="l6.441" class="difflineplus">+        else if (attrDef.special) {</span>
<a href="#l6.442"></a><span id="l6.442" class="difflineplus">+          tableName = nounDef.tableName;</span>
<a href="#l6.443"></a><span id="l6.443">           idColumnName = &quot;id&quot;; // canonical id for a table is &quot;id&quot;.</span>
<a href="#l6.444"></a><span id="l6.444" class="difflineminus">-          valueColumnName = presumedAttr.specialColumnName;</span>
<a href="#l6.445"></a><span id="l6.445" class="difflineminus">-          if (presumedAttr.special == kSpecialString)</span>
<a href="#l6.446"></a><span id="l6.446" class="difflineminus">-            valueQuoter = this._stringSQLQuoter;</span>
<a href="#l6.447"></a><span id="l6.447" class="difflineminus">-          else</span>
<a href="#l6.448"></a><span id="l6.448" class="difflineminus">-            valueQuoter = this._numberQuoter;</span>
<a href="#l6.449"></a><span id="l6.449" class="difflineplus">+          valueColumnName = attrDef.specialColumnName;</span>
<a href="#l6.450"></a><span id="l6.450">         }</span>
<a href="#l6.451"></a><span id="l6.451">         else {</span>
<a href="#l6.452"></a><span id="l6.452" class="difflineminus">-          tableName = nounMeta.attrTableName;</span>
<a href="#l6.453"></a><span id="l6.453" class="difflineminus">-          idColumnName = nounMeta.attrIDColumnName;</span>
<a href="#l6.454"></a><span id="l6.454" class="difflineplus">+          tableName = nounDef.attrTableName;</span>
<a href="#l6.455"></a><span id="l6.455" class="difflineplus">+          idColumnName = nounDef.attrIDColumnName;</span>
<a href="#l6.456"></a><span id="l6.456">           valueColumnName = &quot;value&quot;;</span>
<a href="#l6.457"></a><span id="l6.457" class="difflineminus">-          valueQuoter = this._numberQuoter;</span>
<a href="#l6.458"></a><span id="l6.458" class="difflineplus">+        }</span>
<a href="#l6.459"></a><span id="l6.459" class="difflineplus">+        </span>
<a href="#l6.460"></a><span id="l6.460" class="difflineplus">+        let select = null, bindArgs = null;</span>
<a href="#l6.461"></a><span id="l6.461" class="difflineplus">+        if (constraintType === this.kConstraintIdIn) {</span>
<a href="#l6.462"></a><span id="l6.462" class="difflineplus">+          // this is somewhat of a trick.  this does mean that this can be the</span>
<a href="#l6.463"></a><span id="l6.463" class="difflineplus">+          //  only constraint.  Namely, our idiom is:</span>
<a href="#l6.464"></a><span id="l6.464" class="difflineplus">+          // SELECT * FROM blah WHERE id IN (a INTERSECT b INTERSECT c)</span>
<a href="#l6.465"></a><span id="l6.465" class="difflineplus">+          //  but if we only have 'a', then that becomes &quot;...IN (a)&quot;, and if</span>
<a href="#l6.466"></a><span id="l6.466" class="difflineplus">+          //  'a' is not a select but a list of id's... tricky, no?  </span>
<a href="#l6.467"></a><span id="l6.467" class="difflineplus">+          select = constraintValue.join(&quot;,&quot;);</span>
<a href="#l6.468"></a><span id="l6.468">         }</span>
<a href="#l6.469"></a><span id="l6.469" class="difflineminus">-</span>
<a href="#l6.470"></a><span id="l6.470" class="difflineminus">-        // we want a net 'or' for everyone in here, where 'everyone' is presumed</span>
<a href="#l6.471"></a><span id="l6.471" class="difflineminus">-        //  to have been generated from a single attribute.  Since a single</span>
<a href="#l6.472"></a><span id="l6.472" class="difflineminus">-        //  attribute can actually map to multiple attribute id's because of the</span>
<a href="#l6.473"></a><span id="l6.473" class="difflineminus">-        //  parameters, we actually need to make this slightly more complicated</span>
<a href="#l6.474"></a><span id="l6.474" class="difflineminus">-        //  than it could be.  We want to OR together the clauses for testing</span>
<a href="#l6.475"></a><span id="l6.475" class="difflineminus">-        //  each attributeID, where within each clause we OR the value.</span>
<a href="#l6.476"></a><span id="l6.476" class="difflineminus">-        // ex: (attributeID=1 AND (value=1 OR value=2)) OR (attributeID=2 AND</span>
<a href="#l6.477"></a><span id="l6.477" class="difflineminus">-        //      (value=7))</span>
<a href="#l6.478"></a><span id="l6.478" class="difflineminus">-        // note that we don't consolidate things into an IN clause (although</span>
<a href="#l6.479"></a><span id="l6.479" class="difflineminus">-        //  we could) and it's okay because the optimizer makes all such things</span>
<a href="#l6.480"></a><span id="l6.480" class="difflineminus">-        //  equal.</span>
<a href="#l6.481"></a><span id="l6.481" class="difflineminus">-        for (let iOrIndex = 0; iOrIndex &lt; attr_ors.length; iOrIndex++) {</span>
<a href="#l6.482"></a><span id="l6.482" class="difflineminus">-          let APV = attr_ors[iOrIndex];</span>
<a href="#l6.483"></a><span id="l6.483" class="difflineminus">-</span>
<a href="#l6.484"></a><span id="l6.484" class="difflineminus">-          let attributeID;</span>
<a href="#l6.485"></a><span id="l6.485" class="difflineminus">-          if (APV[1] != null)</span>
<a href="#l6.486"></a><span id="l6.486" class="difflineminus">-            attributeID = APV[0].bindParameter(APV[1]);</span>
<a href="#l6.487"></a><span id="l6.487" class="difflineminus">-          else</span>
<a href="#l6.488"></a><span id="l6.488" class="difflineminus">-            attributeID = APV[0].id;</span>
<a href="#l6.489"></a><span id="l6.489" class="difflineminus">-          if (attributeID != lastAttributeID) {</span>
<a href="#l6.490"></a><span id="l6.490" class="difflineminus">-            valueTests = [];</span>
<a href="#l6.491"></a><span id="l6.491" class="difflineminus">-            if (APV[0].special == kSpecialColumn ||</span>
<a href="#l6.492"></a><span id="l6.492" class="difflineminus">-                APV[0].special == kSpecialString)</span>
<a href="#l6.493"></a><span id="l6.493" class="difflineminus">-              attrValueTests.push([&quot;&quot;, valueTests]);</span>
<a href="#l6.494"></a><span id="l6.494" class="difflineminus">-            else</span>
<a href="#l6.495"></a><span id="l6.495" class="difflineminus">-              attrValueTests.push([&quot;attributeID = &quot; + attributeID, valueTests]);</span>
<a href="#l6.496"></a><span id="l6.496" class="difflineminus">-            lastAttributeID = attributeID;</span>
<a href="#l6.497"></a><span id="l6.497" class="difflineplus">+        else if (constraintType === this.kConstraintIn) {</span>
<a href="#l6.498"></a><span id="l6.498" class="difflineplus">+          let clauses = [];</span>
<a href="#l6.499"></a><span id="l6.499" class="difflineplus">+          for each ([attrID, values] in</span>
<a href="#l6.500"></a><span id="l6.500" class="difflineplus">+              this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l6.501"></a><span id="l6.501" class="difflineplus">+                                                           constraintValues)) {</span>
<a href="#l6.502"></a><span id="l6.502" class="difflineplus">+            clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l6.503"></a><span id="l6.503" class="difflineplus">+                         &quot; AND &quot; + valueColumnName + &quot; IN (&quot; +</span>
<a href="#l6.504"></a><span id="l6.504" class="difflineplus">+                         values.join(&quot;,&quot;) + &quot;))&quot;);</span>
<a href="#l6.505"></a><span id="l6.505">           }</span>
<a href="#l6.506"></a><span id="l6.506" class="difflineminus">-</span>
<a href="#l6.507"></a><span id="l6.507" class="difflineminus">-          // straight value match?</span>
<a href="#l6.508"></a><span id="l6.508" class="difflineminus">-          if (APV.length == 3) {</span>
<a href="#l6.509"></a><span id="l6.509" class="difflineminus">-            if (APV[2] != null)</span>
<a href="#l6.510"></a><span id="l6.510" class="difflineminus">-              valueTests.push(valueColumnName + &quot; = &quot; + valueQuoter(APV[2]));</span>
<a href="#l6.511"></a><span id="l6.511" class="difflineplus">+          select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName +</span>
<a href="#l6.512"></a><span id="l6.512" class="difflineplus">+            &quot; WHERE &quot; + clauses.join(&quot; OR &quot;);</span>
<a href="#l6.513"></a><span id="l6.513" class="difflineplus">+        }</span>
<a href="#l6.514"></a><span id="l6.514" class="difflineplus">+        else if (constraintType === this.kConstraintRanges) {</span>
<a href="#l6.515"></a><span id="l6.515" class="difflineplus">+          let clauses = [];</span>
<a href="#l6.516"></a><span id="l6.516" class="difflineplus">+          for each ([attrID, dbStrings] in</span>
<a href="#l6.517"></a><span id="l6.517" class="difflineplus">+              this._convertRangesToDBStringsAndGroupByAttributeID(attrDef,</span>
<a href="#l6.518"></a><span id="l6.518" class="difflineplus">+                              constraintValues, valueColumnName)) {</span>
<a href="#l6.519"></a><span id="l6.519" class="difflineplus">+            clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l6.520"></a><span id="l6.520" class="difflineplus">+                         &quot; AND (&quot; + dbStrings.join(&quot; OR &quot;) + &quot;))&quot;);</span>
<a href="#l6.521"></a><span id="l6.521">           }</span>
<a href="#l6.522"></a><span id="l6.522" class="difflineminus">-          // (quoting is not required for ranges because we only support ranges</span>
<a href="#l6.523"></a><span id="l6.523" class="difflineminus">-          //  for numbers.  as such, no use of valueQuoter in here.)</span>
<a href="#l6.524"></a><span id="l6.524" class="difflineminus">-          else { // APV.length == 4, so range match</span>
<a href="#l6.525"></a><span id="l6.525" class="difflineminus">-            // - numeric case (no quoting in here)</span>
<a href="#l6.526"></a><span id="l6.526" class="difflineminus">-            if (presumedAttr.special != kSpecialString) {</span>
<a href="#l6.527"></a><span id="l6.527" class="difflineminus">-              if (APV[2] === null) // so just &lt;=</span>
<a href="#l6.528"></a><span id="l6.528" class="difflineminus">-                valueTests.push(valueColumnName + &quot; &lt;= &quot; + APV[3]);</span>
<a href="#l6.529"></a><span id="l6.529" class="difflineminus">-              else if (APV[3] === null) // so just &gt;=</span>
<a href="#l6.530"></a><span id="l6.530" class="difflineminus">-              // BETWEEN is optimized to &gt;= and &lt;=, or we could just do that</span>
<a href="#l6.531"></a><span id="l6.531" class="difflineminus">-              //  ourself (in other words, this shouldn't hurt our use of indices)</span>
<a href="#l6.532"></a><span id="l6.532" class="difflineminus">-                valueTests.push(valueColumnName + &quot; &gt;= &quot; + APV[2]);</span>
<a href="#l6.533"></a><span id="l6.533" class="difflineminus">-              else</span>
<a href="#l6.534"></a><span id="l6.534" class="difflineminus">-                valueTests.push(valueColumnName + &quot; BETWEEN &quot; + APV[2] +</span>
<a href="#l6.535"></a><span id="l6.535" class="difflineminus">-                                  &quot; AND &quot; + APV[3]);</span>
<a href="#l6.536"></a><span id="l6.536" class="difflineminus">-            }</span>
<a href="#l6.537"></a><span id="l6.537" class="difflineminus">-            // - string case (LIKE)</span>
<a href="#l6.538"></a><span id="l6.538" class="difflineminus">-            else {</span>
<a href="#l6.539"></a><span id="l6.539" class="difflineminus">-              // this will result in a warning in debug builds.  as we move to</span>
<a href="#l6.540"></a><span id="l6.540" class="difflineminus">-              //  supporting async operation, we should also move to binding all</span>
<a href="#l6.541"></a><span id="l6.541" class="difflineminus">-              //  arguments for dynamic queries too.</span>
<a href="#l6.542"></a><span id="l6.542" class="difflineminus">-              likePayload = '';</span>
<a href="#l6.543"></a><span id="l6.543" class="difflineminus">-              for each (let [iValuePart, valuePart] in Iterator(APV[2])) {</span>
<a href="#l6.544"></a><span id="l6.544" class="difflineminus">-                if (typeof valuePart == &quot;string&quot;)</span>
<a href="#l6.545"></a><span id="l6.545" class="difflineminus">-                  likePayload += this._escapeLikeStatement.escapeStringForLIKE(</span>
<a href="#l6.546"></a><span id="l6.546" class="difflineminus">-                    valuePart, &quot;/&quot;);</span>
<a href="#l6.547"></a><span id="l6.547" class="difflineminus">-                else</span>
<a href="#l6.548"></a><span id="l6.548" class="difflineminus">-                  likePayload += &quot;%&quot;;</span>
<a href="#l6.549"></a><span id="l6.549" class="difflineminus">-              }</span>
<a href="#l6.550"></a><span id="l6.550" class="difflineminus">-              valueTests.push(valueColumnName + &quot; LIKE ? ESCAPE '/'&quot;);</span>
<a href="#l6.551"></a><span id="l6.551" class="difflineminus">-              boundArgs.push(likePayload);</span>
<a href="#l6.552"></a><span id="l6.552" class="difflineminus">-            }</span>
<a href="#l6.553"></a><span id="l6.553" class="difflineplus">+          select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName +</span>
<a href="#l6.554"></a><span id="l6.554" class="difflineplus">+            &quot; WHERE &quot; + clauses.join(&quot; OR &quot;);</span>
<a href="#l6.555"></a><span id="l6.555" class="difflineplus">+        }</span>
<a href="#l6.556"></a><span id="l6.556" class="difflineplus">+        else if (constraintType === this.kConstraintEquals) {</span>
<a href="#l6.557"></a><span id="l6.557" class="difflineplus">+          let clauses = [];</span>
<a href="#l6.558"></a><span id="l6.558" class="difflineplus">+          for each ([attrID, values] in</span>
<a href="#l6.559"></a><span id="l6.559" class="difflineplus">+              this._convertToDBValuesAndGroupByAttributeID(attrDef,</span>
<a href="#l6.560"></a><span id="l6.560" class="difflineplus">+                                                           constraintValues)) {</span>
<a href="#l6.561"></a><span id="l6.561" class="difflineplus">+            clauses.push(&quot;(attributeID = &quot; + attrID +</span>
<a href="#l6.562"></a><span id="l6.562" class="difflineplus">+                         &quot; AND (&quot; + [valueColumnName + &quot; = ?&quot; for each</span>
<a href="#l6.563"></a><span id="l6.563" class="difflineplus">+                         (value in values)].join(&quot;OR&quot;) + &quot;)&quot;);</span>
<a href="#l6.564"></a><span id="l6.564" class="difflineplus">+            boundArgs.push.apply(boundArgs, values);</span>
<a href="#l6.565"></a><span id="l6.565">           }</span>
<a href="#l6.566"></a><span id="l6.566" class="difflineplus">+          select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName +</span>
<a href="#l6.567"></a><span id="l6.567" class="difflineplus">+            &quot; WHERE &quot; + clauses.join(&quot; OR &quot;);</span>
<a href="#l6.568"></a><span id="l6.568">         }</span>
<a href="#l6.569"></a><span id="l6.569" class="difflineminus">-        let select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName +</span>
<a href="#l6.570"></a><span id="l6.570" class="difflineminus">-          &quot; WHERE &quot; +</span>
<a href="#l6.571"></a><span id="l6.571" class="difflineminus">-          [(&quot;(&quot; + avt[0] +</span>
<a href="#l6.572"></a><span id="l6.572" class="difflineminus">-            (avt[1].length ? ((avt[0] ? &quot; AND &quot; : &quot;&quot;) + &quot;(&quot; </span>
<a href="#l6.573"></a><span id="l6.573" class="difflineminus">-                 + avt[1].join(&quot; OR &quot;) + &quot;)&quot;) :</span>
<a href="#l6.574"></a><span id="l6.574" class="difflineminus">-               &quot;&quot;)</span>
<a href="#l6.575"></a><span id="l6.575" class="difflineminus">-            + &quot;)&quot;)</span>
<a href="#l6.576"></a><span id="l6.576" class="difflineminus">-           for each ([i, avt] in Iterator(attrValueTests))].join(&quot; OR &quot;);</span>
<a href="#l6.577"></a><span id="l6.577" class="difflineminus">-        selects.push(select);</span>
<a href="#l6.578"></a><span id="l6.578" class="difflineplus">+        else if (constraintType === this.kConstraintStringLike) {</span>
<a href="#l6.579"></a><span id="l6.579" class="difflineplus">+          likePayload = '';</span>
<a href="#l6.580"></a><span id="l6.580" class="difflineplus">+          for each (let [iValuePart, valuePart] in Iterator(constraintValues) {</span>
<a href="#l6.581"></a><span id="l6.581" class="difflineplus">+            if (typeof valuePart == &quot;string&quot;)</span>
<a href="#l6.582"></a><span id="l6.582" class="difflineplus">+              likePayload += this._escapeLikeStatement.escapeStringForLIKE(</span>
<a href="#l6.583"></a><span id="l6.583" class="difflineplus">+                valuePart, &quot;/&quot;);</span>
<a href="#l6.584"></a><span id="l6.584" class="difflineplus">+            else</span>
<a href="#l6.585"></a><span id="l6.585" class="difflineplus">+              likePayload += &quot;%&quot;;</span>
<a href="#l6.586"></a><span id="l6.586" class="difflineplus">+          }</span>
<a href="#l6.587"></a><span id="l6.587" class="difflineplus">+          select = &quot;SELECT &quot; + idColumnName + &quot; FROM &quot; + tableName +</span>
<a href="#l6.588"></a><span id="l6.588" class="difflineplus">+            &quot; WHERE &quot; + valueColumnName + &quot; LIKE ? ESCAPE '/'&quot;;</span>
<a href="#l6.589"></a><span id="l6.589" class="difflineplus">+          boundArgs.push(likePayload);</span>
<a href="#l6.590"></a><span id="l6.590" class="difflineplus">+        }</span>
<a href="#l6.591"></a><span id="l6.591" class="difflineplus">+        else if (constraintType === this.kConstraintFulltext) {</span>
<a href="#l6.592"></a><span id="l6.592" class="difflineplus">+          let matchStr = constraintValues[0];</span>
<a href="#l6.593"></a><span id="l6.593" class="difflineplus">+          select = &quot;SELECT docid FROM &quot; + nounDef.tableName + &quot;Text&quot; +</span>
<a href="#l6.594"></a><span id="l6.594" class="difflineplus">+            &quot; WHERE &quot; + attrDef.specialColumnName + &quot; MATCH ?&quot;;</span>
<a href="#l6.595"></a><span id="l6.595" class="difflineplus">+          boundArgs.push(matchStr);</span>
<a href="#l6.596"></a><span id="l6.596" class="difflineplus">+        }</span>
<a href="#l6.597"></a><span id="l6.597" class="difflineplus">+        </span>
<a href="#l6.598"></a><span id="l6.598" class="difflineplus">+        if (select)</span>
<a href="#l6.599"></a><span id="l6.599" class="difflineplus">+          selects.push(select);</span>
<a href="#l6.600"></a><span id="l6.600" class="difflineplus">+        else</span>
<a href="#l6.601"></a><span id="l6.601" class="difflineplus">+          this._log.warning(&quot;Unable to translate constraint of type &quot; + </span>
<a href="#l6.602"></a><span id="l6.602" class="difflineplus">+            constraintType + &quot; on attribute bound as &quot; + aAttrDef.boundName);</span>
<a href="#l6.603"></a><span id="l6.603">       }</span>
<a href="#l6.604"></a><span id="l6.604"> </span>
<a href="#l6.605"></a><span id="l6.605">       if (selects.length)</span>
<a href="#l6.606"></a><span id="l6.606">         whereClauses.push(&quot;id IN (&quot; + selects.join(&quot; INTERSECT &quot;) + &quot; )&quot;);</span>
<a href="#l6.607"></a><span id="l6.607">     }</span>
<a href="#l6.608"></a><span id="l6.608"> </span>
<a href="#l6.609"></a><span id="l6.609" class="difflineminus">-    let sqlString = &quot;SELECT * FROM &quot; + nounMeta.tableName;</span>
<a href="#l6.610"></a><span id="l6.610" class="difflineplus">+    let sqlString = &quot;SELECT * FROM &quot; + nounDef.tableName;</span>
<a href="#l6.611"></a><span id="l6.611">     if (whereClauses.length)</span>
<a href="#l6.612"></a><span id="l6.612">       sqlString += &quot; WHERE &quot; + whereClauses.join(&quot; OR &quot;);</span>
<a href="#l6.613"></a><span id="l6.613">     </span>
<a href="#l6.614"></a><span id="l6.614">     if (aQuery._order.length) {</span>
<a href="#l6.615"></a><span id="l6.615">       let orderClauses = [];</span>
<a href="#l6.616"></a><span id="l6.616">       for (let [, colName] in Iterator(aQuery._order)) {</span>
<a href="#l6.617"></a><span id="l6.617">          if (colName[0] == &quot;-&quot;)</span>
<a href="#l6.618"></a><span id="l6.618">            orderClauses.push(colName.substring(1) + &quot; DESC&quot;);</span>
<a href="#l6.619"></a><span id="l6.619" class="difflineat">@@ -2327,63 +2395,63 @@ var GlodaDatastore = {</span>
<a href="#l6.620"></a><span id="l6.620">     if (bSynchronous) {</span>
<a href="#l6.621"></a><span id="l6.621">       let statement = this._createSyncStatement(sqlString, true);</span>
<a href="#l6.622"></a><span id="l6.622">       for (let [iBinding, bindingValue] in Iterator(boundArgs)) {</span>
<a href="#l6.623"></a><span id="l6.623">         this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l6.624"></a><span id="l6.624">       }</span>
<a href="#l6.625"></a><span id="l6.625"> </span>
<a href="#l6.626"></a><span id="l6.626">       let items = [];</span>
<a href="#l6.627"></a><span id="l6.627">       while (this._syncStep(statement)) {</span>
<a href="#l6.628"></a><span id="l6.628" class="difflineminus">-        items.push(nounMeta.objFromRow.call(nounMeta.datastore, statement));</span>
<a href="#l6.629"></a><span id="l6.629" class="difflineplus">+        items.push(nounDef.objFromRow.call(nounDef.datastore, statement));</span>
<a href="#l6.630"></a><span id="l6.630">       }</span>
<a href="#l6.631"></a><span id="l6.631">       statement.finalize();</span>
<a href="#l6.632"></a><span id="l6.632"> </span>
<a href="#l6.633"></a><span id="l6.633">       // have the collection manager attempt to replace the instances we just</span>
<a href="#l6.634"></a><span id="l6.634">       //  created with pre-existing instances.  if the instance didn't exist,</span>
<a href="#l6.635"></a><span id="l6.635">       //  cache the newly observed ones.  We are trading off wastes here; we don't</span>
<a href="#l6.636"></a><span id="l6.636">       //  want to have to ask the collection manager about every row, and we don't</span>
<a href="#l6.637"></a><span id="l6.637">       //  want to invent some alternate row storage.</span>
<a href="#l6.638"></a><span id="l6.638" class="difflineminus">-      GlodaCollectionManager.cacheLoadUnify(nounMeta.id, items);</span>
<a href="#l6.639"></a><span id="l6.639" class="difflineminus">-      collection = new GlodaCollection(nounMeta, items, aQuery, aListener);</span>
<a href="#l6.640"></a><span id="l6.640" class="difflineplus">+      GlodaCollectionManager.cacheLoadUnify(nounDef.id, items);</span>
<a href="#l6.641"></a><span id="l6.641" class="difflineplus">+      collection = new GlodaCollection(nounDef, items, aQuery, aListener);</span>
<a href="#l6.642"></a><span id="l6.642">       if (aListenerData !== undefined)</span>
<a href="#l6.643"></a><span id="l6.643">         collection.data = aListenerData;</span>
<a href="#l6.644"></a><span id="l6.644"> </span>
<a href="#l6.645"></a><span id="l6.645">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l6.646"></a><span id="l6.646">     }</span>
<a href="#l6.647"></a><span id="l6.647">     else { // async!</span>
<a href="#l6.648"></a><span id="l6.648">       let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l6.649"></a><span id="l6.649">       for (let [iBinding, bindingValue] in Iterator(boundArgs)) {</span>
<a href="#l6.650"></a><span id="l6.650">         this._bindVariant(statement, iBinding, bindingValue);</span>
<a href="#l6.651"></a><span id="l6.651">       }</span>
<a href="#l6.652"></a><span id="l6.652"> </span>
<a href="#l6.653"></a><span id="l6.653" class="difflineminus">-      collection = new GlodaCollection(nounMeta, [], aQuery, aListener);</span>
<a href="#l6.654"></a><span id="l6.654" class="difflineplus">+      collection = new GlodaCollection(nounDef, [], aQuery, aListener);</span>
<a href="#l6.655"></a><span id="l6.655">       if (aListenerData !== undefined)</span>
<a href="#l6.656"></a><span id="l6.656">         collection.data = aListenerData;</span>
<a href="#l6.657"></a><span id="l6.657">       GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l6.658"></a><span id="l6.658"> </span>
<a href="#l6.659"></a><span id="l6.659" class="difflineminus">-      statement.executeAsync(new QueryFromQueryCallback(statement, nounMeta,</span>
<a href="#l6.660"></a><span id="l6.660" class="difflineplus">+      statement.executeAsync(new QueryFromQueryCallback(statement, nounDef,</span>
<a href="#l6.661"></a><span id="l6.661">         collection));</span>
<a href="#l6.662"></a><span id="l6.662">       statement.finalize();</span>
<a href="#l6.663"></a><span id="l6.663">     }</span>
<a href="#l6.664"></a><span id="l6.664">     return collection;</span>
<a href="#l6.665"></a><span id="l6.665">   },</span>
<a href="#l6.666"></a><span id="l6.666"> </span>
<a href="#l6.667"></a><span id="l6.667">   loadNounItem: function gloda_ds_loadNounItem(aItem, aReferencesByNounID) {</span>
<a href="#l6.668"></a><span id="l6.668">     let jsonDict = this._json.decode(aItem._jsonText);</span>
<a href="#l6.669"></a><span id="l6.669">     delete aItem._jsonText;</span>
<a href="#l6.670"></a><span id="l6.670">     </span>
<a href="#l6.671"></a><span id="l6.671" class="difflineminus">-    let attribIDToDef = this._attributeIDToDef;</span>
<a href="#l6.672"></a><span id="l6.672" class="difflineplus">+    let attribIDToDBDefAndParam = this._attributeIDToDBDefAndParam;</span>
<a href="#l6.673"></a><span id="l6.673">     </span>
<a href="#l6.674"></a><span id="l6.674">     let deps = {};</span>
<a href="#l6.675"></a><span id="l6.675">     let hasDeps = false;</span>
<a href="#l6.676"></a><span id="l6.676">     </span>
<a href="#l6.677"></a><span id="l6.677">     // Iterate over the attributes on the item</span>
<a href="#l6.678"></a><span id="l6.678">     for each (let [attribId, jsonValue] in Iterator(jsonDict)) {</span>
<a href="#l6.679"></a><span id="l6.679">       // find the attribute definition that corresponds to this key</span>
<a href="#l6.680"></a><span id="l6.680" class="difflineminus">-      let attrib = attribIDToDef[attribId][0];</span>
<a href="#l6.681"></a><span id="l6.681" class="difflineplus">+      let attrib = attribIDToDBDefAndParam[attribId][0];</span>
<a href="#l6.682"></a><span id="l6.682">       // the attribute should only fail to exist if an extension was removed</span>
<a href="#l6.683"></a><span id="l6.683">       if (attrib === undefined)</span>
<a href="#l6.684"></a><span id="l6.684">         continue;</span>
<a href="#l6.685"></a><span id="l6.685">       </span>
<a href="#l6.686"></a><span id="l6.686">       let objectNounDef = attrib.objectNounDef;</span>
<a href="#l6.687"></a><span id="l6.687">       </span>
<a href="#l6.688"></a><span id="l6.688">       // if it has a tableName member, then it's a persistent object that needs</span>
<a href="#l6.689"></a><span id="l6.689">       //  to be loaded, which also means we need to hold it in a collection</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l7.1"></a><span id="l7.1" class="difflineminus">--- a/modules/explattr.js</span>
<a href="#l7.2"></a><span id="l7.2" class="difflineplus">+++ b/modules/explattr.js</span>
<a href="#l7.3"></a><span id="l7.3" class="difflineat">@@ -94,46 +94,43 @@ var GlodaExplicitAttr = {</span>
<a href="#l7.4"></a><span id="l7.4">   </span>
<a href="#l7.5"></a><span id="l7.5">   defineAttributes: function() {</span>
<a href="#l7.6"></a><span id="l7.6">     // Tag</span>
<a href="#l7.7"></a><span id="l7.7">     this._attrTag = Gloda.defineAttribute({</span>
<a href="#l7.8"></a><span id="l7.8">                         provider: this,</span>
<a href="#l7.9"></a><span id="l7.9">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l7.10"></a><span id="l7.10">                         attributeType: Gloda.kAttrExplicit,</span>
<a href="#l7.11"></a><span id="l7.11">                         attributeName: &quot;tag&quot;,</span>
<a href="#l7.12"></a><span id="l7.12" class="difflineminus">-                        bind: true,</span>
<a href="#l7.13"></a><span id="l7.13">                         bindName: &quot;tags&quot;,</span>
<a href="#l7.14"></a><span id="l7.14">                         singular: false,</span>
<a href="#l7.15"></a><span id="l7.15">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l7.16"></a><span id="l7.16">                         objectNoun: Gloda.NOUN_TAG,</span>
<a href="#l7.17"></a><span id="l7.17">                         parameterNoun: null,</span>
<a href="#l7.18"></a><span id="l7.18">                         // Property change notifications that we care about:</span>
<a href="#l7.19"></a><span id="l7.19">                         propertyChanges: [&quot;keywords&quot;],</span>
<a href="#l7.20"></a><span id="l7.20">                         }); // not-tested</span>
<a href="#l7.21"></a><span id="l7.21"> </span>
<a href="#l7.22"></a><span id="l7.22">     // Star</span>
<a href="#l7.23"></a><span id="l7.23">     this._attrStar = Gloda.defineAttribute({</span>
<a href="#l7.24"></a><span id="l7.24">                         provider: this,</span>
<a href="#l7.25"></a><span id="l7.25">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l7.26"></a><span id="l7.26">                         attributeType: Gloda.kAttrExplicit,</span>
<a href="#l7.27"></a><span id="l7.27">                         attributeName: &quot;star&quot;,</span>
<a href="#l7.28"></a><span id="l7.28" class="difflineminus">-                        bind: true,</span>
<a href="#l7.29"></a><span id="l7.29">                         bindName: &quot;starred&quot;,</span>
<a href="#l7.30"></a><span id="l7.30">                         singular: true,</span>
<a href="#l7.31"></a><span id="l7.31">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l7.32"></a><span id="l7.32">                         objectNoun: Gloda.NOUN_BOOLEAN,</span>
<a href="#l7.33"></a><span id="l7.33">                         parameterNoun: null,</span>
<a href="#l7.34"></a><span id="l7.34">                         }); // tested-by: test_attributes_explicit</span>
<a href="#l7.35"></a><span id="l7.35">     // Read/Unread</span>
<a href="#l7.36"></a><span id="l7.36">     this._attrRead = Gloda.defineAttribute({</span>
<a href="#l7.37"></a><span id="l7.37">                         provider: this,</span>
<a href="#l7.38"></a><span id="l7.38">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l7.39"></a><span id="l7.39">                         attributeType: Gloda.kAttrExplicit,</span>
<a href="#l7.40"></a><span id="l7.40">                         attributeName: &quot;read&quot;,</span>
<a href="#l7.41"></a><span id="l7.41" class="difflineminus">-                        bind: true,</span>
<a href="#l7.42"></a><span id="l7.42">                         singular: true,</span>
<a href="#l7.43"></a><span id="l7.43">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l7.44"></a><span id="l7.44">                         objectNoun: Gloda.NOUN_BOOLEAN,</span>
<a href="#l7.45"></a><span id="l7.45">                         parameterNoun: null,</span>
<a href="#l7.46"></a><span id="l7.46">                         }); // tested-by: test_attributes_explicit</span>
<a href="#l7.47"></a><span id="l7.47">     </span>
<a href="#l7.48"></a><span id="l7.48">   },</span>
<a href="#l7.49"></a><span id="l7.49">   </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l8.1"></a><span id="l8.1" class="difflineminus">--- a/modules/fundattr.js</span>
<a href="#l8.2"></a><span id="l8.2" class="difflineplus">+++ b/modules/fundattr.js</span>
<a href="#l8.3"></a><span id="l8.3" class="difflineat">@@ -92,95 +92,88 @@ var GlodaFundAttr = {</span>
<a href="#l8.4"></a><span id="l8.4">   defineAttributes: function() {</span>
<a href="#l8.5"></a><span id="l8.5">     /* ***** Conversations ***** */</span>
<a href="#l8.6"></a><span id="l8.6">     // conversation: subjectMatches</span>
<a href="#l8.7"></a><span id="l8.7">     this._attrConvSubject = Gloda.defineAttribute({</span>
<a href="#l8.8"></a><span id="l8.8">       provider: this,</span>
<a href="#l8.9"></a><span id="l8.9">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.10"></a><span id="l8.10">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l8.11"></a><span id="l8.11">       attributeName: &quot;subjectMatches&quot;,</span>
<a href="#l8.12"></a><span id="l8.12" class="difflineminus">-      bind: false,</span>
<a href="#l8.13"></a><span id="l8.13">       singular: true,</span>
<a href="#l8.14"></a><span id="l8.14">       special: Gloda.kSpecialFulltext,</span>
<a href="#l8.15"></a><span id="l8.15">       specialColumnName: &quot;subject&quot;,</span>
<a href="#l8.16"></a><span id="l8.16">       subjectNouns: [Gloda.NOUN_CONVERSATION],</span>
<a href="#l8.17"></a><span id="l8.17">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l8.18"></a><span id="l8.18">       });</span>
<a href="#l8.19"></a><span id="l8.19">   </span>
<a href="#l8.20"></a><span id="l8.20">     /* ***** Messages ***** */</span>
<a href="#l8.21"></a><span id="l8.21">     // folder</span>
<a href="#l8.22"></a><span id="l8.22">     this._attrFolder = Gloda.defineAttribute({</span>
<a href="#l8.23"></a><span id="l8.23">       provider: this,</span>
<a href="#l8.24"></a><span id="l8.24">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.25"></a><span id="l8.25">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.26"></a><span id="l8.26">       attributeName: &quot;folderURI&quot;,</span>
<a href="#l8.27"></a><span id="l8.27" class="difflineminus">-      bind: false,</span>
<a href="#l8.28"></a><span id="l8.28">       singular: true,</span>
<a href="#l8.29"></a><span id="l8.29">       special: Gloda.kSpecialColumn,</span>
<a href="#l8.30"></a><span id="l8.30">       specialColumnName: &quot;folderID&quot;,</span>
<a href="#l8.31"></a><span id="l8.31">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.32"></a><span id="l8.32">       objectNoun: Gloda.NOUN_FOLDER,</span>
<a href="#l8.33"></a><span id="l8.33">       }); // tested-by: test_attributes_fundamental</span>
<a href="#l8.34"></a><span id="l8.34">     </span>
<a href="#l8.35"></a><span id="l8.35">     // bodyMatches. super-synthetic full-text matching...</span>
<a href="#l8.36"></a><span id="l8.36">     this._attrBody = Gloda.defineAttribute({</span>
<a href="#l8.37"></a><span id="l8.37">       provider: this,</span>
<a href="#l8.38"></a><span id="l8.38">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.39"></a><span id="l8.39">       attributeType: Gloda.kAttrDerived,</span>
<a href="#l8.40"></a><span id="l8.40">       attributeName: &quot;bodyMatches&quot;,</span>
<a href="#l8.41"></a><span id="l8.41" class="difflineminus">-      bind: false,</span>
<a href="#l8.42"></a><span id="l8.42">       singular: true,</span>
<a href="#l8.43"></a><span id="l8.43">       special: Gloda.kSpecialFulltext,</span>
<a href="#l8.44"></a><span id="l8.44">       specialColumnName: &quot;body&quot;,</span>
<a href="#l8.45"></a><span id="l8.45">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.46"></a><span id="l8.46">       objectNoun: Gloda.NOUN_FULLTEXT,</span>
<a href="#l8.47"></a><span id="l8.47">       }); // not-tested</span>
<a href="#l8.48"></a><span id="l8.48">   </span>
<a href="#l8.49"></a><span id="l8.49">     // --- Fundamental</span>
<a href="#l8.50"></a><span id="l8.50">     // From</span>
<a href="#l8.51"></a><span id="l8.51">     this._attrFrom = Gloda.defineAttribute({</span>
<a href="#l8.52"></a><span id="l8.52">                         provider: this,</span>
<a href="#l8.53"></a><span id="l8.53">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.54"></a><span id="l8.54">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.55"></a><span id="l8.55">                         attributeName: &quot;from&quot;,</span>
<a href="#l8.56"></a><span id="l8.56" class="difflineminus">-                        bind: true,</span>
<a href="#l8.57"></a><span id="l8.57">                         singular: true,</span>
<a href="#l8.58"></a><span id="l8.58">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.59"></a><span id="l8.59">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.60"></a><span id="l8.60">                         }); // tested-by: test_attributes_fundamental</span>
<a href="#l8.61"></a><span id="l8.61">     // To</span>
<a href="#l8.62"></a><span id="l8.62">     this._attrTo = Gloda.defineAttribute({</span>
<a href="#l8.63"></a><span id="l8.63">                         provider: this,</span>
<a href="#l8.64"></a><span id="l8.64">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.65"></a><span id="l8.65">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.66"></a><span id="l8.66">                         attributeName: &quot;to&quot;,</span>
<a href="#l8.67"></a><span id="l8.67" class="difflineminus">-                        bind: true,</span>
<a href="#l8.68"></a><span id="l8.68">                         singular: false,</span>
<a href="#l8.69"></a><span id="l8.69">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.70"></a><span id="l8.70">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.71"></a><span id="l8.71">                         }); // tested-by: test_attributes_fundamental</span>
<a href="#l8.72"></a><span id="l8.72">     // Cc</span>
<a href="#l8.73"></a><span id="l8.73">     this._attrCc = Gloda.defineAttribute({</span>
<a href="#l8.74"></a><span id="l8.74">                         provider: this,</span>
<a href="#l8.75"></a><span id="l8.75">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.76"></a><span id="l8.76">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.77"></a><span id="l8.77">                         attributeName: &quot;cc&quot;,</span>
<a href="#l8.78"></a><span id="l8.78" class="difflineminus">-                        bind: true,</span>
<a href="#l8.79"></a><span id="l8.79">                         singular: false,</span>
<a href="#l8.80"></a><span id="l8.80">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.81"></a><span id="l8.81">                         objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.82"></a><span id="l8.82">                         }); // not-tested</span>
<a href="#l8.83"></a><span id="l8.83"> </span>
<a href="#l8.84"></a><span id="l8.84">     // Date.  now lives on the row.</span>
<a href="#l8.85"></a><span id="l8.85">     this._attrDate = Gloda.defineAttribute({</span>
<a href="#l8.86"></a><span id="l8.86">                         provider: this,</span>
<a href="#l8.87"></a><span id="l8.87">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.88"></a><span id="l8.88">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.89"></a><span id="l8.89">                         attributeName: &quot;date&quot;,</span>
<a href="#l8.90"></a><span id="l8.90" class="difflineminus">-                        bind: false,</span>
<a href="#l8.91"></a><span id="l8.91">                         singular: true,</span>
<a href="#l8.92"></a><span id="l8.92">                         special: Gloda.kSpecialColumn,</span>
<a href="#l8.93"></a><span id="l8.93">                         specialColumnName: &quot;date&quot;,</span>
<a href="#l8.94"></a><span id="l8.94">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.95"></a><span id="l8.95">                         objectNoun: Gloda.NOUN_DATE,</span>
<a href="#l8.96"></a><span id="l8.96">                         }); // tested-by: test_attributes_fundamental</span>
<a href="#l8.97"></a><span id="l8.97"> </span>
<a href="#l8.98"></a><span id="l8.98">     // --- Optimization</span>
<a href="#l8.99"></a><span id="l8.99" class="difflineat">@@ -188,62 +181,57 @@ var GlodaFundAttr = {</span>
<a href="#l8.100"></a><span id="l8.100">     //   this that it seems to justify the cost, especially given the frequent</span>
<a href="#l8.101"></a><span id="l8.101">     //   use case.  (In fact, post-filtering for the specific from/to/cc is</span>
<a href="#l8.102"></a><span id="l8.102">     //   probably justifiable rather than losing this attribute...)</span>
<a href="#l8.103"></a><span id="l8.103">     this._attrInvolves = Gloda.defineAttribute({</span>
<a href="#l8.104"></a><span id="l8.104">       provider: this,</span>
<a href="#l8.105"></a><span id="l8.105">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.106"></a><span id="l8.106">       attributeType: Gloda.kAttrOptimization,</span>
<a href="#l8.107"></a><span id="l8.107">       attributeName: &quot;involves&quot;,</span>
<a href="#l8.108"></a><span id="l8.108" class="difflineminus">-      bind: true,</span>
<a href="#l8.109"></a><span id="l8.109">       singular: false,</span>
<a href="#l8.110"></a><span id="l8.110">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.111"></a><span id="l8.111">       objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.112"></a><span id="l8.112">       }); // not-tested</span>
<a href="#l8.113"></a><span id="l8.113"> </span>
<a href="#l8.114"></a><span id="l8.114">     // From Me To</span>
<a href="#l8.115"></a><span id="l8.115">     this._attrFromMeTo = Gloda.defineAttribute({</span>
<a href="#l8.116"></a><span id="l8.116">       provider: this,</span>
<a href="#l8.117"></a><span id="l8.117">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.118"></a><span id="l8.118">       attributeType: Gloda.kAttrOptimization,</span>
<a href="#l8.119"></a><span id="l8.119">       attributeName: &quot;fromMeTo&quot;,</span>
<a href="#l8.120"></a><span id="l8.120" class="difflineminus">-      bind: false,</span>
<a href="#l8.121"></a><span id="l8.121">       singular: false,</span>
<a href="#l8.122"></a><span id="l8.122">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.123"></a><span id="l8.123">       objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.124"></a><span id="l8.124">       }); // not-tested</span>
<a href="#l8.125"></a><span id="l8.125">     // From Me Cc</span>
<a href="#l8.126"></a><span id="l8.126">     this._attrFromMeCc = Gloda.defineAttribute({</span>
<a href="#l8.127"></a><span id="l8.127">       provider: this,</span>
<a href="#l8.128"></a><span id="l8.128">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.129"></a><span id="l8.129">       attributeType: Gloda.kAttrOptimization,</span>
<a href="#l8.130"></a><span id="l8.130">       attributeName: &quot;fromMeCc&quot;,</span>
<a href="#l8.131"></a><span id="l8.131" class="difflineminus">-      bind: false,</span>
<a href="#l8.132"></a><span id="l8.132">       singular: false,</span>
<a href="#l8.133"></a><span id="l8.133">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.134"></a><span id="l8.134">       objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.135"></a><span id="l8.135">       }); // not-tested</span>
<a href="#l8.136"></a><span id="l8.136">     // To Me</span>
<a href="#l8.137"></a><span id="l8.137">     this._attrToMe = Gloda.defineAttribute({</span>
<a href="#l8.138"></a><span id="l8.138">       provider: this,</span>
<a href="#l8.139"></a><span id="l8.139">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.140"></a><span id="l8.140">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.141"></a><span id="l8.141">       attributeName: &quot;toMe&quot;,</span>
<a href="#l8.142"></a><span id="l8.142" class="difflineminus">-      bind: false,</span>
<a href="#l8.143"></a><span id="l8.143">       singular: false,</span>
<a href="#l8.144"></a><span id="l8.144">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.145"></a><span id="l8.145">       objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.146"></a><span id="l8.146">       }); // not-tested</span>
<a href="#l8.147"></a><span id="l8.147">     // Cc Me</span>
<a href="#l8.148"></a><span id="l8.148">     this._attrCcMe = Gloda.defineAttribute({</span>
<a href="#l8.149"></a><span id="l8.149">       provider: this,</span>
<a href="#l8.150"></a><span id="l8.150">       extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.151"></a><span id="l8.151">       attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.152"></a><span id="l8.152">       attributeName: &quot;ccMe&quot;,</span>
<a href="#l8.153"></a><span id="l8.153" class="difflineminus">-      bind: false,</span>
<a href="#l8.154"></a><span id="l8.154">       singular: false,</span>
<a href="#l8.155"></a><span id="l8.155">       subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.156"></a><span id="l8.156">       objectNoun: Gloda.NOUN_IDENTITY,</span>
<a href="#l8.157"></a><span id="l8.157">       }); // not-tested</span>
<a href="#l8.158"></a><span id="l8.158"> </span>
<a href="#l8.159"></a><span id="l8.159"> </span>
<a href="#l8.160"></a><span id="l8.160">     // -- Mailing List</span>
<a href="#l8.161"></a><span id="l8.161">     // Non-singular, but a hard call.  Namely, it is obvious that a message can</span>
<a href="#l8.162"></a><span id="l8.162" class="difflineat">@@ -261,17 +249,16 @@ var GlodaFundAttr = {</span>
<a href="#l8.163"></a><span id="l8.163">     //  Additionally, our implicit-to logic needs to work on messages that</span>
<a href="#l8.164"></a><span id="l8.164">     //  weren't relayed by the list-serve, especially messages sent to the list</span>
<a href="#l8.165"></a><span id="l8.165">     //  by the user.</span>
<a href="#l8.166"></a><span id="l8.166">     this._attrList = Gloda.defineAttribute({</span>
<a href="#l8.167"></a><span id="l8.167">                         provider: this,</span>
<a href="#l8.168"></a><span id="l8.168">                         extensionName: Gloda.BUILT_IN,</span>
<a href="#l8.169"></a><span id="l8.169">                         attributeType: Gloda.kAttrFundamental,</span>
<a href="#l8.170"></a><span id="l8.170">                         attributeName: &quot;mailing-list&quot;,</span>
<a href="#l8.171"></a><span id="l8.171" class="difflineminus">-                        bind: true,</span>
<a href="#l8.172"></a><span id="l8.172">                         bindName: &quot;mailingLists&quot;,</span>
<a href="#l8.173"></a><span id="l8.173">                         singular: false,</span>
<a href="#l8.174"></a><span id="l8.174">                         subjectNouns: [Gloda.NOUN_MESSAGE],</span>
<a href="#l8.175"></a><span id="l8.175">                         objectNoun: Gloda.NOUN_DATE,</span>
<a href="#l8.176"></a><span id="l8.176">                         }); // not-tested, not-implemented</span>
<a href="#l8.177"></a><span id="l8.177">   },</span>
<a href="#l8.178"></a><span id="l8.178">   </span>
<a href="#l8.179"></a><span id="l8.179">   /**</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l9.1"></a><span id="l9.1" class="difflineminus">--- a/modules/gloda.js</span>
<a href="#l9.2"></a><span id="l9.2" class="difflineplus">+++ b/modules/gloda.js</span>
<a href="#l9.3"></a><span id="l9.3" class="difflineat">@@ -257,25 +257,25 @@ var Gloda = {</span>
<a href="#l9.4"></a><span id="l9.4">     query.value.apply(query.value, [address for (address in addresses)]);</span>
<a href="#l9.5"></a><span id="l9.5">     let collection = query.getCollection(aCallbackHandle);</span>
<a href="#l9.6"></a><span id="l9.6">     yield this.kWorkAsync;</span>
<a href="#l9.7"></a><span id="l9.7"> </span>
<a href="#l9.8"></a><span id="l9.8">     // put the identities in the appropriate result lists</span>
<a href="#l9.9"></a><span id="l9.9">     for each (let [, identity] in Iterator(collection.items)) {</span>
<a href="#l9.10"></a><span id="l9.10">       let nameAndResultLists = addresses[identity.value];</span>
<a href="#l9.11"></a><span id="l9.11">       // index 0 is the name, skip it</span>
<a href="#l9.12"></a><span id="l9.12" class="difflineminus">-      for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++)</span>
<a href="#l9.13"></a><span id="l9.13" class="difflineplus">+      for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++) {</span>
<a href="#l9.14"></a><span id="l9.14">         nameAndResultLists[iResList].push(identity);</span>
<a href="#l9.15"></a><span id="l9.15">       }</span>
<a href="#l9.16"></a><span id="l9.16">       delete addresses[identity.value];</span>
<a href="#l9.17"></a><span id="l9.17">     }</span>
<a href="#l9.18"></a><span id="l9.18">     </span>
<a href="#l9.19"></a><span id="l9.19">     // create the identities that did not exist yet</span>
<a href="#l9.20"></a><span id="l9.20">     for each (let [address, nameAndResultLists] in Iterator(addresses)) {</span>
<a href="#l9.21"></a><span id="l9.21" class="difflineminus">-      let name = nameAndResultsLists[0]; </span>
<a href="#l9.22"></a><span id="l9.22" class="difflineplus">+      let name = nameAndResultsLists[0];</span>
<a href="#l9.23"></a><span id="l9.23"> </span>
<a href="#l9.24"></a><span id="l9.24">       // try and find an existing address book contact.</span>
<a href="#l9.25"></a><span id="l9.25">       let card = GlodaUtils.getCardForEmail();</span>
<a href="#l9.26"></a><span id="l9.26">       // XXX when we have the address book GUID stuff, we need to use that to</span>
<a href="#l9.27"></a><span id="l9.27">       //  find existing contacts... (this will introduce a new query phase</span>
<a href="#l9.28"></a><span id="l9.28">       //  where we batch all the GUIDs for an async query)</span>
<a href="#l9.29"></a><span id="l9.29">       // XXX when the address book supports multiple e-mail addresses, we</span>
<a href="#l9.30"></a><span id="l9.30">       //  should also just create identities for any that don't yet exist</span>
<a href="#l9.31"></a><span id="l9.31" class="difflineat">@@ -292,17 +292,17 @@ var Gloda = {</span>
<a href="#l9.32"></a><span id="l9.32">       // we must create the identity.  use a blank description because there's</span>
<a href="#l9.33"></a><span id="l9.33">       //  nothing to differentiate it from other identities, as this contact</span>
<a href="#l9.34"></a><span id="l9.34">       //  only has one initially (us).</span>
<a href="#l9.35"></a><span id="l9.35">       // XXX when we have multiple e-mails and there is a meaning associated</span>
<a href="#l9.36"></a><span id="l9.36">       //  with each e-mail, try and use that to populate the description. </span>
<a href="#l9.37"></a><span id="l9.37">       let identity = GlodaDatastore.createIdentity(contact.id, contact,</span>
<a href="#l9.38"></a><span id="l9.38">         &quot;email&quot;, mailAddr, /* description */ &quot;&quot;, /* relay? */ false);</span>
<a href="#l9.39"></a><span id="l9.39">       </span>
<a href="#l9.40"></a><span id="l9.40" class="difflineminus">-      for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++)</span>
<a href="#l9.41"></a><span id="l9.41" class="difflineplus">+      for (let iResList = 1; iResList &lt; nameAndResultLists.length; iResList++) {</span>
<a href="#l9.42"></a><span id="l9.42">         nameAndResultLists[iResList].push(identity);</span>
<a href="#l9.43"></a><span id="l9.43">       }</span>
<a href="#l9.44"></a><span id="l9.44">     }</span>
<a href="#l9.45"></a><span id="l9.45"> </span>
<a href="#l9.46"></a><span id="l9.46">     yield aCallbackHandle.doneWithResult(resultLists);</span>
<a href="#l9.47"></a><span id="l9.47">   },</span>
<a href="#l9.48"></a><span id="l9.48"> </span>
<a href="#l9.49"></a><span id="l9.49">   /**</span>
<a href="#l9.50"></a><span id="l9.50" class="difflineat">@@ -585,25 +585,25 @@ var Gloda = {</span>
<a href="#l9.51"></a><span id="l9.51">   /** Next Noun ID to hand out, these don't need to be persisted (for now). */</span>
<a href="#l9.52"></a><span id="l9.52">   _nextNounID: 1000,</span>
<a href="#l9.53"></a><span id="l9.53"> </span>
<a href="#l9.54"></a><span id="l9.54">   /**</span>
<a href="#l9.55"></a><span id="l9.55">    * Maps noun names to noun IDs.</span>
<a href="#l9.56"></a><span id="l9.56">    */</span>
<a href="#l9.57"></a><span id="l9.57">   _nounNameToNounID: {},</span>
<a href="#l9.58"></a><span id="l9.58">   /**</span>
<a href="#l9.59"></a><span id="l9.59" class="difflineminus">-   * Maps noun IDs to noun meta dictionaries.  (Noun meta dictionaries being</span>
<a href="#l9.60"></a><span id="l9.60" class="difflineminus">-   *  the dictionary provided to us at the time a noun was defined, plus some</span>
<a href="#l9.61"></a><span id="l9.61" class="difflineplus">+   * Maps noun IDs to noun definition dictionaries.  (Noun definition</span>
<a href="#l9.62"></a><span id="l9.62" class="difflineplus">+   *  dictionaries provided to us at the time a noun was defined, plus some</span>
<a href="#l9.63"></a><span id="l9.63">    *  additional stuff we put in there.)</span>
<a href="#l9.64"></a><span id="l9.64">    */</span>
<a href="#l9.65"></a><span id="l9.65" class="difflineminus">-  _nounIDToMeta: {},</span>
<a href="#l9.66"></a><span id="l9.66" class="difflineplus">+  _nounIDToDef: {},</span>
<a href="#l9.67"></a><span id="l9.67">   </span>
<a href="#l9.68"></a><span id="l9.68">   _managedToJSON: function gloda_ns_managedToJSON(aItem) {</span>
<a href="#l9.69"></a><span id="l9.69">     return aItem.id;</span>
<a href="#l9.70"></a><span id="l9.70" class="difflineminus">-  }</span>
<a href="#l9.71"></a><span id="l9.71" class="difflineplus">+  },</span>
<a href="#l9.72"></a><span id="l9.72"> </span>
<a href="#l9.73"></a><span id="l9.73">   /**</span>
<a href="#l9.74"></a><span id="l9.74">    * Define a noun.  Takes a dictionary with the following keys/values:</span>
<a href="#l9.75"></a><span id="l9.75">    *</span>
<a href="#l9.76"></a><span id="l9.76">    * @param name The name of the noun.  This is not a display name (anything</span>
<a href="#l9.77"></a><span id="l9.77">    *     being displayed needs to be localized, after all), but simply the</span>
<a href="#l9.78"></a><span id="l9.78">    *     canonical name for debugging purposes and for people to pass to</span>
<a href="#l9.79"></a><span id="l9.79">    *     lookupNoun.  The suggested convention is lower-case-dash-delimited,</span>
<a href="#l9.80"></a><span id="l9.80" class="difflineat">@@ -631,50 +631,57 @@ var Gloda = {</span>
<a href="#l9.81"></a><span id="l9.81">    * @param fromParamAndValue A function that takes a parameter value and the</span>
<a href="#l9.82"></a><span id="l9.82">    *     object value and should return an instantiated noun instance.</span>
<a href="#l9.83"></a><span id="l9.83">    * @param toParamAndValue A function that takes an instantiated noun</span>
<a href="#l9.84"></a><span id="l9.84">    *     instance and returns a 2-element list of [parameter, value] where</span>
<a href="#l9.85"></a><span id="l9.85">    *     parameter may only be non-null if you passed a usesParameter of true.</span>
<a href="#l9.86"></a><span id="l9.86">    *     Parameter may be of any type (BLOB), and value must be numeric (pass</span>
<a href="#l9.87"></a><span id="l9.87">    *     0 if you don't need the value).</span>
<a href="#l9.88"></a><span id="l9.88">    */</span>
<a href="#l9.89"></a><span id="l9.89" class="difflineminus">-  defineNoun: function gloda_ns_defineNoun(aNounMeta, aNounID) {</span>
<a href="#l9.90"></a><span id="l9.90" class="difflineminus">-    this._log.info(&quot;Defining noun: &quot; + aNounMeta.name);</span>
<a href="#l9.91"></a><span id="l9.91" class="difflineplus">+  defineNoun: function gloda_ns_defineNoun(aNounDef, aNounID) {</span>
<a href="#l9.92"></a><span id="l9.92" class="difflineplus">+    this._log.info(&quot;Defining noun: &quot; + aNounDef.name);</span>
<a href="#l9.93"></a><span id="l9.93">     if (aNounID === undefined)</span>
<a href="#l9.94"></a><span id="l9.94">       aNounID = this._nextNounID++;</span>
<a href="#l9.95"></a><span id="l9.95" class="difflineminus">-    aNounMeta.id = aNounID;</span>
<a href="#l9.96"></a><span id="l9.96" class="difflineplus">+    aNounDef.id = aNounID;</span>
<a href="#l9.97"></a><span id="l9.97">     // if it has a table, you can query on it.  seems straight-forward.</span>
<a href="#l9.98"></a><span id="l9.98" class="difflineminus">-    if (aNounMeta.tableName) {</span>
<a href="#l9.99"></a><span id="l9.99" class="difflineminus">-      [aNounMeta.queryClass, aNounMeta.explicitQueryClass,</span>
<a href="#l9.100"></a><span id="l9.100" class="difflineminus">-       aNounMeta.wildcardQueryClass] =</span>
<a href="#l9.101"></a><span id="l9.101" class="difflineminus">-          GlodaQueryClassFactory(aNounMeta);</span>
<a href="#l9.102"></a><span id="l9.102" class="difflineminus">-      aNounMeta._dbMeta = {};</span>
<a href="#l9.103"></a><span id="l9.103" class="difflineminus">-      aNounMeta.class.prototype.NOUN_META = aNounMeta;</span>
<a href="#l9.104"></a><span id="l9.104" class="difflineminus">-      aNounMeta.toJSON = this._managedToJSON;</span>
<a href="#l9.105"></a><span id="l9.105" class="difflineplus">+    if (aNounDef.tableName) {</span>
<a href="#l9.106"></a><span id="l9.106" class="difflineplus">+      [aNounDef.queryClass, aNounDef.explicitQueryClass,</span>
<a href="#l9.107"></a><span id="l9.107" class="difflineplus">+       aNounDef.wildcardQueryClass] =</span>
<a href="#l9.108"></a><span id="l9.108" class="difflineplus">+          GlodaQueryClassFactory(aNounDef);</span>
<a href="#l9.109"></a><span id="l9.109" class="difflineplus">+      aNounDef._dbMeta = {};</span>
<a href="#l9.110"></a><span id="l9.110" class="difflineplus">+      aNounDef.class.prototype.NOUN_DEF = aNounDef;</span>
<a href="#l9.111"></a><span id="l9.111" class="difflineplus">+      aNounDef.toJSON = this._managedToJSON;</span>
<a href="#l9.112"></a><span id="l9.112">     }</span>
<a href="#l9.113"></a><span id="l9.113" class="difflineminus">-    if (aNounMeta.cache) {</span>
<a href="#l9.114"></a><span id="l9.114" class="difflineminus">-      let cacheCost = aNounMeta.cacheCost || 1024;</span>
<a href="#l9.115"></a><span id="l9.115" class="difflineminus">-      let cacheBudget = aNounMeta.cacheBudget || 128 * 1024;</span>
<a href="#l9.116"></a><span id="l9.116" class="difflineplus">+    if (aNounDef.cache) {</span>
<a href="#l9.117"></a><span id="l9.117" class="difflineplus">+      let cacheCost = aNounDef.cacheCost || 1024;</span>
<a href="#l9.118"></a><span id="l9.118" class="difflineplus">+      let cacheBudget = aNounDef.cacheBudget || 128 * 1024;</span>
<a href="#l9.119"></a><span id="l9.119">       let cacheSize = Math.floor(cacheBudget / cacheCost);</span>
<a href="#l9.120"></a><span id="l9.120">       if (cacheSize)</span>
<a href="#l9.121"></a><span id="l9.121" class="difflineminus">-        GlodaCollectionManager.defineCache(aNounMeta, cacheSize);</span>
<a href="#l9.122"></a><span id="l9.122" class="difflineplus">+        GlodaCollectionManager.defineCache(aNounDef, cacheSize);</span>
<a href="#l9.123"></a><span id="l9.123">     }</span>
<a href="#l9.124"></a><span id="l9.124" class="difflineminus">-    if (aNounMeta.allowsArbitraryAttrs) {</span>
<a href="#l9.125"></a><span id="l9.125" class="difflineminus">-      aNounMeta.attribsByBoundName = {};</span>
<a href="#l9.126"></a><span id="l9.126" class="difflineplus">+    if (aNounDef.allowsArbitraryAttrs) {</span>
<a href="#l9.127"></a><span id="l9.127" class="difflineplus">+      aNounDef.attribsByBoundName = {};</span>
<a href="#l9.128"></a><span id="l9.128">     }</span>
<a href="#l9.129"></a><span id="l9.129" class="difflineminus">-    this._nounNameToNounID[aNounMeta.name] = aNounID;</span>
<a href="#l9.130"></a><span id="l9.130" class="difflineminus">-    this._nounIDToMeta[aNounID] = aNounMeta;</span>
<a href="#l9.131"></a><span id="l9.131" class="difflineminus">-    aNounMeta.actions = [];</span>
<a href="#l9.132"></a><span id="l9.132" class="difflineplus">+    this._nounNameToNounID[aNounDef.name] = aNounID;</span>
<a href="#l9.133"></a><span id="l9.133" class="difflineplus">+    this._nounIDToDef[aNounID] = aNounDef;</span>
<a href="#l9.134"></a><span id="l9.134" class="difflineplus">+    aNounDef.actions = [];</span>
<a href="#l9.135"></a><span id="l9.135" class="difflineplus">+    </span>
<a href="#l9.136"></a><span id="l9.136" class="difflineplus">+    this._attrProviderOrderByNoun[aNounDef.id] = [];</span>
<a href="#l9.137"></a><span id="l9.137" class="difflineplus">+    this._attrProvidersByNoun[aNounDef.id] = {};</span>
<a href="#l9.138"></a><span id="l9.138">     </span>
<a href="#l9.139"></a><span id="l9.139" class="difflineminus">-    this._attrProviderOrderByNoun[aNounMeta.id] = [];</span>
<a href="#l9.140"></a><span id="l9.140" class="difflineminus">-    this._attrProvidersByNoun[aNounMeta.id] = {};</span>
<a href="#l9.141"></a><span id="l9.141" class="difflineminus">-    </span>
<a href="#l9.142"></a><span id="l9.142" class="difflineminus">-    if (aNounMeta.tableName) {</span>
<a href="#l9.143"></a><span id="l9.143" class="difflineminus">-      </span>
<a href="#l9.144"></a><span id="l9.144" class="difflineminus">-    }</span>
<a href="#l9.145"></a><span id="l9.145" class="difflineplus">+    // - define the 'id' constrainer</span>
<a href="#l9.146"></a><span id="l9.146" class="difflineplus">+    let idConstrainer = function() {</span>
<a href="#l9.147"></a><span id="l9.147" class="difflineplus">+      let constraint = [GlodaDatastore.kConstraintIdIn, null];</span>
<a href="#l9.148"></a><span id="l9.148" class="difflineplus">+      for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l9.149"></a><span id="l9.149" class="difflineplus">+        constraint.push(arguments[iArg]);</span>
<a href="#l9.150"></a><span id="l9.150" class="difflineplus">+      }</span>
<a href="#l9.151"></a><span id="l9.151" class="difflineplus">+      this._constraints.push(constraint);</span>
<a href="#l9.152"></a><span id="l9.152" class="difflineplus">+      return this;</span>
<a href="#l9.153"></a><span id="l9.153" class="difflineplus">+    };</span>
<a href="#l9.154"></a><span id="l9.154" class="difflineplus">+    subjectNounDef.queryClass.prototype.id = idConstrainer;</span>
<a href="#l9.155"></a><span id="l9.155">   },</span>
<a href="#l9.156"></a><span id="l9.156"> </span>
<a href="#l9.157"></a><span id="l9.157">   /**</span>
<a href="#l9.158"></a><span id="l9.158">    * Lookup a noun (ID) suitable for passing to defineAttribute's various</span>
<a href="#l9.159"></a><span id="l9.159">    *  noun arguments.  Throws an exception if the noun with the given name</span>
<a href="#l9.160"></a><span id="l9.160">    *  cannot be found; the assumption is that you can't live without the noun.</span>
<a href="#l9.161"></a><span id="l9.161">    */</span>
<a href="#l9.162"></a><span id="l9.162">   lookupNoun: function gloda_ns_lookupNoun(aNounName) {</span>
<a href="#l9.163"></a><span id="l9.163" class="difflineat">@@ -703,17 +710,17 @@ var Gloda = {</span>
<a href="#l9.164"></a><span id="l9.164">    *  with facts like &quot;this message is read&quot;.  We currently implement the 'fact'</span>
<a href="#l9.165"></a><span id="l9.165">    *  by defining an attribute with a 'boolean' noun type.  To deal with this,</span>
<a href="#l9.166"></a><span id="l9.166">    *  in various places we pass-in the attribute as well as the noun value.</span>
<a href="#l9.167"></a><span id="l9.167">    *  Since the relationships for booleans and integers in these cases is</span>
<a href="#l9.168"></a><span id="l9.168">    *  standard and well-defined, this works out pretty well, but suggests we</span>
<a href="#l9.169"></a><span id="l9.169">    *  need to think things through.</span>
<a href="#l9.170"></a><span id="l9.170">    *</span>
<a href="#l9.171"></a><span id="l9.171">    * @param aNounID The ID of the noun you want to define an action on.</span>
<a href="#l9.172"></a><span id="l9.172" class="difflineminus">-   * @param aAction Meta The dictionary describing the noun.  The dictionary</span>
<a href="#l9.173"></a><span id="l9.173" class="difflineplus">+   * @param aActionMeta The dictionary describing the noun.  The dictionary</span>
<a href="#l9.174"></a><span id="l9.174">    *     should have the following fields:</span>
<a href="#l9.175"></a><span id="l9.175">    * - actionType: a string indicating the type of action.  Currently, only</span>
<a href="#l9.176"></a><span id="l9.176">    *   &quot;filter&quot; is a legal value.</span>
<a href="#l9.177"></a><span id="l9.177">    * - actionTarget: the noun ID of the noun type on which this action is</span>
<a href="#l9.178"></a><span id="l9.178">    *   applicable.  For example,</span>
<a href="#l9.179"></a><span id="l9.179">    *</span>
<a href="#l9.180"></a><span id="l9.180">    * The following should be present for actionType==&quot;filter&quot;;</span>
<a href="#l9.181"></a><span id="l9.181">    * - shortName: The name that should be used to display this constraint.  For</span>
<a href="#l9.182"></a><span id="l9.182" class="difflineat">@@ -721,29 +728,29 @@ var Gloda = {</span>
<a href="#l9.183"></a><span id="l9.183">    *   using shortName as the label.</span>
<a href="#l9.184"></a><span id="l9.184">    * - makeConstraint: A function that takes the attribute that is the source</span>
<a href="#l9.185"></a><span id="l9.185">    *   of the noun and the noun instance as arguments, and returns APV-style</span>
<a href="#l9.186"></a><span id="l9.186">    *   constraints.  Since the APV-style query mechanism is now deprecated,</span>
<a href="#l9.187"></a><span id="l9.187">    *   this signature is deprecated.  Probably the way to update this would be</span>
<a href="#l9.188"></a><span id="l9.188">    *   to pass in the query instance that constraints should be contributed to.</span>
<a href="#l9.189"></a><span id="l9.189">    */</span>
<a href="#l9.190"></a><span id="l9.190">   defineNounAction: function gloda_ns_defineNounAction(aNounID, aActionMeta) {</span>
<a href="#l9.191"></a><span id="l9.191" class="difflineminus">-    let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l9.192"></a><span id="l9.192" class="difflineminus">-    nounMeta.actions.push(aActionMeta);</span>
<a href="#l9.193"></a><span id="l9.193" class="difflineplus">+    let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l9.194"></a><span id="l9.194" class="difflineplus">+    nounDef.actions.push(aActionMeta);</span>
<a href="#l9.195"></a><span id="l9.195">   },</span>
<a href="#l9.196"></a><span id="l9.196"> </span>
<a href="#l9.197"></a><span id="l9.197">   /**</span>
<a href="#l9.198"></a><span id="l9.198">    * Retrieve all of the actions (as defined using defineNounAction) for the</span>
<a href="#l9.199"></a><span id="l9.199">    *  given noun type (via noun ID) with the given action type (ex: filter).</span>
<a href="#l9.200"></a><span id="l9.200">    */</span>
<a href="#l9.201"></a><span id="l9.201">   getNounActions: function gloda_ns_getNounActions(aNounID, aActionType) {</span>
<a href="#l9.202"></a><span id="l9.202" class="difflineminus">-    let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l9.203"></a><span id="l9.203" class="difflineminus">-    if (!nounMeta)</span>
<a href="#l9.204"></a><span id="l9.204" class="difflineplus">+    let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l9.205"></a><span id="l9.205" class="difflineplus">+    if (!nounDef)</span>
<a href="#l9.206"></a><span id="l9.206">       return [];</span>
<a href="#l9.207"></a><span id="l9.207" class="difflineminus">-    return [action for each ([i, action] in Iterator(nounMeta.actions))</span>
<a href="#l9.208"></a><span id="l9.208" class="difflineplus">+    return [action for each ([i, action] in Iterator(nounDef.actions))</span>
<a href="#l9.209"></a><span id="l9.209">             if (!aActionType || (action.actionType == aActionType))];</span>
<a href="#l9.210"></a><span id="l9.210">   },</span>
<a href="#l9.211"></a><span id="l9.211"> </span>
<a href="#l9.212"></a><span id="l9.212">   /** Attribute providers in the sequence to process them. */</span>
<a href="#l9.213"></a><span id="l9.213">   _attrProviderOrderByNoun: {},</span>
<a href="#l9.214"></a><span id="l9.214">   /** Maps attribute providers to the list of attributes they provide */</span>
<a href="#l9.215"></a><span id="l9.215">   _attrProviders: {},</span>
<a href="#l9.216"></a><span id="l9.216">   /**</span>
<a href="#l9.217"></a><span id="l9.217" class="difflineat">@@ -910,18 +917,40 @@ var Gloda = {</span>
<a href="#l9.218"></a><span id="l9.218">     //  as the value.</span>
<a href="#l9.219"></a><span id="l9.219">     this.defineNoun({</span>
<a href="#l9.220"></a><span id="l9.220">       name: &quot;parameterized-identity&quot;,</span>
<a href="#l9.221"></a><span id="l9.221">       class: null,</span>
<a href="#l9.222"></a><span id="l9.222">       allowsArbitraryAttrs: false,</span>
<a href="#l9.223"></a><span id="l9.223">       computeDelta: function(aCurValues, aOldValues) {</span>
<a href="#l9.224"></a><span id="l9.224">         let oldMap = {};</span>
<a href="#l9.225"></a><span id="l9.225">         for each (let [, tupe] in Iterator(aOldValues)) {</span>
<a href="#l9.226"></a><span id="l9.226" class="difflineminus">-          let [originIdentity, </span>
<a href="#l9.227"></a><span id="l9.227" class="difflineplus">+          let [originIdentity, targetIdentity] = tupe;</span>
<a href="#l9.228"></a><span id="l9.228" class="difflineplus">+          let targets = oldMap[originIdentity];</span>
<a href="#l9.229"></a><span id="l9.229" class="difflineplus">+          if (targets === undefined)</span>
<a href="#l9.230"></a><span id="l9.230" class="difflineplus">+            targets = oldMap[originIdentity] = {};</span>
<a href="#l9.231"></a><span id="l9.231" class="difflineplus">+          targets[targetIdentity] = true;</span>
<a href="#l9.232"></a><span id="l9.232">         }</span>
<a href="#l9.233"></a><span id="l9.233" class="difflineplus">+        </span>
<a href="#l9.234"></a><span id="l9.234" class="difflineplus">+        let added = [], removed = [];</span>
<a href="#l9.235"></a><span id="l9.235" class="difflineplus">+        for each (let [, tupe] in Iterator(aCurValues)) {</span>
<a href="#l9.236"></a><span id="l9.236" class="difflineplus">+          let [originIdentity, targetIdentity] = tupe;</span>
<a href="#l9.237"></a><span id="l9.237" class="difflineplus">+          let targets = oldMap[originIdentity];</span>
<a href="#l9.238"></a><span id="l9.238" class="difflineplus">+          if ((targets === undefined) || !(targetIdentity in targets))</span>
<a href="#l9.239"></a><span id="l9.239" class="difflineplus">+            added.push(tupe);</span>
<a href="#l9.240"></a><span id="l9.240" class="difflineplus">+          else</span>
<a href="#l9.241"></a><span id="l9.241" class="difflineplus">+            delete targets[targetIdentity];</span>
<a href="#l9.242"></a><span id="l9.242" class="difflineplus">+        }</span>
<a href="#l9.243"></a><span id="l9.243" class="difflineplus">+        </span>
<a href="#l9.244"></a><span id="l9.244" class="difflineplus">+        for each (let [originIdentity, targets] in Iterator(oldMap)) {</span>
<a href="#l9.245"></a><span id="l9.245" class="difflineplus">+          for (let targetIdentity in targets) {</span>
<a href="#l9.246"></a><span id="l9.246" class="difflineplus">+            removed.push([originIdentity, targetIdentity]);</span>
<a href="#l9.247"></a><span id="l9.247" class="difflineplus">+          }</span>
<a href="#l9.248"></a><span id="l9.248" class="difflineplus">+        }</span>
<a href="#l9.249"></a><span id="l9.249" class="difflineplus">+        </span>
<a href="#l9.250"></a><span id="l9.250" class="difflineplus">+        return [added, removed];</span>
<a href="#l9.251"></a><span id="l9.251">       },</span>
<a href="#l9.252"></a><span id="l9.252">       contributeObjDependencies: function(aJsonValues, aReferencesByNounID) {</span>
<a href="#l9.253"></a><span id="l9.253">         // nothing to do with a zero-length list</span>
<a href="#l9.254"></a><span id="l9.254">         if (aJsonValues.length == 0)</span>
<a href="#l9.255"></a><span id="l9.255">           return false;</span>
<a href="#l9.256"></a><span id="l9.256">       </span>
<a href="#l9.257"></a><span id="l9.257">         let references = aReferencesByNounID[this.NOUN_IDENTITY];</span>
<a href="#l9.258"></a><span id="l9.258">         if (references === undefined)</span>
<a href="#l9.259"></a><span id="l9.259" class="difflineat">@@ -965,82 +994,71 @@ var Gloda = {</span>
<a href="#l9.260"></a><span id="l9.260">    *  attribute storage, as well as creating the appropriate query object</span>
<a href="#l9.261"></a><span id="l9.261">    *  constraint helper functions.  This name is somewhat of a misnomer because</span>
<a href="#l9.262"></a><span id="l9.262">    *  special attributes are not 'bound' (because specific/non-generic per-class</span>
<a href="#l9.263"></a><span id="l9.263">    *  code provides the properties) but still depend on this method to</span>
<a href="#l9.264"></a><span id="l9.264">    *  establish their constraint helper methods.</span>
<a href="#l9.265"></a><span id="l9.265">    *</span>
<a href="#l9.266"></a><span id="l9.266">    * @XXX potentially rename to not suggest binding is required.</span>
<a href="#l9.267"></a><span id="l9.267">    */</span>
<a href="#l9.268"></a><span id="l9.268" class="difflineminus">-  _bindAttribute: function gloda_ns_bindAttr(aAttr, aSubjectType, aObjectType,</span>
<a href="#l9.269"></a><span id="l9.269" class="difflineminus">-                                             aSingular, aDoBind, aBindName) {</span>
<a href="#l9.270"></a><span id="l9.270" class="difflineminus">-    if (!(aSubjectType in this._nounIDToMeta))</span>
<a href="#l9.271"></a><span id="l9.271" class="difflineplus">+  _bindAttribute: function gloda_ns_bindAttr(aAttrDef, aSubjectType) {</span>
<a href="#l9.272"></a><span id="l9.272" class="difflineplus">+    if (!(aSubjectType in this._nounIDToDef))</span>
<a href="#l9.273"></a><span id="l9.273">       throw Error(&quot;Invalid subject type: &quot; + aSubjectType);</span>
<a href="#l9.274"></a><span id="l9.274"> </span>
<a href="#l9.275"></a><span id="l9.275" class="difflineminus">-    let objNounMeta = this._nounIDToMeta[aObjectType];</span>
<a href="#l9.276"></a><span id="l9.276" class="difflineminus">-    let subjectNounMeta = this._nounIDToMeta[aSubjectType];</span>
<a href="#l9.277"></a><span id="l9.277" class="difflineplus">+    let objNounDef = this._nounIDToDef[aAttrDef.objectNoun];</span>
<a href="#l9.278"></a><span id="l9.278" class="difflineplus">+    let subjectNounDef = this._nounIDToDef[aSubjectType];</span>
<a href="#l9.279"></a><span id="l9.279"> </span>
<a href="#l9.280"></a><span id="l9.280">     // -- the on-object bindings</span>
<a href="#l9.281"></a><span id="l9.281">     if (aDoBind) {</span>
<a href="#l9.282"></a><span id="l9.282">       aAttr.boundName = aBindName;</span>
<a href="#l9.283"></a><span id="l9.283">     }</span>
<a href="#l9.284"></a><span id="l9.284"> </span>
<a href="#l9.285"></a><span id="l9.285">     // -- the query constraint helpers</span>
<a href="#l9.286"></a><span id="l9.286" class="difflineminus">-    if (subjectNounMeta.queryClass !== undefined) {</span>
<a href="#l9.287"></a><span id="l9.287" class="difflineplus">+    if (subjectNounDef.queryClass !== undefined) {</span>
<a href="#l9.288"></a><span id="l9.288">       let constrainer = function() {</span>
<a href="#l9.289"></a><span id="l9.289" class="difflineminus">-        // all the arguments provided end up being ORed together</span>
<a href="#l9.290"></a><span id="l9.290" class="difflineminus">-        let our_ors = [];</span>
<a href="#l9.291"></a><span id="l9.291" class="difflineplus">+        let constraint = [GlodaDatastore.kConstraintIn, aAttrDef];</span>
<a href="#l9.292"></a><span id="l9.292">         for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l9.293"></a><span id="l9.293" class="difflineminus">-          let argument = arguments[iArg];</span>
<a href="#l9.294"></a><span id="l9.294" class="difflineminus">-          our_ors.push([aAttr].concat(nounMeta.toParamAndValue(argument)));</span>
<a href="#l9.295"></a><span id="l9.295" class="difflineplus">+          constraint.push(arguments[iArg]);</span>
<a href="#l9.296"></a><span id="l9.296">         }</span>
<a href="#l9.297"></a><span id="l9.297" class="difflineminus">-        // but the constraints are ANDed together</span>
<a href="#l9.298"></a><span id="l9.298" class="difflineminus">-        this._constraints.push(our_ors);</span>
<a href="#l9.299"></a><span id="l9.299" class="difflineplus">+        this._constraints.push(constraint);</span>
<a href="#l9.300"></a><span id="l9.300">         return this;</span>
<a href="#l9.301"></a><span id="l9.301">       };</span>
<a href="#l9.302"></a><span id="l9.302"> </span>
<a href="#l9.303"></a><span id="l9.303" class="difflineminus">-      subjectNounMeta.queryClass.prototype[aBindName] = constrainer;</span>
<a href="#l9.304"></a><span id="l9.304" class="difflineplus">+      subjectNounDef.queryClass.prototype[aBindName] = constrainer;</span>
<a href="#l9.305"></a><span id="l9.305"> </span>
<a href="#l9.306"></a><span id="l9.306">       // - ranged value helper: fooRange</span>
<a href="#l9.307"></a><span id="l9.307" class="difflineminus">-      if (nounMeta.continuous) {</span>
<a href="#l9.308"></a><span id="l9.308" class="difflineplus">+      if (objNounDef.continuous) {</span>
<a href="#l9.309"></a><span id="l9.309" class="difflineplus">+        // takes one or more tuples of [lower bound, upper bound]</span>
<a href="#l9.310"></a><span id="l9.310">         let rangedConstrainer = function() {</span>
<a href="#l9.311"></a><span id="l9.311" class="difflineminus">-          // all the arguments provided end up being ORed together</span>
<a href="#l9.312"></a><span id="l9.312" class="difflineminus">-          let our_ors = [];</span>
<a href="#l9.313"></a><span id="l9.313" class="difflineminus">-          for (let iArg = 0; iArg &lt; arguments.length; iArg +=2 ) {</span>
<a href="#l9.314"></a><span id="l9.314" class="difflineminus">-            let pv1 = nounMeta.toParamAndValue(arguments[iArg]);</span>
<a href="#l9.315"></a><span id="l9.315" class="difflineminus">-            let pv2 = nounMeta.toParamAndValue(arguments[iArg+1]);</span>
<a href="#l9.316"></a><span id="l9.316" class="difflineminus">-            our_ors.push([aAttr, pv1[0], pv1[1], pv2[1]]);</span>
<a href="#l9.317"></a><span id="l9.317" class="difflineplus">+          let constraint = [GlodaDatastore.kConstraintRanges, aAttrDef];</span>
<a href="#l9.318"></a><span id="l9.318" class="difflineplus">+          for (let iArg = 0; iArg &lt; arguments.length; iArg++ ) {</span>
<a href="#l9.319"></a><span id="l9.319" class="difflineplus">+            constraint.push(arguments[iArg]);</span>
<a href="#l9.320"></a><span id="l9.320">           }</span>
<a href="#l9.321"></a><span id="l9.321" class="difflineminus">-          // but the constraints are ANDed together</span>
<a href="#l9.322"></a><span id="l9.322" class="difflineminus">-          this._constraints.push(our_ors);</span>
<a href="#l9.323"></a><span id="l9.323" class="difflineplus">+          this._constraints.push(constraints);</span>
<a href="#l9.324"></a><span id="l9.324">           return this;</span>
<a href="#l9.325"></a><span id="l9.325">         }</span>
<a href="#l9.326"></a><span id="l9.326"> </span>
<a href="#l9.327"></a><span id="l9.327" class="difflineminus">-        subjectNounMeta.queryClass.prototype[aBindName + &quot;Range&quot;] =</span>
<a href="#l9.328"></a><span id="l9.328" class="difflineplus">+        subjectNounDef.queryClass.prototype[aBindName + &quot;Range&quot;] =</span>
<a href="#l9.329"></a><span id="l9.329">           rangedConstrainer;</span>
<a href="#l9.330"></a><span id="l9.330">       }</span>
<a href="#l9.331"></a><span id="l9.331"> </span>
<a href="#l9.332"></a><span id="l9.332">       // - string LIKE helper for special on-row attributes: fooLike</span>
<a href="#l9.333"></a><span id="l9.333" class="difflineplus">+      // (it is impossible to store a string as an indexed attribute, which is</span>
<a href="#l9.334"></a><span id="l9.334" class="difflineplus">+      //  why we do this for on-row only.)</span>
<a href="#l9.335"></a><span id="l9.335">       if (aAttr.special == this.kSpecialString) {</span>
<a href="#l9.336"></a><span id="l9.336">         let likeConstrainer = function() {</span>
<a href="#l9.337"></a><span id="l9.337" class="difflineminus">-          let our_ors = [];</span>
<a href="#l9.338"></a><span id="l9.338" class="difflineplus">+          let constraint = [GlodaDatastore.kConstraintStringLike, aAttrDef];</span>
<a href="#l9.339"></a><span id="l9.339">           for (let iArg = 0; iArg &lt; arguments.length; iArg++) {</span>
<a href="#l9.340"></a><span id="l9.340" class="difflineminus">-            let argument = arguments[iArg];</span>
<a href="#l9.341"></a><span id="l9.341" class="difflineminus">-            let this_or = [aAttr].concat(nounMeta.toParamAndValue(argument));</span>
<a href="#l9.342"></a><span id="l9.342" class="difflineminus">-            // we are pushing it up to a length of 4 to signify that this is a</span>
<a href="#l9.343"></a><span id="l9.343" class="difflineminus">-            //  LIKE query rather than an exact match.  this results in a</span>
<a href="#l9.344"></a><span id="l9.344" class="difflineminus">-            //  similar decision process to the numeric case.</span>
<a href="#l9.345"></a><span id="l9.345" class="difflineminus">-            this_or.push(&quot;LIKE&quot;);</span>
<a href="#l9.346"></a><span id="l9.346" class="difflineminus">-            our_ors.push(this_or);</span>
<a href="#l9.347"></a><span id="l9.347" class="difflineplus">+            constraint.push(arguments[iArg]);</span>
<a href="#l9.348"></a><span id="l9.348">           }</span>
<a href="#l9.349"></a><span id="l9.349" class="difflineminus">-          this._constraints.push(our_ors);</span>
<a href="#l9.350"></a><span id="l9.350" class="difflineplus">+          this._constraints.push(constraints);</span>
<a href="#l9.351"></a><span id="l9.351">           return this;</span>
<a href="#l9.352"></a><span id="l9.352">         }</span>
<a href="#l9.353"></a><span id="l9.353"> </span>
<a href="#l9.354"></a><span id="l9.354" class="difflineminus">-        subjectNounMeta.queryClass.prototype[aBindName + &quot;Like&quot;] =</span>
<a href="#l9.355"></a><span id="l9.355" class="difflineplus">+        subjectNounDef.queryClass.prototype[aBindName + &quot;Like&quot;] =</span>
<a href="#l9.356"></a><span id="l9.356">           likeConstrainer;</span>
<a href="#l9.357"></a><span id="l9.357">       }</span>
<a href="#l9.358"></a><span id="l9.358">     }</span>
<a href="#l9.359"></a><span id="l9.359"> </span>
<a href="#l9.360"></a><span id="l9.360">     aAttr._singular = aSingular;</span>
<a href="#l9.361"></a><span id="l9.361">   },</span>
<a href="#l9.362"></a><span id="l9.362"> </span>
<a href="#l9.363"></a><span id="l9.363">   /**</span>
<a href="#l9.364"></a><span id="l9.364" class="difflineat">@@ -1092,116 +1110,102 @@ var Gloda = {</span>
<a href="#l9.365"></a><span id="l9.365">         !(&quot;singular&quot; in aAttrDef) ||</span>
<a href="#l9.366"></a><span id="l9.366">         !(&quot;subjectNouns&quot; in aAttrDef) ||</span>
<a href="#l9.367"></a><span id="l9.367">         !(&quot;objectNoun&quot; in aAttrDef))</span>
<a href="#l9.368"></a><span id="l9.368">       // perhaps we should have a list of required attributes, perchance with</span>
<a href="#l9.369"></a><span id="l9.369">       //  and explanation of what it holds, and use that to be friendlier?</span>
<a href="#l9.370"></a><span id="l9.370">       throw Error(&quot;You omitted a required attribute defining property, please&quot; +</span>
<a href="#l9.371"></a><span id="l9.371">                   &quot; consult the documentation as penance.&quot;)</span>
<a href="#l9.372"></a><span id="l9.372"> </span>
<a href="#l9.373"></a><span id="l9.373" class="difflineplus">+    // return if the attribute has already been defined</span>
<a href="#l9.374"></a><span id="l9.374" class="difflineplus">+    if (aAttrDef.dbDef) {</span>
<a href="#l9.375"></a><span id="l9.375" class="difflineplus">+      return aAttrDef;</span>
<a href="#l9.376"></a><span id="l9.376" class="difflineplus">+    }</span>
<a href="#l9.377"></a><span id="l9.377" class="difflineplus">+</span>
<a href="#l9.378"></a><span id="l9.378">     // provider tracking</span>
<a href="#l9.379"></a><span id="l9.379">     if (!(aAttrDef.provider.providerName in this._attrProviders)) {</span>
<a href="#l9.380"></a><span id="l9.380">       this._attrProviders[aAttrDef.provider.providerName] = [];</span>
<a href="#l9.381"></a><span id="l9.381">     }</span>
<a href="#l9.382"></a><span id="l9.382"> </span>
<a href="#l9.383"></a><span id="l9.383" class="difflineplus">+    let compoundName = aAttrDef.extensionName + &quot;:&quot; + aAttrDef.attributeName;</span>
<a href="#l9.384"></a><span id="l9.384" class="difflineplus">+    let attrDBDef;</span>
<a href="#l9.385"></a><span id="l9.385" class="difflineplus">+    if (compoundName in GlodaDatastore._attributeDBDefs) {</span>
<a href="#l9.386"></a><span id="l9.386" class="difflineplus">+      // the existence of the GlodaAttributeDef means that either it has</span>
<a href="#l9.387"></a><span id="l9.387" class="difflineplus">+      //  already been fully defined, or has been loaded from the database but</span>
<a href="#l9.388"></a><span id="l9.388" class="difflineplus">+      //  not yet 'bound' to a provider (and had important meta-info that</span>
<a href="#l9.389"></a><span id="l9.389" class="difflineplus">+      //  doesn't go in the db copied over)</span>
<a href="#l9.390"></a><span id="l9.390" class="difflineplus">+      attrDBDef = GlodaDatastore._attributeDBDefs[compoundName];</span>
<a href="#l9.391"></a><span id="l9.391" class="difflineplus">+    }</span>
<a href="#l9.392"></a><span id="l9.392" class="difflineplus">+    // we need to create the attribute definition in the database</span>
<a href="#l9.393"></a><span id="l9.393" class="difflineplus">+    else {</span>
<a href="#l9.394"></a><span id="l9.394" class="difflineplus">+      let attrID = null;</span>
<a href="#l9.395"></a><span id="l9.395" class="difflineplus">+      attrID = GlodaDatastore._createAttributeDef(aAttrDef.attributeType,</span>
<a href="#l9.396"></a><span id="l9.396" class="difflineplus">+                                                  aAttrDef.extensionName,</span>
<a href="#l9.397"></a><span id="l9.397" class="difflineplus">+                                                  aAttrDef.attributeName,</span>
<a href="#l9.398"></a><span id="l9.398" class="difflineplus">+                                                  null);</span>
<a href="#l9.399"></a><span id="l9.399" class="difflineplus">+    </span>
<a href="#l9.400"></a><span id="l9.400" class="difflineplus">+      attrDBDef = new GlodaAttributeDBDef(GlodaDatastore, attrID, compoundName,</span>
<a href="#l9.401"></a><span id="l9.401" class="difflineplus">+        aAttrDef.attributeType, aAttrDef.extensionName, aAttrDef.attributeName);</span>
<a href="#l9.402"></a><span id="l9.402" class="difflineplus">+      GlodaDatastore._attributeDBDefs[compoundName] = attrDBDef;</span>
<a href="#l9.403"></a><span id="l9.403" class="difflineplus">+      GlodaDatastore._attributeIDToDBDefAndParam[attrID] = [attrDBDef, null];</span>
<a href="#l9.404"></a><span id="l9.404" class="difflineplus">+    }</span>
<a href="#l9.405"></a><span id="l9.405" class="difflineplus">+    </span>
<a href="#l9.406"></a><span id="l9.406" class="difflineplus">+    aAttrDef.dbDef = attrDBDef;</span>
<a href="#l9.407"></a><span id="l9.407" class="difflineplus">+    attrDBDef.attrDef = aAttrDef;</span>
<a href="#l9.408"></a><span id="l9.408" class="difflineplus">+</span>
<a href="#l9.409"></a><span id="l9.409">     let bindName;</span>
<a href="#l9.410"></a><span id="l9.410">     if (&quot;bindName&quot; in aAttrDef)</span>
<a href="#l9.411"></a><span id="l9.411">       bindName = aAttrDef.bindName;</span>
<a href="#l9.412"></a><span id="l9.412">     else</span>
<a href="#l9.413"></a><span id="l9.413">       bindName = aAttrDef.attributeName;</span>
<a href="#l9.414"></a><span id="l9.414" class="difflineplus">+    aAttrDef.boundName = bindName;</span>
<a href="#l9.415"></a><span id="l9.415"> </span>
<a href="#l9.416"></a><span id="l9.416" class="difflineminus">-    let compoundName = aAttrDef.extensionName + &quot;:&quot; + aAttrDef.attributeName;</span>
<a href="#l9.417"></a><span id="l9.417" class="difflineminus">-    let attr = null;</span>
<a href="#l9.418"></a><span id="l9.418" class="difflineminus">-    if (compoundName in GlodaDatastore._attributes) {</span>
<a href="#l9.419"></a><span id="l9.419" class="difflineminus">-      // the existence of the GlodaAttributeDef means that either it has</span>
<a href="#l9.420"></a><span id="l9.420" class="difflineminus">-      //  already been fully defined, or has been loaded from the database but</span>
<a href="#l9.421"></a><span id="l9.421" class="difflineminus">-      //  not yet 'bound' to a provider (and had important meta-info that</span>
<a href="#l9.422"></a><span id="l9.422" class="difflineminus">-      //  doesn't go in the db copied over)</span>
<a href="#l9.423"></a><span id="l9.423" class="difflineminus">-      attr = GlodaDatastore._attributes[compoundName];</span>
<a href="#l9.424"></a><span id="l9.424" class="difflineminus">-      if (attr.provider !== null) {</span>
<a href="#l9.425"></a><span id="l9.425" class="difflineminus">-        return attr;</span>
<a href="#l9.426"></a><span id="l9.426" class="difflineminus">-      }</span>
<a href="#l9.427"></a><span id="l9.427" class="difflineplus">+    for (let iSubject = 0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l9.428"></a><span id="l9.428" class="difflineplus">+           iSubject++) {</span>
<a href="#l9.429"></a><span id="l9.429" class="difflineplus">+      let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l9.430"></a><span id="l9.430" class="difflineplus">+      this._bindAttribute(attr, subjectType, aAttrDef.objectNoun,</span>
<a href="#l9.431"></a><span id="l9.431" class="difflineplus">+                          aAttrDef.singular, aAttrDef.bind, bindName);</span>
<a href="#l9.432"></a><span id="l9.432"> </span>
<a href="#l9.433"></a><span id="l9.433" class="difflineminus">-      // we are behind the abstraction veil and can set these things</span>
<a href="#l9.434"></a><span id="l9.434" class="difflineminus">-      // (these would otherwise be passed in to the GlodaAttributeDef</span>
<a href="#l9.435"></a><span id="l9.435" class="difflineminus">-      //  constructor.  they are not like the HATHATHAT guys below)</span>
<a href="#l9.436"></a><span id="l9.436" class="difflineminus">-      attr._provider = aAttrDef.provider;</span>
<a href="#l9.437"></a><span id="l9.437" class="difflineminus">-      attr._subjectTypes = aAttrDef.subjectNouns;</span>
<a href="#l9.438"></a><span id="l9.438" class="difflineminus">-      attr._objectType = aAttrDef.objectNoun;</span>
<a href="#l9.439"></a><span id="l9.439" class="difflineminus">-      // things after here also need to be set below the new GlodaAttributeDef</span>
<a href="#l9.440"></a><span id="l9.440" class="difflineminus">-      //  clause below... HATHATHAT</span>
<a href="#l9.441"></a><span id="l9.441" class="difflineminus">-      attr._special = aAttrDef.special || this.kSpecialNotAtAll;</span>
<a href="#l9.442"></a><span id="l9.442" class="difflineminus">-      attr._specialColumnName = aAttrDef.specialColumnName || null;</span>
<a href="#l9.443"></a><span id="l9.443" class="difflineminus">-</span>
<a href="#l9.444"></a><span id="l9.444" class="difflineminus">-      for (let iSubject = 0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l9.445"></a><span id="l9.445" class="difflineminus">-           iSubject++) {</span>
<a href="#l9.446"></a><span id="l9.446" class="difflineminus">-        let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l9.447"></a><span id="l9.447" class="difflineminus">-        this._bindAttribute(attr, subjectType, aAttrDef.objectNoun,</span>
<a href="#l9.448"></a><span id="l9.448" class="difflineminus">-                            aAttrDef.singular, aAttrDef.bind, bindName);</span>
<a href="#l9.449"></a><span id="l9.449" class="difflineminus">-</span>
<a href="#l9.450"></a><span id="l9.450" class="difflineminus">-        // update the provider maps...</span>
<a href="#l9.451"></a><span id="l9.451" class="difflineminus">-        if (this._attrProviderOrderByNoun[subjectType]</span>
<a href="#l9.452"></a><span id="l9.452" class="difflineminus">-                .indexOf(aAttrDef.provider) == -1) {</span>
<a href="#l9.453"></a><span id="l9.453" class="difflineminus">-          this._attrProviderOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l9.454"></a><span id="l9.454" class="difflineminus">-          this._attrProvidersByNoun[subjectType][aAttrDef.provider] = [];</span>
<a href="#l9.455"></a><span id="l9.455" class="difflineminus">-        }</span>
<a href="#l9.456"></a><span id="l9.456" class="difflineminus">-        this._attrProvidersByNoun[subjectType][aAttrDef.provider].push(aAttrDef);</span>
<a href="#l9.457"></a><span id="l9.457" class="difflineminus">-        </span>
<a href="#l9.458"></a><span id="l9.458" class="difflineminus">-        let subjectNounDef = this._nounIDToMeta[subjectType];</span>
<a href="#l9.459"></a><span id="l9.459" class="difflineminus">-        subjectNounDef.attribsByBoundName[bindName] = attr;</span>
<a href="#l9.460"></a><span id="l9.460" class="difflineminus">-        </span>
<a href="#l9.461"></a><span id="l9.461" class="difflineplus">+      // update the provider maps...</span>
<a href="#l9.462"></a><span id="l9.462" class="difflineplus">+      if (this._attrProviderOrderByNoun[subjectType]</span>
<a href="#l9.463"></a><span id="l9.463" class="difflineplus">+              .indexOf(aAttrDef.provider) == -1) {</span>
<a href="#l9.464"></a><span id="l9.464" class="difflineplus">+        this._attrProviderOrderByNoun[subjectType].push(aAttrDef.provider);</span>
<a href="#l9.465"></a><span id="l9.465" class="difflineplus">+        this._attrProvidersByNoun[subjectType][aAttrDef.provider] = [];</span>
<a href="#l9.466"></a><span id="l9.466">       }</span>
<a href="#l9.467"></a><span id="l9.467" class="difflineminus">-</span>
<a href="#l9.468"></a><span id="l9.468" class="difflineplus">+      this._attrProvidersByNoun[subjectType][aAttrDef.provider].push(aAttrDef);</span>
<a href="#l9.469"></a><span id="l9.469" class="difflineplus">+      </span>
<a href="#l9.470"></a><span id="l9.470" class="difflineplus">+      let subjectNounDef = this._nounIDToDef[subjectType];</span>
<a href="#l9.471"></a><span id="l9.471" class="difflineplus">+      subjectNounDef.attribsByBoundName[bindName] = attr;</span>
<a href="#l9.472"></a><span id="l9.472" class="difflineplus">+      </span>
<a href="#l9.473"></a><span id="l9.473" class="difflineplus">+      </span>
<a href="#l9.474"></a><span id="l9.474" class="difflineplus">+      if (objectNounDef.tableName ||</span>
<a href="#l9.475"></a><span id="l9.475" class="difflineplus">+          objectNounDef.contributeObjDependencies) {</span>
<a href="#l9.476"></a><span id="l9.476" class="difflineplus">+        subjectNounDef.hasObjDependencies = true;</span>
<a href="#l9.477"></a><span id="l9.477" class="difflineplus">+      }</span>
<a href="#l9.478"></a><span id="l9.478" class="difflineplus">+      </span>
<a href="#l9.479"></a><span id="l9.479">       this._attrProviders[aAttrDef.provider.providerName].push(attr);</span>
<a href="#l9.480"></a><span id="l9.480">       return attr;</span>
<a href="#l9.481"></a><span id="l9.481">     }</span>
<a href="#l9.482"></a><span id="l9.482" class="difflineminus">-</span>
<a href="#l9.483"></a><span id="l9.483" class="difflineminus">-    let objectNounMeta = this._nounIDToMeta[aAttrDef.objectNoun];</span>
<a href="#l9.484"></a><span id="l9.484" class="difflineminus">-</span>
<a href="#l9.485"></a><span id="l9.485" class="difflineminus">-    let attrID = null;</span>
<a href="#l9.486"></a><span id="l9.486" class="difflineminus">-    attrID = GlodaDatastore._createAttributeDef(aAttrDef.attributeType,</span>
<a href="#l9.487"></a><span id="l9.487" class="difflineminus">-                                                aAttrDef.extensionName,</span>
<a href="#l9.488"></a><span id="l9.488" class="difflineminus">-                                                aAttrDef.attributeName,</span>
<a href="#l9.489"></a><span id="l9.489" class="difflineminus">-                                                null);</span>
<a href="#l9.490"></a><span id="l9.490" class="difflineminus">-</span>
<a href="#l9.491"></a><span id="l9.491" class="difflineminus">-    attr = new GlodaAttributeDef(GlodaDatastore, attrID, compoundName,</span>
<a href="#l9.492"></a><span id="l9.492" class="difflineminus">-                                 aAttrDef.provider, aAttrDef.attributeType,</span>
<a href="#l9.493"></a><span id="l9.493" class="difflineminus">-                                 aAttrDef.extensionName, aAttrDef.attributeName,</span>
<a href="#l9.494"></a><span id="l9.494" class="difflineminus">-                                 aAttrDef.subjectNouns, aAttrDef.objectNoun);</span>
<a href="#l9.495"></a><span id="l9.495" class="difflineminus">-    // things here match the HATHATHAT clause above.  clearly, this should also</span>
<a href="#l9.496"></a><span id="l9.496" class="difflineminus">-    //  be resolved more satisfactorily.</span>
<a href="#l9.497"></a><span id="l9.497" class="difflineminus">-    attr._special = aAttrDef.special || this.kSpecialNotAtAll;</span>
<a href="#l9.498"></a><span id="l9.498" class="difflineminus">-    attr._specialColumnName = aAttrDef.specialColumnName || null;</span>
<a href="#l9.499"></a><span id="l9.499" class="difflineminus">-</span>
<a href="#l9.500"></a><span id="l9.500" class="difflineminus">-    GlodaDatastore._attributes[compoundName] = attr;</span>
<a href="#l9.501"></a><span id="l9.501" class="difflineminus">-</span>
<a href="#l9.502"></a><span id="l9.502" class="difflineminus">-    for (let iSubject = 0; iSubject &lt; aAttrDef.subjectNouns.length;</span>
<a href="#l9.503"></a><span id="l9.503" class="difflineminus">-         iSubject++) {</span>
<a href="#l9.504"></a><span id="l9.504" class="difflineminus">-      let subjectType = aAttrDef.subjectNouns[iSubject];</span>
<a href="#l9.505"></a><span id="l9.505" class="difflineminus">-      this._bindAttribute(attr, subjectType, aAttrDef.objectNoun,</span>
<a href="#l9.506"></a><span id="l9.506" class="difflineminus">-                          aAttrDef.singular, aAttrDef.bind, bindName);</span>
<a href="#l9.507"></a><span id="l9.507" class="difflineminus">-    }</span>
<a href="#l9.508"></a><span id="l9.508" class="difflineminus">-</span>
<a href="#l9.509"></a><span id="l9.509" class="difflineplus">+    </span>
<a href="#l9.510"></a><span id="l9.510">     this._attrProviders[aAttrDef.provider.providerName].push(attr);</span>
<a href="#l9.511"></a><span id="l9.511" class="difflineminus">-    GlodaDatastore._attributeIDToDef[attrID] = [attr, null];</span>
<a href="#l9.512"></a><span id="l9.512">     return attr;</span>
<a href="#l9.513"></a><span id="l9.513">   },</span>
<a href="#l9.514"></a><span id="l9.514"> </span>
<a href="#l9.515"></a><span id="l9.515">   /**</span>
<a href="#l9.516"></a><span id="l9.516">    * Retrieve the attribute provided by the given extension with the given</span>
<a href="#l9.517"></a><span id="l9.517">    *  attribute name.  The original idea was that plugins would effectively</span>
<a href="#l9.518"></a><span id="l9.518">    *  name-space attributes, helping avoid collisions.  Since we are leaning</span>
<a href="#l9.519"></a><span id="l9.519">    *  towards using binding heavily, this doesn't really help, as the collisions</span>
<a href="#l9.520"></a><span id="l9.520">    *  will just occur on the attribute name instead.  Also, this can turn</span>
<a href="#l9.521"></a><span id="l9.521">    *  extensions into liars as name changes/moves to core/etc. happen.</span>
<a href="#l9.522"></a><span id="l9.522">    * @TODO consider removing the extension name argument parameter requirement</span>
<a href="#l9.523"></a><span id="l9.523">    */</span>
<a href="#l9.524"></a><span id="l9.524">   getAttrDef: function gloda_ns_getAttrDef(aPluginName, aAttrName) {</span>
<a href="#l9.525"></a><span id="l9.525">     let compoundName = aPluginName + &quot;:&quot; + aAttrName;</span>
<a href="#l9.526"></a><span id="l9.526" class="difflineminus">-    return GlodaDatastore._attributes[compoundName];</span>
<a href="#l9.527"></a><span id="l9.527" class="difflineplus">+    return GlodaDatastore._attributeDBDefs[compoundName];</span>
<a href="#l9.528"></a><span id="l9.528">   },</span>
<a href="#l9.529"></a><span id="l9.529"> </span>
<a href="#l9.530"></a><span id="l9.530">   /**</span>
<a href="#l9.531"></a><span id="l9.531">    * Define a SQL table for plug-ins.  This is intended to be used by</span>
<a href="#l9.532"></a><span id="l9.532">    *  extensions/plug-ins whose storage needs exceed those provided by the</span>
<a href="#l9.533"></a><span id="l9.533">    *  attribute parameter (on the attribute definition)/attribute value (on the</span>
<a href="#l9.534"></a><span id="l9.534">    *  attribute instance) idiom.  (This includes extensions whose parameter</span>
<a href="#l9.535"></a><span id="l9.535">    *  usage would exceed acceptable cardinality.)  They can create a table</span>
<a href="#l9.536"></a><span id="l9.536" class="difflineat">@@ -1256,29 +1260,29 @@ var Gloda = {</span>
<a href="#l9.537"></a><span id="l9.537">    *  the people who are &gt;= 25 and &lt;= 100.  Likewise age(25, null) would just</span>
<a href="#l9.538"></a><span id="l9.538">    *  return all the people who are 25 or older.  And age(25,30,35,40) would</span>
<a href="#l9.539"></a><span id="l9.539">    *  return people who are either 25-30 or 35-30.</span>
<a href="#l9.540"></a><span id="l9.540">    * There are also full-text constraint columns.  In a nutshell, their</span>
<a href="#l9.541"></a><span id="l9.541">    *  arguments are the strings that should be passed to the SQLite FTS3</span>
<a href="#l9.542"></a><span id="l9.542">    *  MATCH clause.</span>
<a href="#l9.543"></a><span id="l9.543">    */</span>
<a href="#l9.544"></a><span id="l9.544">   newQuery: function gloda_ns_newQuery(aNounID) {</span>
<a href="#l9.545"></a><span id="l9.545" class="difflineminus">-    let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l9.546"></a><span id="l9.546" class="difflineminus">-    return new nounMeta.queryClass();</span>
<a href="#l9.547"></a><span id="l9.547" class="difflineplus">+    let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l9.548"></a><span id="l9.548" class="difflineplus">+    return new nounDef.queryClass();</span>
<a href="#l9.549"></a><span id="l9.549">   },</span>
<a href="#l9.550"></a><span id="l9.550"> </span>
<a href="#l9.551"></a><span id="l9.551">   /**</span>
<a href="#l9.552"></a><span id="l9.552">    * Create a collection/query for the given noun-type that only matches the</span>
<a href="#l9.553"></a><span id="l9.553">    *  provided items.  This is to be used when you have an explicit set of items</span>
<a href="#l9.554"></a><span id="l9.554">    *  that you would still like to receive updates for.</span>
<a href="#l9.555"></a><span id="l9.555">    */</span>
<a href="#l9.556"></a><span id="l9.556">   explicitCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l9.557"></a><span id="l9.557" class="difflineminus">-    let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l9.558"></a><span id="l9.558" class="difflineminus">-    let collection = new GlodaCollection(nounMeta, aItems, null, null)</span>
<a href="#l9.559"></a><span id="l9.559" class="difflineminus">-    let query = new nounMeta.explicitQueryClass(collection);</span>
<a href="#l9.560"></a><span id="l9.560" class="difflineplus">+    let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l9.561"></a><span id="l9.561" class="difflineplus">+    let collection = new GlodaCollection(nounDef, aItems, null, null)</span>
<a href="#l9.562"></a><span id="l9.562" class="difflineplus">+    let query = new nounDef.explicitQueryClass(collection);</span>
<a href="#l9.563"></a><span id="l9.563">     collection.query = query;</span>
<a href="#l9.564"></a><span id="l9.564">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l9.565"></a><span id="l9.565">     return collection;</span>
<a href="#l9.566"></a><span id="l9.566">   },</span>
<a href="#l9.567"></a><span id="l9.567"> </span>
<a href="#l9.568"></a><span id="l9.568">   /**</span>
<a href="#l9.569"></a><span id="l9.569">    * Debugging 'wildcard' collection creation support.  A wildcard collection</span>
<a href="#l9.570"></a><span id="l9.570">    *  will 'accept' any new item instances presented to the collection manager</span>
<a href="#l9.571"></a><span id="l9.571" class="difflineat">@@ -1286,19 +1290,19 @@ var Gloda = {</span>
<a href="#l9.572"></a><span id="l9.572">    *  as they are indexed, existing items as they are loaded from the database,</span>
<a href="#l9.573"></a><span id="l9.573">    *  etc.</span>
<a href="#l9.574"></a><span id="l9.574">    * Because the items are added to the collection without limit, this will</span>
<a href="#l9.575"></a><span id="l9.575">    *  result in a leak if you don't do something to clean up after the</span>
<a href="#l9.576"></a><span id="l9.576">    *  collection.  (Forgetting about the collection will suffice, as it is still</span>
<a href="#l9.577"></a><span id="l9.577">    *  weakly held.)</span>
<a href="#l9.578"></a><span id="l9.578">    */</span>
<a href="#l9.579"></a><span id="l9.579">   _wildcardCollection: function gloda_ns_explicitCollection(aNounID, aItems) {</span>
<a href="#l9.580"></a><span id="l9.580" class="difflineminus">-    let nounMeta = this._nounIDToMeta[aNounID];</span>
<a href="#l9.581"></a><span id="l9.581" class="difflineminus">-    let collection = new GlodaCollection(nounMeta, aItems, null, null)</span>
<a href="#l9.582"></a><span id="l9.582" class="difflineminus">-    let query = new nounMeta.wildcardQueryClass(collection);</span>
<a href="#l9.583"></a><span id="l9.583" class="difflineplus">+    let nounDef = this._nounIDToDef[aNounID];</span>
<a href="#l9.584"></a><span id="l9.584" class="difflineplus">+    let collection = new GlodaCollection(nounDef, aItems, null, null)</span>
<a href="#l9.585"></a><span id="l9.585" class="difflineplus">+    let query = new nounDef.wildcardQueryClass(collection);</span>
<a href="#l9.586"></a><span id="l9.586">     collection.query = query;</span>
<a href="#l9.587"></a><span id="l9.587">     GlodaCollectionManager.registerCollection(collection);</span>
<a href="#l9.588"></a><span id="l9.588">     return collection;</span>
<a href="#l9.589"></a><span id="l9.589">   },</span>
<a href="#l9.590"></a><span id="l9.590"> </span>
<a href="#l9.591"></a><span id="l9.591">   /**</span>
<a href="#l9.592"></a><span id="l9.592">    * Process the given GlodaMessage, determining all the attributes it should</span>
<a href="#l9.593"></a><span id="l9.593">    *  possess.  This should not be publicly exposed here for multiple reasons.</span>
<a href="#l9.594"></a><span id="l9.594" class="difflineat">@@ -1335,17 +1339,17 @@ var Gloda = {</span>
<a href="#l9.595"></a><span id="l9.595">       let attribDesc = allAttribs[iAttrib];</span>
<a href="#l9.596"></a><span id="l9.596"> </span>
<a href="#l9.597"></a><span id="l9.597">       // is it an (attributedef / attribute def id, value) tuple?</span>
<a href="#l9.598"></a><span id="l9.598">       if (attribDesc.length == 2) {</span>
<a href="#l9.599"></a><span id="l9.599">         // if it's already an attrib id, we can use the tuple outright</span>
<a href="#l9.600"></a><span id="l9.600">         if (typeof attribDesc[0] == &quot;number&quot;) {</span>
<a href="#l9.601"></a><span id="l9.601">           outAttribs.push(attribDesc);</span>
<a href="#l9.602"></a><span id="l9.602">           let [attribDef, attribParam] =</span>
<a href="#l9.603"></a><span id="l9.603" class="difflineminus">-            GlodaDatastore._attributeIDToDef[attribDesc[0]];</span>
<a href="#l9.604"></a><span id="l9.604" class="difflineplus">+            GlodaDatastore._attributeIDToDBDefAndParam[attribDesc[0]];</span>
<a href="#l9.605"></a><span id="l9.605">           memAttribs.push([attribDef, attribParam, attribDesc[1]]);</span>
<a href="#l9.606"></a><span id="l9.606">         }</span>
<a href="#l9.607"></a><span id="l9.607">         else {</span>
<a href="#l9.608"></a><span id="l9.608">           outAttribs.push([attribDesc[0].id, attribDesc[1]]);</span>
<a href="#l9.609"></a><span id="l9.609">           // the parameter is null if they just pass an attribute def</span>
<a href="#l9.610"></a><span id="l9.610">           memAttribs.push([attribDesc[0], null, attribDesc[1]]);</span>
<a href="#l9.611"></a><span id="l9.611">         }</span>
<a href="#l9.612"></a><span id="l9.612">       }</span>
<a href="#l9.613"></a><span id="l9.613" class="difflineat">@@ -1381,17 +1385,17 @@ var Gloda = {</span>
<a href="#l9.614"></a><span id="l9.614">    *</span>
<a href="#l9.615"></a><span id="l9.615">    * The result of the processing ends up with attributes in 3 different forms:</span>
<a href="#l9.616"></a><span id="l9.616">    * - Database attribute rows (to be added and removed).</span>
<a href="#l9.617"></a><span id="l9.617">    * - In-memory representation.</span>
<a href="#l9.618"></a><span id="l9.618">    * - JSON-able representation.</span>
<a href="#l9.619"></a><span id="l9.619">    */</span>
<a href="#l9.620"></a><span id="l9.620">   grokNounItem: function gloda_ns_grokNounItem(aItem, aRawReps, aIsNew,</span>
<a href="#l9.621"></a><span id="l9.621">       aCallbackHandle) {</span>
<a href="#l9.622"></a><span id="l9.622" class="difflineminus">-    let itemNounDef = this._nounIDToMeta[aItem.NOUN_ID];</span>
<a href="#l9.623"></a><span id="l9.623" class="difflineplus">+    let itemNounDef = this._nounIDToDef[aItem.NOUN_ID];</span>
<a href="#l9.624"></a><span id="l9.624">     let attribsByBoundName = itemNounDef.attribsByBoundName;</span>
<a href="#l9.625"></a><span id="l9.625">     </span>
<a href="#l9.626"></a><span id="l9.626">     let addDBAttribs = [];</span>
<a href="#l9.627"></a><span id="l9.627">     let removeDBAttribs = [];</span>
<a href="#l9.628"></a><span id="l9.628">     </span>
<a href="#l9.629"></a><span id="l9.629">     let jsonDict = {};</span>
<a href="#l9.630"></a><span id="l9.630">     </span>
<a href="#l9.631"></a><span id="l9.631">     let aOldItem = aItem;</span>
<a href="#l9.632"></a><span id="l9.632" class="difflineat">@@ -1476,17 +1480,17 @@ var Gloda = {</span>
<a href="#l9.633"></a><span id="l9.633">           let valuesAdded = [];</span>
<a href="#l9.634"></a><span id="l9.634">           for each (let [iCurValue, curValue] in Iterator(value)) {</span>
<a href="#l9.635"></a><span id="l9.635">             if (curValue in oldValueMap)</span>
<a href="#l9.636"></a><span id="l9.636">               delete oldValueMap[curValue];</span>
<a href="#l9.637"></a><span id="l9.637">             else</span>
<a href="#l9.638"></a><span id="l9.638">               valuesAdded.push(curValue);</span>
<a href="#l9.639"></a><span id="l9.639">           }</span>
<a href="#l9.640"></a><span id="l9.640">           // anything still on oldValueMap was removed.</span>
<a href="#l9.641"></a><span id="l9.641" class="difflineminus">-          let valuesRemoved = [val for val in Iterator(oldValueMap, true)];</span>
<a href="#l9.642"></a><span id="l9.642" class="difflineplus">+          let valuesRemoved = [val for (val in Iterator(oldValueMap, true))];</span>
<a href="#l9.643"></a><span id="l9.643">           // convert the values to database-style attribute rows</span>
<a href="#l9.644"></a><span id="l9.644">           addDBAttribs.push.apply(addDBAttribs,</span>
<a href="#l9.645"></a><span id="l9.645">             attrib.convertValuesToDBAttributes(valuesAdded));</span>
<a href="#l9.646"></a><span id="l9.646">           removeDBAttribs.push.apply(removeDBAttribs,</span>
<a href="#l9.647"></a><span id="l9.647">             attrib.convertValuesToDBAttributes(valuesRemoved));</span>
<a href="#l9.648"></a><span id="l9.648">         }</span>
<a href="#l9.649"></a><span id="l9.649">       </span>
<a href="#l9.650"></a><span id="l9.650">         // delete the old values to mark that we have processed them</span>
<a href="#l9.651"></a><span id="l9.651" class="difflineat">@@ -1550,17 +1554,17 @@ var Gloda = {</span>
<a href="#l9.652"></a><span id="l9.652">       let attribDesc = allAttribs[iAttrib];</span>
<a href="#l9.653"></a><span id="l9.653"> </span>
<a href="#l9.654"></a><span id="l9.654">       // is it an (attributedef / attribute def id, value) tuple?</span>
<a href="#l9.655"></a><span id="l9.655">       if (attribDesc.length == 2) {</span>
<a href="#l9.656"></a><span id="l9.656">         // if it's already an attrib id, we can use the tuple outright</span>
<a href="#l9.657"></a><span id="l9.657">         if (typeof attribDesc[0] == &quot;number&quot;) {</span>
<a href="#l9.658"></a><span id="l9.658">           outAttribs.push(attribDesc);</span>
<a href="#l9.659"></a><span id="l9.659">           let [attribDef, attribParam] =</span>
<a href="#l9.660"></a><span id="l9.660" class="difflineminus">-            GlodaDatastore._attributeIDToDef[attribDesc[0]];</span>
<a href="#l9.661"></a><span id="l9.661" class="difflineplus">+            GlodaDatastore._attributeIDToDBDefAndParam[attribDesc[0]];</span>
<a href="#l9.662"></a><span id="l9.662">           memAttribs.push([attribDef, attribParam, attribDesc[1]]);</span>
<a href="#l9.663"></a><span id="l9.663">         }</span>
<a href="#l9.664"></a><span id="l9.664">         else {</span>
<a href="#l9.665"></a><span id="l9.665">           outAttribs.push([attribDesc[0].id, attribDesc[1]]);</span>
<a href="#l9.666"></a><span id="l9.666">           // the parameter is null if they just pass an attribute def</span>
<a href="#l9.667"></a><span id="l9.667">           memAttribs.push([attribDesc[0], null, attribDesc[1]]);</span>
<a href="#l9.668"></a><span id="l9.668">         }</span>
<a href="#l9.669"></a><span id="l9.669">       }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l10.1"></a><span id="l10.1" class="difflineminus">--- a/modules/query.js</span>
<a href="#l10.2"></a><span id="l10.2" class="difflineplus">+++ b/modules/query.js</span>
<a href="#l10.3"></a><span id="l10.3" class="difflineat">@@ -100,22 +100,22 @@ GlodaQueryClass.prototype = {</span>
<a href="#l10.4"></a><span id="l10.4">    * Return a collection asynchronously populated by this collection.  You must</span>
<a href="#l10.5"></a><span id="l10.5">    *  provide a listener to receive notifications from the collection as it</span>
<a href="#l10.6"></a><span id="l10.6">    *  receives updates.  The listener object should implement onItemsAdded,</span>
<a href="#l10.7"></a><span id="l10.7">    *  onItemsModified, and onItemsRemoved methods, all of which take a single</span>
<a href="#l10.8"></a><span id="l10.8">    *  argument which is the list of items which have been added, modified, or</span>
<a href="#l10.9"></a><span id="l10.9">    *  removed respectively.</span>
<a href="#l10.10"></a><span id="l10.10">    */</span>
<a href="#l10.11"></a><span id="l10.11">   getCollection: function gloda_query_getCollection(aListener, aData) {</span>
<a href="#l10.12"></a><span id="l10.12" class="difflineminus">-    return this._nounMeta.datastore.queryFromQuery(this, aListener, false,</span>
<a href="#l10.13"></a><span id="l10.13" class="difflineplus">+    return this._nounDef.datastore.queryFromQuery(this, aListener, false,</span>
<a href="#l10.14"></a><span id="l10.14">       aData);</span>
<a href="#l10.15"></a><span id="l10.15">   },</span>
<a href="#l10.16"></a><span id="l10.16">   </span>
<a href="#l10.17"></a><span id="l10.17">   getAllSync: function gloda_query_getAllSync(aListener) {</span>
<a href="#l10.18"></a><span id="l10.18" class="difflineminus">-    return this._nounMeta.datastore.queryFromQuery(this, aListener, true);</span>
<a href="#l10.19"></a><span id="l10.19" class="difflineplus">+    return this._nounDef.datastore.queryFromQuery(this, aListener, true);</span>
<a href="#l10.20"></a><span id="l10.20">   },</span>
<a href="#l10.21"></a><span id="l10.21">   </span>
<a href="#l10.22"></a><span id="l10.22">   /**</span>
<a href="#l10.23"></a><span id="l10.23">    * Test whether the given first-class noun instance satisfies this query.</span>
<a href="#l10.24"></a><span id="l10.24">    * </span>
<a href="#l10.25"></a><span id="l10.25">    */</span>
<a href="#l10.26"></a><span id="l10.26">   test: function gloda_query_test(aObj) {</span>
<a href="#l10.27"></a><span id="l10.27">     // when changing this method, be sure that GlodaDatastore's queryFromQuery</span>
<a href="#l10.28"></a><span id="l10.28" class="difflineat">@@ -242,37 +242,37 @@ GlodaWildcardQueryClass.prototype = {</span>
<a href="#l10.29"></a><span id="l10.29">     return true;</span>
<a href="#l10.30"></a><span id="l10.30">   }</span>
<a href="#l10.31"></a><span id="l10.31"> };</span>
<a href="#l10.32"></a><span id="l10.32"> </span>
<a href="#l10.33"></a><span id="l10.33"> /**</span>
<a href="#l10.34"></a><span id="l10.34">  * Factory method to effectively create per-noun subclasses of GlodaQueryClass,</span>
<a href="#l10.35"></a><span id="l10.35">  *  GlodaExplicitQueryClas, and GlodaWildcardQueryClass.  For GlodaQueryClass</span>
<a href="#l10.36"></a><span id="l10.36">  *  this allows us to add per-noun helpers.  For the others, this is merely a</span>
<a href="#l10.37"></a><span id="l10.37" class="difflineminus">- *  means of allowing us to attach the (per-noun) nounMeta to the 'class'.</span>
<a href="#l10.38"></a><span id="l10.38" class="difflineplus">+ *  means of allowing us to attach the (per-noun) nounDef to the 'class'.</span>
<a href="#l10.39"></a><span id="l10.39">  */</span>
<a href="#l10.40"></a><span id="l10.40" class="difflineminus">-function GlodaQueryClassFactory(aNounMeta) {</span>
<a href="#l10.41"></a><span id="l10.41" class="difflineplus">+function GlodaQueryClassFactory(aNounDef) {</span>
<a href="#l10.42"></a><span id="l10.42">   let newQueryClass = function() {</span>
<a href="#l10.43"></a><span id="l10.43">     GlodaQueryClass.call(this);</span>
<a href="#l10.44"></a><span id="l10.44">   }; </span>
<a href="#l10.45"></a><span id="l10.45">   </span>
<a href="#l10.46"></a><span id="l10.46">   newQueryClass.prototype = new GlodaQueryClass;</span>
<a href="#l10.47"></a><span id="l10.47">   newQueryClass.prototype._queryClass = newQueryClass;</span>
<a href="#l10.48"></a><span id="l10.48" class="difflineminus">-  newQueryClass.prototype._nounMeta = aNounMeta;</span>
<a href="#l10.49"></a><span id="l10.49" class="difflineplus">+  newQueryClass.prototype._nounDef = aNounDef;</span>
<a href="#l10.50"></a><span id="l10.50">   </span>
<a href="#l10.51"></a><span id="l10.51">   let newExplicitClass = function(aCollection) {</span>
<a href="#l10.52"></a><span id="l10.52">     GlodaExplicitQueryClass.call(this);</span>
<a href="#l10.53"></a><span id="l10.53">     this.collection = aCollection;</span>
<a href="#l10.54"></a><span id="l10.54">   };</span>
<a href="#l10.55"></a><span id="l10.55">   newExplicitClass.prototype = new GlodaExplicitQueryClass();</span>
<a href="#l10.56"></a><span id="l10.56">   newExplicitClass.prototype._queryClass = newExplicitClass;</span>
<a href="#l10.57"></a><span id="l10.57" class="difflineminus">-  newExplicitClass.prototype._nounMeta = aNounMeta;</span>
<a href="#l10.58"></a><span id="l10.58" class="difflineplus">+  newExplicitClass.prototype._nounDef = aNounDef;</span>
<a href="#l10.59"></a><span id="l10.59"> </span>
<a href="#l10.60"></a><span id="l10.60">   let newWildcardClass = function(aCollection) {</span>
<a href="#l10.61"></a><span id="l10.61">     GlodaWildcardQueryClass.call(this);</span>
<a href="#l10.62"></a><span id="l10.62">     this.collection = aCollection;</span>
<a href="#l10.63"></a><span id="l10.63">   };</span>
<a href="#l10.64"></a><span id="l10.64">   newWildcardClass.prototype = new GlodaWildcardQueryClass();</span>
<a href="#l10.65"></a><span id="l10.65">   newWildcardClass.prototype._queryClass = newWildcardClass;</span>
<a href="#l10.66"></a><span id="l10.66" class="difflineminus">-  newWildcardClass.prototype._nounMeta = aNounMeta;</span>
<a href="#l10.67"></a><span id="l10.67" class="difflineplus">+  newWildcardClass.prototype._nounDef = aNounDefww;</span>
<a href="#l10.68"></a><span id="l10.68">   </span>
<a href="#l10.69"></a><span id="l10.69">   return [newQueryClass, newExplicitClass, newWildcardClass];</span>
<a href="#l10.70"></a><span id="l10.70"> }</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

