<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 11840:0d02d0b5c30c70fc6527a3442d3cb6161bc265b7</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ 0d02d0b5c30c70fc6527a3442d3cb6161bc265b7" />
<meta property="og:url" content="/comm-central/rev/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7" />
<meta property="og:description" content="Bug 746052 - Implement a JS-based MIME parser, part 3: use the parser in the fakeservers. r=irving" />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / 0d02d0b5c30c70fc6527a3442d3cb6161bc265b7 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7">shortlog</a> |
<a href="/comm-central/log/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7">files</a> |
changeset |
<a href="/comm-central/raw-rev/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7">raw</a>  | <a href="/comm-central/archive/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=746052">Bug 746052</a> - Implement a JS-based MIME parser, part 3: use the parser in the fakeservers. r=irving
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#74;&#111;&#115;&#104;&#117;&#97;&#32;&#67;&#114;&#97;&#110;&#109;&#101;&#114;&#32;&#60;&#80;&#105;&#100;&#103;&#101;&#111;&#116;&#49;&#56;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;&#62;</td></tr>
<tr><td></td><td class="date age">Fri, 25 Jan 2013 10:50:24 -0600</td></tr>

<tr>
 <td>changeset 11840</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7">0d02d0b5c30c70fc6527a3442d3cb6161bc265b7</a></td>
</tr>



<tr>
<td>parent 11839</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/d82d65b26412dc67fafefacf9d7d8631657eed27">d82d65b26412dc67fafefacf9d7d8631657eed27</a>
</td>
</tr>

<tr>
<td>child 11841</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/4653f81112f94219ebcb0631e37d6f3450b28414">4653f81112f94219ebcb0631e37d6f3450b28414</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=0d02d0b5c30c70fc6527a3442d3cb6161bc265b7">8819</a></td></tr>
<tr><td>push user</td><td>Pidgeot18@gmail.com</td></tr>
<tr><td>push date</td><td class="date age">Fri, 25 Jan 2013 16:58:52 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@0d02d0b5c30c [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=0d02d0b5c30c70fc6527a3442d3cb6161bc265b7">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=0d02d0b5c30c70fc6527a3442d3cb6161bc265b7&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=0d02d0b5c30c70fc6527a3442d3cb6161bc265b7&newProject=comm-central&newRevision=0d02d0b5c30c70fc6527a3442d3cb6161bc265b7&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=0d02d0b5c30c70fc6527a3442d3cb6161bc265b7&newProject=comm-central&newRevision=0d02d0b5c30c70fc6527a3442d3cb6161bc265b7&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=0d02d0b5c30c70fc6527a3442d3cb6161bc265b7&newProject=comm-central&newRevision=0d02d0b5c30c70fc6527a3442d3cb6161bc265b7&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>
<tr><td>reviewers</td><td><a href="/comm-central/log?rev=reviewer%28irving%29&revcount=50">irving</a></td></tr>
<tr><td>bugs</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=746052">746052</a></td></tr>




</table></div>

<div class="page_body description"><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=746052">Bug 746052</a> - Implement a JS-based MIME parser, part 3: use the parser in the fakeservers. r=irving</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/mime/jsmime/mimeParserCore.js">mailnews/mime/jsmime/mimeParserCore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/mime/jsmime/mimeParserCore.js">file</a> |
<a href="/comm-central/annotate/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/mime/jsmime/mimeParserCore.js">annotate</a> |
<a href="/comm-central/diff/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/mime/jsmime/mimeParserCore.js">diff</a> |
<a href="/comm-central/comparison/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/mime/jsmime/mimeParserCore.js">comparison</a> |
<a href="/comm-central/log/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/mime/jsmime/mimeParserCore.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/imapd.js">mailnews/test/fakeserver/imapd.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/imapd.js">file</a> |
<a href="/comm-central/annotate/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/imapd.js">annotate</a> |
<a href="/comm-central/diff/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/imapd.js">diff</a> |
<a href="/comm-central/comparison/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/imapd.js">comparison</a> |
<a href="/comm-central/log/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/imapd.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/nntpd.js">mailnews/test/fakeserver/nntpd.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/nntpd.js">file</a> |
<a href="/comm-central/annotate/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/nntpd.js">annotate</a> |
<a href="/comm-central/diff/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/nntpd.js">diff</a> |
<a href="/comm-central/comparison/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/nntpd.js">comparison</a> |
<a href="/comm-central/log/0d02d0b5c30c70fc6527a3442d3cb6161bc265b7/mailnews/test/fakeserver/nntpd.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/mailnews/mime/jsmime/mimeParserCore.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/mailnews/mime/jsmime/mimeParserCore.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -90,28 +90,32 @@</span>
<a href="#l1.4"></a><span id="l1.4">  *      Treat the message as starting at the given part number, so that no parts</span>
<a href="#l1.5"></a><span id="l1.5">  *      above &lt;string&gt; are returned.</span>
<a href="#l1.6"></a><span id="l1.6">  *    bodyformat: one of {none, raw, nodecode, decode} [default=nodecode]</span>
<a href="#l1.7"></a><span id="l1.7">  *      How to return the bodies of parts:</span>
<a href="#l1.8"></a><span id="l1.8">  *        none: no part data is returned</span>
<a href="#l1.9"></a><span id="l1.9">  *        raw: the body of the part is passed through raw</span>
<a href="#l1.10"></a><span id="l1.10">  *        nodecode: the body is passed through without decoding QP/Base64</span>
<a href="#l1.11"></a><span id="l1.11">  *        decode: quoted-printable and base64 are fully decoded</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineplus">+ *    stripcontinuations: &lt;boolean&gt; [default=true]</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+ *      If true, then the newlines in headers are removed in the returned</span>
<a href="#l1.14"></a><span id="l1.14" class="difflineplus">+ *      header objects.</span>
<a href="#l1.15"></a><span id="l1.15">  *    onerror: &lt;function(thrown error)&gt; [default = nop-function]</span>
<a href="#l1.16"></a><span id="l1.16">  *      An error function that is called if an emitter callback throws an error.</span>
<a href="#l1.17"></a><span id="l1.17">  *      By default, such errors are swallowed by the parser. If you want the</span>
<a href="#l1.18"></a><span id="l1.18">  *      parser itself to throw an error, rethrow it via the onerror function.</span>
<a href="#l1.19"></a><span id="l1.19">  */</span>
<a href="#l1.20"></a><span id="l1.20"> function Parser(emitter, options) {</span>
<a href="#l1.21"></a><span id="l1.21">   /// The actual emitter</span>
<a href="#l1.22"></a><span id="l1.22">   this._emitter = emitter;</span>
<a href="#l1.23"></a><span id="l1.23">   /// Options for the parser (those listed here are defaults)</span>
<a href="#l1.24"></a><span id="l1.24">   this._options = {</span>
<a href="#l1.25"></a><span id="l1.25">     pruneat: &quot;&quot;,</span>
<a href="#l1.26"></a><span id="l1.26">     bodyformat: &quot;nodecode&quot;,</span>
<a href="#l1.27"></a><span id="l1.27" class="difflineplus">+    stripcontinuations: true,</span>
<a href="#l1.28"></a><span id="l1.28">     onerror: function swallow(error) {}</span>
<a href="#l1.29"></a><span id="l1.29">   };</span>
<a href="#l1.30"></a><span id="l1.30">   // Load the options as a copy here (prevents people from changing on the fly).</span>
<a href="#l1.31"></a><span id="l1.31">   if (options)</span>
<a href="#l1.32"></a><span id="l1.32">     for (var opt in options) {</span>
<a href="#l1.33"></a><span id="l1.33">       this._options[opt] = options[opt];</span>
<a href="#l1.34"></a><span id="l1.34">     }</span>
<a href="#l1.35"></a><span id="l1.35"> </span>
<a href="#l1.36"></a><span id="l1.36" class="difflineat">@@ -459,17 +463,19 @@ Parser.prototype._parseHeaders = functio</span>
<a href="#l1.37"></a><span id="l1.37"> </span>
<a href="#l1.38"></a><span id="l1.38">   let headers = new Map();</span>
<a href="#l1.39"></a><span id="l1.39">   for (let i = 0; i &lt; values.length; i++) {</span>
<a href="#l1.40"></a><span id="l1.40">     // Look for a colon. If it's not present, this header line is malformed,</span>
<a href="#l1.41"></a><span id="l1.41">     // perhaps by premature EOF or similar. The value is null in this case.</span>
<a href="#l1.42"></a><span id="l1.42">     let colon = values[i].indexOf(&quot;:&quot;);</span>
<a href="#l1.43"></a><span id="l1.43">     if (colon &gt;= 0) {</span>
<a href="#l1.44"></a><span id="l1.44">       var header = values[i].substring(0, colon);</span>
<a href="#l1.45"></a><span id="l1.45" class="difflineminus">-      var val = values[i].substring(colon + 1).trim().replace(/[\r\n]/g,'');</span>
<a href="#l1.46"></a><span id="l1.46" class="difflineplus">+      var val = values[i].substring(colon + 1).trim();</span>
<a href="#l1.47"></a><span id="l1.47" class="difflineplus">+      if (this._options.stripcontinuations)</span>
<a href="#l1.48"></a><span id="l1.48" class="difflineplus">+        val = val.replace(/[\r\n]/g, '');</span>
<a href="#l1.49"></a><span id="l1.49">     } else {</span>
<a href="#l1.50"></a><span id="l1.50">       var header = values[i];</span>
<a href="#l1.51"></a><span id="l1.51">       var val = null;</span>
<a href="#l1.52"></a><span id="l1.52">     }</span>
<a href="#l1.53"></a><span id="l1.53"> </span>
<a href="#l1.54"></a><span id="l1.54">     // Canonicalize the header in lower-case form.</span>
<a href="#l1.55"></a><span id="l1.55">     header = header.trim().toLowerCase();</span>
<a href="#l1.56"></a><span id="l1.56">     // Omit &quot;empty&quot; headers</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/mailnews/test/fakeserver/imapd.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/mailnews/test/fakeserver/imapd.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -36,16 +36,20 @@</span>
<a href="#l2.4"></a><span id="l2.4"> // | + Flags: Flags are (as confirmed by Crispin) case-insensitive. Internal  //</span>
<a href="#l2.5"></a><span id="l2.5"> // |       flag equality, though, uses case-sensitive checks. Therefore they  //</span>
<a href="#l2.6"></a><span id="l2.6"> // |       should be normalized to a title-case form (e.g., \Noselect).       //</span>
<a href="#l2.7"></a><span id="l2.7"> // + Synchronization: On certain synchronizing commands, the daemon will call //</span>
<a href="#l2.8"></a><span id="l2.8"> // |   a synchronizing function to allow manipulating code the chance to      //</span>
<a href="#l2.9"></a><span id="l2.9"> // |   perform various (potentially expensive) actions.                       //</span>
<a href="#l2.10"></a><span id="l2.10"> // + Messages: A message is represented internally as an annotated URI.       //</span>
<a href="#l2.11"></a><span id="l2.11"> ////////////////////////////////////////////////////////////////////////////////</span>
<a href="#l2.12"></a><span id="l2.12" class="difflineplus">+</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+if (!(&quot;MimeParser&quot; in this))</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+  Components.utils.import(&quot;resource:///modules/mimeParser.jsm&quot;, this);</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+</span>
<a href="#l2.16"></a><span id="l2.16"> function imapDaemon(flags, syncFunc) {</span>
<a href="#l2.17"></a><span id="l2.17">   this._flags = flags;</span>
<a href="#l2.18"></a><span id="l2.18"> </span>
<a href="#l2.19"></a><span id="l2.19">   this.namespaces = [];</span>
<a href="#l2.20"></a><span id="l2.20">   this.idResponse = &quot;NIL&quot;;</span>
<a href="#l2.21"></a><span id="l2.21">   this.root = new imapMailbox(&quot;&quot;, null, {type : IMAP_NAMESPACE_PERSONAL});</span>
<a href="#l2.22"></a><span id="l2.22">   this.uidvalidity = Math.round(Date.now()/1000);</span>
<a href="#l2.23"></a><span id="l2.23">   this.inbox = new imapMailbox(&quot;INBOX&quot;, null, this.uidvalidity++);</span>
<a href="#l2.24"></a><span id="l2.24" class="difflineat">@@ -365,76 +369,47 @@ imapMessage.prototype = {</span>
<a href="#l2.25"></a><span id="l2.25">     if (str.length != start)</span>
<a href="#l2.26"></a><span id="l2.26">       throw &quot;Erm, we didn't just pass through 8-bit&quot;;</span>
<a href="#l2.27"></a><span id="l2.27">     length = length == -1 ? istream.available() : length;</span>
<a href="#l2.28"></a><span id="l2.28">     if (length &gt; istream.available())</span>
<a href="#l2.29"></a><span id="l2.29">       length = istream.available();</span>
<a href="#l2.30"></a><span id="l2.30">     str = bstream.readBytes(length);</span>
<a href="#l2.31"></a><span id="l2.31">     return str;</span>
<a href="#l2.32"></a><span id="l2.32">   },</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineminus">-  getPart : function (partNum, wantHeaders) {</span>
<a href="#l2.34"></a><span id="l2.34" class="difflineminus">-    // Long explanation of what's going on here:</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineminus">-    // Most of the confusing parts are due to the foibles of libmime.</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineminus">-    // The first thing we do is select how we want the output--raw for when we</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineminus">-    // just need to spit back data, header-land for when we need to actually</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineminus">-    // look at stuff.</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineminus">-    // Next we form the URIs to feed the converter. However, libmime doesn't do</span>
<a href="#l2.40"></a><span id="l2.40" class="difflineminus">-    // part numbers the same way that IMAP does it: where we want 4.2.2.1 in the</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineminus">-    // example, libmime wants 1.4.2.1.2.1. This means we have to collect the</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineminus">-    // headers first to find where the message/rfc822's exist. Yuck.</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineminus">-    // After that, we run the mime converter. Unfortunately, it only acts async,</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineminus">-    // so we do some ugly stuff to make it all sync.</span>
<a href="#l2.45"></a><span id="l2.45" class="difflineminus">-    var converter = Cc[&quot;@mozilla.org/streamconv;1?from=message/rfc822&amp;to=*/*&quot;]</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineminus">-                      .createInstance(Ci.nsIMimeStreamConverter)</span>
<a href="#l2.47"></a><span id="l2.47" class="difflineminus">-                      .QueryInterface(Ci.nsIStreamConverter);</span>
<a href="#l2.48"></a><span id="l2.48" class="difflineminus">-    converter.SetMimeOutputType(wantHeaders ? 1 : 11);</span>
<a href="#l2.49"></a><span id="l2.49"> </span>
<a href="#l2.50"></a><span id="l2.50" class="difflineminus">-    if (partNum == &quot;&quot;) {</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineminus">-      var URI = this._URI;</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineminus">-    } else {</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineminus">-      throw &quot;Can't get subparts!&quot;;</span>
<a href="#l2.54"></a><span id="l2.54" class="difflineminus">-    }</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineminus">-</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineminus">-    if (!gIOService)</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineminus">-      gIOService = Cc[&quot;@mozilla.org/network/io-service;1&quot;]</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineminus">-                     .getService(Ci.nsIIOService);</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineminus">-    var channel = gIOService.newChannel(URI, null, null);</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineminus">-    var requestListener = {</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineminus">-       onStreamComplete : function(loader, context, status, length, result) {</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineminus">-         this.answer = String.fromCharCode.apply(null, result);</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineminus">-         this.complete = true;</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineminus">-       },</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineminus">-       complete: false</span>
<a href="#l2.66"></a><span id="l2.66" class="difflineplus">+  get _partMap() {</span>
<a href="#l2.67"></a><span id="l2.67" class="difflineplus">+    if (this.__partMap)</span>
<a href="#l2.68"></a><span id="l2.68" class="difflineplus">+      return this.__partMap;</span>
<a href="#l2.69"></a><span id="l2.69" class="difflineplus">+    var partMap = {};</span>
<a href="#l2.70"></a><span id="l2.70" class="difflineplus">+    var emitter = {</span>
<a href="#l2.71"></a><span id="l2.71" class="difflineplus">+      startPart: function imap_buildMap_startPart(partNum, headers) {</span>
<a href="#l2.72"></a><span id="l2.72" class="difflineplus">+        var imapPartNum = partNum.replace('$','');</span>
<a href="#l2.73"></a><span id="l2.73" class="difflineplus">+        // If there are multiple imap parts that this represents, we'll</span>
<a href="#l2.74"></a><span id="l2.74" class="difflineplus">+        // overwrite with the latest. This is what we want (most deeply nested).</span>
<a href="#l2.75"></a><span id="l2.75" class="difflineplus">+        partMap[imapPartNum] = [partNum, headers];</span>
<a href="#l2.76"></a><span id="l2.76" class="difflineplus">+      }</span>
<a href="#l2.77"></a><span id="l2.77">     };</span>
<a href="#l2.78"></a><span id="l2.78" class="difflineminus">-    var sl = Cc[&quot;@mozilla.org/network/stream-loader;1&quot;]</span>
<a href="#l2.79"></a><span id="l2.79" class="difflineminus">-               .createInstance(Ci.nsIStreamLoader);</span>
<a href="#l2.80"></a><span id="l2.80" class="difflineminus">-    sl.init(requestListener);</span>
<a href="#l2.81"></a><span id="l2.81" class="difflineminus">-    converter.asyncConvertData(&quot;message/rfc822&quot;, &quot;text/plain&quot;, sl, channel);</span>
<a href="#l2.82"></a><span id="l2.82" class="difflineminus">-</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineminus">-    channel.asyncOpen(converter, null);</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineminus">-    while (!requestListener.complete)</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineminus">-      gThreadManager.currentThread.processNextEvent(true);</span>
<a href="#l2.86"></a><span id="l2.86" class="difflineminus">-</span>
<a href="#l2.87"></a><span id="l2.87" class="difflineminus">-    if (wantHeaders) {</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineminus">-      // It's an XML string... we now need to parse it</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineminus">-      var dmParser = Cc[&quot;@mozilla.org/xmlextras/domparser;1&quot;]</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineminus">-                       .createInstance(Ci.nsIDOMParser)</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineminus">-                       .QueryInterface(Ci.nsIDOMParserJS);</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineminus">-      var doc = dmParser.parseFromString(requestListener.answer, &quot;text/xml&quot;);</span>
<a href="#l2.93"></a><span id="l2.93" class="difflineminus">-      var children = doc.documentElement.firstChild.childNodes;</span>
<a href="#l2.94"></a><span id="l2.94" class="difflineminus">-      var headers = {}</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineminus">-      for (var i=0; i &lt; children.length; i++) {</span>
<a href="#l2.96"></a><span id="l2.96" class="difflineminus">-        var element = children.item(i);</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineminus">-        headers[element.getAttribute(&quot;field&quot;)] = element.lastChild.nodeValue;</span>
<a href="#l2.98"></a><span id="l2.98" class="difflineplus">+    MimeParser.parseSync(this.getText(), emitter,</span>
<a href="#l2.99"></a><span id="l2.99" class="difflineplus">+      {bodyformat: 'none', stripcontinuations: false});</span>
<a href="#l2.100"></a><span id="l2.100" class="difflineplus">+    return this.__partMap = partMap;</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineplus">+  },</span>
<a href="#l2.102"></a><span id="l2.102" class="difflineplus">+  getPartHeaders: function (partNum) {</span>
<a href="#l2.103"></a><span id="l2.103" class="difflineplus">+    return this._partMap[partNum][1];</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineplus">+  },</span>
<a href="#l2.105"></a><span id="l2.105" class="difflineplus">+  getPartBody: function (partNum) {</span>
<a href="#l2.106"></a><span id="l2.106" class="difflineplus">+    var body = '';</span>
<a href="#l2.107"></a><span id="l2.107" class="difflineplus">+    var emitter = {</span>
<a href="#l2.108"></a><span id="l2.108" class="difflineplus">+      deliverPartData: function (partNum, data) {</span>
<a href="#l2.109"></a><span id="l2.109" class="difflineplus">+        body += data;</span>
<a href="#l2.110"></a><span id="l2.110">       }</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineminus">-</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineminus">-      return headers;</span>
<a href="#l2.113"></a><span id="l2.113" class="difflineminus">-    }</span>
<a href="#l2.114"></a><span id="l2.114" class="difflineminus">-</span>
<a href="#l2.115"></a><span id="l2.115" class="difflineminus">-    return requestListener.answer;</span>
<a href="#l2.116"></a><span id="l2.116" class="difflineplus">+    };</span>
<a href="#l2.117"></a><span id="l2.117" class="difflineplus">+    var mimePartNum = this._partMap[partNum][0];</span>
<a href="#l2.118"></a><span id="l2.118" class="difflineplus">+    MimeParser.parseSync(this.getText(), emitter,</span>
<a href="#l2.119"></a><span id="l2.119" class="difflineplus">+      { pruneat: mimePartNum, bodyformat: 'raw'});</span>
<a href="#l2.120"></a><span id="l2.120" class="difflineplus">+    return body;</span>
<a href="#l2.121"></a><span id="l2.121">   }</span>
<a href="#l2.122"></a><span id="l2.122"> }</span>
<a href="#l2.123"></a><span id="l2.123"> // IMAP FLAGS</span>
<a href="#l2.124"></a><span id="l2.124"> // If you don't specify any flag, no flags are set.</span>
<a href="#l2.125"></a><span id="l2.125"> /**</span>
<a href="#l2.126"></a><span id="l2.126">  * This flag represents whether or not the daemon is case-insensitive.</span>
<a href="#l2.127"></a><span id="l2.127">  */</span>
<a href="#l2.128"></a><span id="l2.128"> const IMAP_FLAG_CASE_INSENSITIVE = 1;</span>
<a href="#l2.129"></a><span id="l2.129" class="difflineat">@@ -840,16 +815,17 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l2.130"></a><span id="l2.130">       }</span>
<a href="#l2.131"></a><span id="l2.131">       try {</span>
<a href="#l2.132"></a><span id="l2.132">         return this._tag + &quot; &quot; + func.call(this, line);</span>
<a href="#l2.133"></a><span id="l2.133">       } catch (e) { return this._tag + &quot; BAD &quot; + e; }</span>
<a href="#l2.134"></a><span id="l2.134">     }</span>
<a href="#l2.135"></a><span id="l2.135">     return undefined;</span>
<a href="#l2.136"></a><span id="l2.136">   },</span>
<a href="#l2.137"></a><span id="l2.137">   _dispatchCommand : function (command, args) {</span>
<a href="#l2.138"></a><span id="l2.138" class="difflineplus">+    this.sendingLiteral = false;</span>
<a href="#l2.139"></a><span id="l2.139">     command = command.toUpperCase();</span>
<a href="#l2.140"></a><span id="l2.140">     if (command == this._daemon.commandToFail.toUpperCase())</span>
<a href="#l2.141"></a><span id="l2.141">       return this._tag + &quot; NO &quot; + command + &quot; failed&quot;;</span>
<a href="#l2.142"></a><span id="l2.142">     if (command in this) {</span>
<a href="#l2.143"></a><span id="l2.143">       this._lastCommand = command;</span>
<a href="#l2.144"></a><span id="l2.144">       // Are we allowed to execute this command?</span>
<a href="#l2.145"></a><span id="l2.145">       if (this._enabledCommands[this._state].indexOf(command) == -1)</span>
<a href="#l2.146"></a><span id="l2.146">         return this._tag + &quot; BAD illegal command for current state &quot; + this._state;</span>
<a href="#l2.147"></a><span id="l2.147" class="difflineat">@@ -1504,17 +1480,17 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l2.148"></a><span id="l2.148">           messages.push(this._selectedMailbox._messages[id - 1]);</span>
<a href="#l2.149"></a><span id="l2.149">         }</span>
<a href="#l2.150"></a><span id="l2.150">       }</span>
<a href="#l2.151"></a><span id="l2.151">     }</span>
<a href="#l2.152"></a><span id="l2.152">     return messages;</span>
<a href="#l2.153"></a><span id="l2.153">   },</span>
<a href="#l2.154"></a><span id="l2.154">   _FETCH_BODY : function (message, query) {</span>
<a href="#l2.155"></a><span id="l2.155">     if (query == &quot;BODY&quot;)</span>
<a href="#l2.156"></a><span id="l2.156" class="difflineminus">-      throw &quot;No BODYSTRUCTURE or BODY yet&quot;;</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineplus">+      return &quot;BODYSTRUCTURE &quot; + bodystructure(message.getText(), false);</span>
<a href="#l2.158"></a><span id="l2.158">     // parts = [ name, section, empty, {, partial, empty } ]</span>
<a href="#l2.159"></a><span id="l2.159">     var parts = query.split(/[[\]&lt;&gt;]/);</span>
<a href="#l2.160"></a><span id="l2.160"> </span>
<a href="#l2.161"></a><span id="l2.161">     if (parts[0] != &quot;BODY.PEEK&quot; &amp;&amp; !this._readOnly)</span>
<a href="#l2.162"></a><span id="l2.162">       message.setFlag(&quot;\\Seen&quot;);</span>
<a href="#l2.163"></a><span id="l2.163"> </span>
<a href="#l2.164"></a><span id="l2.164">     if (parts[3])</span>
<a href="#l2.165"></a><span id="l2.165">       parts[3] = parts[3].split(/\./).map(function (e) { return parseInt(e); });</span>
<a href="#l2.166"></a><span id="l2.166" class="difflineat">@@ -1545,100 +1521,73 @@ IMAP_RFC3501_handler.prototype = {</span>
<a href="#l2.167"></a><span id="l2.167">       else</span>
<a href="#l2.168"></a><span id="l2.168">         query = parts[1];</span>
<a href="#l2.169"></a><span id="l2.169">     }</span>
<a href="#l2.170"></a><span id="l2.170">     if (parts[1].indexOf(&quot; &quot;) &gt; 0)</span>
<a href="#l2.171"></a><span id="l2.171">       var queryArgs = parseCommand(parts[1].substr(parts[1].indexOf(&quot; &quot;)))[0];</span>
<a href="#l2.172"></a><span id="l2.172">     else</span>
<a href="#l2.173"></a><span id="l2.173">       var queryArgs = [];</span>
<a href="#l2.174"></a><span id="l2.174"> </span>
<a href="#l2.175"></a><span id="l2.175" class="difflineminus">-    //var raw = query == &quot;TEXT&quot; || query == &quot;&quot;;</span>
<a href="#l2.176"></a><span id="l2.176">     // Now we have three parameters representing the part number (empty for top-</span>
<a href="#l2.177"></a><span id="l2.177">     // level), the subportion representing what we want to find (empty for the</span>
<a href="#l2.178"></a><span id="l2.178">     // body), and an array of arguments if we have a subquery. If we made an</span>
<a href="#l2.179"></a><span id="l2.179">     // error here, it will pop until it gets to FETCH, which will just pop at a</span>
<a href="#l2.180"></a><span id="l2.180">     // BAD response, which is what should happen if the query is malformed.</span>
<a href="#l2.181"></a><span id="l2.181">     // Now we dump it all off onto imapMessage to mess with.</span>
<a href="#l2.182"></a><span id="l2.182" class="difflineminus">-    let information = &quot;&quot;;</span>
<a href="#l2.183"></a><span id="l2.183" class="difflineminus">-    let bodyPart = new createBodyPart(message.getText());</span>
<a href="#l2.184"></a><span id="l2.184" class="difflineminus">-    if (partNum == &quot;&quot;)</span>
<a href="#l2.185"></a><span id="l2.185" class="difflineminus">-      information = message.getPart(partNum, false);</span>
<a href="#l2.186"></a><span id="l2.186" class="difflineminus">-    else</span>
<a href="#l2.187"></a><span id="l2.187" class="difflineminus">-      bodyPart.partNum = partNum.split(/\./);</span>
<a href="#l2.188"></a><span id="l2.188"> </span>
<a href="#l2.189"></a><span id="l2.189">     // Start off the response</span>
<a href="#l2.190"></a><span id="l2.190">     var response = &quot;BODY[&quot; + parts[1] + &quot;]&quot;;</span>
<a href="#l2.191"></a><span id="l2.191">     if (parts[3])</span>
<a href="#l2.192"></a><span id="l2.192">       response += &quot;&lt;&quot; + parts[3][0] + &quot;&gt;&quot;;</span>
<a href="#l2.193"></a><span id="l2.193">     response += &quot; &quot;;</span>
<a href="#l2.194"></a><span id="l2.194"> </span>
<a href="#l2.195"></a><span id="l2.195" class="difflineminus">-    var reconverter = Cc[&quot;@mozilla.org/messenger/mimeconverter;1&quot;]</span>
<a href="#l2.196"></a><span id="l2.196" class="difflineminus">-                        .createInstance(Ci.nsIMimeConverter);</span>
<a href="#l2.197"></a><span id="l2.197">     var data = &quot;&quot;;</span>
<a href="#l2.198"></a><span id="l2.198" class="difflineminus">-    var lines = information.split(/\r\n|\n/);</span>
<a href="#l2.199"></a><span id="l2.199">     switch (query) {</span>
<a href="#l2.200"></a><span id="l2.200">     case &quot;&quot;:</span>
<a href="#l2.201"></a><span id="l2.201">     case &quot;TEXT&quot;:</span>
<a href="#l2.202"></a><span id="l2.202" class="difflineminus">-      data +=  bodyPart.bodyText;</span>
<a href="#l2.203"></a><span id="l2.203" class="difflineplus">+      data += message.getPartBody(partNum);</span>
<a href="#l2.204"></a><span id="l2.204">       break;</span>
<a href="#l2.205"></a><span id="l2.205">     case &quot;HEADER&quot;: // I believe this specifies mime for an RFC822 message only</span>
<a href="#l2.206"></a><span id="l2.206" class="difflineminus">-      for each (let line in lines) {</span>
<a href="#l2.207"></a><span id="l2.207" class="difflineminus">-        // End of headers</span>
<a href="#l2.208"></a><span id="l2.208" class="difflineminus">-        if (line == '')</span>
<a href="#l2.209"></a><span id="l2.209" class="difflineminus">-          break;</span>
<a href="#l2.210"></a><span id="l2.210" class="difflineminus">-        data += line + &quot;\r\n&quot;;</span>
<a href="#l2.211"></a><span id="l2.211" class="difflineminus">-      }</span>
<a href="#l2.212"></a><span id="l2.212" class="difflineplus">+      data += message.getPartHeaders(partNum).rawHeaderText + &quot;\r\n&quot;;</span>
<a href="#l2.213"></a><span id="l2.213">       break;</span>
<a href="#l2.214"></a><span id="l2.214">     case &quot;MIME&quot;:</span>
<a href="#l2.215"></a><span id="l2.215" class="difflineminus">-      data += bodyPart.mime + &quot;\r\n\r\n&quot;;</span>
<a href="#l2.216"></a><span id="l2.216" class="difflineplus">+      data += message.getPartHeaders(partNum).rawHeaderText + &quot;\r\n\r\n&quot;;</span>
<a href="#l2.217"></a><span id="l2.217">       break;</span>
<a href="#l2.218"></a><span id="l2.218">     case &quot;HEADER.FIELDS&quot;:</span>
<a href="#l2.219"></a><span id="l2.219">       var joinList = [];</span>
<a href="#l2.220"></a><span id="l2.220" class="difflineminus">-      /*for each (let header in queryArgs) {</span>
<a href="#l2.221"></a><span id="l2.221" class="difflineminus">-        if (header in information) {</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineminus">-          joinList.push(reconverter.encodeMimePartIIStr_UTF8(</span>
<a href="#l2.223"></a><span id="l2.223" class="difflineminus">-            header + ': ' + information[header],</span>
<a href="#l2.224"></a><span id="l2.224" class="difflineminus">-            false,</span>
<a href="#l2.225"></a><span id="l2.225" class="difflineminus">-            &quot;UTF-8&quot;,</span>
<a href="#l2.226"></a><span id="l2.226" class="difflineminus">-            header.length + 2,</span>
<a href="#l2.227"></a><span id="l2.227" class="difflineminus">-            72));</span>
<a href="#l2.228"></a><span id="l2.228" class="difflineminus">-        }</span>
<a href="#l2.229"></a><span id="l2.229" class="difflineminus">-      }*/</span>
<a href="#l2.230"></a><span id="l2.230" class="difflineminus">-      var wantFold = false;</span>
<a href="#l2.231"></a><span id="l2.231" class="difflineminus">-      for each (let line in lines) {</span>
<a href="#l2.232"></a><span id="l2.232" class="difflineminus">-        // End of headers</span>
<a href="#l2.233"></a><span id="l2.233" class="difflineminus">-        if (line == '')</span>
<a href="#l2.234"></a><span id="l2.234" class="difflineminus">-          break;</span>
<a href="#l2.235"></a><span id="l2.235" class="difflineminus">-        if (line[0] == ' ' || line[0] == '\t') {</span>
<a href="#l2.236"></a><span id="l2.236" class="difflineminus">-          if (wantFold)</span>
<a href="#l2.237"></a><span id="l2.237" class="difflineminus">-            joinList.push(line);</span>
<a href="#l2.238"></a><span id="l2.238" class="difflineminus">-          continue;</span>
<a href="#l2.239"></a><span id="l2.239" class="difflineminus">-        }</span>
<a href="#l2.240"></a><span id="l2.240" class="difflineminus">-        wantFold = false;</span>
<a href="#l2.241"></a><span id="l2.241" class="difflineminus">-        var header = line.substring(0, line.indexOf(':'));</span>
<a href="#l2.242"></a><span id="l2.242" class="difflineminus">-        if (queryArgs.indexOf(header.toUpperCase()) &gt;= 0) {</span>
<a href="#l2.243"></a><span id="l2.243" class="difflineminus">-          joinList.push(line);</span>
<a href="#l2.244"></a><span id="l2.244" class="difflineminus">-          wantFold = true;</span>
<a href="#l2.245"></a><span id="l2.245" class="difflineminus">-        }</span>
<a href="#l2.246"></a><span id="l2.246" class="difflineplus">+      var headers = message.getPartHeaders(partNum);</span>
<a href="#l2.247"></a><span id="l2.247" class="difflineplus">+      for (let header of queryArgs) {</span>
<a href="#l2.248"></a><span id="l2.248" class="difflineplus">+        header = header.toLowerCase();</span>
<a href="#l2.249"></a><span id="l2.249" class="difflineplus">+        if (headers.has(header))</span>
<a href="#l2.250"></a><span id="l2.250" class="difflineplus">+          joinList.push([header + &quot;: &quot; + value</span>
<a href="#l2.251"></a><span id="l2.251" class="difflineplus">+                         for (value of headers.get(header))].join('\r\n'));</span>
<a href="#l2.252"></a><span id="l2.252">       }</span>
<a href="#l2.253"></a><span id="l2.253" class="difflineminus">-      data = joinList.join('\r\n') + &quot;\r\n&quot;;</span>
<a href="#l2.254"></a><span id="l2.254" class="difflineplus">+      data += joinList.join('\r\n') + &quot;\r\n&quot;;</span>
<a href="#l2.255"></a><span id="l2.255">       break;</span>
<a href="#l2.256"></a><span id="l2.256">     case &quot;HEADER.FIELDS.NOT&quot;:</span>
<a href="#l2.257"></a><span id="l2.257" class="difflineminus">-      data += partNum + query + &quot; not yet supported\r\n&quot;;</span>
<a href="#l2.258"></a><span id="l2.258" class="difflineplus">+      var joinList = [];</span>
<a href="#l2.259"></a><span id="l2.259" class="difflineplus">+      var headers = message.getPartHeaders(partNum);</span>
<a href="#l2.260"></a><span id="l2.260" class="difflineplus">+      for (let header of headers) {</span>
<a href="#l2.261"></a><span id="l2.261" class="difflineplus">+        if (!(header in queryArgs))</span>
<a href="#l2.262"></a><span id="l2.262" class="difflineplus">+          joinList.push([header + &quot;: &quot; + value</span>
<a href="#l2.263"></a><span id="l2.263" class="difflineplus">+                         for (value of headers.get(header))].join('\r\n'));</span>
<a href="#l2.264"></a><span id="l2.264" class="difflineplus">+      }</span>
<a href="#l2.265"></a><span id="l2.265" class="difflineplus">+      data += joinList.join('\r\n') + &quot;\r\n&quot;;</span>
<a href="#l2.266"></a><span id="l2.266">       break;</span>
<a href="#l2.267"></a><span id="l2.267">     default:</span>
<a href="#l2.268"></a><span id="l2.268" class="difflineminus">-      data += bodyPart.bodyText;</span>
<a href="#l2.269"></a><span id="l2.269" class="difflineplus">+      data += message.getPartBody(partNum);</span>
<a href="#l2.270"></a><span id="l2.270">     }</span>
<a href="#l2.271"></a><span id="l2.271"> </span>
<a href="#l2.272"></a><span id="l2.272" class="difflineplus">+    this.sendingLiteral = true;</span>
<a href="#l2.273"></a><span id="l2.273">     response += '{' + data.length + '}\r\n';</span>
<a href="#l2.274"></a><span id="l2.274">     response += data;</span>
<a href="#l2.275"></a><span id="l2.275">     return response;</span>
<a href="#l2.276"></a><span id="l2.276">   },</span>
<a href="#l2.277"></a><span id="l2.277">   _FETCH_BODYSTRUCTURE : function (message, query) {</span>
<a href="#l2.278"></a><span id="l2.278" class="difflineminus">-    return &quot;BODYSTRUCTURE &quot; + bodystructure(message.getText());</span>
<a href="#l2.279"></a><span id="l2.279" class="difflineplus">+    return &quot;BODYSTRUCTURE &quot; + bodystructure(message.getText(), true);</span>
<a href="#l2.280"></a><span id="l2.280">   },</span>
<a href="#l2.281"></a><span id="l2.281">   //_FETCH_ENVELOPE,</span>
<a href="#l2.282"></a><span id="l2.282">   _FETCH_FLAGS : function (message) {</span>
<a href="#l2.283"></a><span id="l2.283">     var response = &quot;FLAGS (&quot;;</span>
<a href="#l2.284"></a><span id="l2.284">     response += message.flags.join(&quot; &quot;);</span>
<a href="#l2.285"></a><span id="l2.285">     if (message.recent)</span>
<a href="#l2.286"></a><span id="l2.286">       response += &quot; \\Recent&quot;;</span>
<a href="#l2.287"></a><span id="l2.287">     response += &quot;)&quot;;</span>
<a href="#l2.288"></a><span id="l2.288" class="difflineat">@@ -2207,177 +2156,78 @@ var IMAP_RFC2195_extension = {</span>
<a href="#l2.289"></a><span id="l2.289">       return &quot;OK Hello friend! Where did you pull out this old auth scheme?&quot;;</span>
<a href="#l2.290"></a><span id="l2.290">     }</span>
<a href="#l2.291"></a><span id="l2.291">     else {</span>
<a href="#l2.292"></a><span id="l2.292">       return &quot;BAD Wrong username or password, crook!&quot;;</span>
<a href="#l2.293"></a><span id="l2.293">     }</span>
<a href="#l2.294"></a><span id="l2.294">   },</span>
<a href="#l2.295"></a><span id="l2.295"> };</span>
<a href="#l2.296"></a><span id="l2.296"> </span>
<a href="#l2.297"></a><span id="l2.297" class="difflineminus">-// FETCH BODY PARTS</span>
<a href="#l2.298"></a><span id="l2.298" class="difflineminus">-// part number is assumed valid</span>
<a href="#l2.299"></a><span id="l2.299" class="difflineminus">-function createBodyPart(msg, apn) {</span>
<a href="#l2.300"></a><span id="l2.300" class="difflineminus">-  if (!msg || msg == &quot;&quot;) {</span>
<a href="#l2.301"></a><span id="l2.301" class="difflineminus">-    this.index = null;</span>
<a href="#l2.302"></a><span id="l2.302" class="difflineminus">-    this.mime = &quot;&quot;;</span>
<a href="#l2.303"></a><span id="l2.303" class="difflineminus">-    this.bodyText = &quot;&quot;;</span>
<a href="#l2.304"></a><span id="l2.304" class="difflineminus">-    return;</span>
<a href="#l2.305"></a><span id="l2.305" class="difflineminus">-  }</span>
<a href="#l2.306"></a><span id="l2.306" class="difflineminus">-  this.BndryAttrRE = /boundary=&quot;([^&quot;]+)&quot;/img; // g is to continue where left off</span>
<a href="#l2.307"></a><span id="l2.307" class="difflineminus">-                                              // and enable use of lastIndex</span>
<a href="#l2.308"></a><span id="l2.308" class="difflineminus">-  this._msg = msg;</span>
<a href="#l2.309"></a><span id="l2.309" class="difflineminus">-  if (apn) {</span>
<a href="#l2.310"></a><span id="l2.310" class="difflineminus">-    this._pn  = apn;</span>
<a href="#l2.311"></a><span id="l2.311" class="difflineminus">-    this.init();</span>
<a href="#l2.312"></a><span id="l2.312" class="difflineminus">-  }</span>
<a href="#l2.313"></a><span id="l2.313" class="difflineminus">-}</span>
<a href="#l2.314"></a><span id="l2.314" class="difflineminus">-</span>
<a href="#l2.315"></a><span id="l2.315" class="difflineminus">-createBodyPart.prototype = {</span>
<a href="#l2.316"></a><span id="l2.316" class="difflineminus">-  set msg(x){</span>
<a href="#l2.317"></a><span id="l2.317" class="difflineminus">-    if (!x || x == &quot;&quot;) {</span>
<a href="#l2.318"></a><span id="l2.318" class="difflineminus">-      this.index = null;</span>
<a href="#l2.319"></a><span id="l2.319" class="difflineminus">-      this.mime = &quot;&quot;;</span>
<a href="#l2.320"></a><span id="l2.320" class="difflineminus">-      this.bodyText = &quot;&quot;;</span>
<a href="#l2.321"></a><span id="l2.321" class="difflineminus">-      this._msg = &quot;&quot;;</span>
<a href="#l2.322"></a><span id="l2.322" class="difflineminus">-      return;</span>
<a href="#l2.323"></a><span id="l2.323" class="difflineminus">-    }</span>
<a href="#l2.324"></a><span id="l2.324" class="difflineminus">-    this._msg = x;</span>
<a href="#l2.325"></a><span id="l2.325" class="difflineminus">-  },</span>
<a href="#l2.326"></a><span id="l2.326" class="difflineminus">-</span>
<a href="#l2.327"></a><span id="l2.327" class="difflineminus">-  // setting the partnum here will re-init if we have a msg</span>
<a href="#l2.328"></a><span id="l2.328" class="difflineminus">-  set partNum(x){</span>
<a href="#l2.329"></a><span id="l2.329" class="difflineminus">-    if (!x || x.length == 0)</span>
<a href="#l2.330"></a><span id="l2.330" class="difflineminus">-      return;</span>
<a href="#l2.331"></a><span id="l2.331" class="difflineminus">-    this._pn = x;</span>
<a href="#l2.332"></a><span id="l2.332" class="difflineminus">-    if (this._msg.length &gt; 0)</span>
<a href="#l2.333"></a><span id="l2.333" class="difflineminus">-      this.init();</span>
<a href="#l2.334"></a><span id="l2.334" class="difflineminus">-  },</span>
<a href="#l2.335"></a><span id="l2.335" class="difflineminus">-</span>
<a href="#l2.336"></a><span id="l2.336" class="difflineminus">-  init : function() {</span>
<a href="#l2.337"></a><span id="l2.337" class="difflineminus">-    this.BndryAttrRE.lastIndex = 0;</span>
<a href="#l2.338"></a><span id="l2.338" class="difflineminus">-    for each (let x in this._pn) {</span>
<a href="#l2.339"></a><span id="l2.339" class="difflineminus">-      var bndryAttrArray = this.BndryAttrRE.exec(this._msg);</span>
<a href="#l2.340"></a><span id="l2.340" class="difflineminus">-</span>
<a href="#l2.341"></a><span id="l2.341" class="difflineminus">-      if (!bndryAttrArray)  // FIXME--must have done a BODY[0] of a non-multipart</span>
<a href="#l2.342"></a><span id="l2.342" class="difflineminus">-        return;             // message. This may not be possible but let it be</span>
<a href="#l2.343"></a><span id="l2.343" class="difflineminus">-                            // known it needs a fix if this is done in real world</span>
<a href="#l2.344"></a><span id="l2.344" class="difflineminus">-                            // The RFC specs indicate bodyparts start at 1. Our</span>
<a href="#l2.345"></a><span id="l2.345" class="difflineminus">-                            // backend code uses bodypart 0 internally only.</span>
<a href="#l2.346"></a><span id="l2.346" class="difflineminus">-                            // We may want to throw here if we are asking server</span>
<a href="#l2.347"></a><span id="l2.347" class="difflineminus">-                            // for BODY[0]</span>
<a href="#l2.348"></a><span id="l2.348" class="difflineminus">-</span>
<a href="#l2.349"></a><span id="l2.349" class="difflineminus">-      var bndryTag = Array.map(&quot;--&quot; + bndryAttrArray[1],</span>
<a href="#l2.350"></a><span id="l2.350" class="difflineminus">-                               function(a) {</span>
<a href="#l2.351"></a><span id="l2.351" class="difflineminus">-                                 return '\\x' + parseInt(a.charCodeAt(0),10)</span>
<a href="#l2.352"></a><span id="l2.352" class="difflineminus">-                                                          .toString(16);})</span>
<a href="#l2.353"></a><span id="l2.353" class="difflineminus">-                          .join('');// now have a pattern like '\xnn\xnn\xnn\xnn'</span>
<a href="#l2.354"></a><span id="l2.354" class="difflineminus">-                                    // to allow boundaries with '+' and other</span>
<a href="#l2.355"></a><span id="l2.355" class="difflineminus">-                                    // regex metacharacters</span>
<a href="#l2.356"></a><span id="l2.356" class="difflineminus">-      var bndryRE = new RegExp(bndryTag + &quot;([\\s\\S]*?)\\r\\n&quot;, &quot;gm&quot;);</span>
<a href="#l2.357"></a><span id="l2.357" class="difflineminus">-      while (x &gt; 0) {</span>
<a href="#l2.358"></a><span id="l2.358" class="difflineminus">-        bndryRE.exec(this._msg); //need a check for null maybe. nah.</span>
<a href="#l2.359"></a><span id="l2.359" class="difflineminus">-        --x;</span>
<a href="#l2.360"></a><span id="l2.360" class="difflineminus">-      }</span>
<a href="#l2.361"></a><span id="l2.361" class="difflineminus">-    }</span>
<a href="#l2.362"></a><span id="l2.362" class="difflineminus">-    this.index = bndryRE.lastIndex; // start of mime</span>
<a href="#l2.363"></a><span id="l2.363" class="difflineminus">-    var mimeArrayRE = /[\s\S]*?\r\n\r\n/g;</span>
<a href="#l2.364"></a><span id="l2.364" class="difflineminus">-    mimeArrayRE.lastIndex = this.index;</span>
<a href="#l2.365"></a><span id="l2.365" class="difflineminus">-    var mimeArray = mimeArrayRE.exec(this._msg);</span>
<a href="#l2.366"></a><span id="l2.366" class="difflineminus">-    this.mime = mimeArray[0];</span>
<a href="#l2.367"></a><span id="l2.367" class="difflineminus">-    this.mime = this.mime.replace(/\r\n\s+/g,&quot; &quot;);</span>
<a href="#l2.368"></a><span id="l2.368" class="difflineminus">-    var textRE;</span>
<a href="#l2.369"></a><span id="l2.369" class="difflineminus">-</span>
<a href="#l2.370"></a><span id="l2.370" class="difflineminus">-    // if we have a mime part and it is a multipart find its terminator</span>
<a href="#l2.371"></a><span id="l2.371" class="difflineminus">-    if (mimeArray &amp;&amp; /boundary=/.test(mimeArray[0]))</span>
<a href="#l2.372"></a><span id="l2.372" class="difflineminus">-      textRE= new RegExp(&quot;([\\s\\S]*?)\\r\\n&quot; + bndryTag + &quot;--&quot;, &quot;mg&quot;);</span>
<a href="#l2.373"></a><span id="l2.373" class="difflineminus">-    // else just find next boundary</span>
<a href="#l2.374"></a><span id="l2.374" class="difflineminus">-    else</span>
<a href="#l2.375"></a><span id="l2.375" class="difflineminus">-      textRE = new RegExp(&quot;([\\s\\S]*?)\\r\\n&quot; + bndryTag , &quot;mg&quot;);</span>
<a href="#l2.376"></a><span id="l2.376" class="difflineminus">-</span>
<a href="#l2.377"></a><span id="l2.377" class="difflineminus">-    textRE.lastIndex = mimeArrayRE.lastIndex;</span>
<a href="#l2.378"></a><span id="l2.378" class="difflineminus">-    this.bodyText = textRE.exec(this._msg)[1];</span>
<a href="#l2.379"></a><span id="l2.379" class="difflineminus">-  }</span>
<a href="#l2.380"></a><span id="l2.380" class="difflineminus">-}</span>
<a href="#l2.381"></a><span id="l2.381" class="difflineminus">-</span>
<a href="#l2.382"></a><span id="l2.382"> // FETCH BODYSTRUCTURE</span>
<a href="#l2.383"></a><span id="l2.383" class="difflineminus">-function bodystructure(msg) {</span>
<a href="#l2.384"></a><span id="l2.384" class="difflineplus">+function bodystructure(msg, extension) {</span>
<a href="#l2.385"></a><span id="l2.385">   if (!msg || msg == &quot;&quot;)</span>
<a href="#l2.386"></a><span id="l2.386">     return &quot;&quot;;</span>
<a href="#l2.387"></a><span id="l2.387" class="difflineminus">-  var res = &quot;&quot;;</span>
<a href="#l2.388"></a><span id="l2.388" class="difflineminus">-  const MimeRE = /([\s\S]*?)\r\n\r\n/gm;</span>
<a href="#l2.389"></a><span id="l2.389" class="difflineminus">-  MimeRE.lastIndex = 0;</span>
<a href="#l2.390"></a><span id="l2.390" class="difflineminus">-  const BndryAttrRE = /boundary=&quot;([^&quot;]+)&quot;/img; // g is to continue where left off</span>
<a href="#l2.391"></a><span id="l2.391" class="difflineminus">-                                               // and enable use of lastIndex</span>
<a href="#l2.392"></a><span id="l2.392" class="difflineminus">-  BndryAttrRE.lastIndex = 0;</span>
<a href="#l2.393"></a><span id="l2.393" class="difflineminus">-</span>
<a href="#l2.394"></a><span id="l2.394" class="difflineminus">-  var filterBodyStructure = function(aStr, aBndryTag)</span>
<a href="#l2.395"></a><span id="l2.395" class="difflineminus">-  {</span>
<a href="#l2.396"></a><span id="l2.396" class="difflineminus">-    var isTerm;</span>
<a href="#l2.397"></a><span id="l2.397" class="difflineminus">-    if (!aStr || aStr == &quot;&quot;)</span>
<a href="#l2.398"></a><span id="l2.398" class="difflineminus">-      return;</span>
<a href="#l2.399"></a><span id="l2.399" class="difflineminus">-</span>
<a href="#l2.400"></a><span id="l2.400" class="difflineminus">-    var mime = MimeRE.exec(aStr); // mime[1] is mime string</span>
<a href="#l2.401"></a><span id="l2.401" class="difflineminus">-    var contentType = [];</span>
<a href="#l2.402"></a><span id="l2.402" class="difflineminus">-    var contentTransferEncoding;</span>
<a href="#l2.403"></a><span id="l2.403" class="difflineminus">-    if (mime[1]){</span>
<a href="#l2.404"></a><span id="l2.404" class="difflineminus">-      mime[1] = mime[1].replace(/\r\n\s*/g,&quot; &quot;); // folding</span>
<a href="#l2.405"></a><span id="l2.405" class="difflineminus">-</span>
<a href="#l2.406"></a><span id="l2.406" class="difflineminus">-      // save mime info</span>
<a href="#l2.407"></a><span id="l2.407" class="difflineminus">-      // contentType[1] is type and contentType[2] is subtype</span>
<a href="#l2.408"></a><span id="l2.408" class="difflineminus">-      contentType = /content-type:[^\S]*([^\/]*)\/([^\/;\s]*)/im.exec(mime[1]);</span>
<a href="#l2.409"></a><span id="l2.409" class="difflineminus">-      contentType[1] = contentType[1].toUpperCase();</span>
<a href="#l2.410"></a><span id="l2.410" class="difflineminus">-      contentType[2] = contentType[2].toUpperCase();</span>
<a href="#l2.411"></a><span id="l2.411" class="difflineminus">-      contentTransferEncoding = /Content-Transfer-Encoding:[^\S]*([^;\s]*)/im.exec(mime[1]);</span>
<a href="#l2.412"></a><span id="l2.412" class="difflineminus">-      contentTransferEncoding = contentTransferEncoding ?</span>
<a href="#l2.413"></a><span id="l2.413" class="difflineminus">-                                contentTransferEncoding[1].toUpperCase() :</span>
<a href="#l2.414"></a><span id="l2.414" class="difflineminus">-                                &quot;7BIT&quot;;</span>
<a href="#l2.415"></a><span id="l2.415" class="difflineminus">-    } else {  //default to plain/text</span>
<a href="#l2.416"></a><span id="l2.416" class="difflineminus">-      contentType[1] = &quot;TEXT&quot;;</span>
<a href="#l2.417"></a><span id="l2.417" class="difflineminus">-      contentType[2] = &quot;PLAIN&quot;;</span>
<a href="#l2.418"></a><span id="l2.418" class="difflineminus">-      contentTransferEncoding = &quot;7BIT&quot;;</span>
<a href="#l2.419"></a><span id="l2.419" class="difflineminus">-    }</span>
<a href="#l2.420"></a><span id="l2.420" class="difflineminus">-    if (contentType[1] == &quot;MULTIPART&quot;) {</span>
<a href="#l2.421"></a><span id="l2.421" class="difflineminus">-      res += &quot;(&quot;;</span>
<a href="#l2.422"></a><span id="l2.422"> </span>
<a href="#l2.423"></a><span id="l2.423" class="difflineminus">-      // get boundary. Local scope lastIndex</span>
<a href="#l2.424"></a><span id="l2.424" class="difflineminus">-      BndryAttrRE.lastIndex = 0;</span>
<a href="#l2.425"></a><span id="l2.425" class="difflineminus">-      var bndryAttrArray = BndryAttrRE.exec(mime[1]);</span>
<a href="#l2.426"></a><span id="l2.426" class="difflineminus">-      var bndryTag = Array.map(&quot;--&quot; + bndryAttrArray[1],</span>
<a href="#l2.427"></a><span id="l2.427" class="difflineminus">-                           function(a) {</span>
<a href="#l2.428"></a><span id="l2.428" class="difflineminus">-                             return '\\x' + parseInt(a.charCodeAt(0),10).toString(16);})</span>
<a href="#l2.429"></a><span id="l2.429" class="difflineminus">-                          .join('');</span>
<a href="#l2.430"></a><span id="l2.430" class="difflineminus">-      var bndryRE = new RegExp(bndryTag + &quot;(..)?&quot;, &quot;gm&quot;);</span>
<a href="#l2.431"></a><span id="l2.431" class="difflineplus">+  // Use the mime parser emitter to generate body structure data. Most of the</span>
<a href="#l2.432"></a><span id="l2.432" class="difflineplus">+  // string will be built as we exit a part. Currently not working:</span>
<a href="#l2.433"></a><span id="l2.433" class="difflineplus">+  // 1. Some of the fields return NIL instead of trying to calculate them.</span>
<a href="#l2.434"></a><span id="l2.434" class="difflineplus">+  // 2. MESSAGE is missing the ENVELOPE and the lines at the end.</span>
<a href="#l2.435"></a><span id="l2.435" class="difflineplus">+  var bodystruct = '';</span>
<a href="#l2.436"></a><span id="l2.436" class="difflineplus">+  function paramToString(params) {</span>
<a href="#l2.437"></a><span id="l2.437" class="difflineplus">+    let paramList = [];</span>
<a href="#l2.438"></a><span id="l2.438" class="difflineplus">+    for (var param in params)</span>
<a href="#l2.439"></a><span id="l2.439" class="difflineplus">+      paramList.push('&quot;' + param.toUpperCase() + '&quot; &quot;' + params[param] + '&quot;');</span>
<a href="#l2.440"></a><span id="l2.440" class="difflineplus">+    return paramList.length == 0 ? 'NIL' : '(' + paramList.join(' ') + ')';</span>
<a href="#l2.441"></a><span id="l2.441" class="difflineplus">+  }</span>
<a href="#l2.442"></a><span id="l2.442" class="difflineplus">+  var headerStack = [];</span>
<a href="#l2.443"></a><span id="l2.443" class="difflineplus">+  var BodyStructureEmitter = {</span>
<a href="#l2.444"></a><span id="l2.444" class="difflineplus">+    startPart: function bodystructure_startPart(partNum, headers) {</span>
<a href="#l2.445"></a><span id="l2.445" class="difflineplus">+      bodystruct += '(';</span>
<a href="#l2.446"></a><span id="l2.446" class="difflineplus">+      headerStack.push(headers);</span>
<a href="#l2.447"></a><span id="l2.447" class="difflineplus">+      this.numLines = 0;</span>
<a href="#l2.448"></a><span id="l2.448" class="difflineplus">+      this.length = 0;</span>
<a href="#l2.449"></a><span id="l2.449" class="difflineplus">+    },</span>
<a href="#l2.450"></a><span id="l2.450" class="difflineplus">+    deliverPartData: function bodystructure_deliverPartData(partNum, data) {</span>
<a href="#l2.451"></a><span id="l2.451" class="difflineplus">+      this.length += data.length;</span>
<a href="#l2.452"></a><span id="l2.452" class="difflineplus">+      this.numLines += [x for each (x in data) if (x == '\n')].length;</span>
<a href="#l2.453"></a><span id="l2.453" class="difflineplus">+    },</span>
<a href="#l2.454"></a><span id="l2.454" class="difflineplus">+    endPart: function bodystructure_endPart(partNum) {</span>
<a href="#l2.455"></a><span id="l2.455" class="difflineplus">+      // Grab the headers from before</span>
<a href="#l2.456"></a><span id="l2.456" class="difflineplus">+      let headers = headerStack.pop();</span>
<a href="#l2.457"></a><span id="l2.457" class="difflineplus">+      let contentType = headers.has('content-type') ?</span>
<a href="#l2.458"></a><span id="l2.458" class="difflineplus">+        headers.get('content-type')[0] : 'text/plain';</span>
<a href="#l2.459"></a><span id="l2.459" class="difflineplus">+      let [type, params] = MimeParser.parseHeaderField(contentType,</span>
<a href="#l2.460"></a><span id="l2.460" class="difflineplus">+        MimeParser.HEADER_PARAMETER);</span>
<a href="#l2.461"></a><span id="l2.461" class="difflineplus">+      // Use uppercase canonicalization for now</span>
<a href="#l2.462"></a><span id="l2.462" class="difflineplus">+      type = type.toUpperCase();</span>
<a href="#l2.463"></a><span id="l2.463" class="difflineplus">+      let [media, sub] = type.split('/', 2);</span>
<a href="#l2.464"></a><span id="l2.464" class="difflineplus">+      if (media == &quot;MULTIPART&quot;) {</span>
<a href="#l2.465"></a><span id="l2.465" class="difflineplus">+        bodystruct += ' &quot;' + sub + '&quot;';</span>
<a href="#l2.466"></a><span id="l2.466" class="difflineplus">+        if (extension) {</span>
<a href="#l2.467"></a><span id="l2.467" class="difflineplus">+          bodystruct += ' ' + paramToString(params);</span>
<a href="#l2.468"></a><span id="l2.468" class="difflineplus">+          // XXX: implement the rest</span>
<a href="#l2.469"></a><span id="l2.469" class="difflineplus">+          bodystruct += ' NIL NIL NIL';</span>
<a href="#l2.470"></a><span id="l2.470" class="difflineplus">+        }</span>
<a href="#l2.471"></a><span id="l2.471" class="difflineplus">+      } else {</span>
<a href="#l2.472"></a><span id="l2.472" class="difflineplus">+        bodystruct += '&quot;' + media + '&quot; &quot;' + sub + '&quot;';</span>
<a href="#l2.473"></a><span id="l2.473" class="difflineplus">+        bodystruct += ' ' + paramToString(params);</span>
<a href="#l2.474"></a><span id="l2.474"> </span>
<a href="#l2.475"></a><span id="l2.475" class="difflineminus">-      // goto boundary</span>
<a href="#l2.476"></a><span id="l2.476" class="difflineminus">-      bndryRE.lastIndex = MimeRE.lastIndex;</span>
<a href="#l2.477"></a><span id="l2.477" class="difflineminus">-      // find boundary tag and check if terminated)</span>
<a href="#l2.478"></a><span id="l2.478" class="difflineminus">-      isTerm = bndryRE.exec(aStr)[1] == &quot;--&quot;;</span>
<a href="#l2.479"></a><span id="l2.479" class="difflineplus">+        // XXX: Content ID, Content description</span>
<a href="#l2.480"></a><span id="l2.480" class="difflineplus">+        bodystruct += ' NIL NIL';</span>
<a href="#l2.481"></a><span id="l2.481" class="difflineplus">+</span>
<a href="#l2.482"></a><span id="l2.482" class="difflineplus">+        let cte = headers.has('content-transfer-encoding') ?</span>
<a href="#l2.483"></a><span id="l2.483" class="difflineplus">+          headers.get('content-transfer-encoding')[0].toUpperCase() : '7BIT';</span>
<a href="#l2.484"></a><span id="l2.484" class="difflineplus">+        bodystruct += ' &quot;' + cte + '&quot;';</span>
<a href="#l2.485"></a><span id="l2.485"> </span>
<a href="#l2.486"></a><span id="l2.486" class="difflineminus">-      // loop to get all parts</span>
<a href="#l2.487"></a><span id="l2.487" class="difflineminus">-      while(MimeRE.lastIndex &gt; 0 &amp;&amp; !isTerm) {</span>
<a href="#l2.488"></a><span id="l2.488" class="difflineminus">-        MimeRE.lastIndex = bndryRE.lastIndex;</span>
<a href="#l2.489"></a><span id="l2.489" class="difflineminus">-        filterBodyStructure(aStr, bndryTag);</span>
<a href="#l2.490"></a><span id="l2.490" class="difflineminus">-        isTerm = bndryRE.exec(aStr)[1] == &quot;--&quot;;</span>
<a href="#l2.491"></a><span id="l2.491" class="difflineplus">+        bodystruct += ' ' + this.length;</span>
<a href="#l2.492"></a><span id="l2.492" class="difflineplus">+        if (media == &quot;TEXT&quot;)</span>
<a href="#l2.493"></a><span id="l2.493" class="difflineplus">+          bodystruct += ' ' + this.numLines;</span>
<a href="#l2.494"></a><span id="l2.494" class="difflineplus">+</span>
<a href="#l2.495"></a><span id="l2.495" class="difflineplus">+        // XXX: I don't want to implement these yet</span>
<a href="#l2.496"></a><span id="l2.496" class="difflineplus">+        if (extension)</span>
<a href="#l2.497"></a><span id="l2.497" class="difflineplus">+          bodystruct += ' NIL NIL NIL NIL';</span>
<a href="#l2.498"></a><span id="l2.498">       }</span>
<a href="#l2.499"></a><span id="l2.499" class="difflineminus">-</span>
<a href="#l2.500"></a><span id="l2.500" class="difflineminus">-      // write mime info</span>
<a href="#l2.501"></a><span id="l2.501" class="difflineminus">-      res += ' &quot;'+contentType[2]+'&quot; (&quot;BOUNDARY&quot; &quot;'+bndryAttrArray[1]+'&quot;) NIL NIL)';</span>
<a href="#l2.502"></a><span id="l2.502" class="difflineminus">-    } else {</span>
<a href="#l2.503"></a><span id="l2.503" class="difflineminus">-      var tmpRE = new RegExp(&quot;([\\s\\S]*?)\\r\\n&quot; + aBndryTag, &quot;gm&quot;);</span>
<a href="#l2.504"></a><span id="l2.504" class="difflineminus">-      tmpRE.lastIndex = MimeRE.lastIndex;</span>
<a href="#l2.505"></a><span id="l2.505" class="difflineminus">-      var tmpArr = tmpRE.exec(aStr);</span>
<a href="#l2.506"></a><span id="l2.506" class="difflineminus">-      var lines = 0;</span>
<a href="#l2.507"></a><span id="l2.507" class="difflineminus">-      var len;</span>
<a href="#l2.508"></a><span id="l2.508" class="difflineminus">-      if (tmpArr) {</span>
<a href="#l2.509"></a><span id="l2.509" class="difflineminus">-        len = tmpArr[1].length;</span>
<a href="#l2.510"></a><span id="l2.510" class="difflineminus">-        for each (let i in tmpArr[1]) {</span>
<a href="#l2.511"></a><span id="l2.511" class="difflineminus">-          lines += (i == '\r') ? 1 : 0 ;</span>
<a href="#l2.512"></a><span id="l2.512" class="difflineminus">-        }</span>
<a href="#l2.513"></a><span id="l2.513" class="difflineminus">-      }</span>
<a href="#l2.514"></a><span id="l2.514" class="difflineminus">-      res += '(&quot;' + contentType[1] + '&quot; &quot;' + contentType[2] +</span>
<a href="#l2.515"></a><span id="l2.515" class="difflineminus">-             '&quot; NIL NIL NIL &quot;' +  contentTransferEncoding + '&quot; ' + len +</span>
<a href="#l2.516"></a><span id="l2.516" class="difflineminus">-             ((contentType[1] == &quot;TEXT&quot;) ? (&quot; &quot; + lines) : &quot;&quot;) +</span>
<a href="#l2.517"></a><span id="l2.517" class="difflineminus">-             ' NIL NIL NIL)';</span>
<a href="#l2.518"></a><span id="l2.518" class="difflineplus">+      bodystruct += ')';</span>
<a href="#l2.519"></a><span id="l2.519">     }</span>
<a href="#l2.520"></a><span id="l2.520">   };</span>
<a href="#l2.521"></a><span id="l2.521" class="difflineminus">-  filterBodyStructure(msg);</span>
<a href="#l2.522"></a><span id="l2.522" class="difflineminus">-  return res;</span>
<a href="#l2.523"></a><span id="l2.523" class="difflineplus">+  MimeParser.parseSync(msg, BodyStructureEmitter, {});</span>
<a href="#l2.524"></a><span id="l2.524" class="difflineplus">+  return bodystruct;</span>
<a href="#l2.525"></a><span id="l2.525"> }</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/mailnews/test/fakeserver/nntpd.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/mailnews/test/fakeserver/nntpd.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -1,11 +1,13 @@</span>
<a href="#l3.4"></a><span id="l3.4"> /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</span>
<a href="#l3.5"></a><span id="l3.5"> // This file implements test NNTP servers</span>
<a href="#l3.6"></a><span id="l3.6"> </span>
<a href="#l3.7"></a><span id="l3.7" class="difflineplus">+Components.utils.import(&quot;resource:///modules/mimeParser.jsm&quot;);</span>
<a href="#l3.8"></a><span id="l3.8" class="difflineplus">+</span>
<a href="#l3.9"></a><span id="l3.9"> function nntpDaemon(flags) {</span>
<a href="#l3.10"></a><span id="l3.10">   this._groups = {};</span>
<a href="#l3.11"></a><span id="l3.11">   this._messages = {};</span>
<a href="#l3.12"></a><span id="l3.12">   this._flags = flags;</span>
<a href="#l3.13"></a><span id="l3.13"> }</span>
<a href="#l3.14"></a><span id="l3.14"> nntpDaemon.prototype = {</span>
<a href="#l3.15"></a><span id="l3.15">   addGroup : function(group, postable) {</span>
<a href="#l3.16"></a><span id="l3.16">     var flags = 0;</span>
<a href="#l3.17"></a><span id="l3.17" class="difflineat">@@ -61,51 +63,36 @@ nntpDaemon.prototype = {</span>
<a href="#l3.18"></a><span id="l3.18"> }</span>
<a href="#l3.19"></a><span id="l3.19"> </span>
<a href="#l3.20"></a><span id="l3.20"> function newsArticle(text) {</span>
<a href="#l3.21"></a><span id="l3.21">   this.headers = {};</span>
<a href="#l3.22"></a><span id="l3.22">   this.body = &quot;&quot;;</span>
<a href="#l3.23"></a><span id="l3.23">   this.messageID = &quot;&quot;;</span>
<a href="#l3.24"></a><span id="l3.24">   this.fullText = text;</span>
<a href="#l3.25"></a><span id="l3.25"> </span>
<a href="#l3.26"></a><span id="l3.26" class="difflineminus">-  var lines = text.split(&quot;\n&quot;), passedHeaders = false;</span>
<a href="#l3.27"></a><span id="l3.27" class="difflineminus">-  var preamble = &quot;&quot;;</span>
<a href="#l3.28"></a><span id="l3.28" class="difflineminus">-  for each(var line in lines) {</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineminus">-    if (!passedHeaders) {</span>
<a href="#l3.30"></a><span id="l3.30" class="difflineminus">-      if (line.length == 0) {</span>
<a href="#l3.31"></a><span id="l3.31" class="difflineminus">-        passedHeaders = true;</span>
<a href="#l3.32"></a><span id="l3.32" class="difflineminus">-        continue;</span>
<a href="#l3.33"></a><span id="l3.33" class="difflineminus">-      }</span>
<a href="#l3.34"></a><span id="l3.34" class="difflineminus">-      preamble += line + '\n';</span>
<a href="#l3.35"></a><span id="l3.35" class="difflineminus">-      var parts = line.split(/:[ \t]*/);</span>
<a href="#l3.36"></a><span id="l3.36" class="difflineminus">-      this.headers[parts[0].toLowerCase()] = parts[1];</span>
<a href="#l3.37"></a><span id="l3.37" class="difflineminus">-      switch (parts[0].toLowerCase()) {</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineminus">-        case &quot;message-id&quot;:</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineminus">-          var start = parts[1].indexOf('&lt;');</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineminus">-          var end = parts[1].indexOf('&gt;', start);</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineminus">-          this.messageID = parts[1].substring(start, end+1);</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineminus">-          break;</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineminus">-        case &quot;newsgroups&quot;:</span>
<a href="#l3.44"></a><span id="l3.44" class="difflineminus">-          this.groups = parts[1].split(/[ \t]*,[ \t]*/);</span>
<a href="#l3.45"></a><span id="l3.45" class="difflineminus">-          break;</span>
<a href="#l3.46"></a><span id="l3.46" class="difflineminus">-      }</span>
<a href="#l3.47"></a><span id="l3.47" class="difflineminus">-    } else {</span>
<a href="#l3.48"></a><span id="l3.48" class="difflineminus">-      this.body += line + &quot;\n&quot;;</span>
<a href="#l3.49"></a><span id="l3.49" class="difflineplus">+  var headerMap;</span>
<a href="#l3.50"></a><span id="l3.50" class="difflineplus">+  [headerMap, this.body] = MimeParser.extractHeadersAndBody(text);</span>
<a href="#l3.51"></a><span id="l3.51" class="difflineplus">+  for (var [header, values] of headerMap) {</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineplus">+    var value = values[0];</span>
<a href="#l3.53"></a><span id="l3.53" class="difflineplus">+    this.headers[header] = value;</span>
<a href="#l3.54"></a><span id="l3.54" class="difflineplus">+    if (header == &quot;message-id&quot;) {</span>
<a href="#l3.55"></a><span id="l3.55" class="difflineplus">+      var start = value.indexOf('&lt;');</span>
<a href="#l3.56"></a><span id="l3.56" class="difflineplus">+      var end = value.indexOf('&gt;', start);</span>
<a href="#l3.57"></a><span id="l3.57" class="difflineplus">+      this.messageID = value.substring(start, end+1);</span>
<a href="#l3.58"></a><span id="l3.58" class="difflineplus">+    } else if (header == &quot;newsgroups&quot;) {</span>
<a href="#l3.59"></a><span id="l3.59" class="difflineplus">+      this.groups = value.split(/[ \t]*,[ \t]*/);</span>
<a href="#l3.60"></a><span id="l3.60">     }</span>
<a href="#l3.61"></a><span id="l3.61">   }</span>
<a href="#l3.62"></a><span id="l3.62"> </span>
<a href="#l3.63"></a><span id="l3.63">   // Add in non-existent fields</span>
<a href="#l3.64"></a><span id="l3.64">   if (!(&quot;lines&quot; in this.headers))</span>
<a href="#l3.65"></a><span id="l3.65">   {</span>
<a href="#l3.66"></a><span id="l3.66">     let lines = this.body.split('\n').length;</span>
<a href="#l3.67"></a><span id="l3.67">     this.headers[&quot;lines&quot;] = lines;</span>
<a href="#l3.68"></a><span id="l3.68" class="difflineminus">-    preamble += &quot;Lines: &quot;+lines;</span>
<a href="#l3.69"></a><span id="l3.69">   }</span>
<a href="#l3.70"></a><span id="l3.70" class="difflineminus">-</span>
<a href="#l3.71"></a><span id="l3.71" class="difflineminus">-  this.fulltext = preamble + '\n' + this.body;</span>
<a href="#l3.72"></a><span id="l3.72"> }</span>
<a href="#l3.73"></a><span id="l3.73"> </span>
<a href="#l3.74"></a><span id="l3.74"> /**</span>
<a href="#l3.75"></a><span id="l3.75">  * This function converts an NNTP wildmat into a regular expression.</span>
<a href="#l3.76"></a><span id="l3.76">  *</span>
<a href="#l3.77"></a><span id="l3.77">  * I don't know how accurate it is wrt i18n characters, but it's primary usage</span>
<a href="#l3.78"></a><span id="l3.78">  * right now is just XPAT, where i18n effects are utterly unspecified, so I am</span>
<a href="#l3.79"></a><span id="l3.79">  * not too concerned.</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

