<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<link rel="icon" href="/static/35f393d6769a/hgicon.png" type="image/png" />
<meta name="robots" content="index, nofollow"/>
<link rel="stylesheet" href="/static/35f393d6769a/style-gitweb.css" type="text/css" />

<style type="text/css">
div.feed {
  float: right;
}
a img {
  border-width: 0px;
}
div.log_link {
  width: 80px;
  background-color: white;
}

div.log_body {
  padding-left: 96px;
}
</style>
<script type="text/javascript" src="/static/35f393d6769a/mercurial.js"></script>

<meta property="og:image" content="/static/35f393d6769a/moz-logo-bw-rgb.svg"/>
<meta property="og:type" content="website"/>

<title>comm-central: changeset 931:c2df7b8472375d2cff1684a8b6aec7f15355840f</title>
<link rel="alternate" type="application/atom+xml"
   href="/comm-central/atom-log" title="Atom feed for comm-central"/>
<link rel="alternate" type="application/rss+xml"
   href="/comm-central/rss-log" title="RSS feed for comm-central"/>

<meta property="og:title" content="comm-central @ c2df7b8472375d2cff1684a8b6aec7f15355840f" />
<meta property="og:url" content="/comm-central/rev/c2df7b8472375d2cff1684a8b6aec7f15355840f" />
<meta property="og:description" content="status commit, private propagation so as to not break peoples." />

</head>
<body>

<div class="page_header">
<div class="logo">
    <a href="https://developer.mozilla.org/en/docs/Mercurial">
        <img src="/static/35f393d6769a/moz-logo-bw-rgb.svg" alt="mercurial" />
    </a>
</div>
<a href="/">Mercurial</a> &gt; <a href="/comm-central">comm-central</a>  / changeset / c2df7b8472375d2cff1684a8b6aec7f15355840f 
</div>

<div class="page_nav">
<div>
<a href="/comm-central/summary">summary</a> |
<a href="/comm-central/shortlog/c2df7b8472375d2cff1684a8b6aec7f15355840f">shortlog</a> |
<a href="/comm-central/log/c2df7b8472375d2cff1684a8b6aec7f15355840f">changelog</a> |
<a href="/comm-central/pushloghtml">pushlog</a> |
<a href="/comm-central/graph/c2df7b8472375d2cff1684a8b6aec7f15355840f">graph</a> |
<a href="/comm-central/tags">tags</a> |
<a href="/comm-central/bookmarks">bookmarks</a> |
<a href="/comm-central/branches">branches</a> |
<a href="/comm-central/file/c2df7b8472375d2cff1684a8b6aec7f15355840f">files</a> |
changeset |
<a href="/comm-central/raw-rev/c2df7b8472375d2cff1684a8b6aec7f15355840f">raw</a>  | <a href="/comm-central/archive/c2df7b8472375d2cff1684a8b6aec7f15355840f.zip">zip</a>  |
<a href="/comm-central/help">help</a>
</div>

<div class="search">
<form id="searchform" action="/comm-central/log">

<input name="rev" type="text" value="" size="40" />
<div id="hint">Find changesets by keywords (author, files, the commit message), revision
number or hash, or <a href="/comm-central/help/revsets">revset expression</a>.</div>
</form>
</div>
</div>

<div class="title">
status commit, private propagation so as to not break peoples.
<span class="logtags"></span>
</div>
<div class="title_text">
<table cellspacing="0">

<tr><td>author</td><td>&#65;&#110;&#100;&#114;&#101;&#119;&#32;&#83;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#32;&#60;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#64;&#97;&#115;&#117;&#116;&#104;&#101;&#114;&#108;&#97;&#110;&#100;&#46;&#111;&#114;&#103;&#62;</td></tr>
<tr><td></td><td class="date age">Sat, 20 Sep 2008 05:00:13 -0700</td></tr>

<tr>
 <td>changeset 931</td>
 <td style="font-family:monospace"><a class="list" href="/comm-central/rev/c2df7b8472375d2cff1684a8b6aec7f15355840f">c2df7b8472375d2cff1684a8b6aec7f15355840f</a></td>
</tr>



<tr>
<td>parent 930</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/1f547582f25ee366fc65d754bb93b31a69c4d5e0">1f547582f25ee366fc65d754bb93b31a69c4d5e0</a>
</td>
</tr>

<tr>
<td>child 932</td>
<td style="font-family:monospace">
<a class="list" href="/comm-central/rev/9082e6d74f2d06a0a0556585ec78174fbe276cc0">9082e6d74f2d06a0a0556585ec78174fbe276cc0</a>
</td>
</tr>
<tr><td>push id</td><td><a href="/comm-central/pushloghtml?changeset=c2df7b8472375d2cff1684a8b6aec7f15355840f">743</a></td></tr>
<tr><td>push user</td><td>dmosedale@mozilla.com</td></tr>
<tr><td>push date</td><td class="date age">Tue, 04 Nov 2008 20:01:44 +0000</td></tr>

<tr><td>treeherder</td><td>comm-central@a79b923a9cba [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf">default view</a>] [<a href="https://treeherder.mozilla.org/#/jobs?repo=comm-central&revision=a79b923a9cba395cb3911b27c9599ffb8c997caf&filter-resultStatus=testfailed&filter-resultStatus=busted&filter-resultStatus=exception">failures only]</td></tr>
<tr><td>perfherder</td><td>[<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=1" target="_blank">talos</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=2" target="_blank">build metrics</a>] [<a href="https://treeherder.mozilla.org/perf.html#/compare?originalProject=comm-central&originalRevision=a79b923a9cba395cb3911b27c9599ffb8c997caf&newProject=comm-central&newRevision=d32b4cc6f46d1195ae66fd0cf8395c60b9259ca6&framework=6" target="_blank">platform microbench</a>] (compared to previous push)</td></tr>






</table></div>

<div class="page_body description">status commit, private propagation so as to not break peoples.</div>
<div class="list_head"></div>
<div class="title_text">
<table cellspacing="0">

<tr class="parity0">
<td><a class="list" href="/comm-central/diff/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/collection.js">modules/collection.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/collection.js">file</a> |
<a href="/comm-central/annotate/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/collection.js">annotate</a> |
<a href="/comm-central/diff/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/collection.js">diff</a> |
<a href="/comm-central/comparison/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/collection.js">comparison</a> |
<a href="/comm-central/log/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/collection.js">revisions</a>
</td>
</tr>
<tr class="parity1">
<td><a class="list" href="/comm-central/diff/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/datastore.js">modules/datastore.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/datastore.js">file</a> |
<a href="/comm-central/annotate/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/datastore.js">annotate</a> |
<a href="/comm-central/diff/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/datastore.js">diff</a> |
<a href="/comm-central/comparison/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/datastore.js">comparison</a> |
<a href="/comm-central/log/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/datastore.js">revisions</a>
</td>
</tr>
<tr class="parity0">
<td><a class="list" href="/comm-central/diff/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/indexer.js">modules/indexer.js</a></td>
<td></td>
<td class="link">
<a href="/comm-central/file/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/indexer.js">file</a> |
<a href="/comm-central/annotate/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/indexer.js">annotate</a> |
<a href="/comm-central/diff/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/indexer.js">diff</a> |
<a href="/comm-central/comparison/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/indexer.js">comparison</a> |
<a href="/comm-central/log/c2df7b8472375d2cff1684a8b6aec7f15355840f/modules/indexer.js">revisions</a>
</td>
</tr>
</table></div>

<div class="page_body diffblocks"><div class="diffblock"><pre class="sourcelines">
<a href="#l1.1"></a><span id="l1.1" class="difflineminus">--- a/modules/collection.js</span>
<a href="#l1.2"></a><span id="l1.2" class="difflineplus">+++ b/modules/collection.js</span>
<a href="#l1.3"></a><span id="l1.3" class="difflineat">@@ -104,25 +104,28 @@ GlodaCollectionManager.prototype = {</span>
<a href="#l1.4"></a><span id="l1.4">                                                                    aCacheSize);</span>
<a href="#l1.5"></a><span id="l1.5">   },</span>
<a href="#l1.6"></a><span id="l1.6">   </span>
<a href="#l1.7"></a><span id="l1.7">   /**</span>
<a href="#l1.8"></a><span id="l1.8">    * Attempt to locate an instance of the object of the given noun type with the</span>
<a href="#l1.9"></a><span id="l1.9">    *  given id.  Counts as a cache hit if found.  (And if it was't in a cache,</span>
<a href="#l1.10"></a><span id="l1.10">    *  but rather a collection, it is added to the cache.)</span>
<a href="#l1.11"></a><span id="l1.11">    */</span>
<a href="#l1.12"></a><span id="l1.12" class="difflineminus">-  cacheLookupOne: function gloda_colm_cacheLookupOne(aNounID, aID) {</span>
<a href="#l1.13"></a><span id="l1.13" class="difflineplus">+  cacheLookupOne: function gloda_colm_cacheLookupOne(aNounID, aID, aDoCache) {</span>
<a href="#l1.14"></a><span id="l1.14">     let cache = this._cachesByNoun[aNounID];</span>
<a href="#l1.15"></a><span id="l1.15">     </span>
<a href="#l1.16"></a><span id="l1.16">     if (cache) {</span>
<a href="#l1.17"></a><span id="l1.17">       if (aID in cache._idMap) {</span>
<a href="#l1.18"></a><span id="l1.18">         let item = cache._idMap[aID];</span>
<a href="#l1.19"></a><span id="l1.19">         return cache.hit(item);</span>
<a href="#l1.20"></a><span id="l1.20">       }</span>
<a href="#l1.21"></a><span id="l1.21">     }</span>
<a href="#l1.22"></a><span id="l1.22" class="difflineplus">+    </span>
<a href="#l1.23"></a><span id="l1.23" class="difflineplus">+    if (aDoCache === false)</span>
<a href="#l1.24"></a><span id="l1.24" class="difflineplus">+      cache = null;</span>
<a href="#l1.25"></a><span id="l1.25">   </span>
<a href="#l1.26"></a><span id="l1.26">     for each (let collection in this.getCollectionsForNounID(aNounID)) {</span>
<a href="#l1.27"></a><span id="l1.27">       if (aID in collection._idMap) {</span>
<a href="#l1.28"></a><span id="l1.28">         let item = collection._idMap[aID];</span>
<a href="#l1.29"></a><span id="l1.29">         if (cache)</span>
<a href="#l1.30"></a><span id="l1.30">           cache.add([item]);</span>
<a href="#l1.31"></a><span id="l1.31">         return item;</span>
<a href="#l1.32"></a><span id="l1.32">       }</span>
<a href="#l1.33"></a><span id="l1.33" class="difflineat">@@ -423,17 +426,18 @@ function GlodaLRUCacheCollection(aNounMe</span>
<a href="#l1.34"></a><span id="l1.34">     aCacheSize = 32;</span>
<a href="#l1.35"></a><span id="l1.35">   this._maxCacheSize = aCacheSize;</span>
<a href="#l1.36"></a><span id="l1.36"> }</span>
<a href="#l1.37"></a><span id="l1.37"> </span>
<a href="#l1.38"></a><span id="l1.38"> GlodaLRUCacheCollection.prototype = new GlodaCollection;</span>
<a href="#l1.39"></a><span id="l1.39"> GlodaLRUCacheCollection.prototype.add = function cache_add(aItems) {</span>
<a href="#l1.40"></a><span id="l1.40">   for each (let item in aItems) {</span>
<a href="#l1.41"></a><span id="l1.41">     if (item.id in this._idMap) {</span>
<a href="#l1.42"></a><span id="l1.42" class="difflineminus">-      LOG.error(&quot;attempt to add an item to a collection it is already in!&quot;);</span>
<a href="#l1.43"></a><span id="l1.43" class="difflineplus">+      // DEBUGME so, we're dealing with this, but it shouldn't happen.  need</span>
<a href="#l1.44"></a><span id="l1.44" class="difflineplus">+      //  trace-debuggage.</span>
<a href="#l1.45"></a><span id="l1.45">       continue;</span>
<a href="#l1.46"></a><span id="l1.46">     }</span>
<a href="#l1.47"></a><span id="l1.47">     this._idMap[item.id] = item;</span>
<a href="#l1.48"></a><span id="l1.48">     </span>
<a href="#l1.49"></a><span id="l1.49">     item._lruPrev = this._tail;</span>
<a href="#l1.50"></a><span id="l1.50">     // we do have to make sure that we will set _head the first time we insert</span>
<a href="#l1.51"></a><span id="l1.51">     //  something</span>
<a href="#l1.52"></a><span id="l1.52">     if (this._tail !== null)</span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l2.1"></a><span id="l2.1" class="difflineminus">--- a/modules/datastore.js</span>
<a href="#l2.2"></a><span id="l2.2" class="difflineplus">+++ b/modules/datastore.js</span>
<a href="#l2.3"></a><span id="l2.3" class="difflineat">@@ -484,34 +484,59 @@ let GlodaDatastore = {</span>
<a href="#l2.4"></a><span id="l2.4">     //  manage that.</span>
<a href="#l2.5"></a><span id="l2.5">     this._populateAttributeDefManagedId();</span>
<a href="#l2.6"></a><span id="l2.6">     this._populateConversationManagedId();</span>
<a href="#l2.7"></a><span id="l2.7">     this._populateMessageManagedId();</span>
<a href="#l2.8"></a><span id="l2.8">     this._populateContactManagedId();</span>
<a href="#l2.9"></a><span id="l2.9">     this._populateIdentityManagedId();</span>
<a href="#l2.10"></a><span id="l2.10">   },</span>
<a href="#l2.11"></a><span id="l2.11">   </span>
<a href="#l2.12"></a><span id="l2.12" class="difflineminus">-  shutdown: function gloda_ds_shutdown() {</span>
<a href="#l2.13"></a><span id="l2.13" class="difflineplus">+  /**</span>
<a href="#l2.14"></a><span id="l2.14" class="difflineplus">+   * Initiate database shutdown; because this might requiring waiting for</span>
<a href="#l2.15"></a><span id="l2.15" class="difflineplus">+   *  outstanding synchronous events to drain, we allow the caller to pass in</span>
<a href="#l2.16"></a><span id="l2.16" class="difflineplus">+   *  a callback to invoke if we are unable to complete shutdown within this</span>
<a href="#l2.17"></a><span id="l2.17" class="difflineplus">+   *  call.</span>
<a href="#l2.18"></a><span id="l2.18" class="difflineplus">+   * @return true if we were able to shutdown fully, false if we were not.  The</span>
<a href="#l2.19"></a><span id="l2.19" class="difflineplus">+   *   callback, if provided, will be notified if we return false.  It will</span>
<a href="#l2.20"></a><span id="l2.20" class="difflineplus">+   *   not be called if we return true.  </span>
<a href="#l2.21"></a><span id="l2.21" class="difflineplus">+   */</span>
<a href="#l2.22"></a><span id="l2.22" class="difflineplus">+  shutdown: function gloda_ds_shutdown(aCallback, aCallbackThis) {</span>
<a href="#l2.23"></a><span id="l2.23">     // clear out any transaction</span>
<a href="#l2.24"></a><span id="l2.24">     while (this._transactionDepth) {</span>
<a href="#l2.25"></a><span id="l2.25">       this._log.info(&quot;Closing pending transaction out for shutdown.&quot;);</span>
<a href="#l2.26"></a><span id="l2.26">       // just schedule this function to be run again once the transaction has</span>
<a href="#l2.27"></a><span id="l2.27">       //  been closed out.</span>
<a href="#l2.28"></a><span id="l2.28" class="difflineminus">-      this._commitTransaction(this.shutdown, this);</span>
<a href="#l2.29"></a><span id="l2.29" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l2.30"></a><span id="l2.30" class="difflineplus">+    }</span>
<a href="#l2.31"></a><span id="l2.31" class="difflineplus">+    </span>
<a href="#l2.32"></a><span id="l2.32" class="difflineplus">+    let datastore = this;</span>
<a href="#l2.33"></a><span id="l2.33" class="difflineplus">+    </span>
<a href="#l2.34"></a><span id="l2.34" class="difflineplus">+    function finish_cleanup() {</span>
<a href="#l2.35"></a><span id="l2.35" class="difflineplus">+      datastore._cleanupAsyncStatements();</span>
<a href="#l2.36"></a><span id="l2.36" class="difflineplus">+      datastore._log.info(&quot;Closing async connection&quot;);</span>
<a href="#l2.37"></a><span id="l2.37" class="difflineplus">+      datastore.asyncConnection.close();</span>
<a href="#l2.38"></a><span id="l2.38" class="difflineplus">+      datastore.asyncConnection = null;</span>
<a href="#l2.39"></a><span id="l2.39" class="difflineplus">+      </span>
<a href="#l2.40"></a><span id="l2.40" class="difflineplus">+      datastore._cleanupSyncStatements();</span>
<a href="#l2.41"></a><span id="l2.41" class="difflineplus">+      datastore._log.info(&quot;Closing sync connection&quot;);</span>
<a href="#l2.42"></a><span id="l2.42" class="difflineplus">+      datastore.syncConnection.close();</span>
<a href="#l2.43"></a><span id="l2.43" class="difflineplus">+      datastore.syncConnection = null;</span>
<a href="#l2.44"></a><span id="l2.44" class="difflineplus">+      </span>
<a href="#l2.45"></a><span id="l2.45" class="difflineplus">+      if (aCallback)</span>
<a href="#l2.46"></a><span id="l2.46" class="difflineplus">+        aCallback.call(aCallbackThis);</span>
<a href="#l2.47"></a><span id="l2.47">     }</span>
<a href="#l2.48"></a><span id="l2.48"> </span>
<a href="#l2.49"></a><span id="l2.49" class="difflineminus">-    this._cleanupAsyncStatements();</span>
<a href="#l2.50"></a><span id="l2.50" class="difflineminus">-    this._log.info(&quot;Closing async connection&quot;);</span>
<a href="#l2.51"></a><span id="l2.51" class="difflineminus">-    this.asyncConnection.close();</span>
<a href="#l2.52"></a><span id="l2.52" class="difflineminus">-    this.asyncConnection = null;</span>
<a href="#l2.53"></a><span id="l2.53" class="difflineminus">-    </span>
<a href="#l2.54"></a><span id="l2.54" class="difflineminus">-    this._cleanupSyncStatements();</span>
<a href="#l2.55"></a><span id="l2.55" class="difflineminus">-    this._log.info(&quot;Closing sync connection&quot;);</span>
<a href="#l2.56"></a><span id="l2.56" class="difflineminus">-    this.syncConnection.close();</span>
<a href="#l2.57"></a><span id="l2.57" class="difflineminus">-    this.syncConnection = null;</span>
<a href="#l2.58"></a><span id="l2.58" class="difflineplus">+    if (this._pendingAsyncStatements) {</span>
<a href="#l2.59"></a><span id="l2.59" class="difflineplus">+      this._pendingAsyncCompletedListener = finish_cleanup;</span>
<a href="#l2.60"></a><span id="l2.60" class="difflineplus">+      return false;</span>
<a href="#l2.61"></a><span id="l2.61" class="difflineplus">+    }</span>
<a href="#l2.62"></a><span id="l2.62" class="difflineplus">+    else {</span>
<a href="#l2.63"></a><span id="l2.63" class="difflineplus">+      finish_cleanup();</span>
<a href="#l2.64"></a><span id="l2.64" class="difflineplus">+      return true;</span>
<a href="#l2.65"></a><span id="l2.65" class="difflineplus">+    }</span>
<a href="#l2.66"></a><span id="l2.66">   },</span>
<a href="#l2.67"></a><span id="l2.67">   </span>
<a href="#l2.68"></a><span id="l2.68">   /**</span>
<a href="#l2.69"></a><span id="l2.69">    * Create our database; basically a wrapper around _createSchema.</span>
<a href="#l2.70"></a><span id="l2.70">    */</span>
<a href="#l2.71"></a><span id="l2.71">   _createDB: function gloda_ds_createDB(aDBService, aDBFile) {</span>
<a href="#l2.72"></a><span id="l2.72">     var dbConnection = aDBService.openUnsharedDatabase(aDBFile);</span>
<a href="#l2.73"></a><span id="l2.73">     </span>
<a href="#l2.74"></a><span id="l2.74" class="difflineat">@@ -765,43 +790,29 @@ let GlodaDatastore = {</span>
<a href="#l2.75"></a><span id="l2.75">     }</span>
<a href="#l2.76"></a><span id="l2.76">     this._transactionDepth++;</span>
<a href="#l2.77"></a><span id="l2.77">   },</span>
<a href="#l2.78"></a><span id="l2.78">   /**</span>
<a href="#l2.79"></a><span id="l2.79">    * Commit a potentially nested transaction; if we are the outer-most</span>
<a href="#l2.80"></a><span id="l2.80">    *  transaction and no sub-transaction issues a rollback</span>
<a href="#l2.81"></a><span id="l2.81">    *  (via _rollbackTransaction) then we commit, otherwise we rollback.</span>
<a href="#l2.82"></a><span id="l2.82">    */</span>
<a href="#l2.83"></a><span id="l2.83" class="difflineminus">-  _commitTransaction: function gloda_ds_commitTransaction(aCallback,</span>
<a href="#l2.84"></a><span id="l2.84" class="difflineminus">-      aCallbackThis) {</span>
<a href="#l2.85"></a><span id="l2.85" class="difflineplus">+  _commitTransaction: function gloda_ds_commitTransaction() {</span>
<a href="#l2.86"></a><span id="l2.86">     this._transactionDepth--;</span>
<a href="#l2.87"></a><span id="l2.87">     if (this._transactionDepth == 0) {</span>
<a href="#l2.88"></a><span id="l2.88" class="difflineminus">-      let notifier = undefined;</span>
<a href="#l2.89"></a><span id="l2.89" class="difflineminus">-      if (aCallback) {</span>
<a href="#l2.90"></a><span id="l2.90" class="difflineminus">-        notifier = {</span>
<a href="#l2.91"></a><span id="l2.91" class="difflineminus">-          handleResult: function () {},</span>
<a href="#l2.92"></a><span id="l2.92" class="difflineminus">-          handleError: function() {},</span>
<a href="#l2.93"></a><span id="l2.93" class="difflineminus">-          handleCompletion: function () {</span>
<a href="#l2.94"></a><span id="l2.94" class="difflineminus">-            aCallback.call(aCallbackThis);</span>
<a href="#l2.95"></a><span id="l2.95" class="difflineminus">-          }</span>
<a href="#l2.96"></a><span id="l2.96" class="difflineminus">-        };</span>
<a href="#l2.97"></a><span id="l2.97" class="difflineminus">-      }</span>
<a href="#l2.98"></a><span id="l2.98">       try {</span>
<a href="#l2.99"></a><span id="l2.99">         if (this._transactionGood)</span>
<a href="#l2.100"></a><span id="l2.100" class="difflineminus">-          this._commitTransactionStatement.executeAsync(notifier);</span>
<a href="#l2.101"></a><span id="l2.101" class="difflineplus">+          this._commitTransactionStatement.executeAsync(this.trackAsync());</span>
<a href="#l2.102"></a><span id="l2.102">         else</span>
<a href="#l2.103"></a><span id="l2.103" class="difflineminus">-          this._rollbackTransaction.executeAsync(notifier);</span>
<a href="#l2.104"></a><span id="l2.104" class="difflineplus">+          this._rollbackTransaction.executeAsync(this.trackAsync());</span>
<a href="#l2.105"></a><span id="l2.105">       }</span>
<a href="#l2.106"></a><span id="l2.106">       catch (ex) {</span>
<a href="#l2.107"></a><span id="l2.107">         this._log.error(&quot;Commit problem: &quot; + ex);</span>
<a href="#l2.108"></a><span id="l2.108">       }</span>
<a href="#l2.109"></a><span id="l2.109">     }</span>
<a href="#l2.110"></a><span id="l2.110" class="difflineminus">-    // call the callback immediately if we don't need to pend</span>
<a href="#l2.111"></a><span id="l2.111" class="difflineminus">-    else if (aCallback)</span>
<a href="#l2.112"></a><span id="l2.112" class="difflineminus">-      aCallback.call(aCallbackThis);</span>
<a href="#l2.113"></a><span id="l2.113">   },</span>
<a href="#l2.114"></a><span id="l2.114">   /**</span>
<a href="#l2.115"></a><span id="l2.115">    * Abort the commit of the potentially nested transaction.  If we are not the</span>
<a href="#l2.116"></a><span id="l2.116">    *  outermost transaction, we set a flag that tells the outermost transaction</span>
<a href="#l2.117"></a><span id="l2.117">    *  that it must roll back.</span>
<a href="#l2.118"></a><span id="l2.118">    */</span>
<a href="#l2.119"></a><span id="l2.119">   _rollbackTransaction: function gloda_ds_rollbackTransaction() {</span>
<a href="#l2.120"></a><span id="l2.120">     this._transactionDepth--;</span>
<a href="#l2.121"></a><span id="l2.121" class="difflineat">@@ -837,16 +848,18 @@ let GlodaDatastore = {</span>
<a href="#l2.122"></a><span id="l2.122">       GlodaDatastore._asyncCompleted();</span>
<a href="#l2.123"></a><span id="l2.123">     }</span>
<a href="#l2.124"></a><span id="l2.124">   },</span>
<a href="#l2.125"></a><span id="l2.125">   /**</span>
<a href="#l2.126"></a><span id="l2.126">    * Increments _pendingAsyncStatements and returns a listener that will</span>
<a href="#l2.127"></a><span id="l2.127">    *  decrement the value when the statement completes.</span>
<a href="#l2.128"></a><span id="l2.128">    */</span>
<a href="#l2.129"></a><span id="l2.129">   trackAsync: function() {</span>
<a href="#l2.130"></a><span id="l2.130" class="difflineplus">+    this._pendingAsyncStatements++;</span>
<a href="#l2.131"></a><span id="l2.131" class="difflineplus">+    return this._asyncTrackerListener;</span>
<a href="#l2.132"></a><span id="l2.132">   },</span>
<a href="#l2.133"></a><span id="l2.133">   </span>
<a href="#l2.134"></a><span id="l2.134">   /* ********** Attribute Definitions ********** */</span>
<a href="#l2.135"></a><span id="l2.135">   /** Maps (attribute def) compound names to the GlodaAttributeDef objects. */</span>
<a href="#l2.136"></a><span id="l2.136">   _attributes: {},</span>
<a href="#l2.137"></a><span id="l2.137">   /** Map attribute ID to the definition and parameter value that produce it. */</span>
<a href="#l2.138"></a><span id="l2.138">   _attributeIDToDef: {},</span>
<a href="#l2.139"></a><span id="l2.139">   /**</span>
<a href="#l2.140"></a><span id="l2.140" class="difflineat">@@ -1382,16 +1395,68 @@ let GlodaDatastore = {</span>
<a href="#l2.141"></a><span id="l2.141">     }</span>
<a href="#l2.142"></a><span id="l2.142">     </span>
<a href="#l2.143"></a><span id="l2.143">     // In completely abstract theory, this is where we would call</span>
<a href="#l2.144"></a><span id="l2.144">     //  GlodaCollectionManager.itemsModified, except that the attributes may</span>
<a href="#l2.145"></a><span id="l2.145">     //  also have changed, so it's out of our hands.  (Gloda.processMessage</span>
<a href="#l2.146"></a><span id="l2.146">     //  handles it.)</span>
<a href="#l2.147"></a><span id="l2.147">   },</span>
<a href="#l2.148"></a><span id="l2.148"> </span>
<a href="#l2.149"></a><span id="l2.149" class="difflineplus">+  get _updateMessageLocationStatement() {</span>
<a href="#l2.150"></a><span id="l2.150" class="difflineplus">+    let statement = this._createAsyncStatement(</span>
<a href="#l2.151"></a><span id="l2.151" class="difflineplus">+      &quot;UPDATE messages SET folderID = ?1, messageKey = ?2 WHERE id = ?3&quot;);</span>
<a href="#l2.152"></a><span id="l2.152" class="difflineplus">+    this.__defineGetter__(&quot;_updateMessageLocationStatement&quot;,</span>
<a href="#l2.153"></a><span id="l2.153" class="difflineplus">+                          function() statement);</span>
<a href="#l2.154"></a><span id="l2.154" class="difflineplus">+    return this._updateMessageLocationStatement;</span>
<a href="#l2.155"></a><span id="l2.155" class="difflineplus">+  }, </span>
<a href="#l2.156"></a><span id="l2.156" class="difflineplus">+</span>
<a href="#l2.157"></a><span id="l2.157" class="difflineplus">+  /**</span>
<a href="#l2.158"></a><span id="l2.158" class="difflineplus">+   * Given a list of gloda message ids, and a list of their new message keys in</span>
<a href="#l2.159"></a><span id="l2.159" class="difflineplus">+   *  the given new folder location, asynchronously update the message's</span>
<a href="#l2.160"></a><span id="l2.160" class="difflineplus">+   *  database locations.  Also, update the in-memory representations.</span>
<a href="#l2.161"></a><span id="l2.161" class="difflineplus">+   */</span>
<a href="#l2.162"></a><span id="l2.162" class="difflineplus">+  updateMessageLocations: function gloda_ds_updateMessageLocations(aMessageIds,</span>
<a href="#l2.163"></a><span id="l2.163" class="difflineplus">+      aNewMessageKeys, aDestFolderURI) {</span>
<a href="#l2.164"></a><span id="l2.164" class="difflineplus">+    let statement = this._updateMessageLocationStatement;</span>
<a href="#l2.165"></a><span id="l2.165" class="difflineplus">+    let destFolderID = this._mapFolderURI(aDestFolderURI);</span>
<a href="#l2.166"></a><span id="l2.166" class="difflineplus">+    </span>
<a href="#l2.167"></a><span id="l2.167" class="difflineplus">+    let modifiedItems = [];</span>
<a href="#l2.168"></a><span id="l2.168" class="difflineplus">+    </span>
<a href="#l2.169"></a><span id="l2.169" class="difflineplus">+    for (let iMsg = 0; iMsg &lt; aMessageIds.length; iMsg++) {</span>
<a href="#l2.170"></a><span id="l2.170" class="difflineplus">+      let id = aMessageIds[iMsg]</span>
<a href="#l2.171"></a><span id="l2.171" class="difflineplus">+      statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l2.172"></a><span id="l2.172" class="difflineplus">+      statement.bindInt64Parameter(1, aNewMessageKeys[iMsg]);</span>
<a href="#l2.173"></a><span id="l2.173" class="difflineplus">+      statement.bindInt64Parameter(2, id);</span>
<a href="#l2.174"></a><span id="l2.174" class="difflineplus">+      statement.executeAsync(this.trackAsync());</span>
<a href="#l2.175"></a><span id="l2.175" class="difflineplus">+      </span>
<a href="#l2.176"></a><span id="l2.176" class="difflineplus">+      // so, if the message is currently loaded, we also need to change it up...</span>
<a href="#l2.177"></a><span id="l2.177" class="difflineplus">+      let message = GlodaCollectionManager.cacheLookupOne(</span>
<a href="#l2.178"></a><span id="l2.178" class="difflineplus">+        GlodaMessage.prototype.NOUN_ID, id);</span>
<a href="#l2.179"></a><span id="l2.179" class="difflineplus">+      if (message) {</span>
<a href="#l2.180"></a><span id="l2.180" class="difflineplus">+        message._folderID = destFolderID;</span>
<a href="#l2.181"></a><span id="l2.181" class="difflineplus">+        modifiedItems.push(message);</span>
<a href="#l2.182"></a><span id="l2.182" class="difflineplus">+      }</span>
<a href="#l2.183"></a><span id="l2.183" class="difflineplus">+    }</span>
<a href="#l2.184"></a><span id="l2.184" class="difflineplus">+</span>
<a href="#l2.185"></a><span id="l2.185" class="difflineplus">+    // if we're talking about a lot of messages, it's worth committing after</span>
<a href="#l2.186"></a><span id="l2.186" class="difflineplus">+    //  this to ensure that we don't spill to disk and cause contention with</span>
<a href="#l2.187"></a><span id="l2.187" class="difflineplus">+    //  synchronous reads off (this) the main thread.</span>
<a href="#l2.188"></a><span id="l2.188" class="difflineplus">+    if ((aMessageIds.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l2.189"></a><span id="l2.189" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l2.190"></a><span id="l2.190" class="difflineplus">+      this._beginTransaction();</span>
<a href="#l2.191"></a><span id="l2.191" class="difflineplus">+    }</span>
<a href="#l2.192"></a><span id="l2.192" class="difflineplus">+    </span>
<a href="#l2.193"></a><span id="l2.193" class="difflineplus">+    // tell the collection manager about the modified messages so it can update</span>
<a href="#l2.194"></a><span id="l2.194" class="difflineplus">+    //  any existing views...</span>
<a href="#l2.195"></a><span id="l2.195" class="difflineplus">+    if (modifiedItems.length) {</span>
<a href="#l2.196"></a><span id="l2.196" class="difflineplus">+      GlodaCollectionManager.itemsModified(GlodaMessage.prototype.NOUN,</span>
<a href="#l2.197"></a><span id="l2.197" class="difflineplus">+                                           modifiedItems);</span>
<a href="#l2.198"></a><span id="l2.198" class="difflineplus">+    }</span>
<a href="#l2.199"></a><span id="l2.199" class="difflineplus">+  },</span>
<a href="#l2.200"></a><span id="l2.200" class="difflineplus">+</span>
<a href="#l2.201"></a><span id="l2.201">   /**</span>
<a href="#l2.202"></a><span id="l2.202">    * Asynchronously mutate message folder id/message keys for the given</span>
<a href="#l2.203"></a><span id="l2.203">    *  messages, indicating that we are moving them to the target folder, but</span>
<a href="#l2.204"></a><span id="l2.204">    *  don't yet know their target message keys.</span>
<a href="#l2.205"></a><span id="l2.205">    */</span>
<a href="#l2.206"></a><span id="l2.206">   updateMessageFoldersByKeyPurging:</span>
<a href="#l2.207"></a><span id="l2.207">       function gloda_ds_updateMessageFoldersByKeyPurging(aSrcFolderURI,</span>
<a href="#l2.208"></a><span id="l2.208">         aMessageKeys, aDestFolderURI) {</span>
<a href="#l2.209"></a><span id="l2.209" class="difflineat">@@ -1403,16 +1468,24 @@ let GlodaDatastore = {</span>
<a href="#l2.210"></a><span id="l2.210">                    WHERE folderID = ?3 \</span>
<a href="#l2.211"></a><span id="l2.211">                      AND messageKey IN (&quot; + aMessageKeys.join(&quot;, &quot;) + &quot;)&quot;;</span>
<a href="#l2.212"></a><span id="l2.212">     let statement = this._createAsyncStatement(sqlStr, true);</span>
<a href="#l2.213"></a><span id="l2.213">     statement.bindInt64Parameter(2, srcFolderID);</span>
<a href="#l2.214"></a><span id="l2.214">     statement.bindInt64Parameter(0, destFolderID);</span>
<a href="#l2.215"></a><span id="l2.215">     statement.bindNullParameter(1);</span>
<a href="#l2.216"></a><span id="l2.216">     statement.executeAsync(this.trackAsync());</span>
<a href="#l2.217"></a><span id="l2.217">     statement.finalize();</span>
<a href="#l2.218"></a><span id="l2.218" class="difflineplus">+</span>
<a href="#l2.219"></a><span id="l2.219" class="difflineplus">+    // if we're talking about a lot of messages, it's worth committing after</span>
<a href="#l2.220"></a><span id="l2.220" class="difflineplus">+    //  this to ensure that we don't spill to disk and cause contention with</span>
<a href="#l2.221"></a><span id="l2.221" class="difflineplus">+    //  synchronous reads off (this) the main thread.</span>
<a href="#l2.222"></a><span id="l2.222" class="difflineplus">+    if ((aMessageKeys.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l2.223"></a><span id="l2.223" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l2.224"></a><span id="l2.224" class="difflineplus">+      this._beginTransaction();</span>
<a href="#l2.225"></a><span id="l2.225" class="difflineplus">+    }</span>
<a href="#l2.226"></a><span id="l2.226">   },</span>
<a href="#l2.227"></a><span id="l2.227">   </span>
<a href="#l2.228"></a><span id="l2.228">   _messageFromRow: function gloda_ds_messageFromRow(aRow) {</span>
<a href="#l2.229"></a><span id="l2.229">     let folderId, messageKey, date;</span>
<a href="#l2.230"></a><span id="l2.230">     if (aRow.getTypeOfIndex(1) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l2.231"></a><span id="l2.231">       folderId = null;</span>
<a href="#l2.232"></a><span id="l2.232">     else</span>
<a href="#l2.233"></a><span id="l2.233">       folderId = aRow.getInt64(1);</span>
<a href="#l2.234"></a><span id="l2.234" class="difflineat">@@ -1421,17 +1494,17 @@ let GlodaDatastore = {</span>
<a href="#l2.235"></a><span id="l2.235">     else</span>
<a href="#l2.236"></a><span id="l2.236">       messageKey = aRow.getInt64(2);</span>
<a href="#l2.237"></a><span id="l2.237">     if (aRow.getTypeOfIndex(4) == Ci.mozIStorageValueArray.VALUE_TYPE_NULL)</span>
<a href="#l2.238"></a><span id="l2.238">       date = null;</span>
<a href="#l2.239"></a><span id="l2.239">     else</span>
<a href="#l2.240"></a><span id="l2.240">       date = new Date(aRow.getInt64(4) / 1000);</span>
<a href="#l2.241"></a><span id="l2.241">     return new GlodaMessage(this, aRow.getInt64(0), folderId, messageKey,</span>
<a href="#l2.242"></a><span id="l2.242">                             aRow.getInt64(3), null, date, aRow.getString(5),</span>
<a href="#l2.243"></a><span id="l2.243" class="difflineminus">-                            aRow.getInt64(6);</span>
<a href="#l2.244"></a><span id="l2.244" class="difflineplus">+                            aRow.getInt64(6));</span>
<a href="#l2.245"></a><span id="l2.245">   },</span>
<a href="#l2.246"></a><span id="l2.246"> </span>
<a href="#l2.247"></a><span id="l2.247">   get _selectMessageByIDStatement() {</span>
<a href="#l2.248"></a><span id="l2.248">     let statement = this._createSyncStatement(</span>
<a href="#l2.249"></a><span id="l2.249">       &quot;SELECT id, folderID, messageKey, conversationID, date, headerMessageID, \</span>
<a href="#l2.250"></a><span id="l2.250">            deleted FROM messages WHERE id = ?1&quot;);</span>
<a href="#l2.251"></a><span id="l2.251">     this.__defineGetter__(&quot;_selectMessageByIDStatement&quot;,</span>
<a href="#l2.252"></a><span id="l2.252">       function() statement);</span>
<a href="#l2.253"></a><span id="l2.253" class="difflineat">@@ -1559,32 +1632,44 @@ let GlodaDatastore = {</span>
<a href="#l2.254"></a><span id="l2.254">     let statement = this._createAsyncStatement(</span>
<a href="#l2.255"></a><span id="l2.255">       &quot;UPDATE messages SET folderID = NULL, messageKey = NULL, \</span>
<a href="#l2.256"></a><span id="l2.256">               deleted = 1 WHERE folderID = ?1&quot;);</span>
<a href="#l2.257"></a><span id="l2.257">     this.__defineGetter__(&quot;_updateMessagesMarkDeletedByFolderID&quot;,</span>
<a href="#l2.258"></a><span id="l2.258">       function() statement);</span>
<a href="#l2.259"></a><span id="l2.259">     return this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l2.260"></a><span id="l2.260">   },</span>
<a href="#l2.261"></a><span id="l2.261"> </span>
<a href="#l2.262"></a><span id="l2.262" class="difflineminus">-  markMessagesDeletedByFolderID: function gloda_ds_markMessagesDeletedByIDs(</span>
<a href="#l2.263"></a><span id="l2.263" class="difflineminus">-      aFolderID) {</span>
<a href="#l2.264"></a><span id="l2.264" class="difflineplus">+  markMessagesDeletedByFolderID:</span>
<a href="#l2.265"></a><span id="l2.265" class="difflineplus">+      function gloda_ds_markMessagesDeletedByFolderID(aFolderID) {</span>
<a href="#l2.266"></a><span id="l2.266">     let statement = this._updateMessagesMarkDeletedByFolderID;</span>
<a href="#l2.267"></a><span id="l2.267">     statement.bindInt64Parameter(0, aFolderID);</span>
<a href="#l2.268"></a><span id="l2.268">     statement.executeAsync(this.trackAsync());</span>
<a href="#l2.269"></a><span id="l2.269">     statement.finalize();</span>
<a href="#l2.270"></a><span id="l2.270">   },</span>
<a href="#l2.271"></a><span id="l2.271"> </span>
<a href="#l2.272"></a><span id="l2.272">   markMessagesDeletedByIDs: function gloda_ds_markMessagesDeletedByIDs(</span>
<a href="#l2.273"></a><span id="l2.273">       aMessageIDs) {</span>
<a href="#l2.274"></a><span id="l2.274">     let sqlString = &quot;UPDATE messages SET deleted = 1 WHERE id IN (&quot; + </span>
<a href="#l2.275"></a><span id="l2.275">       aMessageIDs.join(&quot;,&quot;) + &quot;)&quot;;</span>
<a href="#l2.276"></a><span id="l2.276">     </span>
<a href="#l2.277"></a><span id="l2.277">     let statement = this._createAsyncStatement(sqlString, true);</span>
<a href="#l2.278"></a><span id="l2.278">     statement.executeAsync(this.trackAsync());</span>
<a href="#l2.279"></a><span id="l2.279">     statement.finalize();</span>
<a href="#l2.280"></a><span id="l2.280" class="difflineplus">+    </span>
<a href="#l2.281"></a><span id="l2.281" class="difflineplus">+    // some people are inclined to deleting ridiculous numbers of messages at</span>
<a href="#l2.282"></a><span id="l2.282" class="difflineplus">+    //  a time.  if we are in a transaction, this has the potential to cause us</span>
<a href="#l2.283"></a><span id="l2.283" class="difflineplus">+    //  to spill the transaction to disk prior to disk, resulting in a lock</span>
<a href="#l2.284"></a><span id="l2.284" class="difflineplus">+    //  escalation and making any synchronous reads from the main thread need</span>
<a href="#l2.285"></a><span id="l2.285" class="difflineplus">+    //  to become blocking.  We don't want that, so:</span>
<a href="#l2.286"></a><span id="l2.286" class="difflineplus">+    // If we are in a transaction and there are a &quot;lot&quot; of messages being</span>
<a href="#l2.287"></a><span id="l2.287" class="difflineplus">+    //  marked as deleted, issue a commit and then re-open the transaction.</span>
<a href="#l2.288"></a><span id="l2.288" class="difflineplus">+    if ((aMessageIDs.length &gt; 200) &amp;&amp; this._transactionDepth) {</span>
<a href="#l2.289"></a><span id="l2.289" class="difflineplus">+      this._commitTransaction();</span>
<a href="#l2.290"></a><span id="l2.290" class="difflineplus">+      this._beginTransaction();</span>
<a href="#l2.291"></a><span id="l2.291" class="difflineplus">+    }</span>
<a href="#l2.292"></a><span id="l2.292">   },</span>
<a href="#l2.293"></a><span id="l2.293"> </span>
<a href="#l2.294"></a><span id="l2.294">   get _deleteMessageByIDStatement() {</span>
<a href="#l2.295"></a><span id="l2.295">     let statement = this._createAsyncStatement(</span>
<a href="#l2.296"></a><span id="l2.296">       &quot;DELETE FROM messages WHERE id = ?1&quot;);</span>
<a href="#l2.297"></a><span id="l2.297">     this.__defineGetter__(&quot;_deleteMessageByIDStatement&quot;,</span>
<a href="#l2.298"></a><span id="l2.298">                           function() statement);</span>
<a href="#l2.299"></a><span id="l2.299">     return this._deleteMessageByIDStatement; </span></pre></div><div class="diffblock"><pre class="sourcelines">
<a href="#l3.1"></a><span id="l3.1" class="difflineminus">--- a/modules/indexer.js</span>
<a href="#l3.2"></a><span id="l3.2" class="difflineplus">+++ b/modules/indexer.js</span>
<a href="#l3.3"></a><span id="l3.3" class="difflineat">@@ -283,39 +283,45 @@ let GlodaIndexer = {</span>
<a href="#l3.4"></a><span id="l3.4">     if (this._inited)</span>
<a href="#l3.5"></a><span id="l3.5">       return;</span>
<a href="#l3.6"></a><span id="l3.6">     </span>
<a href="#l3.7"></a><span id="l3.7">     this._inited = true;</span>
<a href="#l3.8"></a><span id="l3.8">     </span>
<a href="#l3.9"></a><span id="l3.9">     // initialize our listeners' this pointers</span>
<a href="#l3.10"></a><span id="l3.10">     this._databaseAnnouncerListener.indexer = this;</span>
<a href="#l3.11"></a><span id="l3.11">     this._msgFolderListener.indexer = this;</span>
<a href="#l3.12"></a><span id="l3.12" class="difflineplus">+    this._shutdownTask.indexer = this;</span>
<a href="#l3.13"></a><span id="l3.13">     </span>
<a href="#l3.14"></a><span id="l3.14">     // create the timer that drives our intermittent indexing</span>
<a href="#l3.15"></a><span id="l3.15">     this._timer = Cc[&quot;@mozilla.org/timer;1&quot;].createInstance(Ci.nsITimer);</span>
<a href="#l3.16"></a><span id="l3.16"> </span>
<a href="#l3.17"></a><span id="l3.17"> </span>
<a href="#l3.18"></a><span id="l3.18">     // figure out if event-driven indexing should be enabled...</span>
<a href="#l3.19"></a><span id="l3.19">     let prefService = Cc[&quot;@mozilla.org/preferences-service;1&quot;].</span>
<a href="#l3.20"></a><span id="l3.20">                         getService(Ci.nsIPrefService);</span>
<a href="#l3.21"></a><span id="l3.21">     let branch = prefService.getBranch(&quot;mailnews.database.global.indexer&quot;);</span>
<a href="#l3.22"></a><span id="l3.22">     let eventDrivenEnabled = true; // default</span>
<a href="#l3.23"></a><span id="l3.23">     if (branch.prefHasUserValue(&quot;enabled&quot;))</span>
<a href="#l3.24"></a><span id="l3.24">       eventDrivenEnabled = branch.getBoolPref(&quot;enabled&quot;);</span>
<a href="#l3.25"></a><span id="l3.25">     this.enabled = eventDrivenEnabled;</span>
<a href="#l3.26"></a><span id="l3.26">   },</span>
<a href="#l3.27"></a><span id="l3.27">   </span>
<a href="#l3.28"></a><span id="l3.28" class="difflineminus">-  _shutdown: function gloda_index_shutdown() {</span>
<a href="#l3.29"></a><span id="l3.29" class="difflineplus">+  _shutdown: function gloda_index_shutdown(aUrlListener) {</span>
<a href="#l3.30"></a><span id="l3.30">     this._log.info(&quot;Shutting Down&quot;);</span>
<a href="#l3.31"></a><span id="l3.31"> </span>
<a href="#l3.32"></a><span id="l3.32" class="difflineplus">+    this.suppressIndexing = true;</span>
<a href="#l3.33"></a><span id="l3.33">     this._indexerLeaveFolder(); // nop if we aren't &quot;in&quot; a folder</span>
<a href="#l3.34"></a><span id="l3.34">     this.enabled = false;</span>
<a href="#l3.35"></a><span id="l3.35"> </span>
<a href="#l3.36"></a><span id="l3.36" class="difflineminus">-    </span>
<a href="#l3.37"></a><span id="l3.37" class="difflineminus">-    GlodaDatastore.shutdown();</span>
<a href="#l3.38"></a><span id="l3.38" class="difflineplus">+    // if the datastore can't stop immediately, it will call the provided</span>
<a href="#l3.39"></a><span id="l3.39" class="difflineplus">+    //  callback.</span>
<a href="#l3.40"></a><span id="l3.40" class="difflineplus">+    return GlodaDatastore.shutdown(function () {</span>
<a href="#l3.41"></a><span id="l3.41" class="difflineplus">+      if (aUrlListener)</span>
<a href="#l3.42"></a><span id="l3.42" class="difflineplus">+        aUrlListener.OnStopRunningUrl(null, Components.results.NS_OK);</span>
<a href="#l3.43"></a><span id="l3.43" class="difflineplus">+    });</span>
<a href="#l3.44"></a><span id="l3.44">   },</span>
<a href="#l3.45"></a><span id="l3.45">   </span>
<a href="#l3.46"></a><span id="l3.46">   /**</span>
<a href="#l3.47"></a><span id="l3.47">    * Are we enabled, read: are we processing change events?</span>
<a href="#l3.48"></a><span id="l3.48">    */</span>
<a href="#l3.49"></a><span id="l3.49">   _enabled: false,</span>
<a href="#l3.50"></a><span id="l3.50">   get enabled() { return this._enabled; },</span>
<a href="#l3.51"></a><span id="l3.51">   set enabled(aEnable) {</span>
<a href="#l3.52"></a><span id="l3.52" class="difflineat">@@ -330,18 +336,19 @@ let GlodaIndexer = {</span>
<a href="#l3.53"></a><span id="l3.53">       this._folderListener._init(this);</span>
<a href="#l3.54"></a><span id="l3.54">       mailSession.AddFolderListener(this._folderListener,</span>
<a href="#l3.55"></a><span id="l3.55">                                     Ci.nsIFolderListener.propertyFlagChanged |</span>
<a href="#l3.56"></a><span id="l3.56">                                     Ci.nsIFolderListener.event);</span>
<a href="#l3.57"></a><span id="l3.57">   </span>
<a href="#l3.58"></a><span id="l3.58">       // register for shutdown, offline notifications</span>
<a href="#l3.59"></a><span id="l3.59">       let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l3.60"></a><span id="l3.60">                               getService(Ci.nsIObserverService);</span>
<a href="#l3.61"></a><span id="l3.61" class="difflineminus">-      observerService.addObserver(this, &quot;quit-application&quot;, false);</span>
<a href="#l3.62"></a><span id="l3.62">       observerService.addObserver(this, &quot;network:offline-status-changed&quot;, false);</span>
<a href="#l3.63"></a><span id="l3.63" class="difflineplus">+      // sign up for the nsIMsgShutdownService's scheme</span>
<a href="#l3.64"></a><span id="l3.64" class="difflineplus">+      observerService.addObserver(this._shutdownTask, &quot;msg-shutdown&quot;, false);</span>
<a href="#l3.65"></a><span id="l3.65">   </span>
<a href="#l3.66"></a><span id="l3.66">       // register for idle notification</span>
<a href="#l3.67"></a><span id="l3.67">       let idleService = Cc[&quot;@mozilla.org/widget/idleservice;1&quot;].</span>
<a href="#l3.68"></a><span id="l3.68">                           getService(Ci.nsIIdleService);</span>
<a href="#l3.69"></a><span id="l3.69">       idleService.addIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l3.70"></a><span id="l3.70"> </span>
<a href="#l3.71"></a><span id="l3.71">       let notificationService =</span>
<a href="#l3.72"></a><span id="l3.72">         Cc[&quot;@mozilla.org/messenger/msgnotificationservice;1&quot;].</span>
<a href="#l3.73"></a><span id="l3.73" class="difflineat">@@ -350,19 +357,18 @@ let GlodaIndexer = {</span>
<a href="#l3.74"></a><span id="l3.74">                                       Ci.nsIMsgFolderNotificationService.all);</span>
<a href="#l3.75"></a><span id="l3.75">       </span>
<a href="#l3.76"></a><span id="l3.76">       this._enabled = true;</span>
<a href="#l3.77"></a><span id="l3.77">     }</span>
<a href="#l3.78"></a><span id="l3.78">     else if (this._enabled &amp;&amp; !aEnable) {</span>
<a href="#l3.79"></a><span id="l3.79">       // remove observer; no more events to observe!</span>
<a href="#l3.80"></a><span id="l3.80">       let observerService = Cc[&quot;@mozilla.org/observer-service;1&quot;].</span>
<a href="#l3.81"></a><span id="l3.81">                               getService(Ci.nsIObserverService);</span>
<a href="#l3.82"></a><span id="l3.82" class="difflineminus">-      observerService.removeObserver(this, &quot;quit-application&quot;);</span>
<a href="#l3.83"></a><span id="l3.83">       observerService.removeObserver(this, &quot;network:offline-status-changed&quot;);</span>
<a href="#l3.84"></a><span id="l3.84" class="difflineminus">-  </span>
<a href="#l3.85"></a><span id="l3.85" class="difflineplus">+      observerService.removeObserver(this._shutdownTask, &quot;msg-shutdown&quot;, false);</span>
<a href="#l3.86"></a><span id="l3.86">   </span>
<a href="#l3.87"></a><span id="l3.87">       // remove idle</span>
<a href="#l3.88"></a><span id="l3.88">       let idleService = Cc[&quot;@mozilla.org/widget/idleservice;1&quot;].</span>
<a href="#l3.89"></a><span id="l3.89">                           getService(Ci.nsIIdleService);</span>
<a href="#l3.90"></a><span id="l3.90">       idleService.removeIdleObserver(this, this._indexIdleThresholdSecs);</span>
<a href="#l3.91"></a><span id="l3.91">   </span>
<a href="#l3.92"></a><span id="l3.92">       // remove FolderLoaded notification listener</span>
<a href="#l3.93"></a><span id="l3.93">       let mailSession = Cc[&quot;@mozilla.org/messenger/services/session;1&quot;].</span>
<a href="#l3.94"></a><span id="l3.94" class="difflineat">@@ -436,16 +442,25 @@ let GlodaIndexer = {</span>
<a href="#l3.95"></a><span id="l3.95">         !this._indexingActive) {</span>
<a href="#l3.96"></a><span id="l3.96">         this._log.info(&quot;+++ Indexing Queue Processing Resuming&quot;);</span>
<a href="#l3.97"></a><span id="l3.97">         this._indexingActive = true;</span>
<a href="#l3.98"></a><span id="l3.98">         this._timer.initWithCallback(this._wrapCallbackDriver,</span>
<a href="#l3.99"></a><span id="l3.99">                                      this._indexInterval,</span>
<a href="#l3.100"></a><span id="l3.100">                                      Ci.nsITimer.TYPE_ONE_SHOT);</span>
<a href="#l3.101"></a><span id="l3.101">     }</span>
<a href="#l3.102"></a><span id="l3.102">   },</span>
<a href="#l3.103"></a><span id="l3.103" class="difflineplus">+</span>
<a href="#l3.104"></a><span id="l3.104" class="difflineplus">+  /**</span>
<a href="#l3.105"></a><span id="l3.105" class="difflineplus">+   * Indicates that we have pending deletions to process, meaning that there</span>
<a href="#l3.106"></a><span id="l3.106" class="difflineplus">+   *  are gloda message rows flagged for deletion.  If this value is a boolean,</span>
<a href="#l3.107"></a><span id="l3.107" class="difflineplus">+   *  it means the value is known reliably.  If this value is null, it means</span>
<a href="#l3.108"></a><span id="l3.108" class="difflineplus">+   *  that we don't know, likely because we have started up and have not checked</span>
<a href="#l3.109"></a><span id="l3.109" class="difflineplus">+   *  the database.</span>
<a href="#l3.110"></a><span id="l3.110" class="difflineplus">+   */</span>
<a href="#l3.111"></a><span id="l3.111" class="difflineplus">+  pendingDeletions: null,</span>
<a href="#l3.112"></a><span id="l3.112">   </span>
<a href="#l3.113"></a><span id="l3.113">   GLODA_MESSAGE_ID_PROPERTY: &quot;gloda-id&quot;,</span>
<a href="#l3.114"></a><span id="l3.114">   GLODA_DIRTY_PROPERTY: &quot;gloda-dirty&quot;,</span>
<a href="#l3.115"></a><span id="l3.115">   </span>
<a href="#l3.116"></a><span id="l3.116">   /**</span>
<a href="#l3.117"></a><span id="l3.117">    * Our current job number, out of _indexingJobGoal.  Although our jobs comes</span>
<a href="#l3.118"></a><span id="l3.118">    *  from _indexQueue, this is not an offset into that list because we forget</span>
<a href="#l3.119"></a><span id="l3.119">    *  jobs once we complete them.  As such, this value is strictly for progress</span>
<a href="#l3.120"></a><span id="l3.120" class="difflineat">@@ -456,22 +471,16 @@ let GlodaIndexer = {</span>
<a href="#l3.121"></a><span id="l3.121">    * Total number of jobs to process in this current indexing session; may</span>
<a href="#l3.122"></a><span id="l3.122">    *  increase as new jobs are added to the _indexQueue.  This value won't</span>
<a href="#l3.123"></a><span id="l3.123">    *  decrease until the indexing session is completed (and we become idle),</span>
<a href="#l3.124"></a><span id="l3.124">    *  and then it will go to zero.</span>
<a href="#l3.125"></a><span id="l3.125">    */</span>
<a href="#l3.126"></a><span id="l3.126">   _indexingJobGoal: 0,</span>
<a href="#l3.127"></a><span id="l3.127">   </span>
<a href="#l3.128"></a><span id="l3.128">   /**</span>
<a href="#l3.129"></a><span id="l3.129" class="difflineminus">-   * Indicates that we have pending deletions to process, meaning that there</span>
<a href="#l3.130"></a><span id="l3.130" class="difflineminus">-   *  are gloda message rows </span>
<a href="#l3.131"></a><span id="l3.131" class="difflineminus">-   */</span>
<a href="#l3.132"></a><span id="l3.132" class="difflineminus">-  _pendingDeletions: null,</span>
<a href="#l3.133"></a><span id="l3.133" class="difflineminus">-  </span>
<a href="#l3.134"></a><span id="l3.134" class="difflineminus">-  /**</span>
<a href="#l3.135"></a><span id="l3.135">    * A list of IndexingJob instances to process.</span>
<a href="#l3.136"></a><span id="l3.136">    * - ['account', account object]</span>
<a href="#l3.137"></a><span id="l3.137">    * - ['folder', folder URI]</span>
<a href="#l3.138"></a><span id="l3.138">    * - ['message', delta type, message header, folder ID, message key,</span>
<a href="#l3.139"></a><span id="l3.139">    *      message ID]</span>
<a href="#l3.140"></a><span id="l3.140">    *   (we use folder ID instead of URI so that renames can't trick us)</span>
<a href="#l3.141"></a><span id="l3.141">    */</span>
<a href="#l3.142"></a><span id="l3.142">   _indexQueue: [],</span>
<a href="#l3.143"></a><span id="l3.143" class="difflineat">@@ -909,36 +918,56 @@ let GlodaIndexer = {</span>
<a href="#l3.144"></a><span id="l3.144">     this._log.debug(&quot;Pulling job from queue of size &quot; +</span>
<a href="#l3.145"></a><span id="l3.145">                     this._indexQueue.length);</span>
<a href="#l3.146"></a><span id="l3.146">     let job = this._curIndexingJob = this._indexQueue.shift();</span>
<a href="#l3.147"></a><span id="l3.147">     this._indexingJobCount++;</span>
<a href="#l3.148"></a><span id="l3.148">     this._log.debug(&quot;Pulled job: &quot; + job.jobType + &quot;, &quot; +</span>
<a href="#l3.149"></a><span id="l3.149">                     job.deltaType + &quot;, &quot; + job.id);</span>
<a href="#l3.150"></a><span id="l3.150">     let generator = null;</span>
<a href="#l3.151"></a><span id="l3.151">     </span>
<a href="#l3.152"></a><span id="l3.152" class="difflineminus">-    if (job.jobType == &quot;folder&quot;) {</span>
<a href="#l3.153"></a><span id="l3.153" class="difflineminus">-      if (job.deltaType &gt; 0)</span>
<a href="#l3.154"></a><span id="l3.154" class="difflineminus">-        this._actualWorker = this._worker_folderAdd(job);</span>
<a href="#l3.155"></a><span id="l3.155" class="difflineplus">+    if (job.jobType == &quot;sweep&quot;) {</span>
<a href="#l3.156"></a><span id="l3.156" class="difflineplus">+      this._actualWorker = this._worker_indexingSweep(job);</span>
<a href="#l3.157"></a><span id="l3.157" class="difflineplus">+    }</span>
<a href="#l3.158"></a><span id="l3.158" class="difflineplus">+    else if (job.jobType == &quot;folder&quot;) {</span>
<a href="#l3.159"></a><span id="l3.159" class="difflineplus">+      this._actualWorker = this._worker_folderIndex(job);</span>
<a href="#l3.160"></a><span id="l3.160">     }</span>
<a href="#l3.161"></a><span id="l3.161">     else if(job.jobType == &quot;message&quot;) {</span>
<a href="#l3.162"></a><span id="l3.162">       if (job === this._pendingAddJob)</span>
<a href="#l3.163"></a><span id="l3.163">         this._pendingAddJob = null;</span>
<a href="#l3.164"></a><span id="l3.164">       // update our goal from the items length</span>
<a href="#l3.165"></a><span id="l3.165">       job.goal = job.items.length;</span>
<a href="#l3.166"></a><span id="l3.166">                   </span>
<a href="#l3.167"></a><span id="l3.167" class="difflineminus">-      if (job.deltaType &gt; 0)</span>
<a href="#l3.168"></a><span id="l3.168" class="difflineminus">-        this._actualWorker = this._worker_messageIndex(job);</span>
<a href="#l3.169"></a><span id="l3.169" class="difflineminus">-      else if (job.deltaType == 0)</span>
<a href="#l3.170"></a><span id="l3.170" class="difflineminus">-        this._actualWorker = this._worker_messageMove(job);</span>
<a href="#l3.171"></a><span id="l3.171" class="difflineplus">+      this._actualWorker = this._worker_messageIndex(job);</span>
<a href="#l3.172"></a><span id="l3.172" class="difflineplus">+    }</span>
<a href="#l3.173"></a><span id="l3.173" class="difflineplus">+    else if (job.jobType == &quot;delete&quot;) {</span>
<a href="#l3.174"></a><span id="l3.174" class="difflineplus">+      // we'll count the block processing as a cost of 1...</span>
<a href="#l3.175"></a><span id="l3.175" class="difflineplus">+      job.goal = 1;</span>
<a href="#l3.176"></a><span id="l3.176" class="difflineplus">+      this._actualWorker = this._worker_processDeletes(job);</span>
<a href="#l3.177"></a><span id="l3.177">     }</span>
<a href="#l3.178"></a><span id="l3.178">     </span>
<a href="#l3.179"></a><span id="l3.179">     return true;</span>
<a href="#l3.180"></a><span id="l3.180">   },</span>
<a href="#l3.181"></a><span id="l3.181"> </span>
<a href="#l3.182"></a><span id="l3.182">   /**</span>
<a href="#l3.183"></a><span id="l3.183" class="difflineplus">+   * Performs the folder sweep, locating folders that should be indexed, and</span>
<a href="#l3.184"></a><span id="l3.184" class="difflineplus">+   *  creating a folder indexing job for them, and rescheduling itself for</span>
<a href="#l3.185"></a><span id="l3.185" class="difflineplus">+   *  execution after that job is completed.  Once it indexes all the folders,</span>
<a href="#l3.186"></a><span id="l3.186" class="difflineplus">+   *  if we believe we have deletions to process (or just don't know), it kicks</span>
<a href="#l3.187"></a><span id="l3.187" class="difflineplus">+   *  off a deletion processing job. </span>
<a href="#l3.188"></a><span id="l3.188" class="difflineplus">+   */</span>
<a href="#l3.189"></a><span id="l3.189" class="difflineplus">+  _worker_indexingSweep: function gloda_worker_indexingSweep(aJob) {</span>
<a href="#l3.190"></a><span id="l3.190" class="difflineplus">+    // walk the folders</span>
<a href="#l3.191"></a><span id="l3.191" class="difflineplus">+    RESUMECODING HERE WHERE THE SYNTAX IS NOT SO GOOD</span>
<a href="#l3.192"></a><span id="l3.192" class="difflineplus">+    // consider deletion</span>
<a href="#l3.193"></a><span id="l3.193" class="difflineplus">+    if (this.pendingDeletion || this.pendingDeletion === null) {</span>
<a href="#l3.194"></a><span id="l3.194" class="difflineplus">+      </span>
<a href="#l3.195"></a><span id="l3.195" class="difflineplus">+    }</span>
<a href="#l3.196"></a><span id="l3.196" class="difflineplus">+  },</span>
<a href="#l3.197"></a><span id="l3.197" class="difflineplus">+</span>
<a href="#l3.198"></a><span id="l3.198" class="difflineplus">+  /**</span>
<a href="#l3.199"></a><span id="l3.199">    * Index the contents of a folder.</span>
<a href="#l3.200"></a><span id="l3.200">    */</span>
<a href="#l3.201"></a><span id="l3.201">   _worker_folderIndex: function gloda_worker_folderAdd(aJob) {</span>
<a href="#l3.202"></a><span id="l3.202">     yield this._indexerEnterFolder(aJob.id, true);</span>
<a href="#l3.203"></a><span id="l3.203">     aJob.goal = this._indexingFolder.getTotalMessages(false);</span>
<a href="#l3.204"></a><span id="l3.204">     </span>
<a href="#l3.205"></a><span id="l3.205">     // there is of course a cost to all this header investigation even if we</span>
<a href="#l3.206"></a><span id="l3.206">     //  don't do something.  so we will yield with kWorkSync for every block. </span>
<a href="#l3.207"></a><span id="l3.207" class="difflineat">@@ -975,16 +1004,21 @@ let GlodaIndexer = {</span>
<a href="#l3.208"></a><span id="l3.208">           if (!isDirty)</span>
<a href="#l3.209"></a><span id="l3.209">             continue;</span>
<a href="#l3.210"></a><span id="l3.210">         }</span>
<a href="#l3.211"></a><span id="l3.211">         </span>
<a href="#l3.212"></a><span id="l3.212">         yield this._indexMessage(msgHdr);</span>
<a href="#l3.213"></a><span id="l3.213">       }</span>
<a href="#l3.214"></a><span id="l3.214">     }</span>
<a href="#l3.215"></a><span id="l3.215">     </span>
<a href="#l3.216"></a><span id="l3.216" class="difflineplus">+    this._indexingFolder.setStringProperty(this.GLODA_DIRTY_PROPERTY, &quot;0&quot;);</span>
<a href="#l3.217"></a><span id="l3.217" class="difflineplus">+    </span>
<a href="#l3.218"></a><span id="l3.218" class="difflineplus">+    // by definition, it's not likely we'll visit this folder again anytime soon</span>
<a href="#l3.219"></a><span id="l3.219" class="difflineplus">+    this._indexerLeaveFolder();</span>
<a href="#l3.220"></a><span id="l3.220" class="difflineplus">+    </span>
<a href="#l3.221"></a><span id="l3.221">     yield kWorkDone;</span>
<a href="#l3.222"></a><span id="l3.222">   },</span>
<a href="#l3.223"></a><span id="l3.223">   </span>
<a href="#l3.224"></a><span id="l3.224">   /**</span>
<a href="#l3.225"></a><span id="l3.225">    * Index a specific list of messages that we know to index from</span>
<a href="#l3.226"></a><span id="l3.226">    *  event-notification hints.</span>
<a href="#l3.227"></a><span id="l3.227">    */</span>
<a href="#l3.228"></a><span id="l3.228">   _worker_messageIndex: function gloda_worker_messageAdd(aJob) {</span>
<a href="#l3.229"></a><span id="l3.229" class="difflineat">@@ -1009,40 +1043,40 @@ let GlodaIndexer = {</span>
<a href="#l3.230"></a><span id="l3.230">         yield this._indexMessage(msgHdr);</span>
<a href="#l3.231"></a><span id="l3.231">       else</span>
<a href="#l3.232"></a><span id="l3.232">         yield kWorkSync;</span>
<a href="#l3.233"></a><span id="l3.233">     }</span>
<a href="#l3.234"></a><span id="l3.234">     yield kWorkDone;</span>
<a href="#l3.235"></a><span id="l3.235">   },</span>
<a href="#l3.236"></a><span id="l3.236">   </span>
<a href="#l3.237"></a><span id="l3.237">   /**</span>
<a href="#l3.238"></a><span id="l3.238" class="difflineminus">-   *</span>
<a href="#l3.239"></a><span id="l3.239" class="difflineplus">+   * Process pending deletes...</span>
<a href="#l3.240"></a><span id="l3.240">    */</span>
<a href="#l3.241"></a><span id="l3.241" class="difflineminus">-  _worker_messageMove: function gloda_worker_messageMove(aJob) {</span>
<a href="#l3.242"></a><span id="l3.242" class="difflineminus">-    for (; aJob.offset &lt; aJob.items.length; aJob.offset++) {</span>
<a href="#l3.243"></a><span id="l3.243" class="difflineminus">-      let item = aJob.items[aJob.offset];</span>
<a href="#l3.244"></a><span id="l3.244" class="difflineminus">-      // item must be [folder ID, header message-id]</span>
<a href="#l3.245"></a><span id="l3.245" class="difflineminus">-      </span>
<a href="#l3.246"></a><span id="l3.246" class="difflineminus">-      if (this._indexingFolderID != item[0])</span>
<a href="#l3.247"></a><span id="l3.247" class="difflineminus">-        yield this._indexerEnterFolder(item[0], false);</span>
<a href="#l3.248"></a><span id="l3.248" class="difflineminus">-      </span>
<a href="#l3.249"></a><span id="l3.249" class="difflineminus">-      // process everyone with the message-id.  yeck.</span>
<a href="#l3.250"></a><span id="l3.250" class="difflineminus">-      // uh, except nsIMsgDatabase only thinks there should be one, so</span>
<a href="#l3.251"></a><span id="l3.251" class="difflineminus">-      //  let's pretend that this assumption is not a bad idea for now</span>
<a href="#l3.252"></a><span id="l3.252" class="difflineminus">-      // TODO: stop pretending this assumption is not a bad idea</span>
<a href="#l3.253"></a><span id="l3.253" class="difflineminus">-      let msgHdr = this._indexingDatabase.getMsgHdrForMessageID(item[1]);</span>
<a href="#l3.254"></a><span id="l3.254" class="difflineminus">-      if (msgHdr)</span>
<a href="#l3.255"></a><span id="l3.255" class="difflineminus">-        yield this._indexMessage(msgHdr);</span>
<a href="#l3.256"></a><span id="l3.256" class="difflineminus">-      else {</span>
<a href="#l3.257"></a><span id="l3.257" class="difflineminus">-        this._log.info(&quot;Move unable to locate message with header &quot; +</span>
<a href="#l3.258"></a><span id="l3.258" class="difflineminus">-          &quot;message-id &quot; + item[1] + &quot;. Folder is known to possess &quot; +</span>
<a href="#l3.259"></a><span id="l3.259" class="difflineminus">-          this._indexingFolder.getTotalMessages(false) +&quot; messages.&quot;);</span>
<a href="#l3.260"></a><span id="l3.260" class="difflineplus">+  _worker_processDeletes: function gloda_worker_processDeletes(aJob) {</span>
<a href="#l3.261"></a><span id="l3.261" class="difflineplus">+    // get a block of messages to delete.  for now, let's just do this</span>
<a href="#l3.262"></a><span id="l3.262" class="difflineplus">+    //  synchronously.  we don't care if there are un-landed delete changes</span>
<a href="#l3.263"></a><span id="l3.263" class="difflineplus">+    //  on the asynchronous thread.  (well, there is a potential race that</span>
<a href="#l3.264"></a><span id="l3.264" class="difflineplus">+    //  would result in us clearing pendingDeletions erroneously, but the</span>
<a href="#l3.265"></a><span id="l3.265" class="difflineplus">+    //  processedAny flag and our use of a while loop here make this</span>
<a href="#l3.266"></a><span id="l3.266" class="difflineplus">+    //  sufficiently close to zero until we move to being async.)</span>
<a href="#l3.267"></a><span id="l3.267" class="difflineplus">+    let messagesToDelete = this._datastore.getDeletedMessageBlock();</span>
<a href="#l3.268"></a><span id="l3.268" class="difflineplus">+    let processedAny = false;</span>
<a href="#l3.269"></a><span id="l3.269" class="difflineplus">+    while (messagesToDelete.length) {</span>
<a href="#l3.270"></a><span id="l3.270" class="difflineplus">+      aJob.goal += messagesToDelete.length;</span>
<a href="#l3.271"></a><span id="l3.271" class="difflineplus">+      for each (let message in messagesToDelete) {</span>
<a href="#l3.272"></a><span id="l3.272" class="difflineplus">+        this._deleteMessage(message);</span>
<a href="#l3.273"></a><span id="l3.273" class="difflineplus">+        aJob.offset++;</span>
<a href="#l3.274"></a><span id="l3.274">         yield kWorkSync;</span>
<a href="#l3.275"></a><span id="l3.275">       }</span>
<a href="#l3.276"></a><span id="l3.276" class="difflineplus">+      </span>
<a href="#l3.277"></a><span id="l3.277" class="difflineplus">+      processedAny = true;</span>
<a href="#l3.278"></a><span id="l3.278" class="difflineplus">+      messagesToDelete = this._datastore.getDeletedMessageBlock(); </span>
<a href="#l3.279"></a><span id="l3.279">     }</span>
<a href="#l3.280"></a><span id="l3.280" class="difflineplus">+    if (processedAny)</span>
<a href="#l3.281"></a><span id="l3.281" class="difflineplus">+      this.pendingDeletions = false;</span>
<a href="#l3.282"></a><span id="l3.282">     </span>
<a href="#l3.283"></a><span id="l3.283">     yield kWorkDone;</span>
<a href="#l3.284"></a><span id="l3.284">   },</span>
<a href="#l3.285"></a><span id="l3.285"> </span>
<a href="#l3.286"></a><span id="l3.286">   /**</span>
<a href="#l3.287"></a><span id="l3.287">    * Queue all of the folders of all of the accounts of the current profile</span>
<a href="#l3.288"></a><span id="l3.288">    *  for indexing.  We traverse all folders and queue them immediately to try</span>
<a href="#l3.289"></a><span id="l3.289">    *  and have an accurate estimate of the number of folders that need to be</span>
<a href="#l3.290"></a><span id="l3.290" class="difflineat">@@ -1124,35 +1158,36 @@ let GlodaIndexer = {</span>
<a href="#l3.291"></a><span id="l3.291">     this._indexingJobGoal++;</span>
<a href="#l3.292"></a><span id="l3.292">     this.indexing = true;</span>
<a href="#l3.293"></a><span id="l3.293">   },</span>
<a href="#l3.294"></a><span id="l3.294">   </span>
<a href="#l3.295"></a><span id="l3.295">   /* *********** Event Processing *********** */</span>
<a href="#l3.296"></a><span id="l3.296">   observe: function gloda_indexer_observe(aSubject, aTopic, aData) {</span>
<a href="#l3.297"></a><span id="l3.297">     // idle</span>
<a href="#l3.298"></a><span id="l3.298">     if (aTopic == &quot;idle&quot;) {</span>
<a href="#l3.299"></a><span id="l3.299" class="difflineplus">+      if (this.indexing)</span>
<a href="#l3.300"></a><span id="l3.300" class="difflineplus">+        this._log.debug(&quot;Detected idle, throttling up.&quot;);</span>
<a href="#l3.301"></a><span id="l3.301">       this._indexInterval = this._indexInterval_whenIdle;</span>
<a href="#l3.302"></a><span id="l3.302">       this._indexTokens = this._indexTokens_whenIdle;</span>
<a href="#l3.303"></a><span id="l3.303">     }</span>
<a href="#l3.304"></a><span id="l3.304">     else if (aTopic == &quot;back&quot;) {</span>
<a href="#l3.305"></a><span id="l3.305" class="difflineplus">+      if (this.indexing)</span>
<a href="#l3.306"></a><span id="l3.306" class="difflineplus">+        this._log.debug(&quot;Detected un-idle, throttling down.&quot;);</span>
<a href="#l3.307"></a><span id="l3.307">       this._indexInterval = this._indexInterval_whenActive;</span>
<a href="#l3.308"></a><span id="l3.308">       this._indexTokens = this._indexTokens_whenActive;</span>
<a href="#l3.309"></a><span id="l3.309">     }</span>
<a href="#l3.310"></a><span id="l3.310">     // offline status</span>
<a href="#l3.311"></a><span id="l3.311">     else if (aTopic == &quot;network:offline-status-changed&quot;) {</span>
<a href="#l3.312"></a><span id="l3.312">       if (aData == &quot;offline&quot;) {</span>
<a href="#l3.313"></a><span id="l3.313">         this.suppressIndexing = true;</span>
<a href="#l3.314"></a><span id="l3.314">       }</span>
<a href="#l3.315"></a><span id="l3.315">       else { // online</span>
<a href="#l3.316"></a><span id="l3.316">         this.suppressIndexing = false;</span>
<a href="#l3.317"></a><span id="l3.317">       }</span>
<a href="#l3.318"></a><span id="l3.318">     }</span>
<a href="#l3.319"></a><span id="l3.319" class="difflineminus">-    else if (aTopic == &quot;quit-application&quot;) {</span>
<a href="#l3.320"></a><span id="l3.320" class="difflineminus">-      GlodaIndexer._shutdown();</span>
<a href="#l3.321"></a><span id="l3.321" class="difflineminus">-    }</span>
<a href="#l3.322"></a><span id="l3.322">   },</span>
<a href="#l3.323"></a><span id="l3.323"> </span>
<a href="#l3.324"></a><span id="l3.324">   /* ***** Folder Changes ***** */  </span>
<a href="#l3.325"></a><span id="l3.325">   /**</span>
<a href="#l3.326"></a><span id="l3.326">    * All additions and removals are queued for processing.  Indexing messages</span>
<a href="#l3.327"></a><span id="l3.327">    *  is potentially phenomenally expensive, and deletion can still be</span>
<a href="#l3.328"></a><span id="l3.328">    *  relatively expensive due to our need to delete the message, its</span>
<a href="#l3.329"></a><span id="l3.329">    *  attributes, and all attributes that reference it.  Additionally,</span>
<a href="#l3.330"></a><span id="l3.330" class="difflineat">@@ -1183,30 +1218,37 @@ let GlodaIndexer = {</span>
<a href="#l3.331"></a><span id="l3.331">      */</span>
<a href="#l3.332"></a><span id="l3.332">     msgAdded: function gloda_indexer_msgAdded(aMsgHdr) {</span>
<a href="#l3.333"></a><span id="l3.333">       this.indexer._log.debug(&quot;msgAdded notification&quot;);</span>
<a href="#l3.334"></a><span id="l3.334">       if (this.indexer._pendingAddJob === null) {</span>
<a href="#l3.335"></a><span id="l3.335">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l3.336"></a><span id="l3.336">         this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l3.337"></a><span id="l3.337">         this.indexer._indexingJobGoal++;</span>
<a href="#l3.338"></a><span id="l3.338">       }</span>
<a href="#l3.339"></a><span id="l3.339" class="difflineminus">-      this.indexer._pendingAddJob.items.push(</span>
<a href="#l3.340"></a><span id="l3.340" class="difflineminus">-        [GlodaDatastore._mapFolderURI(aMsgHdr.folder.URI),</span>
<a href="#l3.341"></a><span id="l3.341" class="difflineminus">-         aMsgHdr.messageKey]);</span>
<a href="#l3.342"></a><span id="l3.342" class="difflineplus">+      // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l3.343"></a><span id="l3.343" class="difflineplus">+      if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l3.344"></a><span id="l3.344" class="difflineplus">+          this._indexMaxEventQueueMessages)</span>
<a href="#l3.345"></a><span id="l3.345" class="difflineplus">+        this.indexer._pendingAddJob.items.push(</span>
<a href="#l3.346"></a><span id="l3.346" class="difflineplus">+          [GlodaDatastore._mapFolderURI(aMsgHdr.folder.URI),</span>
<a href="#l3.347"></a><span id="l3.347" class="difflineplus">+           aMsgHdr.messageKey]);</span>
<a href="#l3.348"></a><span id="l3.348">       this.indexer.indexing = true;</span>
<a href="#l3.349"></a><span id="l3.349">     },</span>
<a href="#l3.350"></a><span id="l3.350">     </span>
<a href="#l3.351"></a><span id="l3.351">     /**</span>
<a href="#l3.352"></a><span id="l3.352">      * Handle real, actual deletion (move to trash and IMAP deletion model</span>
<a href="#l3.353"></a><span id="l3.353">      *  don't count; we only see the deletion here when it becomes forever,</span>
<a href="#l3.354"></a><span id="l3.354">      *  or rather _just before_ it becomes forever.  Because the header is</span>
<a href="#l3.355"></a><span id="l3.355">      *  going away, we need to either process things immediately or extract the</span>
<a href="#l3.356"></a><span id="l3.356">      *  information required to purge it later without the header.</span>
<a href="#l3.357"></a><span id="l3.357">      * To this end, we mark all messages that were indexed in the gloda message</span>
<a href="#l3.358"></a><span id="l3.358" class="difflineminus">-     *  database as deleted.  We set our pending </span>
<a href="#l3.359"></a><span id="l3.359" class="difflineplus">+     *  database as deleted.  We set our pending deletions flag to let our</span>
<a href="#l3.360"></a><span id="l3.360" class="difflineplus">+     *  indexing logic know that after its next wave of folder traversal, it</span>
<a href="#l3.361"></a><span id="l3.361" class="difflineplus">+     *  should perform a deletion pass.  If it turns out the messages are coming</span>
<a href="#l3.362"></a><span id="l3.362" class="difflineplus">+     *  back, the fact that deletion is thus deferred can be handy, as we can</span>
<a href="#l3.363"></a><span id="l3.363" class="difflineplus">+     *  reuse the existing gloda message. </span>
<a href="#l3.364"></a><span id="l3.364">      */</span>
<a href="#l3.365"></a><span id="l3.365">     msgsDeleted: function gloda_indexer_msgsDeleted(aMsgHdrs) {</span>
<a href="#l3.366"></a><span id="l3.366">       this.indexer._log.debug(&quot;msgsDeleted notification&quot;);</span>
<a href="#l3.367"></a><span id="l3.367">       </span>
<a href="#l3.368"></a><span id="l3.368">       let glodaMessageIds = [];</span>
<a href="#l3.369"></a><span id="l3.369">       </span>
<a href="#l3.370"></a><span id="l3.370">       let deleteJob = new IndexingJob(&quot;message&quot;, -1, null);</span>
<a href="#l3.371"></a><span id="l3.371">       for (let iMsgHdr=0; iMsgHdr &lt; aMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l3.372"></a><span id="l3.372" class="difflineat">@@ -1220,71 +1262,110 @@ let GlodaIndexer = {</span>
<a href="#l3.373"></a><span id="l3.373">       </span>
<a href="#l3.374"></a><span id="l3.374">       if (glodaMessageIds.length) {</span>
<a href="#l3.375"></a><span id="l3.375">         this._datastore.markMessagesDeletedByIDs(glodaMessageIds);</span>
<a href="#l3.376"></a><span id="l3.376">         this.indexer.pendingDeletions = true;</span>
<a href="#l3.377"></a><span id="l3.377">       }</span>
<a href="#l3.378"></a><span id="l3.378">     },</span>
<a href="#l3.379"></a><span id="l3.379">     </span>
<a href="#l3.380"></a><span id="l3.380">     /**</span>
<a href="#l3.381"></a><span id="l3.381" class="difflineminus">-     * Process a move or copy.  Copies are treated as additions and accordingly</span>
<a href="#l3.382"></a><span id="l3.382" class="difflineminus">-     *  queued for subsequent indexing.  Moves are annoying in that, in theory,</span>
<a href="#l3.383"></a><span id="l3.383" class="difflineminus">-     *  we should be able to just alter the location information and be done</span>
<a href="#l3.384"></a><span id="l3.384" class="difflineminus">-     *  with it.  Unfortunately, we have no clue what the messageKey is for</span>
<a href="#l3.385"></a><span id="l3.385" class="difflineminus">-     *  the moved message until we go looking.  For now, we &quot;simply&quot; move the</span>
<a href="#l3.386"></a><span id="l3.386" class="difflineminus">-     *  messages into the destination folder, wiping their message keys, and</span>
<a href="#l3.387"></a><span id="l3.387" class="difflineminus">-     *  scheduling them all for re-indexing based on their message ids, which</span>
<a href="#l3.388"></a><span id="l3.388" class="difflineminus">-     *  may catch some same-folder duplicates.</span>
<a href="#l3.389"></a><span id="l3.389" class="difflineminus">-     *</span>
<a href="#l3.390"></a><span id="l3.390" class="difflineminus">-     * @TODO Handle the move case better, avoiding a full reindexing of the</span>
<a href="#l3.391"></a><span id="l3.391" class="difflineminus">-     *     messages when possible.  (In fact, the _indexMessage method basically</span>
<a href="#l3.392"></a><span id="l3.392" class="difflineminus">-     *     has enough information to try and give this a whirl, but it's not</span>
<a href="#l3.393"></a><span id="l3.393" class="difflineminus">-     *     foolproof, hence not done and this issue yet to-do.  </span>
<a href="#l3.394"></a><span id="l3.394" class="difflineplus">+     * Process a move or copy.</span>
<a href="#l3.395"></a><span id="l3.395" class="difflineplus">+     * Moves to a local folder can be dealt with (relatively) efficiently; the</span>
<a href="#l3.396"></a><span id="l3.396" class="difflineplus">+     *  target message headers exist at the time of the notification.  The trick</span>
<a href="#l3.397"></a><span id="l3.397" class="difflineplus">+     *  is that we aren't provided with them.</span>
<a href="#l3.398"></a><span id="l3.398" class="difflineplus">+     * Moves to an IMAP folder are troublesome because mailnews may not actually</span>
<a href="#l3.399"></a><span id="l3.399" class="difflineplus">+     *  know anything about the messages in their new location.  If there isn't</span>
<a href="#l3.400"></a><span id="l3.400" class="difflineplus">+     *  a currently open connection to the destination folder, we will only hear</span>
<a href="#l3.401"></a><span id="l3.401" class="difflineplus">+     *  about the headers when the user browses there or IMAP auto-sync gets to</span>
<a href="#l3.402"></a><span id="l3.402" class="difflineplus">+     *  the folder.  Either way, we will actually receive a msgAdded event for</span>
<a href="#l3.403"></a><span id="l3.403" class="difflineplus">+     *  each message, so the main thing we need to do is provide a hint to the</span>
<a href="#l3.404"></a><span id="l3.404" class="difflineplus">+     *  indexing logic that the gloda message in question should be reused and</span>
<a href="#l3.405"></a><span id="l3.405" class="difflineplus">+     *  is not a duplicate.</span>
<a href="#l3.406"></a><span id="l3.406" class="difflineplus">+     * Because copied messages are, by their nature, duplicate messages, we</span>
<a href="#l3.407"></a><span id="l3.407" class="difflineplus">+     *  do not particularly care about them.  As such, we defer their processing</span>
<a href="#l3.408"></a><span id="l3.408" class="difflineplus">+     *  to the automatic sync logic that will happen much later on.  This is</span>
<a href="#l3.409"></a><span id="l3.409" class="difflineplus">+     *  potentially desirable in case the user deletes some of the original</span>
<a href="#l3.410"></a><span id="l3.410" class="difflineplus">+     *  messages, allowing us to reuse the gloda message representations when</span>
<a href="#l3.411"></a><span id="l3.411" class="difflineplus">+     *  we finally get around to indexing the messages.  We do need to mark the</span>
<a href="#l3.412"></a><span id="l3.412" class="difflineplus">+     *  folder as dirty, though, to clue in the sync logic.</span>
<a href="#l3.413"></a><span id="l3.413">      */</span>
<a href="#l3.414"></a><span id="l3.414">     msgsMoveCopyCompleted: function gloda_indexer_msgsMoveCopyCompleted(aMove,</span>
<a href="#l3.415"></a><span id="l3.415">                              aSrcMsgHdrs, aDestFolder) {</span>
<a href="#l3.416"></a><span id="l3.416">       this.indexer._log.debug(&quot;MoveCopy notification.  Move: &quot; + aMove);</span>
<a href="#l3.417"></a><span id="l3.417">       try {</span>
<a href="#l3.418"></a><span id="l3.418">         if (aMove) {</span>
<a href="#l3.419"></a><span id="l3.419" class="difflineminus">-          let srcFolder = aSrcMsgHdrs.queryElementAt(0, Ci.nsIMsgDBHdr).folder;</span>
<a href="#l3.420"></a><span id="l3.420" class="difflineminus">-          let messageKeys = [];</span>
<a href="#l3.421"></a><span id="l3.421" class="difflineminus">-  </span>
<a href="#l3.422"></a><span id="l3.422" class="difflineminus">-          let reindexJob = new IndexingJob(&quot;message&quot;, 0, null);</span>
<a href="#l3.423"></a><span id="l3.423" class="difflineminus">-  </span>
<a href="#l3.424"></a><span id="l3.424" class="difflineminus">-          // get the current (about to be nulled) messageKeys and build the</span>
<a href="#l3.425"></a><span id="l3.425" class="difflineminus">-          //  job list too.</span>
<a href="#l3.426"></a><span id="l3.426" class="difflineminus">-          for (let iSrcMsgHdr=0; iSrcMsgHdr &lt; aSrcMsgHdrs.length; iSrcMsgHdr++) {</span>
<a href="#l3.427"></a><span id="l3.427" class="difflineminus">-            let msgHdr = aSrcMsgHdrs.queryElementAt(iSrcMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l3.428"></a><span id="l3.428" class="difflineminus">-            messageKeys.push(msgHdr.messageKey);</span>
<a href="#l3.429"></a><span id="l3.429" class="difflineminus">-            reindexJob.items.push(</span>
<a href="#l3.430"></a><span id="l3.430" class="difflineminus">-              [GlodaDatastore._mapFolderURI(aDestFolder.URI),</span>
<a href="#l3.431"></a><span id="l3.431" class="difflineminus">-               msgHdr.messageId]);</span>
<a href="#l3.432"></a><span id="l3.432" class="difflineplus">+          // target is a local folder, we can find the destination messages</span>
<a href="#l3.433"></a><span id="l3.433" class="difflineplus">+          if (aDestFolder instanceof Ci.nsIMsgLocalMailFolder) {</span>
<a href="#l3.434"></a><span id="l3.434" class="difflineplus">+            // ...of course, finding the destination messages is not going to</span>
<a href="#l3.435"></a><span id="l3.435" class="difflineplus">+            //  be cheap.  we're O(n) for the messages in the target folder</span>
<a href="#l3.436"></a><span id="l3.436" class="difflineplus">+            //  (which is &gt;= the number of moved messages).</span>
<a href="#l3.437"></a><span id="l3.437" class="difflineplus">+            // XXX for now, we assume the gloda-id is not propagated at the</span>
<a href="#l3.438"></a><span id="l3.438" class="difflineplus">+            //  cost of getting confused if multiple messages have the same</span>
<a href="#l3.439"></a><span id="l3.439" class="difflineplus">+            //  message-id header; we would do better to get the gloda-id</span>
<a href="#l3.440"></a><span id="l3.440" class="difflineplus">+            //  propagated and use that.  (needs C++ code changes.)</span>
<a href="#l3.441"></a><span id="l3.441" class="difflineplus">+            // (we would still need to do the traversal because we still need</span>
<a href="#l3.442"></a><span id="l3.442" class="difflineplus">+            //  to know the messageKey in the target folder...)</span>
<a href="#l3.443"></a><span id="l3.443" class="difflineplus">+            let srcMsgIdToHdr = {};</span>
<a href="#l3.444"></a><span id="l3.444" class="difflineplus">+</span>
<a href="#l3.445"></a><span id="l3.445" class="difflineplus">+            for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l3.446"></a><span id="l3.446" class="difflineplus">+              let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l3.447"></a><span id="l3.447" class="difflineplus">+              // (note: collissions on message-id headers are possible and sad)</span>
<a href="#l3.448"></a><span id="l3.448" class="difflineplus">+              srcMsgIdToHdr[msgHdr.messageId] = msgHdr;</span>
<a href="#l3.449"></a><span id="l3.449" class="difflineplus">+            }</span>
<a href="#l3.450"></a><span id="l3.450" class="difflineplus">+            let glodaIds = [];</span>
<a href="#l3.451"></a><span id="l3.451" class="difflineplus">+            let newMessageKeys = [];</span>
<a href="#l3.452"></a><span id="l3.452" class="difflineplus">+            for each (let destMsgHdr in fixIterator(aDest.getMessages(null),</span>
<a href="#l3.453"></a><span id="l3.453" class="difflineplus">+                                                    Ci.nsIMsgDBHdr)) {</span>
<a href="#l3.454"></a><span id="l3.454" class="difflineplus">+              let destMsgId = destMsgHdr.messageId;</span>
<a href="#l3.455"></a><span id="l3.455" class="difflineplus">+              let matchingSrcHdr = srcMsgIdToHdr[destMsgId];</span>
<a href="#l3.456"></a><span id="l3.456" class="difflineplus">+              if (matchingSrcHdr) {</span>
<a href="#l3.457"></a><span id="l3.457" class="difflineplus">+                try {</span>
<a href="#l3.458"></a><span id="l3.458" class="difflineplus">+                  let glodaId = matchingSrcHdr.getUint32Property(</span>
<a href="#l3.459"></a><span id="l3.459" class="difflineplus">+                    this.GLODA_MESSAGE_ID_PROPERTY); </span>
<a href="#l3.460"></a><span id="l3.460" class="difflineplus">+                  glodaIds.push(glodaId);</span>
<a href="#l3.461"></a><span id="l3.461" class="difflineplus">+                  newMessageKeys.push(destMsgHdr.messageKey);</span>
<a href="#l3.462"></a><span id="l3.462" class="difflineplus">+                }</span>
<a href="#l3.463"></a><span id="l3.463" class="difflineplus">+                // no gloda id means it hasn't been indexed, so the move isn't</span>
<a href="#l3.464"></a><span id="l3.464" class="difflineplus">+                //  required.</span>
<a href="#l3.465"></a><span id="l3.465" class="difflineplus">+                catch (ex) {}</span>
<a href="#l3.466"></a><span id="l3.466" class="difflineplus">+              }</span>
<a href="#l3.467"></a><span id="l3.467" class="difflineplus">+            }</span>
<a href="#l3.468"></a><span id="l3.468" class="difflineplus">+            </span>
<a href="#l3.469"></a><span id="l3.469" class="difflineplus">+            // this method takes care to update the in-memory representations</span>
<a href="#l3.470"></a><span id="l3.470" class="difflineplus">+            //  too; we don't need to do anything</span>
<a href="#l3.471"></a><span id="l3.471" class="difflineplus">+            this._datastore.updateMessageLocations(glodaIds, newMessageKeys,</span>
<a href="#l3.472"></a><span id="l3.472" class="difflineplus">+                                                   aDestFolder.URI);</span>
<a href="#l3.473"></a><span id="l3.473">           }</span>
<a href="#l3.474"></a><span id="l3.474" class="difflineminus">-          // quickly move them to the right folder, zeroing their message keys</span>
<a href="#l3.475"></a><span id="l3.475" class="difflineminus">-          GlodaDatastore.updateMessageFoldersByKeyPurging(srcFolder.URI,</span>
<a href="#l3.476"></a><span id="l3.476" class="difflineminus">-                                                          messageKeys,</span>
<a href="#l3.477"></a><span id="l3.477" class="difflineminus">-                                                          aDestFolder.URI);</span>
<a href="#l3.478"></a><span id="l3.478" class="difflineminus">-          // and now let us queue the re-indexings...</span>
<a href="#l3.479"></a><span id="l3.479" class="difflineminus">-          this.indexer._indexQueue.push(reindexJob);</span>
<a href="#l3.480"></a><span id="l3.480" class="difflineminus">-          this.indexer.indexingJobGoal++;</span>
<a href="#l3.481"></a><span id="l3.481" class="difflineminus">-          this.indexer.indexing = true;</span>
<a href="#l3.482"></a><span id="l3.482" class="difflineplus">+          // target is IMAP or something we equally don't understand</span>
<a href="#l3.483"></a><span id="l3.483" class="difflineplus">+          else {</span>
<a href="#l3.484"></a><span id="l3.484" class="difflineplus">+            // XXX the srcFolder will always be the same for now, but we</span>
<a href="#l3.485"></a><span id="l3.485" class="difflineplus">+            //  probably don't want to depend on it, or at least want a unit</span>
<a href="#l3.486"></a><span id="l3.486" class="difflineplus">+            //  test that will break if it changes...</span>
<a href="#l3.487"></a><span id="l3.487" class="difflineplus">+            let srcFolder = aSrcMsgHdrs.queryElementAt(0,Ci.nsIMsgDBHdr).folder;</span>
<a href="#l3.488"></a><span id="l3.488" class="difflineplus">+    </span>
<a href="#l3.489"></a><span id="l3.489" class="difflineplus">+            // get the current (about to be nulled) messageKeys and build the</span>
<a href="#l3.490"></a><span id="l3.490" class="difflineplus">+            //  job list too.</span>
<a href="#l3.491"></a><span id="l3.491" class="difflineplus">+            let messageKeys = [];</span>
<a href="#l3.492"></a><span id="l3.492" class="difflineplus">+            for (let iMsgHdr = 0; iMsgHdr &lt; aSrcMsgHdrs.length; iMsgHdr++) {</span>
<a href="#l3.493"></a><span id="l3.493" class="difflineplus">+              let msgHdr = aSrcMsgHdrs.queryElementAt(iMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l3.494"></a><span id="l3.494" class="difflineplus">+              messageKeys.push(msgHdr.messageKey);</span>
<a href="#l3.495"></a><span id="l3.495" class="difflineplus">+            }</span>
<a href="#l3.496"></a><span id="l3.496" class="difflineplus">+            // XXX we could extract the gloda message id's instead.</span>
<a href="#l3.497"></a><span id="l3.497" class="difflineplus">+            // quickly move them to the right folder, zeroing their message keys</span>
<a href="#l3.498"></a><span id="l3.498" class="difflineplus">+            this._datastore.updateMessageFoldersByKeyPurging(srcFolder.URI,</span>
<a href="#l3.499"></a><span id="l3.499" class="difflineplus">+                                                             messageKeys,</span>
<a href="#l3.500"></a><span id="l3.500" class="difflineplus">+                                                             aDestFolder.URI);</span>
<a href="#l3.501"></a><span id="l3.501" class="difflineplus">+            // we _do not_ need to mark the folder as dirty, because the</span>
<a href="#l3.502"></a><span id="l3.502" class="difflineplus">+            //  message added events will cause that to happen.</span>
<a href="#l3.503"></a><span id="l3.503" class="difflineplus">+          }</span>
<a href="#l3.504"></a><span id="l3.504">         }</span>
<a href="#l3.505"></a><span id="l3.505" class="difflineplus">+       // copy case</span>
<a href="#l3.506"></a><span id="l3.506">         else {</span>
<a href="#l3.507"></a><span id="l3.507" class="difflineminus">-          let copyIndexJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l3.508"></a><span id="l3.508" class="difflineminus">-  </span>
<a href="#l3.509"></a><span id="l3.509" class="difflineminus">-          for (let iSrcMsgHdr=0; iSrcMsgHdr &lt; aSrcMsgHdrs.length; iSrcMsgHdr++) {</span>
<a href="#l3.510"></a><span id="l3.510" class="difflineminus">-            let msgHdr = aSrcMsgHdrs.queryElementAt(iSrcMsgHdr, Ci.nsIMsgDBHdr);</span>
<a href="#l3.511"></a><span id="l3.511" class="difflineminus">-            copyIndexJob.items.push([</span>
<a href="#l3.512"></a><span id="l3.512" class="difflineminus">-              GlodaDatastore._mapFolderURI(aDestFolder.URI),</span>
<a href="#l3.513"></a><span id="l3.513" class="difflineminus">-              msgHdr.messageId]);</span>
<a href="#l3.514"></a><span id="l3.514" class="difflineminus">-          }</span>
<a href="#l3.515"></a><span id="l3.515" class="difflineminus">-  </span>
<a href="#l3.516"></a><span id="l3.516" class="difflineminus">-          this.indexer._indexQueue.push(copyIndexJob);</span>
<a href="#l3.517"></a><span id="l3.517" class="difflineminus">-          this.indexer._indexingJobGoal++;</span>
<a href="#l3.518"></a><span id="l3.518" class="difflineminus">-          this.indexer.indexing = true;</span>
<a href="#l3.519"></a><span id="l3.519" class="difflineplus">+          // mark the folder as dirty; we'll get to it later.</span>
<a href="#l3.520"></a><span id="l3.520" class="difflineplus">+          aDestFolder.setStringProperty(this.GLODA_DIRTY_PROPERTY, &quot;1&quot;);</span>
<a href="#l3.521"></a><span id="l3.521">         }</span>
<a href="#l3.522"></a><span id="l3.522">       } catch (ex) {</span>
<a href="#l3.523"></a><span id="l3.523">         this.indexer._log.error(&quot;Problem encountered during message move/copy&quot; +</span>
<a href="#l3.524"></a><span id="l3.524">           &quot;: &quot; + ex);</span>
<a href="#l3.525"></a><span id="l3.525">       }</span>
<a href="#l3.526"></a><span id="l3.526">     },</span>
<a href="#l3.527"></a><span id="l3.527">     </span>
<a href="#l3.528"></a><span id="l3.528">     /**</span>
<a href="#l3.529"></a><span id="l3.529" class="difflineat">@@ -1420,23 +1501,25 @@ let GlodaIndexer = {</span>
<a href="#l3.530"></a><span id="l3.530">      *  the indexer will cleanly map this to the existing gloda message.</span>
<a href="#l3.531"></a><span id="l3.531">      */</span>
<a href="#l3.532"></a><span id="l3.532">     _reindexChangedMessage: function(aMsgHdr) {</span>
<a href="#l3.533"></a><span id="l3.533">       // mark the message as dirty</span>
<a href="#l3.534"></a><span id="l3.534">       // (We could check for the presence of the gloda message id property</span>
<a href="#l3.535"></a><span id="l3.535">       //  first to know whether we technically need the dirty property.  I'm</span>
<a href="#l3.536"></a><span id="l3.536">       //  not sure whether it is worth the high-probability exception cost.) </span>
<a href="#l3.537"></a><span id="l3.537">       aMsgHdr.setUint32Property(this.GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l3.538"></a><span id="l3.538" class="difflineplus">+      // mark the folder dirty too, so we know to look inside</span>
<a href="#l3.539"></a><span id="l3.539" class="difflineplus">+      aMsgHdr.folder.setStringProperty(this.GLODA_DIRTY_PROPERTY, 1);</span>
<a href="#l3.540"></a><span id="l3.540">       </span>
<a href="#l3.541"></a><span id="l3.541">       if (this.indexer._pendingAddJob === null) {</span>
<a href="#l3.542"></a><span id="l3.542">         this.indexer._pendingAddJob = new IndexingJob(&quot;message&quot;, 1, null);</span>
<a href="#l3.543"></a><span id="l3.543">         this.indexer._indexQueue.push(this.indexer._pendingAddJob);</span>
<a href="#l3.544"></a><span id="l3.544">         this.indexer._indexingJobGoal++;</span>
<a href="#l3.545"></a><span id="l3.545">       }</span>
<a href="#l3.546"></a><span id="l3.546" class="difflineminus">-      // only queue the messe if we haven't overflowed our event-driven budget</span>
<a href="#l3.547"></a><span id="l3.547" class="difflineplus">+      // only queue the message if we haven't overflowed our event-driven budget</span>
<a href="#l3.548"></a><span id="l3.548">       if (this.indexer._pendingAddJob.items.length &lt;</span>
<a href="#l3.549"></a><span id="l3.549">           this._indexMaxEventQueueMessages)</span>
<a href="#l3.550"></a><span id="l3.550">         this.indexer._pendingAddJob.items.push(</span>
<a href="#l3.551"></a><span id="l3.551">           [GlodaDatastore._mapFolderURI(aMsgHdr.folder.URI),</span>
<a href="#l3.552"></a><span id="l3.552">            aMsgHdr.messageKey]);</span>
<a href="#l3.553"></a><span id="l3.553">       this.indexer.indexing = true;</span>
<a href="#l3.554"></a><span id="l3.554">     },</span>
<a href="#l3.555"></a><span id="l3.555">   </span>
<a href="#l3.556"></a><span id="l3.556" class="difflineat">@@ -1517,55 +1600,50 @@ let GlodaIndexer = {</span>
<a href="#l3.557"></a><span id="l3.557">                               aInstigator) {},</span>
<a href="#l3.558"></a><span id="l3.558">     onReadChanged: function(aInstigator) {},</span>
<a href="#l3.559"></a><span id="l3.559">     onJunkScoreChanged: function(aInstigator) {},</span>
<a href="#l3.560"></a><span id="l3.560">     onHdrPropertyChanged: function (aHdrToChange, aPreChange, aStatus,</span>
<a href="#l3.561"></a><span id="l3.561">                                     aInstigator) {},</span>
<a href="#l3.562"></a><span id="l3.562">   },</span>
<a href="#l3.563"></a><span id="l3.563">   </span>
<a href="#l3.564"></a><span id="l3.564">   /* ***** MailNews Shutdown ***** */</span>
<a href="#l3.565"></a><span id="l3.565" class="difflineminus">-  // TODO: implement a shutdown/pre-shutdown listener that attempts to either</span>
<a href="#l3.566"></a><span id="l3.566" class="difflineminus">-  //  drain the indexing queue or persist it.</span>
<a href="#l3.567"></a><span id="l3.567">   /**</span>
<a href="#l3.568"></a><span id="l3.568" class="difflineminus">-   * Shutdown task.  THIS IS NOT HOOKED UP TO ANYTHING YET.  THIS IS PROBABLY</span>
<a href="#l3.569"></a><span id="l3.569" class="difflineminus">-   *  NOT HOW WE WANT TO HANDLE THINGS EITHER.</span>
<a href="#l3.570"></a><span id="l3.570" class="difflineplus">+   * The shutdown task exists because shutdown may entail waiting for the</span>
<a href="#l3.571"></a><span id="l3.571" class="difflineplus">+   *  datastore to ensure that all async statements have completed execution.</span>
<a href="#l3.572"></a><span id="l3.572" class="difflineplus">+   *  Merely observing on 'quit-application' is insufficient because that would</span>
<a href="#l3.573"></a><span id="l3.573" class="difflineplus">+   *  not allow us to ensure that Thunderbird doesn't quit/teardown XPCOM before</span>
<a href="#l3.574"></a><span id="l3.574" class="difflineplus">+   *  we finish shutting down.</span>
<a href="#l3.575"></a><span id="l3.575">    *</span>
<a href="#l3.576"></a><span id="l3.576">    * We implement nsIMsgShutdownTask, served up by nsIMsgShutdownService.  We</span>
<a href="#l3.577"></a><span id="l3.577">    *  offer our services by registering ourselves as a &quot;msg-shutdown&quot; observer</span>
<a href="#l3.578"></a><span id="l3.578">    *  with the observer service.</span>
<a href="#l3.579"></a><span id="l3.579">    */</span>
<a href="#l3.580"></a><span id="l3.580">   _shutdownTask: {</span>
<a href="#l3.581"></a><span id="l3.581">     indexer: null,</span>
<a href="#l3.582"></a><span id="l3.582">     </span>
<a href="#l3.583"></a><span id="l3.583" class="difflineplus">+    /**</span>
<a href="#l3.584"></a><span id="l3.584" class="difflineplus">+     * Indicate that we need to run, because if anyone knows about us, we</span>
<a href="#l3.585"></a><span id="l3.585" class="difflineplus">+     *  clearly are active and need to perform a shutdown.</span>
<a href="#l3.586"></a><span id="l3.586" class="difflineplus">+     */</span>
<a href="#l3.587"></a><span id="l3.587">     get needsToRunTask() {</span>
<a href="#l3.588"></a><span id="l3.588" class="difflineminus">-      return this.indexer.indexing;</span>
<a href="#l3.589"></a><span id="l3.589" class="difflineplus">+      return true;</span>
<a href="#l3.590"></a><span id="l3.590">     },</span>
<a href="#l3.591"></a><span id="l3.591">     </span>
<a href="#l3.592"></a><span id="l3.592">     /**</span>
<a href="#l3.593"></a><span id="l3.593" class="difflineminus">-     * So we could either go all out finishing our indexing, or write down what</span>
<a href="#l3.594"></a><span id="l3.594" class="difflineminus">-     *  we need to index next time around.  For now, we opt to complete our</span>
<a href="#l3.595"></a><span id="l3.595" class="difflineminus">-     *  indexing since it greatly simplifies our lives, but it probably would</span>
<a href="#l3.596"></a><span id="l3.596" class="difflineminus">-     *  be friendly to simply persist our state.</span>
<a href="#l3.597"></a><span id="l3.597" class="difflineminus">-     *</span>
<a href="#l3.598"></a><span id="l3.598" class="difflineminus">-     * XXX: so we can either return false and be done with it, or return true</span>
<a href="#l3.599"></a><span id="l3.599" class="difflineminus">-     *  and provide the stop running notification.</span>
<a href="#l3.600"></a><span id="l3.600" class="difflineminus">-     * We call aUrlListener's OnStopRunningUrl(null, NS_OK) when we are done,</span>
<a href="#l3.601"></a><span id="l3.601" class="difflineminus">-     *  and can provide status updates by calling the shutdown service</span>
<a href="#l3.602"></a><span id="l3.602" class="difflineminus">-     *  (nsIMsgShutdownService)'s setStatusText method. </span>
<a href="#l3.603"></a><span id="l3.603" class="difflineplus">+     * Tell the indexer shutdown logic to happen.  The indexer's shutdown</span>
<a href="#l3.604"></a><span id="l3.604" class="difflineplus">+     *  returns true on complete shutdown, or false on async pending.  This</span>
<a href="#l3.605"></a><span id="l3.605" class="difflineplus">+     *  is the opposite of our nsIMsgShutdownTask behaviour, so we invert it.</span>
<a href="#l3.606"></a><span id="l3.606">      */</span>
<a href="#l3.607"></a><span id="l3.607">     doShutdownTask: function gloda_indexer_doShutdownTask(aUrlListener,</span>
<a href="#l3.608"></a><span id="l3.608">                                                           aMsgWingow) {</span>
<a href="#l3.609"></a><span id="l3.609" class="difflineminus">-      this.indexer._onStopIndexingUrlListener = aUrlListener;</span>
<a href="#l3.610"></a><span id="l3.610" class="difflineminus">-      </span>
<a href="#l3.611"></a><span id="l3.611" class="difflineminus">-      return true;</span>
<a href="#l3.612"></a><span id="l3.612" class="difflineplus">+      return !this._shutdown(aUrlListener);</span>
<a href="#l3.613"></a><span id="l3.613">     },</span>
<a href="#l3.614"></a><span id="l3.614">     </span>
<a href="#l3.615"></a><span id="l3.615">     getCurrentTaskName: function gloda_indexer_getCurrentTaskName() {</span>
<a href="#l3.616"></a><span id="l3.616" class="difflineminus">-      // if we hook this up, we will probably need to L10n this after all...</span>
<a href="#l3.617"></a><span id="l3.617" class="difflineminus">-      return &quot;Global Database Indexer&quot;; // L10n me</span>
<a href="#l3.618"></a><span id="l3.618" class="difflineplus">+      return &quot;Global Database Indexer&quot;; // L10n-me</span>
<a href="#l3.619"></a><span id="l3.619">     },</span>
<a href="#l3.620"></a><span id="l3.620">   }, </span>
<a href="#l3.621"></a><span id="l3.621">   </span>
<a href="#l3.622"></a><span id="l3.622">   _indexMessage: function gloda_indexMessage(aMsgHdr) {</span>
<a href="#l3.623"></a><span id="l3.623">     this._log.debug(&quot;*** Indexing message: &quot; + aMsgHdr.messageKey + &quot; : &quot; +</span>
<a href="#l3.624"></a><span id="l3.624">                     aMsgHdr.subject);</span>
<a href="#l3.625"></a><span id="l3.625">     MsgHdrToMimeMessage(aMsgHdr, this, this._indexMessageWithBody);</span>
<a href="#l3.626"></a><span id="l3.626">     return kWorkAsync;</span>
<a href="#l3.627"></a><span id="l3.627" class="difflineat">@@ -1785,16 +1863,17 @@ let GlodaIndexer = {</span>
<a href="#l3.628"></a><span id="l3.628">     // -- delete our attributes</span>
<a href="#l3.629"></a><span id="l3.629">     // delete the message's attributes (if we implement the cascade delete, that</span>
<a href="#l3.630"></a><span id="l3.630">     //  could do the honors for us... right now we define the trigger in our</span>
<a href="#l3.631"></a><span id="l3.631">     //  schema but the back-end ignores it)</span>
<a href="#l3.632"></a><span id="l3.632">     aMessage._datastore.clearMessageAttributes(aMessage);</span>
<a href="#l3.633"></a><span id="l3.633">     </span>
<a href="#l3.634"></a><span id="l3.634">     // -- delete our message or ghost us, and maybe nuke the whole conversation</span>
<a href="#l3.635"></a><span id="l3.635">     // look at the other messages in the conversation.</span>
<a href="#l3.636"></a><span id="l3.636" class="difflineplus">+    // TODO: have this be/use an async lookup.  we have no need to block here.</span>
<a href="#l3.637"></a><span id="l3.637">     let conversationMsgs = aMessage._datastore.getMessagesByConversationID(</span>
<a href="#l3.638"></a><span id="l3.638">                              aMessage.conversationID, true);</span>
<a href="#l3.639"></a><span id="l3.639">     let ghosts = [];</span>
<a href="#l3.640"></a><span id="l3.640">     let twinMessage = null;</span>
<a href="#l3.641"></a><span id="l3.641">     for (let iMsg=0; iMsg &lt; conversationMsgs.length; iMsg++) {</span>
<a href="#l3.642"></a><span id="l3.642">       let convMsg = conversationMsgs[iMsg];</span>
<a href="#l3.643"></a><span id="l3.643">       </span>
<a href="#l3.644"></a><span id="l3.644">       // ignore our message</span></pre></div></div>

<div class="page_footer">
<div class="page_footer_text">comm-central</div>
<div class="page_footer_text" style="padding-left: 10px">Deployed from <a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/35f393d6769a">35f393d6769a</a> at 2020-07-16T17:23:43Z.</div>
<div class="rss_logo">
<a href="/comm-central/rss-log">RSS</a>
<a href="/comm-central/atom-log">Atom</a>
</div>
<br />

</div>
</body>
</html>

